Journal of Artificial Intelligence Research 48 (2013) 635-669

Submitted 11/12; published 11/13

Reasoning about Explanations for
Negative Query Answers in DL-Lite
Diego Calvanese

calvanese@inf.unibz.it

Free University of Bozen-Bolzano, Italy

Magdalena Ortiz

ortiz@kr.tuwien.ac.at

Vienna University of Technology, Austria

Mantas SÃåimkus

simkus@dbai.tuwien.ac.at

Vienna University of Technology, Austria

Giorgio Stefanoni

Giorgio.Stefanoni@cs.ox.ac.uk

University of Oxford, United Kingdom

Abstract
In order to meet usability requirements, most logic-based applications provide explanation facilities for reasoning services. This holds also for Description Logics, where research
has focused on the explanation of both TBox reasoning and, more recently, query answering. Besides explaining the presence of a tuple in a query answer, it is important to explain
also why a given tuple is missing. We address the latter problem for instance and conjunctive query answering over DL-Lite ontologies by adopting abductive reasoning; that is, we
look for additions to the ABox that force a given tuple to be in the result. As reasoning
tasks we consider existence and recognition of an explanation, and relevance and necessity
of a given assertion for an explanation. We characterize the computational complexity of
these problems for arbitrary, subset minimal, and cardinality minimal explanations.

1. Introduction
Ontology-based data access (OBDA) systems are a new form of information systems that
use an ontology, a set of logical constraints, to mediate the access to data. The role of
the ontology in an OBDA system is twofold. On the one hand, it is an intermediate layer
between the domain user and the physical data providing a unified view of the information
held in the various data sources. In many cases, the ontology extends the data vocabulary
by introducing new intensional predicates that can be used to query information in a more
succinct and declarative way. On the other hand, the ontology provides constraints, which
are taken into account while answering queries and which may contribute to enrich the
obtained answers. Hence, potentially relevant implicit knowledge that can be derived from
the data, plus the ontology, can be made explicit by using specifically tailored reasoning
algorithms. Most existing OBDA systems are based on the DL-Lite family of lightweight
Description Logics (DLs), introduced by Calvanese, De Giacomo, Lembo, Lenzerini, and
Rosati (2007), which is also the basis for the QL profile of the OWL 2 ontology language
(Motik, Fokoue, Horrocks, Wu, Lutz, & Grau, 2009).
As argued by McGuinness and Patel-Schneider (1998), in order to meet usability requirements set by domain users, knowledge-based systems should be equipped with explanation algorithms for reasoning services. This holds also for Description Logics, where
c
2013
AI Access Foundation. All rights reserved.

Calvanese, Ortiz, SÃåimkus & Stefanoni

research has focused on the explanation of TBox reasoning (cf., McGuinness & Borgida,
1995; Borgida, Franconi, & Horrocks, 2000; Penaloza & Sertkaya, 2010; Horridge, Parsia, &
Sattler, 2008). Additionally, Borgida, Calvanese, and Rodriguez-Muro (2008) studied the
problem of explaining positive query answers to conjunctive queries over DL-Lite ontologies. In particular, they outlined a procedure for computing the reasons for a tuple to be
in the answer to a query, and for minimizing the corresponding explanation shown to the
user. In addition, Borgida et al. (2008) suggested that OBDA systems, besides explaining
positive query answers, should also explain negative query answers; that is, those tuples
that a user expects to be in the result but actually do not occur there. As OBDA systems
answer queries under ontological constraints, explaining negative query answers is not trivial: these constraints need to be taken into account to understand why a required tuple is
missing from the answers. A procedure for explaining negative query answers would then
improve the usability of OBDA systems.
For this reason, we formalize this explanation problem in the context of query answering
over DL ontologies. Following Eiter and Gottlob (1995), we adopt abductive reasoning; that
is, explanations are set of facts that need to be asserted in the ABox to force the required
tuple to be in the result. Such explanations help users in debugging a negative answer by
giving an effective way of repairing the OBDA system in terms of updates to the data layer.
Since ontologies can be used to enrich the data vocabulary, we consider also restrictions
to the vocabulary over which the additional assertions can be constructed. More precisely,
given a DL TBox T , an ABox A, a query q, and a set Œ£ of predicates, an explanation for
a given tuple ~c is a new ABox E, all whose predicates occur in Œ£, such that the answer
to q over the ontology hT , A ‚à™ Ei contains ~c. According to the Occam‚Äôs razor principle,
an important aspect in explanations is to provide users with solutions that are simple to
understand and free of redundancy, hence as small as possible. To address this requirement,
we study various restrictions on explanations, in particular, we focus on subset minimal and
cardinality minimal ones. We consider standard decision problems associated to logic-based
abduction: (i) existence of an explanation, (ii) recognition of a given ABox as being an
explanation, and (iii) relevance and (iv) necessity of an ABox assertion‚Äîthat is, whether
it occurs in some or all explanations. At first, the latter two problems may appear rather
artificial, however, they provide valuable information to the user when debugging negative
answers. Relevance can be used to test whether an assertion the user deems related to the
negative answer is indeed so; whereas, necessity can be used to test whether an assertion is
intrinsically related to the negative answer.
The idea of restricting the vocabulary of explanations is an adaptation of a concept
introduced by Baader, Bienvenu, Lutz, and Wolter (2010), who study among others the
query emptiness problem. That is, given a query q over a TBox T decide whether for all
ABoxes A over a given signature Œ£, we have that evaluating q over hT , Ai leads to an
empty result. In Section 3, we shall see that in our framework deciding the existence of an
explanation relates to the query non-emptiness problem. In fact, for many DLs, deciding
whether a query is non-empty w.r.t. a TBox reduces to checking whether there exists an
explanation for a missing answer.
The purpose of this paper is to shed light on the computational complexity of explaining
missing answers to queries over ontologies formulated in DL-Lite A ‚Äîan expressive member
of the DL-Lite family of DLs. To this end, we consider two important classes of queries‚Äî
636

Reasoning about Explanations for Negative Query Answers in DL-Lite

that is, instance queries and unions of conjunctive queries (UCQs)‚Äîand we provide computational complexity results for the four decision problems defined above. Moreover, we
perform our complexity analysis under two different explanation settings. We consider the
case in which the explanation vocabulary is a strict subset of the vocabulary of the ontology
and the data, as well as the case in which explanations can be constructed over arbitrary
predicates. In Section 4, we show that when we consider instance queries as input, the
relevant decision problems are NL-complete, irrespective of the chosen explanation setting
and of the particular minimality criterion applied over explanations. In Section 5, we analyze the complexity of the problem when we admit UCQs as input, and we show that the
complexity varies with respect to both the chosen explanation setting and the minimality
criterion. Our complexity results for UCQs are summarized in Table 5.1.

2. Preliminaries
In this section, we first introduce ontologies formulated in DLs, with a particular focus on the
DL DL-Lite A . We then introduce the languages for querying ontologies that we consider,
and we recall some important properties of DL-Lite A that will be used throughout the
paper. Finally, we briefly present some of the less known complexity classes that will be
mentioned later.
2.1 Description Logic Ontologies
As usual in DLs, we consider countably infinite sets NC , NR , and NI of atomic concepts,
atomic roles, and individuals, respectively. Whenever the distinction between atomic concepts and roles is immaterial, we call an element of NC ‚à™ NR a predicate.
A DL TBox T is a finite set of axioms, whose form depends on the specific DL being
considered; for DL-Lite A , the DL adopted in this paper, the definition is given below. A
DL ABox A is a finite set of ABox assertions, which are expressions of the form A(c) or
P (c, d), where A is an atomic concept, P is an atomic role, and c and d are individuals. A
DL ontology is a pair O = hT , Ai, where T is a DL TBox and A is a DL ABox.
The semantics of DL ontologies is based on first-order interpretations I = h‚àÜI , ¬∑I i, where
I
‚àÜ is a non-empty set called the domain and ¬∑I is the interpretation function mapping each
individual c ‚àà NI to an object cI ‚àà ‚àÜI , each atomic concept A ‚àà NC to a set AI ‚äÜ ‚àÜI ,
and each atomic role P ‚àà NR to a binary relation P I ‚äÜ ‚àÜI √ó ‚àÜI .
An interpretation I satisfies an ABox assertion A(c) if cI ‚àà AI , and it satisfies an
assertion P (c, d) if hcI , dI i ‚àà P I . Satisfaction of TBox axioms is also defined according to
their form in each specific DL; we define it below for DL-Lite A . An interpretation I is a
model of hT , Ai, if it satisfies all the axioms in T and all the assertions in A. We call hT , Ai
consistent if it admits at least one model, and inconsistent otherwise. Also, an ABox A is
consistent with a TBox T if the ontology hT , Ai is consistent.
2.1.1 DL-Lite A
DL-Lite A is a member of the DL-Lite family of DLs (Calvanese et al., 2007; Calvanese,
De Giacomo, Lembo, Lenzerini, Poggi, Rodriguez-Muro, & Rosati, 2009), which has been
designed for dealing efficiently with large amounts of extensional information. In DL-Lite A ,
637

Calvanese, Ortiz, SÃåimkus & Stefanoni

concept expressions (or, concepts) C, denoting sets of objects, and role expressions (or,
roles) R, denoting binary relations between objects, are formed according to the following
syntax, where A denotes an atomic concept and P an atomic role.1
R ‚àí‚Üí P | P ‚àí

C ‚àí‚Üí A | ‚àÉR

A DL-Lite A TBox consists of axioms of the following form.
C1 v C2
R1 v R2

C1 v ¬¨C2
R1 v ¬¨R2

(funct R)

Axioms in the first column are called positive inclusions (among concepts and roles, respectively), those in the second column disjointness axioms, and those in the third column
functionality assertions on roles. In order to retain tractability of reasoning, DL-Lite A
TBoxes must satisfy the additional restriction that roles that are functional or inverse functional cannot be specialized. Formally, if a DL-Lite A TBox contains (funct P ) or (funct P ‚àí ),
then for each role R it does not contain R v P or R v P ‚àí (Calvanese et al., 2007).
The semantics of concept expressions is specified as follows.
(‚àÉR)I

= {o ‚àà ‚àÜI | ‚àÉo0 ‚àà ‚àÜI : ho, o0 i ‚àà RI }

(P ‚àí )I

= {ho, o0 i ‚àà ‚àÜI √ó ‚àÜI | ho0 , oi ‚àà P I }

An interpretation I satisfies axiom Œ±1 v Œ±2 if Œ±1I ‚äÜ Œ±2I , it satisfies axiom Œ±1 v ¬¨Œ±2 if
Œ±1I ‚à© Œ±2I = ‚àÖ, and it satisfies axiom (funct R) if RI is a partial function‚Äîthat is, for each
set of objects {o, o1 , o2 } ‚äÜ ‚àÜI , if ho, o1 i ‚àà RI and ho, o2 i ‚àà RI , then o1 = o2 .
Following the common practice for the DLs of the DL-Lite family (Calvanese et al.,
2007), we usually adopt the unique name assumption (UNA)‚Äîthat is, for each interpretation I and individual pair c 6= d, we require that cI 6= dI . Whenever we drop this
assumption, we will explicitly say so. Under the UNA, the problem of checking whether a
DL-Lite A ontology is consistent is NL-complete, whereas without the UNA, the problem
becomes PTime-complete (Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009).
2.2 Instance Queries and Conjunctive Queries
Let NV be a countably infinite set of variables. Together NI and NV form the set of terms.
Expressions of the form A(t) or P (t, t0 ), where A is an atomic concept, P is an atomic role,
and t, t0 are terms, are called atoms.
A conjunctive query (CQ) q of arity n ‚â• 0 is an expression q(x1 , . . . , xn ) ‚Üê a1 , . . . , am ,
where, for each i ‚àà {1, . . . , m}, we have that ai is an atom. The tuple hx1 , . . . , xn i is the
tuple of answer variables of q. Let NV (q) be the set of variables occurring in q, let NI (q)
be the set of individuals in q, let at(q) = {a1 , . . . , am }, and let |q| be the number of terms
occurring in q. We consider safe CQs‚Äîthat is, each answer variable xi of q occurs in at
least one of the atoms of q. A Boolean conjunctive query is a CQ with arity 0, and we shall
write it simply as a set of atoms. An instance query q(x) is a conjunctive query whose body
consists of a single unary atom A(x). A union of conjunctive queries (UCQ) is a set of CQs
1. We ignore here the distinction between data values and objects present in DL-Lite A and OWL 2 QL,
since it is immaterial for our results. That is, we do not consider value domains and attributes.

638

Reasoning about Explanations for Negative Query Answers in DL-Lite

of the same arity, and we assume w.l.o.g. that all CQs in a UCQ have the same tuple of
answer variables. In the following, we denote with IQ the set of all instance queries and
with CQ the set of all UCQs.
A match for an n-ary CQ q in an interpretation I is a mapping œÄ : NV (q) ‚à™ NI (q) ‚Üí ‚àÜI
such that
(i) œÄ(c) = cI , for each c ‚àà NI (q),
(ii) œÄ(t) ‚àà AI , for each A(t) ‚àà at(q), and
(iii) hœÄ(t), œÄ(t0 )i ‚àà P I , for each P (t, t0 ) ‚àà at(q).
An n-tuple of individuals hc1 , . . . , cn i is an answer to q in I, if there exists a match
œÄ for q in I such that hcI1 , . . . , cIn i = hœÄ(x1 ), . . . , œÄ(xn )i. We let ans(q, I) denote the set
of all answers to q in I. A Boolean CQ returns as answer either ‚àÖ, representing the
value ‚Äòfalse‚Äô,S or the empty tuple hi, representing the value ‚Äòtrue‚Äô. For a UCQ q, we let
ans(q, I) = q0 ‚ààq ans(q 0 , I). The certain answer to a UCQ q of arity n over ontology hT , Ai
is defined as
cert(q, T , A) = {~c ‚àà (NI )n | ~c ‚àà ans(q, I), for each model I of hT , Ai}.
2.3 Query Answering in DL-Lite A
The problem of query answering in DLs is the problem of computing the certain answer
to a given query over a given DL ontology. Formulated in this way, query answering is a
computation problem and not a decision problem. Since in this paper we are interested in
establishing computational complexity results, we identify query answering with its decision
problem, sometimes called the recognition problem, in which the input is constituted by a
DL ontology hT , Ai, a query q(~x), and a tuple ~c of arity |~x|, and the task is to determine
whether ~c ‚àà cert(q, T , A). In the special case of instance queries, this problem is also known
as instance checking. Notice that, since we consider both the ontology and the query as
part of the input, we are considering so-called combined complexity (Vardi, 1982).
In many DLs, instance checking can be reduced to the problem of deciding ontology
consistency. This holds also for DL-Lite A and, thus, answering an instance query can be
done in nondeterministic logarithmic space. In contrast, the problem of answering a UCQ
(and hence a CQ) q over a DL-Lite A ontology hT , Ai can be solved in nondeterministic
polynomial time by adopting a pure query rewriting approach (Calvanese et al., 2007, 2009).
This technique works in two steps. In the first step, we compute the perfect reformulation
Rq,T of q w.r.t. T ‚Äîthat is, we rewrite the input query q with respect to the TBox T into
a UCQ Rq,T . In this rewriting step, the portion of the TBox relevant for answering q is
compiled into Rq,T . In the second step, we simply evaluate the computed rewriting Rq,T
over the ABox A‚Äîseen as a first order interpretation. This is captured by the proposition
below, which makes use of the notion of interpretation associated to an ABox, formalized
in the following definition.
Definition 2.1. Given an ABox A, let DB A be the interpretation whose domain ‚àÜDB A is
the set of individuals occurring in A, and
(i) cDB A = c, for all individuals c occurring in A;
639

Calvanese, Ortiz, SÃåimkus & Stefanoni

(ii) ADB A = {c | A(c) ‚àà A}, for all A ‚àà NC ;
(iii) P DB A = {hc, di | P (c, d) ‚àà A}, for all P ‚àà NR .
The following proposition summarizes the results about query answering based on rewriting that have been shown for the logics of the DL-Lite family (and for DL-Lite A in particular) and that we will exploit in the following.
Proposition 2.1. (Calvanese et al., 2007, 2009) Let hT , Ai be a DL-LiteA ontology, let q
be a UCQ, and let max(q) = maxqi ‚ààq |at(qi )|. It is possible to construct a UCQ Rq,T , called
the perfect reformulation of q w.r.t. T , such that
cert(q, T , A) = ans(Rq,T , DB A ).
Moreover, Rq,T satisfies the following properties.
‚Ä¢ All predicates occurring in Rq,T occur in T or in q.
‚Ä¢ Each qr ‚àà Rq,T has at most max(q) atoms and at most 2 ¬∑ max(q) terms.
‚Ä¢ If q consists of a single instance query, then each qr ‚àà Rq,T has only one atom.
‚Ä¢ Each qr ‚àà Rq,T can be obtained in nondeterministic polynomial time in the combined
size of T and q.
‚Ä¢ Deciding whether a given tuple of individuals is in ans(Rq,T , DB A ) can also be achieved
in nondeterministic polynomial time in the combined size of T and q.
2.4 Complexity Theory
We briefly outline the definition of some non-canonical complexity classes used in the paper;
for more details, we refer the reader to standard textbooks on computational complexity
(e.g., Papadimitriou, 1994). The class Œ£P2 is a member of the Polynomial Hierarchy: it is
the class of all decision problems solvable in nondeterministic polynomial time using an NP
oracle. The class PNP
k contains all decision problems that can be solved in polynomial time
with an NP oracle, where all oracle calls must be first prepared and then issued in parallel.
The class DP contains all problems that, considered as languages, can be characterized as
the intersection of a language in NP and a language in coNP. Additionally, the class NL
contains all decision problems that can be solved by a nondeterministic Turing machine using
P
a logarithmic amount of space. It is believed that NL ‚äÜ PTime ‚äÜ NP ‚äÜ DP ‚äÜ PNP
k ‚äÜ Œ£2
is a strict hierarchy of inclusions. Here we make such an assumption.
As usual, we use reductions between problems to infer complexity bounds throughout
the paper. Unless stated otherwise, these are all many-one logarithmic space reductions.

3. Explaining Negative Query Answers
In this section, we formalize as an abductive task the problem of finding explanations for
negative answers to queries over DL ontologies.
For a DL TBox T , a DL ABox A, and a query q from IQ ‚à™ CQ, we let Œ£(T , A, q) denote
the set of all those predicates that occur in T , A, or q. A signature Œ£ is a non-empty finite
subset of NC ‚à™ NR . Furthermore, an ABox A is a Œ£-ABox if all the assertions in A use
only predicates from Œ£; that is, if Œ£(‚àÖ, A, ‚àÖ) ‚äÜ Œ£.
640

Reasoning about Explanations for Negative Query Answers in DL-Lite

Definition 3.1. Let hT , Ai be a DL ontology, q(~x) a query from IQ ‚à™ CQ, ~c a tuple of
individuals of arity |~x|, and Œ£ a signature. We call P = hT , A, q, ~c, Œ£i a Query Abduction
Problem (QAP). An explanation for (or, a solution to) P is a Œ£-ABox E such that
(i) the ontology hT , A ‚à™ Ei is consistent, and
(ii) ~c ‚àà cert(q, T , A ‚à™ E).
The set of all explanations for P is denoted by expl(P). The predicates in Œ£ are the ones
allowed in explanations, hence we call them abducible predicates. If Œ£(T , A, q) ‚äÜ Œ£, we say
that P has unrestricted explanation signature; otherwise, if Œ£ does not contain all symbols
in Œ£(T , A, q), we say that P has restricted explanation signature.
For such a QAP, we call tuple ~c a negative answer to q over hT , Ai, if ~c ‚àà
/ cert(q, T , A).
Clearly, query q over ontology hT , Ai admits a negative answer only if hT , Ai is consistent.
Also, by condition (i), if the ontology is inconsistent, then P does not admit explanations.
Ontology languages, such as DL-Lite A , which allow for the specification of existential
restrictions and negative constraints (e.g., disjointness axioms), sometimes require explanations to introduce fresh individuals that do not occur within the QAP. We next precisely
characterize these individuals.
Definition 3.2. Let P = hT , A, q, ~c, Œ£i be a QAP and let E be a solution to P. An arbitrary
individual u occurring in E is anonymous if it does not occur in T , A, q, and in ~c.
Now, we use an example to highlight how query abduction problems can be useful in
debugging negative query answers.
Example 3.1. Let Au be the following set of assertions about a particular university.
DPhil(Anna)
enroll(Anna, KR)
enroll(Luca, IDB )

DPhil(Beppe)
teach(Marco, KR)
teach(Carlo, IDB )

That is, Anna and Beppe are doctoral students, Anna is enrolled in the KR course, which
is taught by Marco, and Luca is enrolled in the introductory DB course (IDB ), which is
taught by Carlo. Now, consider the following DL-Lite A TBox Tu formalizing the university
domain, of which Au is a (partial) instance.
‚àÉenroll v Student
‚àÉenroll‚àí v Course
DPhil v Student

‚àÉteach v Lecturer
‚àÉteach‚àí v Course
Course v ‚àÉteach‚àí

Tu models that objects in the domain of enroll are Students, and objects in the domain of
teach are Lecturers, whereas objects in the range of enroll or of teach are Courses. Among
the students we have DPhil students. Finally, every Course must be taught by someone.
Now, assume that the university administration is interested in finding all those who
are teaching a course in which at least one of the enrolled students is a doctoral student,
which is captured by the following query.
qu (x) ‚Üê teach(x, y), enroll(z, y), DPhil(z)
641

Calvanese, Ortiz, SÃåimkus & Stefanoni

Assume that Carlo is expected to be part of the result. This is not the case, as Luca is the
only student of Carlo and he is not known to be a DPhil student. Hence Carlo ‚àà
/ cert(q, T , A)
and Carlo is a negative answer. Suppose that we have complete information on all the
predicates but enroll and teach‚Äîthat is, only the latter predicates are abducible. It is easy
to see that
Eu = {teach(Carlo, c), enroll(Beppe, c), enroll(Luca, c)}
is an explanation for the QAP Pu = hTu , Au , qu , Carlo, {enroll, teach}i, which suggests the
existence of a course, represented by the anonymous individual c, that does not occur in
the ABox Au .
The above example shows that certain explanations may be too assumptive in that they
include assertions that are not required to solve the problem. Indeed, in the example‚Äôs
explanation there is no reason to assume that Luca is enrolled in the anonymous course
c. In the following, we will examine various restrictions to expl(P) to reduce redundancy
in explanations, achieved by introducing a preference relation among explanations. This
relation is reflexive and transitive‚Äîthat is, we have a pre-order among explanations. For
such a pre-order  on expl(P), we write E ‚â∫ E 0 if E  E 0 and E 0  E.
Definition 3.3. The preferred explanations expl (P) of a QAP P under the pre-order ,
called -explanations or (-solutions), are defined as follows.
expl (P) = { E ‚àà expl(P) | there is no E 0 ‚àà expl(P) such that E 0 ‚â∫ E }
We consider two preference orders that are commonly adopted when comparing abductive solutions: the subset-minimality order, denoted by ‚äÜ, and the minimum explanation
size order, denoted by ‚â§. The latter order is defined by E ‚â§ E 0 iff |E| ‚â§ |E 0 |. Considering
that, by the definition, explanations are finite, for an arbitrary QAP P, we have that each
‚â§-solution to P is also a ‚äÜ-solution to P; that is, expl‚â§ (P) ‚äÜ expl‚äÜ (P).
Example 3.2. As we already argued, the ABox Eu is a redundant solution to the QAP Pu
introduced in Example 3.1. Next, we introduce two minimal solutions. First, we consider
the solution asserting Carlo to teach an anonymous course c and Beppe to be enrolled in
that course. This ABox Eu0 = {teach(Carlo, c), enroll(Beppe, c)} is a ‚äÜ-explanation. Second,
we consider the solution asserting Beppe to be enrolled in the IDB course. This ABox
Eu00 = {enroll(Beppe, IDB )} is a ‚â§-explanation (and hence also a ‚äÜ-explanation).
In the context of logic-based abduction, four main decision problems have been considered of interest (Eiter & Gottlob, 1995), and they are parametrized according to the chosen
preference order .
~ over abducible predicate œï, and
Definition 3.4. Given a QAP P, an ABox assertion œï(d)
an ABox E, we define the following decision problems.
‚Ä¢ -exist(ence): Does there exist a -explanation for P?
~ occur in all -explanations for P?
‚Ä¢ -nec(essity): Does assertion œï(d)
~ occur in some -explanation for P?
‚Ä¢ -rel(evance): Does assertion œï(d)
642

Reasoning about Explanations for Negative Query Answers in DL-Lite

‚Ä¢ -rec(ognition): Is ABox E a -explanation for P?
Whenever no preference is applied (i.e., when  is the identity), we omit to write  in
front of the problems‚Äô names.
In this paper, we study the complexity of the above reasoning problems for query abduction. We start by highlighting, in the remaining part of this section, interesting properties
of query abduction problems and important connections between reasoning tasks.
3.1 Reductions between Reasoning Problems
We now show that some of the introduced problems can be reduced to each other. Unless
otherwise stated, the reductions we present work for all DLs, for both instance queries and
UCQs, and for both restricted and unrestricted explanation signatures.
We start by showing that nec is at least as hard as non-exist (i.e., the complement of
the exist problem).
Proposition 3.1. For every DL, non-exist is reducible to nec.
~ be an arbitrary ABox assertion,
Proof. Assume a QAP P = hT , A, q, ~c, Œ£i and let œï(d)
~ is
such that œï and d~ do not occur in P. The following holds: P has no explanation iff œï(d)
0
necessary for P = hT , A, q, ~c, Œ£ ‚à™ {œï}i. By the construction, it follows that each solution
to P is also a solution to P 0 ; furthermore, for each solution E 0 to P 0 , œï 6‚àà Œ£(‚àÖ, E 0 , ‚àÖ) implies
that E 0 is a solution to P. By the definition of P 0 and since œï and d~ are globally fresh,
~ is an
for each ABox E, we have that E is an explanation for P 0 if and only if E \ {œï(d)}
0
explanation for P . The correctness of the reduction immediately follows.
For QAPs with restricted explanation signatures, we next show that nec reduces to
non-exist. The reduction works for every DL that allows for disjointness axioms.
Proposition 3.2. For every DL that allows for concept and role disjointness axioms, and
under restricted explanation signatures, nec is reducible to non-exist.
Proof. Consider an instance of nec given by a QAP P = hT , A, q, ~c, Œ£i where Œ£ might be
~ Next, we show how to construct a QAP P 0 such
restricted, and by an ABox assertion œï(d).
0
~
that œï(d) is necessary for P iff P does not admit solutions. To this end, let œï0 and œïÃÑ be
two globally fresh predicates of the same arity as œï; furthermore, let TBox T 0 , ABox A0 ,
and signature Œ£0 be as follows.
T 0 := T ‚à™ {œï0 v œï} ‚à™ {œïÃÑ v ¬¨œï0 }

~
A0 := A ‚à™ {œïÃÑ(d)}

Œ£0 := {œà ‚àà Œ£ | œà 6= œï} ‚à™ {œï0 }

Finally, let P 0 := hT 0 , A0 , q, ~c, Œ£0 i. Now, we show the correctness of the reduction; that is,
~ is necessary for P iff P 0 does not admit solutions.
œï(d)
(‚áí) We prove the contrapositive. Suppose that P 0 has a solution E 0 . By the definition
~ 6‚àà E 0 and that predicate œï does not occur in E 0 .
of hT 0 , A0 i and of Œ£0 , we have that œï0 (d)
Let ABox E be defined as follows.
E := {œà(~t) ‚àà E 0 | œà 6= œï0 } ‚à™ {œï(~t) | œï0 (~t) ‚àà E 0 }
643

Calvanese, Ortiz, SÃåimkus & Stefanoni

~ It remains to show that
By the construction, E is a Œ£-ABox that does not contain œï(d).
E is a solution to P. To this end, please observe that each model J of hT 0 , A0 ‚à™ E 0 i is
a model of hT , A ‚à™ Ei, since œï0 v œï ‚àà T 0 . In addition, each model I of hT , A ‚à™ Ei can
be extended to a model J of hT 0 , A0 ‚à™ E 0 i by setting œï0J := {(~t)J | œï0 (~t) ‚àà E 0 } and
~ J }. It follows that hT 0 , A0 ‚à™ E 0 i is a conservative extension of hT , A ‚à™ Ei. Given
œïÃÑJ := {(d)
that ~c ‚àà cert(q, T 0 , A0 ‚à™ E 0 ) and that q is over hT , Ai, we obtain that ~c ‚àà cert(q, T , A ‚à™ E).
Furthermore, since hT 0 , A0 ‚à™ E 0 i is consistent, we also have that hT , A ‚à™ Ei is consistent; so
~ as required.
E is a solution to P that does not contain assertion œï(d),
(‚áê) We prove the contrapositive. Suppose that a solution E to P exists such that
~
œï(d) 6‚àà E. Let ABox E 0 be defined as follows.
E 0 := {œà(~t) ‚àà E | œà 6= œï} ‚à™ {œï0 (~t) | œï(~t) ‚àà E}
~ It remains to show
By the construction, E 0 is a Œ£0 -ABox which does not contain œï0 (d).
0
0
0
0
0
that E is a solution to P . As we have seen before, hT , A ‚à™ E i is a conservative extension of hT , A ‚à™ Ei. Given that ~c ‚àà cert(q, T , A ‚à™ E), we obtain that ~c ‚àà cert(q, T 0 , A0 ‚à™ E 0 ).
~ 6‚àà E 0 , we also have that hT 0 , A0 ‚à™ E 0 i
Furthermore, since hT , A ‚à™ Ei is consistent and œï0 (d)
is consistent; so E 0 is a solution to P 0 , as required.
A simple modification of Proposition 3.2 shows that this result applies also to DLs that
allow for negative ABox assertions of the form ¬¨A(c) and ¬¨P (c, c0 ) instead of disjointness
axioms. We next show that rel and exist are mutually reducible.
Proposition 3.3. For every DL, rel and exist are mutually reducible.
Proof. First, we show that we can reduce rel to exist. Let P be an arbitrary QAP of
~ be an arbitrary ABox assertion such that œï ‚àà Œ£. We
the form hT , A, q, ~c, Œ£i and let œï(d)
0
~ is relevant to P if and only if P 0 admits a solution.
construct a QAP P such that œï(d)
~
To this end, let A0 be the ABox defined as A0 = A ‚à™ {œï(d)}.
Then, we define QAP P 0 as
0
0
P = hT , A , q, ~c, Œ£i. Next, we prove the correctness of the reduction. The only-if direction
is immediate. For the if direction, suppose that P 0 admits a solution E 0 . It follows, by the
~ is consistent with TBox T . Moreover, this latter
definition of P 0 , that Œ£-ABox E 0 ‚à™ {œï(d)}
ABox is also a solution to P and, therefore, the given assertion is relevant.
Second, we prove that exist is reducible to rel. Let P be an arbitrary QAP of the
form hT , A, q, ~c, Œ£i, let œï be an arbitrary predicate from Œ£, and let d~ be an arbitrary tuple
of individuals not occurring in P such that d~ is of the same arity as predicate œï. We prove
~ is relevant for P. The if direction follows by the definition
that P admits a solution iff œï(d)
~
of relevance. To show the only-if direction, suppose that P admits a solution E. If œï(d)
~
occurs in E, it is relevant for P. Otherwise, since individuals d do not occur in P and œï ‚àà Œ£,
~ is also a solution to P, and hence œï(d)
~ is relevant for P.
ABox E ‚à™ {œï(d)}
Moreover, ‚äÜ-nec and nec are also mutually reducible.
Proposition 3.4. For every DL, ‚äÜ-nec and nec are mutually reducible.
~ we have that œï(d)
~
Proof. For an arbitrary QAP P and an arbitrary ABox assertion œï(d),
~
occurs in all ‚äÜ-minimal explanations for P iff œï(d) occurs in all explanations for P. Thus,
nec and ‚äÜ-nec are equivalent problems.
644

Reasoning about Explanations for Negative Query Answers in DL-Lite

Finally, since our preference orders prefer ‚Äòsmaller‚Äô explanations and, by the definition,
explanations are finite, our orders are well-founded. It immediately follows that there exists
an explanation for an arbitrary QAP P if and only if P admits a minimal explanation under
both our preference orders.
Proposition 3.5. For every DL, ‚äÜ-exist, ‚â§-exist, and exist are mutually reducible.
3.2 QAPs and the Query Emptiness Problem
As mentioned in the introduction, deciding the existence of an explanation is related to the
query emptiness problem studied by Baader et al. (2010). Since we will rely on that problem
to infer some complexity bounds throughout the paper, we briefly introduce it here.
Definition 3.5. Let T be a DL TBox, Q ‚àà {IQ, CQ} a query language, and Œ£ a signature.
We say that a Q-query q is empty for Œ£ given T if for every Œ£-ABox A that is consistent
with T we have that cert(q, T , A) = ‚àÖ. Otherwise, we say that q is non-empty for Œ£ given
T . The Q non-emptiness problem consists in deciding, for input T , q, and Œ£, whether q is
non-empty for Œ£ given T .
Next, we first show that, for every DL, and for both instance queries and Boolean UCQs,
query non-emptiness reduces to exist. Then, we show that for the DL-Lite A case this holds
even for arbitrary UCQs.
Proposition 3.6. For every DL and both instance queries and Boolean UCQs, Q nonemptiness is reducible to exist.
Proof. Let T be an arbitrary DL TBox, let q ‚àà IQ ‚à™ CQ be an arbitrary query such that
q ‚àà CQ implies that q is a Boolean UCQ, and let Œ£ be an arbitrary signature. We show
how to construct a QAP P such that q is non-empty for Œ£ given T iff P admits a solution.
To this end, let ~c be an arbitrary tuple such that q ‚àà CQ implies that ~c = hi, and q ‚àà IQ
implies that ~c = hai where a is a globally fresh individual. Clearly, we have that q is
non-empty for Œ£ given T iff P = hT , ‚àÖ, q, ~c, Œ£i admits a solution.
The relationship between CQ non-emptiness and exist can tightened, when we restrict
our attention to DL-Lite A TBoxes.
Proposition 3.7. For DL-LiteA , CQ non-emptiness is reducible to exist.
Proof. Consider a DL-Lite A TBox T , a signature Œ£, and this time an n-ary query q ‚àà CQ.
W.l.o.g., we assume that q is a CQ. Then, we cannot immediately extend the proof given
for Boolean CQs by introducing n (distinct) individuals since we might be forced to match
distinct answer variables of q to the same individual in an ABox witnessing non-emptiness
of q. However, we can adapt the proof to this case as follows. We let N be a fresh atomic
concept not occurring in Œ£(T , ‚àÖ, q)‚à™Œ£. We define Œ£0 = Œ£‚à™{N } and we let q 0 be the Boolean
CQ such that at(q 0 ) = at(q) ‚à™ {N (x1 ), . . . , N (xn )}. Finally, we let P = hT , ‚àÖ, q 0 , hi, Œ£0 i be a
QAP. In the following, we show that q is non-empty for Œ£ given T iff P admits a solution.
(‚áí) Suppose that q is non-empty for Œ£ given T . That is, there exists a Œ£-ABox A such
that hT , Ai is consistent and there exists some n-ary tuple ~a = ha1 , . . . , an i of individuals
645

Calvanese, Ortiz, SÃåimkus & Stefanoni

such that ~a ‚àà cert(q, T , A). Now, consider the Œ£0 -ABox E = A ‚à™ {N (ai ) | 1 ‚â§ i ‚â§ n}.
Since N is a fresh predicate, we have that hT , Ei is a conservative extension of hT , Ai.
That is, each model of hT , Ai can be extended to be a model of hT , Ei, and every model
of hT , Ei is also a model of hT , Ai. By the assumption that hT , Ai is consistent and that
~a ‚àà cert(q, T , A), we conclude that E is a solution to P.
(‚áê) Suppose that P admits a solution E. It follows that hT , Ei is consistent and that
for each model I of hT , Ei, there exists a match œÄ for q 0 such that I |=œÄ q 0 . Since N is
a fresh predicate not occurring in T and for each answer variable xi of q the atom N (xi )
is contained in q 0 , we have that œÄ(xi ) = aIi for some ai ‚àà NI such that N (ai ) ‚àà E. It
follows that ~a ‚àà cert(q, T , E). Consider the Œ£-ABox A obtained from E by removing all the
assertions over N ; it immediately follows that hT , Ei is a conservative extension of hT , Ai.
Therefore, also ~a ‚àà cert(q, T , A) and, thus, q is non-empty for Œ£ given T .
Proposition 3.7 can be generalized to Horn DLs‚Äîthat is, to all those DLs for which
answering instance and conjunctive queries reduces to evaluating the input query over a
single, canonical model of the ontology. It follows that for DL-Lite A and, more in general,
for all Horn-DLs, deciding exist generalizes the query non-emptiness problem. Hence,
all the hardness results for non-emptiness obtained by Baader et al. (2010) that hold for
instance queries and UCQs apply also to the exist problem under restricted explanation
signatures. However, since we also consider ABoxes and we require a specific tuple to be in
the query answer, the converse does not hold and we can not always transfer their upper
bounds to our setting.
3.3 Canonical Explanations
Before studying the complexity of reasoning over query abduction problems, we first show
that we can restrict the search for explanations. In order to do so, we define the notion of
instantiation of a conjunctive query.
Definition 3.6. Let q be an n-ary CQ with answer variables hx1 , . . . , xn i; furthermore, let
~c = hc1 , . . . , cn i be a tuple of individuals. Let Œæ be a mapping from the terms of q to NI such
that Œæ is identity over NI and for each answer variable xj of q we have that Œæ(xj ) = cj .
Then, we call the ABox
EŒæ = {A(Œæ(t)) | A(t) ‚àà at(q)} ‚à™ {R(Œæ(s), Œæ(t)) | R(s, t) ‚àà at(q)}
a ~c-instantiation of q. Given a DL ontology O, if we additionally have that, for each
quantified variable y, Œæ(y) is a distinct anonymous individual uy not occurring in q and O,
then we say that EŒæ is direct for O.
Note that in the following we do not distinguish between instantiations that differ only
in the assignment of anonymous individuals to variables. Hence, a CQ has only a finite
number of distinct instantiations, and a unique direct one.
3.3.1 Unrestricted Explanation Signature
To obtain an explanation for a QAP P with unrestricted explanation signature, we can
iterate over the set of all possible instantiations to the input query, searching for one such
646

Reasoning about Explanations for Negative Query Answers in DL-Lite

instantiation that is consistent with the input ontology. In the absence of the UNA, we
can even consider one single instantiation of each CQ: the direct instantiation, where all
existentially quantified variables are mapped to distinct anonymous individuals. In the
presence of the UNA, if our underlying DL is expressive enough to enforce inequalities over
the individuals occurring in P (e.g., by means of disjointness axioms), we can again reduce
the problem to searching for a CQ whose direct instantiation is consistent with the input
ontology, when the UNA is dropped.
Proposition 3.8. Let O = hT , Ai be an arbitrary DL ontology and let P = hT , A, q, ~c, Œ£i
be an arbitrary QAP with unrestricted explanation signature. Furthermore, for each qi ‚àà q,
let Eqi be the direct ~c-instantiation of qi for O. The following hold:
1. Under the UNA, a solution to P exists iff a ~c-instantiation EŒæ of some qi ‚àà q exists
such that hT , A ‚à™ EŒæ i is consistent.
2. Without the UNA, a solution to P exists iff a query qi ‚àà q exists such that hT , A ‚à™ Eqi i
is consistent.
3. Furthermore, suppose that the DL supports concept disjointness axioms. Under the
UNA, a solution to P exists iff a query qi ‚àà q exists such that hT 0 , A0 ‚à™ Eqi i is consistent without the UNA, where A0 and T 0 extend A and T with a quadratic number of
assertions and axioms, respectively.
Proof. Consider an arbitrary qi ‚àà q and let EŒæ be an arbitrary ~c-instantiation of qi . We
first prove that consistency of hT , A ‚à™ EŒæ i (with or without the UNA) implies that EŒæ is a
solution to P (with or without the UNA, resp.). This shows the if direction of 1 and 2. Let
Œæ be the mapping generating EŒæ and suppose that hT , A ‚à™ EŒæ i is consistent. Let I be an
arbitrary model of hT , A ‚à™ EŒæ i. Then we build a match œÄ for qi in I by setting œÄ(t) = Œæ(t)I
for each term t in qi . As œÄ(xj ) = Œæ(xj )I = cIj for each answer variable xj , the match œÄ
witnesses ~c ‚àà ans(q, I). Hence ~c ‚àà cert(q, T , A ‚à™ EŒæ ) and EŒæ is a solution to P, as desired.
For the only-if direction of 1, we assume an arbitrary solution E to P, and use it to
show that there exists a ~c-instantiation EŒæ of some qi ‚àà q such that hT , A ‚à™ EŒæ i is consistent.
Since E is a solution to P, by definition, there exists a model I of hT , A ‚à™ Ei under the
UNA. Without loss of generality, we assume that ‚àÜI = NI and that for each c ‚àà NI we have
that cI = c. Moreover, the interpretation I admits a match œÄ for some qi ‚àà q witnessing
~c ‚àà ans(qi , I). To define the mapping Œæ, we let Œæ(t) = œÄ(t) for each term t occurring in qi .
Then I is a model of EŒæ . Since it is also a model of hT , Ai, it is a model of hT , A ‚à™ EŒæ i and
shows that the latter is consistent, as desired.
The only-if direction of 2 is shown similarly. Suppose that P admits a solution E.
Then there exists a model I of hT , A ‚à™ Ei (without the UNA) that admits a match œÄ for
some qi ‚àà q witnessing ~c ‚àà ans(qi , I). To obtain an interpretation J that is a model of
hT , A ‚à™ Eqi i, we extend I as follows. For every anonymous individual uy that was introduced
in Eqi due to an existentially quantified variable y, we let uy J = œÄ(y). The resulting
interpretation is a model of Eqi , and since these individuals uy do not occur in the ontology,
modelhood for hT , Ai is preserved.
For 3, we use the extended ABox A0 and TBox T 0 to enforce the UNA over the individuals occurring in P. The ABox A0 extends A with an assertion Ac (c) for each individual
647

Calvanese, Ortiz, SÃåimkus & Stefanoni

c occurring in P, where each Ac is a fresh concept name. The TBox T 0 consists of axioms
Ac v ¬¨Ac0 for all pairs c 6= c0 of individuals occurring in P. Since the interpretations of
hT , Ai under the UNA and of hT 0 , A0 i without the UNA coincide, the claim easily follows
from statement 2 above.
A direct consequence of this proposition is that, for all DLs, we can restrict our search
to explanations that result from instantiating the input query.
Corollary 3.9. Let P = hT , A, q, ~c, Œ£i be a QAP with unrestricted explanation signature,
let max(q) = maxqi ‚ààq |at(qi )|, and let max-terms(q) = maxqi ‚ààq |qi |. If P has an explanation,
then P has an explanation with concepts and roles only from q, at most max(q) atoms, and
at most max-terms(q) individuals.
3.3.2 Restricted Explanation Signature
If we allow for restricted explanation signatures, then Proposition 3.8 does not hold anymore,
and the search space for possible explanations becomes significantly larger. As we will see
in the following sections, this has a notable effect on the complexity of the different decision
problems. However, in the case of DL-Lite A , we can still show a weaker version of the
proposition that allows us to restrict our search to the instantiations of the queries in the
perfect reformulation of the input query q. Moreover, every ‚äÜ-minimal explanation can be
obtained this way.
Proposition 3.10. Let P = hT , A, q, ~c, Œ£i be a QAP where hT , Ai is a DL-LiteA ontology,
and let Rq,T be the perfect reformulation of q w.r.t. T . A solution to P exists if and only
if a ~c-instantiation EŒæ of some qr ‚àà Rq,T exists such that (i) hT , A ‚à™ EŒæ i is consistent,
and (ii) EŒæ \ A is a Œ£-ABox. Moreover, E 0 is a ‚äÜ-minimal explanation implies that query
qr ‚àà Rq,T and ABox EŒæ exist such that EŒæ is a ~c-instantiation of qr and E 0 = EŒæ \ A.
Proof. The first part of the claim is shown analogously to item 1 of Proposition 3.8 (recall
that in DL-Lite A we make the UNA). For the if direction, consider an arbitrary qr ‚àà Rq,T
and let EŒæ be a ~c-instantiation of qr generated from a mapping Œæ. We assume that hT , A ‚à™ EŒæ i
is consistent and that EŒæ \ A is a Œ£-ABox. Then, to show that EŒæ \ A is a solution to P, it
suffices to show the existence of a match œÄ for qr in DB A‚à™EŒæ witnessing ~c ‚àà cert(q, T , A‚à™EŒæ ).
This œÄ is easily obtained by setting œÄ(t) = Œæ(t)I for each term t in qr . For the only-if
direction, we assume an arbitrary solution E to P and use it to show that there exists a ~cinstantiation EŒæ of some qr ‚àà Rq,T that satisfies conditions (i) and (ii). Since E is a solution
to P, by definition, E is a Œ£-ABox, hT , A ‚à™ Ei is consistent, and ~c ‚àà cert(q, T , A ‚à™ E). By
Proposition 2.1, it follows that there exists a query qr ‚àà Rq,T and a match œÄ for qr in
DB A‚à™E that witness ~c ‚àà ans(qr , DB A‚à™E ). We define a mapping Œæ by setting Œæ(t) = œÄ(t) for
each term t in qr . Then, for the resulting ~c-instantiation EŒæ we have that EŒæ ‚äÜ E ‚à™ A, which
implies the consistency of hT , A ‚à™ EŒæ i and that EŒæ \ A is also a Œ£-ABox as desired.
To show the second part of the claim, suppose E is a ‚äÜ-minimal solution to P. By
Proposition 2.1, we have that there exists some qr ‚àà Rq,T for which there exists a match œÄ
witnessing ~c ‚àà ans(qr , DB A‚à™E ). We construct a ~c-instantiation EŒæ of qr as follows:
EŒæ = {A(œÄ(t)) ‚àà A ‚à™ E | A(t) ‚àà at(qr )} ‚à™ {R(œÄ(t), œÄ(t0 )) ‚àà A ‚à™ E | R(t, t0 ) ‚àà at(qr )}
By the minimality of E, we have that E = EŒæ \ A.
648

Reasoning about Explanations for Negative Query Answers in DL-Lite

Similarly as above, this implies that we can consider only small explanations whose size
is linear in the size of the input query q, but now their signature depends not only on q,
but also on the signature of the input TBox T .
Corollary 3.11. Let P = hT , A, q, ~c, Œ£i be a QAP where hT , Ai is a DL-LiteA ontology.
Furthermore, let max(q) = maxqi ‚ààq |at(qi )|. If P = hT , A, q, ~c, Œ£i has an explanation, then
P has an explanation with concepts and roles only from T and q, at most max(q) atoms,
and at most 2 ¬∑ max(q) individuals.

4. Complexity for Instance Queries
We now study the complexity of reasoning over query abduction problems. We consider the
complexity under both unrestricted and restricted explanation signatures, and we consider
the different minimality criteria over abductive solutions. We measure the complexity of
a QAP P = hT , A, q, ~c, Œ£i in terms of the combined size of T , A, q, and Œ£‚Äîthat is, we
consider combined complexity. In this section, we investigate the complexity of reasoning
over QAPs when the body of the input query consists of a single unary atom‚Äîthat is, we
consider instance queries. In the following section, we shall turn our attention to UCQs.
4.1 Existence of Explanations
Before giving the first complexity results, we show that, for instance queries, ‚äÜ-minimal and
‚â§-minimal explanations coincide. To see this, consider an arbitrary QAP P = hT , A, q, c, Œ£i
such that q ‚àà IQ and let qr be an arbitrary CQ in the perfect reformulation Rq,T . By Propositions 2.1 and 3.10, it follows that each ~c-instantiation of qr that is consistent with hT , Ai
contains an explanation for P; moreover, each ‚äÜ-minimal explanation for P can be obtained
in this way. As these explanations contain at most one assertion (cf. Proposition 2.1), ‚â§and ‚äÜ-minimal explanations are both of size at most one, and we obtain the following result.
Proposition 4.1. Let P = hT , A, q, ~c, Œ£i be a QAP such that hT , Ai is a DL-LiteA ontology
and q ‚àà IQ, and let E be an arbitrary Œ£-ABox. Then, E is a solution to P implies that a
solution E 0 ‚äÜ E to P exists such that |E 0 | ‚â§ 1. Hence, expl‚â§ (P) = expl‚äÜ (P).
Now we consider the complexity of deciding existence of an explanation.
Theorem 4.2. For DL-LiteA , instance queries, and under both unrestricted and restricted
explanation signatures, exist, ‚äÜ-exist, and ‚â§-exist are NL-complete.
Proof. By Proposition 3.5, it suffices to show the result for exist. We first provide an
algorithm that yields the desired upper bound, even with restricted explanation signatures.
Then we show that the problem is NL-hard already for the case of unrestricted signatures.
(membership) Let P = hT , A, q, c, Œ£i be a QAP such that q ‚àà IQ. To decide exist in
non-deterministic logarithmic space, we can exploit Proposition 4.1 and test all candidate
singleton explanations by iterating over Œ£, the individuals occurring in P, and at most
two anonymous individuals. This results in at most polynomially many candidate solutions E of constant size. For each of them we test whether hT , A ‚à™ Ei is consistent and
c ‚àà cert(q, T , A ‚à™ E). Since for DL-Lite A both ontology consistency and instance checking
can be solved in non-deterministic logarithmic space, exist is in NL.
649

Calvanese, Ortiz, SÃåimkus & Stefanoni

Algorithm 1 isNEC
~ such that hT , Ai is a DL-Lite A ontology,
Input: QAP P = hT , A, q, ~c, Œ£i and assertion œï(d)
q ‚àà IQ ‚à™ CQ, Œ£ is unrestricted, and œï ‚àà Œ£.
~ is necessary for P.
Output: ‚Äúyes‚Äù iff œï(d)
1: Let œïÃÑ be a globally fresh predicate of the same arity as œï.
~
2: Let T 0 := T ‚à™ {œïÃÑ v ¬¨œï} and let A0 := A ‚à™ {œïÃÑ(d)}.
0
0
3: If hT , A , q, ~
c, Œ£i admits a solution, then return ‚Äúno‚Äù.
~
4: Let I be the set of all individuals occurring in P and d.
Let u be a globally fresh anonymous individual.
~ 6‚àà E ‚àó do
for all Œ£-ABoxes E ‚àó over the individuals in I ‚à™ {u} s.t. |E ‚àó | ‚â§ 1 and œï(d)
~ and hT , A ‚à™ E ‚àó , q, ~c, Œ£i admits a solution, then return ‚Äúno‚Äù.
7:
If hT , A ‚à™ E ‚àó i |= œï(d)
8: end for
9: Return ‚Äúyes‚Äù.

5:
6:

(hardness) We reduce the DL-Lite A ontology consistency problem (under the UNA)
to exist. Consider an arbitrary DL-Lite A ontology hT , Ai. Furthermore, consider an
arbitrary atomic concept A not occurring in hT , Ai, let q = A(x), let c ‚àà NI be an arbitrary
individual, and let P = hT , A, q, c, Œ£i be a QAP with unrestricted Œ£. We show that hT , Ai
is consistent if and only if P admits a solution. The if direction is trivial. For the onlyif direction, suppose that hT , Ai is consistent, and consider E = {A(c)}. Since hT , Ai is
consistent and A is fresh, hT , A ‚à™ Ei is also consistent. As each model I of hT , A ‚à™ Ei
satisfies the assertion A(c), E is a solution to P.
4.2 Deciding Necessity
In Section 3.1, we have seen that for QAPs with restricted explanation signatures and
DLs that allow for disjointness axioms, nec reduces to non-exist. For the case of QAPs
with unrestricted explanation signatures but ontologies restricted to DL-Lite A , we provide
in Algorithm 1 a Turing reduction to (non-)exist; that is, a procedure that solves nec by
employing a subroutine for solving exist. The following proposition proves its correctness.
Proposition 4.3. For DL-LiteA , instance queries and UCQs, and under unrestricted explanation signatures, algorithm isNEC decides nec.
Proof. Let P = hT , A, q, ~c, Œ£i be a QAP such that hT , Ai is a DL-Lite A ontology, query
~ be an assertion over
q ‚àà IQ ‚à™ CQ, and signature Œ£ is unrestricted; furthermore, let œï(d)
~
abducible predicate œï ‚àà Œ£. We prove that œï(d) is necessary for P iff isNEC returns ‚Äúyes‚Äù.
For the only-if direction, we prove the contrapositive. Suppose that isNEC returns ‚Äúno‚Äù
~ 6‚àà E. According
on the given instance; we show that a solution E to P exists such that œï(d)
to the construction of isNEC, we consider two alternative cases.
‚Ä¢ QAP hT 0 , A0 , q, ~c, Œ£i admits a solution E. For DL-Lite A , Calvanese et al. (2009)
showed that negative inclusion axioms affect only the consistency of the given ontology,
but do not contribute towards computing the certain answer; that is, ~c ‚àà cert(q, T 0 , A0 )
~ is over a
iff hT 0 , A0 i is consistent and ~c ‚àà cert(q, T , A0 ). Then, since assertion œïÃÑ(d)
0
0
predicate not occurring in P and hT , A i is consistent, we have that E is also a solution
650

Reasoning about Explanations for Negative Query Answers in DL-Lite

~ since
to P = hT , A, q, ~c, Œ£i. By the definition, such solution does not contain œï(d),
0
0
0
~ and œïÃÑ v ¬¨œï ‚àà T .
hT , A i |= œïÃÑ(d)
‚Ä¢ QAP hT 0 , A0 , q, ~c, Œ£i has no solution. Since isNEC returns ‚Äúno‚Äù, a Œ£-ABox E ‚àó ex~ 6‚àà E ‚àó , hT , A ‚à™ E ‚àó i |= œï(d),
~ and QAP hT , A ‚à™ E ‚àó , q, ~c, Œ£i
ists such that |E ‚àó | ‚â§ 1, œï(d)
~ is entailed by hT , A ‚à™ E ‚àó i we have that
has a solution E. Given that assertion œï(d)
0
~
E := E \ {œï(d)} is also a solution to hT , A ‚à™ E ‚àó , q, ~c, Œ£i. We conclude that E 0 ‚à™ E ‚àó is
~ as required.
a solution to hT , A, q, ~c, Œ£i that does not contain œï(d),
For the if direction, we prove the contrapositive. Suppose that a Œ£-ABox E exists such
~ 6‚àà E; we show that isNEC returns ‚Äúno‚Äù. W.l.o.g., the
that E is a solution to P and œï(d)
~ we have that E is
individual u of Algorithm 1 does not occur in E. Now, if hT , A ‚à™ Ei 6|= œï(d),
0
0
a solution to QAP hT , A , q, ~c, Œ£i, so isNEC returns ‚Äúno‚Äù, as required. Otherwise, consider
~ and take the conjunctive query q 0 (~x) ‚Üê œï(~x). By the
the case in which hT , A ‚à™ Ei |= œï(d)
assumption, we have that d~ ‚àà cert(q 0 , T , A ‚à™ E). By Proposition 2.1, a query r ‚àà Rq0 ,T and
a match œÄ for r exist such that r contains a single atom and d~ ‚àà ans(r, DB A‚à™E ) is witnessed
by œÄ. Let œà(~y ) be the unique atom occurring in r such that ~x ‚äÜ ~y and let œà(~t) be the
assertion obtained from œà(~y ) by replacing each variable y ‚àà ~y with œÄ(y). Clearly, we have
that œà(~t) ‚àà A ‚à™ E. Next, we distinguish among two cases.
‚Ä¢ For each variable y ‚àà ~y we have that œÄ(y) ‚àà I. Then, let E ‚àó := ‚àÖ, if œà(~t) ‚àà A,
~ 6‚àà E ‚àó , that
and let E ‚àó := {œà(~t)}, if œà(~t) ‚àà E. In either case, we have that œï(d)
‚àó
‚àó
~ and that E ‚äÜ E. Hence, E is a solution to QAP hT , A ‚à™ E ‚àó , q, ~c, Œ£i;
hT , A ‚à™ E i |= œï(d),
so isNEC returns ‚Äúno‚Äù, as required.
‚Ä¢ Variable y ‚àà ~y exists such that œÄ(y) 6‚àà I. Given that d~ ‚äÜ I, d~ ‚àà ans(r, DB A‚à™E ), and
predicates have arity at most 2, we have that d~ is of the form d~ := hdi, œï ‚àà NC , and
œà ‚àà NR . It follows that CQ r is of the form r(x) ‚Üê œà(x, y) or r(x) ‚Üê œà(y, x). Next,
we consider the former case only, as the other case is symmetrical. Then, assertion
œà(~t) is of the form œà(d, œÄ(y)). Since œÄ(y) 6‚àà I, we have that œà(d, œÄ(y)) ‚àà E. Now, let
E 0 be the ABox obtained from E by replacing each occurrence of individual œÄ(y) with
the individual u of Algorithm 1. Since E 0 is obtained from solution E by uniformly
replacing an anonymous individual with an individual that does not occur in E and P,
we have that E 0 is also a solution to P. By the definition, œï(d) 6‚àà E 0 and œà(d, u) ‚àà E 0 .
Now, let E ‚àó := {œà(d, u)}. Since d ‚àà ans(r, DB A‚à™E ) is witnessed by œÄ and by the
definition of E ‚àó , we have that hT , A ‚à™ E ‚àó i |= œï(d). At last, since E ‚àó ‚äÜ E 0 and E 0 is a
solution to P, we conclude that ABox E 0 is a solution to hT , A ‚à™ E ‚àó , q, ~c, Œ£i. Hence,
isNEC returns ‚Äúno‚Äù, as required.
Next, we use Algorithm 1 and Propositions 3.1 and 3.2 to characterize the complexity
of nec in the presence of instance queries.
Theorem 4.4. For DL-LiteA , instance queries, and under both unrestricted and restricted
explanation signatures, nec, ‚â§-nec, and ‚äÜ-nec are NL-complete.
Proof. For the NL upper bound for nec and under restricted signatures, observe that, by
Proposition 3.2, nec reduces to non-exist. In Theorem 4.2, we proved that exist is in NL.
651

Calvanese, Ortiz, SÃåimkus & Stefanoni

Given that NL = coNL, we have that nec is in NL as well. The NL upper bound in the
case of unrestricted signature can be established using algorithm isNEC and Proposition 4.3.
Indeed, given that NL = coNL, that non-exist is in coNL, and that checking whether an
assertion is entailed by a DL-Lite A ontology is in coNL as well, we immediately obtain that
isNEC runs in nondeterministic logarithmic space. The coNL-hardness and thus also NLhardness of nec follows from Proposition 3.1 and Theorem 4.2. In addition, Proposition 3.4
states that nec and ‚äÜ-nec are equivalent and, thus, also ‚äÜ-nec is NL-complete. Finally,
by Proposition 4.1, we conclude that ‚â§-nec is NL-complete.
4.3 Deciding Relevance
By Proposition 3.3, deciding the relevance of an assertion to a QAP is equivalent to assessing
whether a QAP admits a solution. We already showed this latter problem to be NL-complete
(see Theorem 4.2). Therefore, the following result easily follows.
Theorem 4.5. For DL-LiteA , instance queries, and under both unrestricted and restricted
explanation signatures, rel is NL-complete.
In the next theorem, we show that the complexity of the problem does not change even
when we apply a minimality criterion over solutions.
Theorem 4.6. For DL-LiteA , instance queries, and under both restricted and unrestricted
explanation signatures, ‚â§-rel and ‚äÜ-rel are NL-complete.
Proof. By Proposition 4.1, it suffices to show that ‚â§-rel is NL-complete.
~ be an
(membership) Let P = hT , A, q, c, Œ£i be a QAP such that q ‚àà IQ and let œï(d)
~ is ‚â§-relevant to P if and only
ABox assertion over abducible predicate œï. We argue that œï(d)
~
~
if (i) c 6‚àà cert(q, T , A), (ii) hT , A ‚à™ {œï(d)}i is consistent, and (iii) c ‚àà cert(q, T , A ‚à™ {œï(d)}).
We show the only-if direction, since the if direction directly follows by Proposition 4.1 and
~ is ‚â§-relevant to P. By the definition
by the definition of solution. Suppose that œï(d)
of minimal solution, it follows that c 6‚àà cert(q, T , A). Also, by Proposition 4.1, it follows
~ is a ‚â§-solution to P. But then, we have that c ‚àà cert(q, T , A ‚à™ {œï(d)})
~
that {œï(d)}
and
~
that the ontology hT , A ‚à™ {œï(d)}i is consistent. Since conditions (i-iii) can be decided in
non-deterministic logarithmic space for DL-Lite A ontologies, we conclude that, for instance
queries and (un)restricted explanation signatures, ‚â§-rel is in NL.
(hardness) Hardness can be proved by employing the same reduction as in Theorem 4.2
and by taking A(c) to be the assertion to be shown relevant. By Proposition 4.1, we have
that hT , Ai is consistent if and only if A(c) is ‚â§-relevant for P.
4.4 Deciding Recognition
Finally, we consider the problem of deciding whether a given ABox is a solution to a QAP.
Theorem 4.7. For DL-LiteA , instance queries, and under both unrestricted and restricted
explanation signatures, rec is NL-complete.
Proof. (membership) Let P = hT , A, q, c, Œ£i be a QAP (where Œ£ may be restricted) such
that q ‚àà IQ and let E be an ABox. By the definition of solution to a QAP, we can decide
652

Reasoning about Explanations for Negative Query Answers in DL-Lite



-exist
unrestr.

restr.

none
‚â§
‚äÜ

PTime

NP

-nec

-rel

-rec

unrestr.

restr.

unrestr.

restr.

PTime

coNP

PTime

NP

PNP
k
PTime

PNP
k
coNP

in Œ£P2

unrestr.

restr.

NP
DP

Œ£P2

DP

Table 5.1: Complexity of reasoning over QAPs with UCQs for DL-Lite A . All entries in the
table denote completeness results, except for ‚äÜ-rel under unrestricted explanation signatures.

whether E ‚àà expl(P) in three steps: (i) check that E is a Œ£-ABox, (ii) check that hT , A ‚à™ Ei
is consistent, and (iii) check that c ‚àà cert(q, T , A ‚à™ E). For DL-Lite A ontologies, we can
perform these three steps in non-deterministic logarithmic space. Thus, for instance queries
and under both restricted and unrestricted signatures, rec is in NL.
(hardness) We provide a reduction from the consistency problem of DL-Lite A ontologies. Consider an arbitrary ontology hT , Ai. Then, we let A be a fresh concept name not
occurring in the ontology and we let c be a fresh individual. Furthermore, let q(x) ‚Üê A(x)
be our instance query. Finally, we let P = hT , A, q, c, Œ£i be our query abduction problem
with unrestricted explanation signature and we let E = {A(c)} be our target ABox. It is
not too difficult to see that hT , Ai is consistent iff E is a solution to P.
Unsurprisingly, the complexity does not change when we consider a minimality criterion
over solutions.
Theorem 4.8. For DL-LiteA , instance queries, and under both unrestricted and restricted
explanation signatures, ‚â§-rec and ‚äÜ-rec are NL-complete
Proof. By Proposition 4.1, we focus only on ‚â§-rec.
(membership) In order to decide whether E ‚àà expl‚â§ (P) we first check that E is indeed
a solution to P, which we can do in non-deterministic logarithmic space (see Theorem 4.7).
Then, by Proposition 4.1, we need to check that |E| ‚â§ 1 and that E is the empty ABox
whenever c ‚àà cert(q, T , A). Since instance checking in DL-Lite A is in NL, we conclude that
‚â§-rec is in NL as well.
(hardness) We can reuse the reduction to consistency in DL-Lite A provided in Theorem 4.7 to show that, for instance queries and under unrestricted explanation signatures,
‚â§-nec is NL-hard. We conclude that, under both restricted and unrestricted explanation
signature, ‚â§-nec and ‚äÜ-nec are NL-complete.

5. Complexity for Unions of Conjunctive Queries
In this section, we consider the more general problem of reasoning over query abduction
problems that admit UCQs in the input. We establish the complexity of the various rea653

Calvanese, Ortiz, SÃåimkus & Stefanoni

Algorithm 2 someExplanation
Input: QAP P = hT , A, q, ~c, Œ£i.
Output: ‚Äúyes‚Äù iff P has an explanation.
1: Guess a CQ qr in the perfect reformulation Rq,T of q w.r.t. T .
2: Guess a ~
c-instantiation EŒæ of qr .
3: If EŒæ \ A is a Œ£-ABox and hT , A ‚à™ EŒæ i is consistent, then return ‚Äúyes‚Äù.
4: Return ‚Äúno‚Äù.
soning tasks for these problems in DL-Lite A , under both unrestricted and restricted explanation signatures, and under the different minimality criteria. The results in this section
are summarized in Table 5.1.
5.1 Existence of Explanations
We first focus on the problem of deciding whether a query abduction problem with unrestricted signature admits at least one explanation.
It follows from Proposition 3.8 that the complexity of this problem coincides with the
complexity of deciding consistency without the UNA in the underlying DL. By Proposition 3.5, this extends to ‚äÜ-exist, and ‚â§-exist. Since reasoning without the UNA is
PTime-complete for DL-Lite A (Artale et al., 2009), we obtain the following result.
Theorem 5.1. For every DL L, UCQs, and under unrestricted explanation signatures,
exist, ‚äÜ-exist, and ‚â§-exist have the same complexity as consistency checking without
the UNA in L. Hence for DL-LiteA , the mentioned problems are PTime-complete.
If we allow for restricted explanation signatures, then deciding exist becomes harder.
For DL-Lite A , the complexity increases from PTime to NP.
Theorem 5.2. For DL-LiteA , UCQs, and under restricted explanation signatures, exist,
‚äÜ-exist, and ‚â§-exist are NP-complete. NP-hardness holds already in the following restricted settings:
1. QAPs where the TBox contains only concept inclusions of the forms A1 v A2 and
A1 v¬¨A2 for concept names A1 and A2 , the ABox is empty, and the query is a Boolean
CQ consisting of a conjunction of unary atoms over a single quantified variable.
2. QAPs with an empty TBox.
Proof. By Proposition 3.5, it is sufficient to show that exist is NP-complete.
(membership) The upper bound follows from guess-and-check Algorithm 2, which is
immediate by Proposition 3.10. It guesses non-deterministically a CQ qr in the perfect
reformulation Rq,T of q w.r.t. T , and a ~c-instantiation EŒæ of qr . The algorithm then checks
in polynomial time that EŒæ \ A is a Œ£-ABox and that the ontology hT , A ‚à™ EŒæ i is consistent;
it was shown by Calvanese et al. (2009) that the latter check is polynomial.
(hardness) Next, we provide the two hardness results. The first one follows directly
from Proposition 3.7 and the hardness proof for CQ query emptiness for the sublogic of
654

Reasoning about Explanations for Negative Query Answers in DL-Lite

DL-LiteA known as DL-Litecore given in Theorem 17 by Baader et al. (2010). For showing hardness in the second setting, we reduce the following NP-complete problem: given a
pair of directed graphs G = (V, E) and G0 = (V 0 , E 0 ), decide whether there exists an homomorphism from G to G0 . To this end, let A = {e(ca , cb ) | (a, b) ‚àà E 0 } be an ABox.
Furthermore, for B an arbitrary atomic concept and c a globally fresh individual, let
q = {e(xa , xb ) | (a, b) ‚àà E} ‚à™ {B(c)} be a Boolean CQ and Œ£ = {B} be a signature. Finally, let PG,G0 = h‚àÖ, A, q, Œ£i be a QAP; we show that there exists a homomorphism from
G to G0 iff there is a solution to PG,G0 . Indeed, if there is a homomorphism from G to G0 ,
then {B(c)} is a solution to P. For the other direction, assume there is an explanation E
for P. Since binary atoms are prohibited from occurring in E by the selection of Œ£, there
must exist a match œÄ from q to DB A . Such a mapping œÄ also witnesses the existence a
homomorphism from G to G0 .
5.2 Deciding Necessity
Now, we consider the problem of checking whether an assertion occurs in all the solutions
to a QAP P; that is, whether an assertion is necessary for P. For the case of restricted
explanation signatures, we use the reductions from Section 3.1 and Theorem 5.2 to derive
that nec and ‚äÜ-nec are coNP-complete. For the case of unrestricted explanation signatures, we use the procedure for solving nec described in Algorithm 1 to show that nec and
‚äÜ-nec are PTime-complete.
Theorem 5.3. For DL-LiteA , UCQs, and under unrestricted explanation signatures, nec
and ‚äÜ-nec are PTime-complete. Furthermore, under restricted explanation signatures,
nec and ‚äÜ-nec are coNP-complete.
Proof. In Theorem 5.1 and Theorem 5.2, we proved that the problems of deciding the existence of a solution to a QAP with unrestricted and with restricted explanation signatures
are PTime-complete and NP-complete, respectively. By applying the reduction in Proposition 3.1, we have that nec is PTime-hard under unrestricted and coNP-hard under
restricted explanation signatures.
For the upper bound, we first consider the case of restricted explanation signatures. By
Proposition 3.2, nec reduces to non-exist. By Theorem 5.2, this latter problem can be
solved in nondeterministic polynomial time. We readily obtain that nec is in coNP. For
the case of unrestricted signatures, Proposition 4.3 states that algorithm isNEC solves nec,
even when we consider UCQs in input. By the definition, isNEC requires checking whether
polynomially many QAPs do not admit a solution, and whether polynomially many DLLite A ontologies entail a given assertion. Since for DL-Lite A , instance checking is in PTime
and, by Theorem 5.1, non-exist is in PTime, we conclude that isNEC runs in polynomial
time. Thus, nec under unrestricted signatures is in PTime.
We conclude that nec is PTime-complete under unrestricted and coNP-complete under
restricted explanation signatures.
Finally, Proposition 3.4 states that nec and ‚äÜ-nec are equivalent and, thus, also ‚äÜ-nec
is PTime-complete under unrestricted and coNP-complete under restricted explanation
signatures.
655

Calvanese, Ortiz, SÃåimkus & Stefanoni

Now, we consider the complexity of ‚â§-nec and we show that, under common assumptions, the problem is harder than nec. Intuitively, this is because one has to first compute
the minimal size of an explanation, and then inspect all the explanations of that size. In
the following, we will use [i..j] to denote the integer interval {i, . . . , j}.
Theorem 5.4. For DL-LiteA , UCQs, and under both unrestricted and restricted explanation signatures, ‚â§-nec is PNP
k -complete. The hardness holds already for QAPs with an
empty TBox and a CQ.
Proof. We structure the proof as follows. First, we show that ‚â§-nec is in PNP
k . Then, we
NP
prove that the problem is Pk -hard under restricted signatures. Finally, we argue that the
same reduction can also be used in the particular case of unrestricted signatures.
(membership) Consider an arbitrary QAP P = hT , A, q, ~c, Œ£i (where the signature
may be restricted) and let Œ± be an arbitrary ABox assertion. From Corollary 3.9, we know
that if P has an explanation, then there exists an explanation whose size m is bounded
by max(q) = maxqi ‚ààq |at(qi )|. Observe that hP, Œ±i is a negative instance of ‚â§-nec iff there
is an i ‚àà [0..m] such that (a) P has an explanation E with |E| = i and Œ± 6‚àà E, and (b) E
is ‚â§-minimal. Thus, we use an auxiliary problem size-out, which is to decide given a
tuple hP 0 , Œ±0 , n0 i, where P 0 is a QAP, Œ±0 is an assertion, and n0 is an integer, whether there
exists an explanation E 0 for P 0 such that |E 0 | = n0 and Œ±0 6‚àà E 0 . Furthermore, the problem
no-smaller is to decide, given a tuple hP 0 , n0 i of a QAP and an integer, whether there
is no explanation E 0 for P 0 such that |E 0 | < n0 . Observe that size-out is in NP, while
no-smaller is in coNP. Take the tuple S = hA0 , B0 , . . . , Am , Bm i, where Ai = hP, Œ±, ii
and Bi = hP, ii, for all i ‚àà [0..m]. Due to the above observation, Œ± occurs in all ‚â§-minimal
explanations E for P iff for all i ‚àà [0..m], one of the following holds: (i) Ai is a negative
instance of size-out, or (ii) Bi is a negative instance of no-smaller. S can be built in
polynomial time in the size of the input, and whether all instances instances in S satisfy (i)
and (ii) above can be decided by making 2m parallel calls to an NP oracle. Thus we obtain
membership in PNP
k .
(hardness) We give a reduction from OddMinVertexCover, which is PNP
k -complete
(Wagner, 1987). An instance of this problem is given by a graph G = (V, E), and we are
asked whether the least cardinality over all vertex covers in G is odd. That is, is there an
odd integer k ‚àà [1..|V |] such that G has a vertex cover C with |C| = k, and there is no
vertex cover C 0 in G with |C 0 | < k?
In the reduction we exploit the following property. Given an integer k and a directed
graph G = (V, E) with m vertices, construct a new graph G0 = ([1..m], E 0 ) such that there
exist two symmetric edges between each i ‚àà [1..k] and j ‚àà [1..m]. The following holds: if
there is an injective homomorphism h from G to G0 , then G has a vertex cover of size k.
Indeed, take C = {v ‚àà V | h(v) ‚â§ k}. Due to injectivity, |C| = k. Assume an arbitrary
edge {v1 , v2 } ‚àà E. Since h is a homomorphism, due to the selection of edges we must have
h(v1 ) ‚â§ k or h(v2 ) ‚â§ k. Then {v1 , v2 } ‚à© C 6= ‚àÖ by the selection of C.
Assume an arbitrary graph G = (V, E) with vertices V = {v1 , . . . , vm }. W.l.o.g.,
G is connected, directed, and has at least 2 nodes. We construct next a QAP PG =
h‚àÖ, A|V | , qG , hi, Œ£G i and an assertion Œ±G such that G is a positive instance of OddMinVertexCover iff Œ±G is ‚â§-necessary for PG . In the reduction we use individuals odd , even, cij ,
where i, j ‚àà [0..m], concept names M , L, and roles P , 6=, Edge.
656

Reasoning about Explanations for Negative Query Answers in DL-Lite

odd
A0
L

L

A1
L

L

L

A2
L

L

L

A3
L

A4

L

even

Figure 1: The structure of A|V | for a graph G = (V, E) with 4 vertices. Solid arcs in
A` represent assertions Egde(a, b) in A` introduced in (b). A dashed arc from
an ABox A` to the individual par (`) represents the collection of assertions that
relate each individual in A` to par (`) via the role P .
Let qG be the Boolean query consisting of atoms
(i) Edge(xi1 , xi2 ), for each edge (vi1 , vi2 ) ‚àà E,
(ii) 6=(xi1 , xi2 ), for each i1 , i2 ‚àà [1..m], i1 6= i2 , and
(iii) L(x1 ), . . . , L(xm ) and P (x1 , y), M (y).
Intuitively, in (i) we represent the graph G in the query. We will use atoms in (ii) to
ensure that different variables are mapped to distinct elements. The atoms L(xi ) will be
used to measure the size of vertex covers, while the atoms P (x1 , y) and M (y) will be used
to determine their parity. We allow explanations only over concept names, and thus set
Œ£G = {M, L}.
To define A|V | , we first construct a collection A0 , . . . , Am of ABoxes, where each Aj
consists of the assertions
(a) L(cji ), for each i ‚àà [j..m],
(b) Edge(cji1 , cji2 ), for all i1 , i2 ‚àà [1..m] with i1 ‚â§ j or i2 ‚â§ j, and
(c) 6=(cji1 , cji2 ), for all i1 , i2 ‚àà [1..m] with i1 6= i2 .
For an integer k, let par (k) = odd if k is odd, and par (k) = even, otherwise. Let A0 =
{P (cji , par (j)) | i, j ‚àà [0..m]}. Then A|V | = A0 ‚à™ ¬∑ ¬∑ ¬∑ ‚à™ Am ‚à™ A0 . See Figure 1 for an example.
Finally, we let Œ±G = M (odd ). To prove the correctness of the reduction, we define
up(k) = {L(ck1 ), . . . , L(ckk ), M (par (k))}, and claim the following:
claim 1: If C is a vertex cover in G of size k, then up(k) is an explanation for PG .
Let A‚àó = A|V | ‚à™ up(k). It suffices to show the existence of a match œÄ for qG in DB A‚àó . Take
an enumeration z1 , . . . , zm of variables x1 , . . . , xm such that {z1 , . . . , zk } = {xi | vi ‚àà C}.
Take the mapping œÄ such that œÄ(zi ) = cki for all i ‚àà [1..m], and œÄ(y) = par (k). Assume
an atom Edge(xi1 , xi2 ) in qG . Due to (b) in the definition of Aj , it suffices to show that
œÄ(xi1 ) = ck` or œÄ(xi2 ) = ck` for some ` ‚â§ k. Indeed, since C is a vertex cover, vi1 ‚àà C or
vi2 ‚àà C. Then due to the enumeration of variables, xi1 = z` or xi2 = z` for some ` ‚â§ k.
Due to the definition of œÄ, œÄ(xi1 ) = ck` or œÄ(xi2 ) = ck` for ` ‚â§ k. The atoms 6=(xi1 , xi2 ) in
qG are properly mapped due to (c) in the construction of Aj and the fact that œÄ is injective
657

Calvanese, Ortiz, SÃåimkus & Stefanoni

by construction. For an atom L(xi ) in qG we have two options. If œÄ(xi ) = ck` with ` ‚â§ k,
then L(ck` ) ‚àà up(k) by the definition of up(k). Otherwise, if ` > k, then L(ck` ) ‚àà Ak by the
definition of Ak . The atom P (œÄ(x1 ), œÄ(y)) belongs to A‚àó due to the definition of A0 , while
M (œÄ(y)) ‚àà up(k) by construction of up(k).
claim 2: Assume up(k) is an explanation for PG . Then G has a vertex cover of size k.
Let A‚àó = A|V | ‚à™up(k) and let œÄ be a match for qG in DB A‚àó . Observe that due irreflexivity of
the role 6= and the atoms (ii) in qG , œÄ must be injective. Observe also that for all ` ‚àà [1..m],
where ` 6= k, we have |{c`i | L(c`i ) ‚àà A` }| < m. Due to the connectedness of G and atoms
L(x1 ), . . . , L(xm ) in qG , œÄ must use only the atoms in Ak ‚à™ A0 ‚à™ up(k). That is, œÄ is also a
match for qG in DB Ak ‚à™A0 ‚à™up(k) . Let C = {vi ‚àà V | œÄ(xi ) = ckn , n ‚àà [1..k]}. Then |C| = k
due to the injectivity of œÄ. To see that C is a vertex cover, assume an edge (vi1 , vi2 ) ‚àà E.
By construction, qG has the atom Edge(xi1 , xi2 ). Since œÄ is a match in DB Ak ‚à™A0 ‚à™up(k) ,
Edge(œÄ(xi1 ), œÄ(xi2 )) ‚àà Ak . Then, by construction of Ak , we have œÄ(xi1 ) = ckn or œÄ(xi2 ) = ckn
with n ‚â§ k. Then by the selection of C, {œÄ(xi1 ), œÄ(xi2 )} ‚à© C 6= ‚àÖ.
claim 3: Assume E is a ‚â§-minimal explanation for PG with size k. Then E = up(k ‚àí
1). Since G is connected and E is ‚â§-minimal, there exist an index ` ‚àà [1..m] such that
E ‚äÜ {L(c`1 ), . . . , L(c`m ), M (par (`))} and there is a match for qG in A` ‚à™ A0 ‚à™ E. Since
L(c`i ) ‚àà A` for i ‚àà [`+1..m] by the definition of A` , we have by cardinality minimality that
E ‚äÜ {L(c`1 ), . . . , L(c`` ), M (par (`))}. By the definition of A` , |{c`i | L(c`i ) ‚àà A` }| = m ‚àí `.
Thus, due to the injectivity of any match œÄ for qG , we must have |{c`i | L(c`i ) ‚àà E}| ‚â• `.
Hence, E = {L(c`1 ), . . . , L(c`` ), M (par (`))} = up(`). Since |E| = k, we have ` = k ‚àí 1.
We can now finalize the correctness proof:
(‚áí) Suppose there exists an odd integer k ‚àà [1..|V |] such that G has a vertex cover C
with |C| = k, and there is no vertex cover C 0 in G with |C 0 | < k. By claim 1, up(k) is
an explanation for PG . We make sure that up(k) is ‚â§-minimal. Suppose there exists an
explanation E 0 with size |E 0 | < |up(k)|, i.e., |E 0 | = ` for some ` ‚â§ k. We can assume that
E 0 is ‚â§-minimal. Then by claim 3, E 0 = up(` ‚àí 1). It follows from claim 2 that G has a
vertex cover of size ` ‚àí 1. Since ` ‚àí 1 < k, we arrive at a contradiction to the assumption
that G has no vertex cover of size < k. Thus up(k) is ‚â§-minimal. Since k is odd, we have
M (odd ) ‚àà up(k). By claim 3, apart from up(k) there is no other ‚â§-minimal explanation
for PG . That is, M (odd ) occurs in all ‚â§-minimal explanations for PG .
(‚áê) Assume M (odd ) occurs in all ‚â§-minimal explanations for PG . By claim 3, we
know that up(k) is the unique ‚â§-minimal explanation, for some integer k. Since M (odd ) ‚àà
up(k), we get that k is odd. Then, by claim 2, there is a vertex cover C with size k. It
remains to ensure that there is no vertex cover C 0 of size ` < k. Assume the opposite.
Then by claim 1 we have that up(`) is an explanation with size |up(`)| < |up(k)|, which
contradicts the assumption that up(k) is ‚â§-minimal. Thus G is a positive instance of
OddMinVertexCover.
The definition of Œ£G prohibits binary atoms from occurring in ‚â§-minimal explanations.
The same effect can be achieved by using Œ£G = Œ£(‚àÖ, A|V | , qG ) and by modifying A|V | and qG
to make it prohibitively expensive to have binary atoms in ‚â§-minimal explanations. Simply
replace each binary assertion r(c, d) in A|V | by fresh assertions r1 (c, d), . . . , rm+2 (c, d), and
each binary r(x, y) in qG by r1 (x, y), . . . , rm+2 (x, y). In this way the lower-bound can be
shown for unrestricted explanation signatures.
658

Reasoning about Explanations for Negative Query Answers in DL-Lite

5.3 Deciding Relevance
Using Theorems 5.1 and 5.2, and the reductions in Section 3, we obtain the following results.
Theorem 5.5. For DL-LiteA , UCQs, and under unrestricted explanation signatures, rel
is PTime-complete. Under restricted explanation signatures, rel is NP-complete.
Unsurprisingly, for UCQs, ‚â§-rel has the same complexity as ‚â§-nec. Indeed, the two
problems share the same source of complexity, namely the need to inspect all explanations
up to a computed size, which allows us to reduce the OddMinVertexCover problem. In
fact, PNP
k -hardness can be shown using the same reduction as in the proof of Theorem 5.4,
and a matching upper bound can be obtained by slightly modifying the algorithm for ‚â§-nec.
Theorem 5.6. For DL-LiteA , UCQs, and under both unrestricted and restricted explaNP
nation signatures, ‚â§-rel is PNP
k -complete. Pk -hardness holds already for QAPs with an
empty TBox and a CQ.
Proof. First, we show that, under restricted explanation signatures, the problem ‚â§-rel is in
NP
PNP
k . Second, we argue that, under unrestricted explanation signatures, ‚â§-rel is Pk -hard.
(membership) ‚â§-rel can be tackled in a way similar to ‚â§-nec. In fact, the algorithm
described in Theorem 5.4 can be modified in order to solve this problem. Let size-in solve
the following problem: given a tuple hP, Œ±, ni, where P is a QAP, Œ± an assertion, and n
an integer, decide whether there exists an explanation E, with |E| = n and Œ± ‚àà E. Then,
we change the positivity condition of the ‚â§-nec algorithm as follows: Œ± occurs in some
‚â§-minimal explanation E for P iff for some i ‚àà [0..m] it holds that: (i) Ai is a positive
instance of size-in, and (ii) Bi is a positive instance of no-smaller. It is easy to see
that size-in is solvable in NP, hence the whole problem is again in PNP
k .
(hardness) Recall the reduction from OddMinVertexCover to ‚â§-nec in the proof
of Theorem 5.4. We argue that exactly the same reduction also shows PNP
k -hardness of
‚â§-rel. Assume a directed graph G and let PG and Œ±G be the QAP and the assertion
resulting in the reduction. To prove the claim it suffices to show the following equivalence:
Œ±G is ‚â§-necessary for PG iff Œ±G is ‚â§-relevant for PG . This equivalence follows directly from
claim 3, which states that PG has a unique ‚â§-minimal explanation.
We now turn our attention to ‚äÜ-rel. For this problem we obtain a precise complexity
characterization for the case of restricted explanation signatures, but we leave it open
whether for unrestricted signatures the Œ£P2 upper bound shown below is tight.2 We note
that for the latter case, a coNP lower bound can be easily shown, for instance, by a
reduction from the non-existence of a homomorphism between two graphs.
Theorem 5.7. For DL-LiteA , UCQs, and under both unrestricted and restricted explanation signatures, ‚äÜ-rel is in Œ£P2 . Under restricted explanation signatures, ‚äÜ-rel is Œ£P2 -hard,
and the hardness holds already for QAPs with an empty TBox and a CQ.
Proof. (membership) Let P = hT , A, q, ~c, Œ£i be a QAP and let Œ± be an ABox assertion. We
now provide an extended version of the algorithm solving existence, which decides whether Œ±
2. The proof of the Œ£P2 lower bound under unrestricted signatures in Theorem 2 by Calvanese, Ortiz, Simkus,
and Stefanoni (2011) is incorrect.

659

Calvanese, Ortiz, SÃåimkus & Stefanoni

is ‚äÜ-relevant for P. Let has-subexpl solve the problem of deciding whether a given explanation E has a subset which is itself an explanation. In our modified algorithm, similarly to
Algorithm 2, first we non-deterministically guess a CQ qr in the perfect reformulation Rq,T
of q w.r.t. T and a ~c-instantiation EŒæ of qr such that Œ± ‚àà EŒæ . Additionally to the consistency
test and to checking that EŒæ is a Œ£-ABox, we also check the complement of has-subexpl
for E, in order to assure that E is ‚äÜ-minimal. It follows that Œ± is ‚äÜ-relevant. Since checking
the complement of has-subexpl can be done in coNP, the problem is solvable in Œ£P2 .
(hardness) We reduce the Œ£P2 -complete problem non-cert3col (Stewart, 1991, see
also Bonatti, Lutz, & Wolter, 2009). An instance of non-cert3col is given by a graph
G = (V, E) with vertices V = {1, . . . , n} such that every edge is labelled with a disjunction
of two literals over the Boolean propositions {p(i,j) | 1 ‚â§ i, j ‚â§ n}. We say that edge e ‚àà E
evaluates to true under truth assignment œÑ if œÑ satisfies the disjunction labelling e. Then,
graph G is a positive instance to non-cert3col iff a truth assignment œÑ exists such that
graph œÑ (G)‚Äîobtained from G by including only those edges that evalute to true under
œÑ ‚Äîis not 3-colorable. Assume an instance G of non-cert3col. We show how to build in
polynomial time a QAP PG = hTG , AG , qG , ~cG , Œ£G i and an ABox assertion Œ±G . We first
present all relevant definitions, after which we discuss the intuition behind the reduction
and prove its correctness.
In the construction, we use an empty TBox and a Boolean CQ, thus TG = ‚àÖ and ~cG = hi.
In order to define the ABox AG , let L be a function that assigns to each edge e ‚àà E the
set {l1 , l2 } of literals occurring in its label. Moreover, we let T(e) (resp., F(e)) be the set
containing each truth assignment œÑ to the literals in L(e) such that edge e evaluates to true
(resp., false) under œÑ . Finally, for each truth assignment œÑ and each literal l occurring in
G, we define the image of l w.r.t. œÑ , written imgœÑ (l), as follows.
(
l if œÑ (l) = t
imgœÑ (l) :=
¬Øl otherwise
We are now ready to define the ABox AG . In the definition, we use individuals a1 , . . . , a4 ;
moreover, for each literal l in G, we use individuals l and ¬Øl to denote l‚Äôs truth value. Also,
for all 1 ‚â§ k ‚â§ ` ‚â§ 4, each edge e ‚àà E, and each truth assignment œÑ ‚àà T(e) ‚à™ F(e), we let
e,œÑ
œÉk,`
be a fresh individual. ABox AG consists of four distinct components A‚àó , AtT , AfT , and
AC which we introduce next.
A‚àó ={d(l, ¬Øl), d(¬Øl, l) | literal l occurs in G} ‚à™
{B(ak ) | 1 ‚â§ k ‚â§ 3}
e,œÑ
e,œÑ
AtT ={Re (ak , œÉk,`
), Re (œÉk,`
, a` ) | e ‚àà E, œÑ ‚àà T(e), 1 ‚â§ k < ` ‚â§ 3} ‚à™
e,œÑ
{P (œÉk,`
, imgœÑ (l)) | e ‚àà E, œÑ ‚àà T(e), l ‚àà L(e), 1 ‚â§ k < ` ‚â§ 3}
e,œÑ
e,œÑ
AfT ={Re (ak , œÉk,`
), Re (œÉk,`
, a` ) | e ‚àà E, œÑ ‚àà F(e), 1 ‚â§ k ‚â§ ` ‚â§ 3} ‚à™
e,œÑ
{P (œÉk,`
, imgœÑ (l)) | e ‚àà E, œÑ ‚àà F(e), l ‚àà L(e), 1 ‚â§ k ‚â§ ` ‚â§ 3}
e,œÑ
e,œÑ
AC ={Re (a4 , œÉ4,4
), Re (œÉ4,4
, a4 ) | e ‚àà E, œÑ ‚àà T(e) ‚à™ F(e)} ‚à™
e,œÑ
{P (œÉ4,4
, imgœÑ (l)) | e ‚àà E, œÑ ‚àà T(e) ‚à™ F(e), l ‚àà L(e)}

660

Reasoning about Explanations for Negative Query Answers in DL-Lite

Next, we define the Boolean query qG . To this end, for each vertex i ‚àà V , let xi be a
distinct variable; for each edge hi, ji ‚àà E, let yi,j be a distinct variable; and, for each literal
l occurring in G, let zl and zÃÑl be two distinct variables. Then, for each edge hi, ji ‚àà E, let
qG contain the following atoms.
{B(xi ), Re (xi , yi,j ), Re (yi,j , xj ), B(xj )} ‚à™ {P (yi,j , zl ), Al (zl ), d(zl , zÃÑl ) | l ‚àà L(e)}
Finally, we let Œ±G = B(a4 ) be the assertion we want to show to be relevant and let
Œ£G = {Al | literal l occurs in G} ‚à™ {B} be the signature.
Now, we outline the main idea behind this construction. ABox AG encodes two structures: a triangular structure AtT ‚à™ AfT and a cyclic structure AC . The former structure
over individuals a1 , a2 , and a3 is such that edges in G that evaluate to true according to an
arbitrary truth assignment œÑ can be mapped only to non-reflexive edges (cf. AtT ). In contrast, edges of G that evaluate to false according to œÑ can be mapped to an arbitrary edge
(cf. AfT ). The latter, cyclic, structure AC over individual a4 (which is not asserted to be
member of B) is such that G can be mapped over AC under all possible truth assignments.
Query qG is obtained from graph G by requiring that each vertex of the graph is a
member of concept B, by reifying edges of the graph, and by incorporating the disjunction
over literals. In particular, for each literal l in G, variables zl and zÃÑl represent the truth
values of l and atom Al (zl ) is used to enforce a particular truth assignment. Since ABox AG
does not contain assertions over concept Al , each minimal explanation EœÑ for PG corresponds
to a truth assignment œÑ for G. That is, such EœÑ contains, for each literal l in G, either Al (l)
or Al (¬Øl). Also, by the definition of the ABox, query qG can be mapped over AtT ‚à™ AfT
under minimal explanation EœÑ implies that œÑ (G) is 3-colorable. In contrast, for every truth
assignment œÑ , we can map query qG over the cyclic structure AC , provided that explanation
EœÑ asserts the individual a4 to be a member of B. We are now ready to formally prove the
correctness of our reduction.
(‚áí) Suppose there is a truth assignment œÑ such that œÑ (G) is not 3-colorable; we show
that assertion B(a4 ) is ‚äÜ-relevant for PG . Consider the Œ£-ABox E = {B(a4 )} ‚à™ EœÑ , where
EœÑ = {Al (l) | œÑ (l) = t} ‚à™ {Al (¬Øl) | œÑ (l) = f }. Clearly, E is an explanation. Indeed, we can
match the query qG over the cyclic structure AC by mapping all variables xi of qG to
(interpretation of) a4 . Suppose there is a smaller explanation E 0 ‚äÇ E. Observe that EœÑ ‚äÜ E 0 .
This is because, for each literal l, concept Al does not occur in AG but does occur in qG .
Then, E \ {B(a4 )} must be an explanation. Then qG can be matched over the triangular
structure encoded in AG . Thus, œÑ (G) is 3-colorable which contradicts the assumption.
(‚áê) Let E be a ‚äÜ-minimal explanation for PG containing B(a4 ); we show that there
exists a truth assignment œÑ such that œÑ (G) is not 3-colorable. We first argue that for each
literal l we have that either Al (l) ‚àà E or Al (¬Øl) ‚àà E. This follows from three considerations.
First, due to the signature restriction, predicate d cannot occur in E. Second, for each literal
l, query qG contains atoms Al (zl ) and d(zl , zÃÑl ), whereas ABox AG contains assertions d(l, ¬Øl)
and d(¬Øl, l). Third, for each literal l, concept Al occurs in qG with one and only variable
zl . Therefore, since E is a minimal solution, we know that exactly one of Al (l) ‚àà E and
Al (¬Øl) ‚àà E holds. Next, we define the truth assignment œÑ to the literals occurring in G. For
each literal l in G, let œÑ (l) = t if Al (l) ‚àà E, and œÑ (l) = f if Al (¬Øl) ‚àà E. It is not difficult
to argue that t(G) is not 3-colorable and thus G is a positive instance of non-cert3col.
661

Calvanese, Ortiz, SÃåimkus & Stefanoni

Indeed, if œÑ (G) was 3-colorable, qG could be mapped over the triangle structure of AG
making E \ {B(a4 )} a smaller explanation, which is a contradiction.
5.4 Recognizing Explanations
Unsurprisingly, for UCQs and under both unrestricted and restricted explanation signatures,
rec is in NP. Indeed, in order to solve the problem, we need to check consistency of the
explanation with the ontology, and check whether the given tuple is in the certain answer
to the query. The former is polynomial and the latter in NP.
Theorem 5.8. For DL-LiteA , UCQs, and under both restricted and unrestricted explanation signatures, we have that rec is NP-complete. NP-hardness holds already for QAPs
with an empty TBox and a CQ.
Proof. As usual, we first show that, under (un)restricted explanation signatures, rec is
in NP. Then, we argue that, under unrestricted explanation signatures, the problem is
NP-hard.
(membership) Given a QAP P = hT , A, q, ~c, Œ£i and an ABox E, we devise an algorithm
deciding rec as follows. Firstly, the procedure checks that E is indeed a Œ£-ABox; this check
is linear in E. Then it makes sure that extending the ontology with ABox E does not lead
to an inconsistent theory; this can be checked in polynomial time (Artale et al., 2009). At
last, it decides whether ~c occurs in cert(q, T , A ‚à™ E); by Proposition 2.1 this is feasible in
NP. Hence overall the algorithm runs in non-deterministic polynomial time.
(hardness) We use essentially the same reduction from the existence of a homomorphism between directed graphs G and G0 as in the proof of Theorem 5.2, the only difference
being that instead of reducing it to the existence of an explanation over the signature
Œ£ = {B}, we leave the signature unrestricted (that is, Œ£ = Œ£(T , A, q)), and reduce the
problem to deciding whether E = {B(c)} is an explanation.
In case a preference order is in place, to recognize an explanation one has to check minimality as well. This check is coNP-hard for ‚äÜ- and ‚â§-minimality, leading to completeness
for DP.
Theorem 5.9. For DL-LiteA , UCQs, and under both restricted and unrestricted explanation signatures, we have that ‚â§-rec and ‚äÜ-rec are DP-complete. DP-hardness holds
already for QAPs with an empty TBox and a CQ.
Proof. We first argue that, under (un)restricted explanation signatures, the two problems
are in DP. Then, under unrestricted explanation signatures, we prove that ‚â§-rec and
‚äÜ-rec are DP-hard.
(membership) Membership of a problem Œ† in DP can be shown by providing two
languages L1 ‚àà NP and L2 ‚àà coNP, such that the set of all yes-instances of Œ† is L1 ‚à© L2 .
For ‚â§-rec, simply let
L1 = {(P, E) | E ‚àà expl(P)}
L2 = {(P, E) | P has no explanation E 0 s.t. |E 0 | < |E|}
For ‚äÜ-rec, we take L1 as above and L2 = {(P, E) | P has no explanation E 0 s.t. E 0 ( E}.
662

Reasoning about Explanations for Negative Query Answers in DL-Lite

(hardness) DP-hardness is shown by a reduction from the problem HP-noHP. An
instance of HP-noHP is given by two directed graphs G = (V, E) and G0 = (V 0 , E 0 ), where
hG, G0 i is a positive instance iff G has an Hamilton path and G0 does not have one. For
such a pair hG, G0 i, we define a QAP P = h‚àÖ, A, q, hi, Œ£i and a Œ£-ABox E such that:
(a) hG, G0 i is a positive instance of HP-noHP iff E is a ‚â§-minimal explanation for P, and
(b) hG, G0 i is a positive instance of HP-noHP iff E is a ‚äÜ-minimal explanation for P.
W.l.o.g., nodes in G and G0 are disjoint and are ordinary individuals. Construct an ABox
AG = {e(vi , vj ) | (vi , vj ) ‚àà E} ‚à™ {d(vi , vj ) | vi , vj ‚àà V, vi 6= vi }. Intuitively, an assertion
e(vi , vj ) encodes an edge (vi , vj ) in the graph G, whereas an assertion d(vi , vj ) encodes that
nodes vi and vj are distinct. The ABox AG0 encodes G0 in a similar way as before, using roles
e0 instead of e, and in addition it has an assertion A(vi0 ) for each vi0 ‚àà V 0 . Take a set of fresh
individuals O = {o1 , . . . , o|V 0 | } and an ABox AC = {e0 (oi , oj ), d(oi , oj ) | 1 ‚â§ i 6= j ‚â§ |V 0 |}.
Then the ABox A in P is defined as A = AG ‚à™ AG0 ‚à™ AC .
Let q = q1 ‚àß q10 ‚àß q2 ‚àß q20 ‚àß q3 be a Boolean CQ with
q1
q10
q2
q20
q3

=
=
=
=
=

{e(x1 , x2 ), e(x2 , x3 ), . . . , e(x|V |‚àí1 , x|V | ))},
{d(xi , xj ) | vi , vj ‚àà V, vi 6= vj },
{e0 (y1 , y2 ), e0 (y2 , y3 ), . . . , e0 (y|V 0 |‚àí1 , y|V 0 | )},
{d(yi , yj ) | vi0 , vj0 ‚àà V 0 , vi0 6= vj0 },
{A(y1 ), . . . , A(y|V 0 | )}.

Intuitively, q1 ‚àßq10 asks for a simple path with |V | vertices related via the role e. Analogously,
q2 ‚àß q20 asks for a simple path with |V 0 | vertices related via the role e0 . Additionally, q3 asks
that each node on the latter path satisfies A.
Finally, we let E = {A(oi ) | oi ‚àà O} and we let Œ£ = Œ£(T , A, q).
(‚áí) Assume that hG, G0 i is a positive instance of HP-noHP, and let a1 , . . . a|V | be a
Hamilton path in G. We show that E is a ‚â§-minimal and a ‚äÜ-minimal explanation for P.
To this end, first take a mapping œÄ for variables in q such that œÄ(x1 ) = a1 , . . . , œÄ(x|V | ) = a|V |
and œÄ(y1 ) = o1 , . . . , œÄ(y|V 0 | ) = o|V 0 | . Then clearly œÄ is a match for q in DB A‚à™E , and hence
E is an explanation to P. Indeed, the subquery q1 ‚àß q10 of q is fulfilled because a1 , . . . a|V |
is a Hamilton path in G, q2 ‚àß q20 is fulfilled because AC has a clique of size |V 0 |, while q3
is fulfilled by E. To assure minimality, assume towards a contradiction that there is an
explanation E 0 with |E 0 | < |E| or |E 0 | ‚äÇ |E|. In any case, |E 0 | < |V 0 |. Assume œÄ 0 is a match
for q in DB A‚à™E 0 . Note that AG and AG0 do not share individuals. Since q3 ‚àß q20 asks for
|V 0 | elements satisfying A and |E 0 | < |V 0 |, œÄ 0 must map the variables y1 , . . . , y|V 0 | to the |V 0 |
distinct individuals of AG0 . Then the presence of q2 in q implies the existence of a Hamilton
path in G0 . Contradiction.
(‚áê) Assume that E ‚àà expl‚â§ (P) (resp., E ‚àà expl‚äÜ (P)) and œÄ is a match for q in DB A‚à™E .
Note that e0 does not occur in AG and e does not occur in AG0 ‚à™ AC . Then by construction
of q1 ‚àß q10 and AG , œÄ maps the variables x1 , . . . , x|V | to the |V | distinct constants of AG and
G must have a Hamilton path. Towards a contradiction suppose G0 also has a Hamilton
path. Then by construction of AG0 , q2 ‚àß q20 ‚àß q3 has a match in DB AG0 . This means we can
build a match œÄ 0 for q in DB AG0 , which in turn means that ‚àÖ is an explanation to P. This
contradicts the assumption that E is ‚â§-minimal (resp., ‚äÜ-minimal).
663

Calvanese, Ortiz, SÃåimkus & Stefanoni

6. Discussion
In this section, we discuss some issues that remain for further investigation.
6.1 Computing Explanations
In our complexity analysis for DL-Lite A , we have not considered the problem of computing
solutions to query abduction problems. Nevertheless, we can infer upper bounds on the
complexity of computing solutions to a QAP P from the presented results. If the input
query in P is an instance query, then both computing an arbitrary solution and computing
all minimal3 solutions is easy, since by Proposition 3.10, we only need to consider singleton candidate explanations, and their number is polynomially bounded. The problem of
computing an arbitrary solution E remains polynomial for UCQs if the signature of P is
unrestricted, since we can always obtain E by creating a suitable direct instantiation of
one of the CQs in input (see Section 3.3). Instead, under restricted signatures, the total
number of (minimal) solutions is in general exponential in the size of the signature Œ£ and
in the maximal size of each query occurring in the input UCQ; so computing all of them
requires in general exponential time. It remains to be investigated whether these solutions
can be enumerated with a polynomial delay (cf., Penaloza & Sertkaya, 2010). In the case of
a restricted signature, however, the NP-harness result established in Theorem 5.2 implies
that to compute a solution E one essentially essentially cannot do better than guessing the
ABox E and deciding whether E ‚àà expl (P).
6.2 Data Complexity
In this work we have focused on combined complexity. With respect to data complexity
(i.e., when the complexity is measured with respect to the size of the ABox only, while both
the query and the TBox are considered fixed) and ontology complexity (i.e., when only the
query is considered fixed), we observe that those inference tasks that we have shown to be
NP-complete essentially rely on checking ontology consistency, and hence are in AC0 in data
complexity (Calvanese et al., 2009). Moreover, by Corollaries 3.9 and 3.11, one can restrict
the attention to explanations that are bounded by the size of the query, it follows that for
a fixed query, there are only polynomially many explanations to be considered. Hence all
our reasoning tasks are polynomial both in data complexity and in ontology complexity.
6.3 Other Description Logics.
All the lower bounds proved in the paper do not rely on properties that are exclusive to
DL-Lite A , hence they hold for other DLs as well. In fact, as we have mentioned, many
lower bounds hold even in the absence of a TBox. As for the upper bounds, we have
relied on DL-Lite A and on the existence of the perfect reformulation of a given query (see
Proposition 2.1) only to argue that canonical explanations are small and have a restricted
signature (more specifically, that they can be obtained by instantiating CQs in the perfect
reformulation of the input query) and that query answering can be done in NP. For this
reason, we expect our results to carry over to other DLs that admit ‚Äúsmall‚Äù explanations
3. Since every ABox that is a superset of a solution is itself a solution, if we don‚Äôt impose any minimality
condition, there will always be an exponential number of solutions, provided that one exists.

664

Reasoning about Explanations for Negative Query Answers in DL-Lite

and for which query answering is in NP. For instance, both the lower and the upper bounds
we have established hold for OWL 2 QL, which is obtained from DL-Lite A by forbidding
functionality assertions and dropping the unique name assumption (as our results do not
rely on functionality axioms, the unique name assumption is irrelevant).
For more expressive DLs, some bounds on the complexity of our reasoning tasks can also
be inferred. In Corollary 5.1, we showed that for QAPs under unrestricted explanation signatures, deciding the existence of an explanation has the same complexity as ontology consistency without the UNA. Hence, the problem is ExpTime-complete for all the extensions
of ALC in which standard reasoning (with or without the UNA) is also ExpTime-complete,
like the well known SHIQ. If we consider restricted explanation signatures, the problem
becomes significantly harder. This is witnessed by the lower bounds by Baader et al. (2010)
stemming from CQ-emptiness (see Proposition 3.6): exist is already 2ExpTime hard for
ALCI (Theorem 28 of Baader et al., 2010), and undecidable for ALCF (Theorem 29). For
ALC, the authors have recently improved the lower bound of CQ-emptiness from ExpTime
to NExpTime (personal communication). As mentioned in Section 3, their upper bounds
do not apply directly to our setting (although we expect some of them to extend), and the
precise characterization of the reasoning problems considered in this paper for expressive
DLs remains open.

7. Related Work
The problem of explaining missing query answers was first considered by the database
community (Jagadish, Chapman, Elkiss, Jayapandian, Li, Nandi, & Yu, 2007). In the
literature, we found three different models of explanation for missing answers, which differ
on the notion of solution. First, Chapman and Jagadish (2009) have proposed a model in
which explanations are those relational operations (e.g., natural joins or selections) that are
responsible for preventing the given tuple to be returned in the answers. Second, Tran and
Chan (2010) have defined solutions to be refinements to the input query such that the given
tuple is an answer to the relaxed query over the database. Third, Huang, Chen, Doan,
and Naughton (2008) have defined solutions to be sequences of database update operations
such that the result of answering the given conjunctive query over the updated relational
instance includes the missing answer. Herschel and HernaÃÅndez (2010) have generalized
this latter model by considering UCQs with aggregation and grouping. Although this
explanation model is closely related to ours, both the work by Huang et al. and by Herschel
and HernaÃÅndez tackle the problem from the point of view of computing solutions, whereas
we are interested in outlining the computational complexity of the problem. Moreover, in
the spirit of abductive reasoning, our solutions are of a declarative rather than operational
nature‚Äîthat is, solutions are databases rather than a sequence of database operations.
In classical logic, abductive reasoning is a form of non sequitur argument, in which a
conclusion B is not a logical consequence of the premises Œì (Œì 6|= B), even though B is
assumed to follow from the theory (Eiter & Gottlob, 1995). The aim is to find a set of
formulas A such that Œì ‚à™ A |= B. Abductive reasoning is important also in the context of
Description Logics (Elsenbroich, Kutz, & Sattler, 2006), where three orthogonal abductive
problems have been studied. First, abduction has been studied to explain concepts‚Äîthat
is, given two concepts C and D and a TBox T , concept abduction amounts to finding a
665

Calvanese, Ortiz, SÃåimkus & Stefanoni

concept H such that T |= C u H v D and C u H is satisfiable w.r.t. T (Noia, Sciascio, &
Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012)
have applied TBox abductive reasoning to diagnosis of complex systems. In particular,
given a TBox T , a set of abducible axioms Ax , and a set of axioms O, TBox abduction
amounts to finding a subset A of Ax such that T ‚à™ A |= O. Third, Klarman, Endriss, and
Schlobach (2011) have studied the problem of ABox abduction over ALC ontologies. This
problem consists in finding which additions need to be made to the ABox in order to force
a set of ABox assertions to be logically entailed by the ontology. Along the same line, Du,
Qi, Shen, and Pan (2011a) have considered this problem from a more practical perspective.
More recently, Du, Wang, Qi, Pan, and Hu (2011b) have defined the problem of abductive
conjunctive query answering, which they use as the basis for a new approach to semantic
matchmaking. Given a satisfiable DL ontology O and a CQ q, a tuple ~c is called an abductive
answer to q w.r.t. O if there exists a set E of ABox assertions such that O ‚à™ E |= q(~c).
Similarly to our approach, the authors allow to restrict the signature over which abductive
solutions can be constructed. In addition, one can limit the impact of E on O by specifying
a set of closed predicates; for each assertion Œ± over a closed predicate we require that
O ‚à™ E |= Œ± if and only if O |= Œ±. The main contribution of the paper is a procedure for
computing abductive answers to CQs over ontologies formulated in the DLP fragment of
OWL 2, which is a fragment orthogonal to DL-Lite A in terms of expressiveness. Considering
closed predicates in the context of DL-Lite A and QAPs is an interesting research direction.

8. Conclusions
In this paper we have studied the problem of explaining negative answers to user queries
over DL-Lite A ontologies. We have formalized the problem as an abductive task: given
a (U)CQ q, a consistent ontology O and a tuple of constants ~c such that ~c is not in the
certain answers of q over O, an explanation is defined as a set of ABox assertions that,
when added to O, preserve its consistency and result in ~c being in the certain answers.
We considered the special cases of allowing only a restricted signature for the assertions
in the explanation, and having only an instance query rather than a full (U)CQ in the
input. We have also considered preference orders between explanations, and studied two
such orders: subset minimal and cardinality minimal explanations. For all these cases,
we have obtained complexity bounds for four decision problems inspired in knowledge base
abduction: deciding existence of an explanation (exist), deciding whether a given assertion
occurs in all (nec) or some (rel) explanations, and recognizing explanations (rec). All
our complexity bounds are tight, with the exception of rel for subset minimal explanations
under unrestricted signatures, for which we leave open a gap between coNP-hardness and
membership in Œ£P2 .
Specifically, we have shown that in the case of instance queries all these decision problems are tractable, and in fact NL-complete, even when restricted explanations signatures
and preference orders are simultaneously considered. The picture is significantly different
for (U)CQs, as the results in Table 5.1 show. Indeed, tractability is always lost as soon as
one considers restricted explanations signatures. If the signatures are not restricted, considering a preference order also results in intractability for most cases, the only exceptions
being exist, which is always tractable, and nec, which is polynomial for subset minimal
666

Reasoning about Explanations for Negative Query Answers in DL-Lite

explanations but PNP
k for cardinality minimal ones. In contrast to nec, rel is harder, under
common assumptions, for subset minimal than for cardinality minimal explanations. rec
is hard even when the explanations signature is not restricted and no preference order is
considered.
It would be interesting to apply this framework to other lightweight description logics,
starting with those of the EL-family. Also, we would like to investigate other minimality
criteria. For instance, semantic criteria allow one to reward explanations that are less/more
constraining in terms of the models of an ontology.
Acknowledgments
The authors would like to thank the anonymous referees for their careful reading of the
submitted manuscript and their valuable comments. This work was partially supported by
the Austrian Science Fund (FWF) grants P20840 and T515, the EU FP7 projects ACSI
(Artifact-Centric Service Interoperation), grant agreement n. FP7-257593, and Optique
(Scalable End-user Access to Big Data), grant agreement n. FP7-318338, and by AlcatelLucent and EPSRC.

References
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). The DL-Lite family
and relations. J. of Artificial Intelligence Research, 36, 1‚Äì69.
Baader, F., Bienvenu, M., Lutz, C., & Wolter, F. (2010). Query and predicate emptiness
in description logics. In Proc. of the 12th Int. Conf. on the Principles of Knowledge
Representation and Reasoning (KR 2010).
Bienvenu, M. (2008). Complexity of abduction in the EL family of lightweight description
logics. In Proc. of the 11th Int. Conf. on the Principles of Knowledge Representation
and Reasoning (KR 2008), pp. 220‚Äì230. AAAI Press.
Bonatti, P. A., Lutz, C., & Wolter, F. (2009). The complexity of circumscription in description logics. J. of Artificial Intelligence Research, 35, 717‚Äì773.
Borgida, A., Franconi, E., & Horrocks, I. (2000). Explaining ALC subsumption. In Proc.
of the 14th Eur. Conf. on Artificial Intelligence (ECAI 2000).
Borgida, A., Calvanese, D., & Rodriguez-Muro, M. (2008). Explanation in the DL-Lite family of description logics. In Proc. of the 7th Int. Conf. on Ontologies, DataBases, and
Applications of Semantics (ODBASE 2008), Vol. 5332 of Lecture Notes in Computer
Science, pp. 1440‚Äì1457. Springer.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rodriguez-Muro, M.,
& Rosati, R. (2009). Ontologies and databases: The DL-Lite approach. In Tessaris,
S., & Franconi, E. (Eds.), Semantic Technologies for Informations Systems ‚Äì 5th Int.
Reasoning Web Summer School (RW 2009), Vol. 5689 of Lecture Notes in Computer
Science, pp. 255‚Äì356. Springer.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning and efficient query answering in description logics: The DL-Lite family. J.
of Automated Reasoning, 39 (3), 385‚Äì429.
667

Calvanese, Ortiz, SÃåimkus & Stefanoni

Calvanese, D., Ortiz, M., Simkus, M., & Stefanoni, G. (2011). The complexity of conjunctive
query abduction in DL-Lite. In Proc. of the 24th Int. Workshop on Description Logic
(DL 2011), Vol. 745 of CEUR Electronic Workshop Proceedings, http://ceur-ws.
org/.
Chapman, A., & Jagadish, H. V. (2009). Why not?. In Proc. of the ACM SIGMOD Int.
Conf. on Management of Data, pp. 523‚Äì534.
Du, J., Qi, G., Shen, Y.-D., & Pan, J. Z. (2011a). Towards practical ABox abduction in
large OWL DL ontologies. In Proc. of the 25th AAAI Conf. on Artificial Intelligence
(AAAI 2011). AAAI Press.
Du, J., Wang, S., Qi, G., Pan, J. Z., & Hu, Y. (2011b). A new matchmaking approach
based on abductive conjunctive query answering. In Proc. of the Joint Int. Semantic
Tech. Conf. (JIST 2011), pp. 144‚Äì159.
Eiter, T., & Gottlob, G. (1995). The complexity of logic-based abduction. J. of the ACM,
42 (1), 3‚Äì42.
Elsenbroich, C., Kutz, O., & Sattler, U. (2006). A case for abductive reasoning over
ontologies. In Proc. of the 2nd Int. Workshop on OWL: Experiences and Directions (OWLED 2006), Vol. 216. CEUR Electronic Workshop Proceedings, http:
//ceur-ws.org/.
Herschel, M., & HernaÃÅndez, M. A. (2010). Explaining missing answers to SPJUA queries.
Proc. of the VLDB Endowment, 3 (1), 185‚Äì196.
Horridge, M., Parsia, B., & Sattler, U. (2008). Laconic and precise justifications in OWL.
In Proc. of the 7th Int. Semantic Web Conf. (ISWC 2008), Vol. 5318 of Lecture Notes
in Computer Science, pp. 323‚Äì338. Springer.
Huang, J., Chen, T., Doan, A., & Naughton, J. (2008). On the provenance of non-answers
to queries over extracted data. Proc. of the VLDB Endowment, 1 (1), 736‚Äì747.
Hubauer, T., Grimm, S., Lamparter, S., & Roshchin, M. (2012). A diagnostics framework
based on abductive description logic reasoning. In Proc. of the IEEE Int. Conf. on
Industrial Technology, (ICIT 2012), pp. 1047 ‚Äì1054.
Jagadish, H. V., Chapman, A., Elkiss, A., Jayapandian, M., Li, Y., Nandi, A., & Yu, C.
(2007). Making database systems usable. In Proc. of the ACM SIGMOD Int. Conf.
on Management of Data, pp. 13‚Äì24.
Klarman, S., Endriss, U., & Schlobach, S. (2011). ABox abduction in the description logic
ALC. J. of Automated Reasoning, 46 (1), 43‚Äì80.
McGuinness, D. L., & Borgida, A. (1995). Explaining subsumption in description logics. In
Proc. of the 14th Int. Joint Conf. on Artificial Intelligence (IJCAI 1995), pp. 816‚Äì821.
McGuinness, D. L., & Patel-Schneider, P. F. (1998). Usability issues in knowledge representation systems. In Proc. of the 15th Nat. Conf. on Artificial Intelligence (AAAI 1998),
pp. 608‚Äì614. AAAI Press/The MIT Press.
Motik, B., Fokoue, A., Horrocks, I., Wu, Z., Lutz, C., & Grau, B. C. (2009). OWL 2 Web
Ontology Language Profiles. W3C Recommendation, World Wide Web Consortium.
668

Reasoning about Explanations for Negative Query Answers in DL-Lite

Noia, T. D., Sciascio, E. D., & Donini, F. M. (2009). A tableaux-based calculus for abduction
in expressive description logics: Preliminary results. In Proc. of the 22rd Int. Workshop
on Description Logic (DL 2009), Vol. 477. CEUR Electronic Workshop Proceedings,
http://ceur-ws.org/.
Papadimitriou, C. H. (1994). Computational Complexity. Addison Wesley Publ. Co.
Penaloza, R., & Sertkaya, B. (2010). Complexity of axiom pinpointing in the DL-Lite
family of description logics. In Proc. of the 19th Eur. Conf. on Artificial Intelligence
(ECAI 2010), pp. 29‚Äì34. IOS Press.
Stewart, I. A. (1991). Complete problems involving boolean labelled structures and projection transactions. J. of Logic and Computation, 1 (6), 861‚Äì882.
Tran, Q. T., & Chan, C.-Y. (2010). How to ConQueR why-not questions. In Proc. of the
ACM SIGMOD Int. Conf. on Management of Data, pp. 15‚Äì26.
Vardi, M. Y. (1982). The complexity of relational query languages. In Proc. of the 14th
Symp. on Theory of computing (STOC 1982), pp. 137‚Äì146.
Wagner, K. W. (1987). More complicated questions about maxima and minima, and some
closures of NP. Theoretical Computer Science, 51 (1‚Äì2), 53‚Äì80.

669

Journal of Artificial Intelligence Research 48 (2013) 733-782

Submitted 04/13; published 11/13

Unsupervised Sub-tree Alignment
for Tree-to-Tree Translation
Tong Xiao
Jingbo Zhu

xiaotong@mail.neu.edu.cn
zhujingbo@mail.neu.edu.cn

College of Information Science and Engineering
Northeastern University
No 3-11, Wenhua Road, Heping District
Shenyang, China

Abstract
This article presents a probabilistic sub-tree alignment model and its application to
tree-to-tree machine translation. Unlike previous work, we do not resort to surface heuristics or expensive annotated data, but instead derive an unsupervised model to infer the
syntactic correspondence between two languages. More importantly, the developed model
is syntactically-motivated and does not rely on word alignments. As a by-product, our
model outputs a sub-tree alignment matrix encoding a large number of diverse alignments
between syntactic structures, from which machine translation systems can efficiently extract translation rules that are often filtered out due to the errors in 1-best alignment.
Experimental results show that the proposed approach outperforms three state-of-the-art
baseline approaches in both alignment accuracy and grammar quality. When applied to
machine translation, our approach yields a +1.0 BLEU improvement and a -0.9 TER reduction on the NIST machine translation evaluation corpora. With tree binarization and
fuzzy decoding, it even outperforms a state-of-the-art hierarchical phrase-based system.

1. Introduction
Recent years have witnessed increasing interest in syntax-based methods for many Artificial Intelligence (AI) and Natural Language Processing (NLP) applications ranging from
text summarization to Machine Translation (MT). In particular, syntax-based models have
been intensively investigated in Statistical Machine Translation (SMT). Approaches include
string-to-tree MT (Galley, Hopkins, Knight, & Marcu, 2004; Galley, Graehl, Knight, Marcu,
DeNeefe, Wang, & Thayer, 2006), tree-to-string MT (Liu, Liu, & Lin, 2006; Huang, Kevin,
& Joshi, 2006) and tree-to-tree MT (Eisner, 2003; Zhang, Jiang, Aw, Li, Tan, & Li, 2008;
Liu, LuÃà, & Liu, 2009a; Chiang, 2010), all of which train on tree-string/tree-tree pairs and
seek to model the translation equivalency relations learned from parsed data. As a part of
the focus on syntax-based MT, tree-to-tree models that use synchronous context free grammars or synchronous tree substitution grammars have received growing interest, showing
very promising results on several well-established evaluation tasks (Zhang et al., 2008; Liu
et al., 2009a; Chiang, 2010). For example, recent studies (Chiang, 2010) have demonstrated
that modern tree-to-tree systems can significantly outperform the hierarchical phrase-based
counterpart in large scale Chinese-English and Arabic-English translation.
In tree-to-tree MT, the translation problem can be broadly regarded as transformation
from a source-language syntax tree to a target-language syntax tree. To model this process,
c
2013
AI Access Foundation. All rights reserved.

Xiao & Zhu

most tree-to-tree systems resort to the general framework of synchronous grammars, where
a pair of trees is generated with derivations of synchronous grammar rules (or translation
rules). In such a model, the goal of translation is to build the underlying derivations for
all pairs of trees and output the target string encoded in the most likely derivation. Figure
1 shows an intuitive example to illustrate the generation process of a tree pair using a
sample grammar, where both the source and target-language sentences are associated with
the phrase structure trees generated using automatic parsers.1
Previous work has shown that the acquisition of good translation rules is one of the essential factors contributing to the success of syntax-based systems (DeNeefe, Knight, Wang,
& Marcu, 2007). To date, several research groups have addressed the issue of rule acquisition and designed effective algorithms to extract high-coverage grammars from bilingual
parsed data (Zhang et al., 2008; Liu et al., 2009a; Chiang, 2010). Despite their differences
in detailed modeling, all these approaches rely on syntactic alignments that align tree nodes
in the syntactic parse tree in one language to tree nodes in the other, and these alignments
could be employed by standard tree-to-tree rule extraction algorithms (Liu et al., 2009a;
Chiang, 2010).
While current tree-to-tree models heavily depend on syntactic alignments between two
languages, all these alignments are induced indirectly from word alignments and tree-to-tree
systems are very sensitive to the word alignment behavior. Unfortunately, word alignments
are in general far from perfect from the viewpoint of syntactic alignment (Fossum, Knight,
& Abney, 2008). In some cases, even one spurious word alignment can prevent a large
number of desirable rules from extraction. For example, Figure 2(a) shows some tree-totree translation rules extracted using the word alignment produced by GIZA++. This
alignment incorrectly aligns the source word ‚Äù‰∫Ü‚Äù (a past tense marker in Chinese) to the
target word ‚Äùthe‚Äù. This spurious word alignment produces an incorrect rule ‚ÄùAS(‰∫Ü) ‚Üí
DT(the)‚Äù and blocks the extraction of more high-level syntactic transfer rules, such as
‚ÄùIP(NN1 VP2 ) ‚Üí S(NP1 VP2 )‚Äù.
Obviously, a more desirable solution is to directly infer node correspondences from
the source and target parse trees, namely sub-tree alignment. As syntactic parse trees can
explain the underlying structure of sentences well, performing alignment in sub-tree level can
make more benefits from the high-level structural information and syntactic categorization.
For example, consider the alignment in Figure 2(b). It links up the nodes in the two parse
trees (in Chinese and English), rather than aligning them in word level. In this example, it
is very confident to align the VP sub-tree (spanning ‚ÄùÂ§ßÂπÖÂ∫¶ ÂáèÂ∞ë ‰∫Ü‚Äù) in the source tree
to the VP sub-tree (spanning ‚Äùhave drastically fallen‚Äù) in the target tree.2 We therefore
1. In a phrase structure tree, the leaf nodes are words of the sentence. The internal tree nodes followed by
leaf nodes are labeled with Part-Of-Speech (POS) tags, while other tree nodes are labeled with syntactic
categories defined in treebanks (see appendix for meanings of the POS tags and syntactic categories used
in this work). In NLP, many well-developed parsers are available for automatic parsing. Also, several
good-quality phrase structure treebanks across languages can be used to train parsing models, such as
the Penn English and Chinese Treebanks (Marcus, Santorini, & Marcinkiewicz, 1993; Xue, Xia, Chiou,
& Palmer, 2005). Note that in addition to phrase structure syntax, there are other popular formalisms
(e.g., dependency syntax) can be used in syntax-based MT. But the discussion on different formalisms
of syntactic parsing is beyond the scope of this article. We instead focus on tree-to-tree MT based on
phrase structure trees throughout this work.
2. Both Chinese and English follow the subject-verb-object structure. The verb phrases in a Chinese
sentence are frequently aligned to the verb phrases in its English translation.

734

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

NP

VP

NP

VP

PRP

VBD

he

was

Target-language Side
(English)

S

VP
VBN

PP

satisfied
PP
IN

NP

with

r1

r4

DT

NNS

the

answers

r2

‰ªñ
(ta)

ÂõûÁ≠î
(huida)

P

NN

Ë°®Á§∫
(biaoshi)

Êª°ÊÑè
(manyi)

VV

NN

PP

PN

PP

VP

NP

VP

NP

VP

Source-language Side
(Chinese)

r3
ÂØπ
(dui)

IP

Synchronous Grammar Used
ID
r1
r2
r3
r4

Source-language Side
NP(PN(‰ªñ))
PP(P(ÂØπ) NN(ÂõûÁ≠î))
VP(PP1 VP(VV(Ë°®Á§∫) NN(Êª°ÊÑè)))
IP(NP1 VP2 )

Target-language Side
NP(PRP(he))
PP(IN(with) NP(DT(the) NNS(answers)))
VP(VBD(was) VP(VBN(satisfied) PP1 ))
S(NP1 VP2 )

Figure 1: Example derivation of tree-to-tree translation rules. All the rules are represented
as aligned pairs of tree-fragments (linked with dotted lines). The subscripts on
both language sides of the grammar rules indicate the alignments of frontier nonterminals. On each language side of the derivation, the round-head lines link up
the frontier non-terminals that are rewritten during translation.
know that the child nodes in the source-language VP are likely to be aligned with the child
nodes in the target-language VP. This means that once the two VPs are aligned, their
children should not be aligned outside the VP sub-tree structure, i.e., we can prevent the
alignment between the Chinese tree node ‚ÄùAS‚Äù and the English tree node ‚ÄùDT‚Äù due to its
inconsistency with the VP-VP alignment. In this case, ‚ÄùAS‚Äù is correctly aligned to ‚ÄùVBP‚Äù.
735

Xiao & Zhu

S

S
NP
DT

NP

VP

NNS

VBP

DT

ADVP

the imports have

RB

VP

NNS

VBP

ADVP

the imports have

VBN

RB

drastically fallen

drastically fallen

Â§ßÂπÖÂ∫¶
ËøõÂè£

ÂáèÂ∞ë

‰∫Ü

VV

AS

AD

NN

VBN

Â§ßÂπÖÂ∫¶
ËøõÂè£

VP

‰∫Ü

VV

AS

AD

NN

VP

ÂáèÂ∞ë

VP
VP

IP

IP

(Minimal) Rules Extracted

(Minimal) Rules Extracted
r1

AS(‰∫Ü) ‚Üí DT(the)

r3

AD(Â§ßÂπÖÂ∫¶) ‚Üí RB(drastically)

r2

NN(ËøõÂè£) ‚Üí NNS(imports)

r4

VV(ÂáèÂ∞ë) ‚Üí VBN(fallen)

r3

AD(Â§ßÂπÖÂ∫¶) ‚Üí RB(drastically)

r6

AS(‰∫Ü) ‚Üí VBP(have)

r4

VV(ÂáèÂ∞ë) ‚Üí VBN(fallen)

r7

NN(ËøõÂè£) ‚Üí NP(DT(the) NNS(imports))

r5

IP(NN1 VP(AD2 VP(VV3 AS4 ))) ‚Üí

r8

VP(AD1 VP(VV2 AS3 )) ‚Üí
VP(VBP3 ADVP(RB1 VBN2 ))

S(NP(DT4 NNS1 ) VP(VBP(have) ADVP(RB2 VBN3 )))

r9

(a) word alignment and extracted rules

IP(NN1 VP2 ) ‚Üí S(NP1 VP2 )

(b) sub-tree alignment and extracted rules

Figure 2: Tree-to-tree translation rules extracted via word alignment (a) or sub-tree alignment (b). The dashed lines represent word alignment links, and the dotted lines
represent sub-tree alignment (or node alignment) links.
As a result, the bad rule ‚ÄùAS(‰∫Ü) ‚Üí DT(the)‚Äù is ruled out, and a few more desirable rules
are extracted using the sub-tree alignment (including the desirable rules that are blocked
in Figure 2(a)).
Actually, researchers have been aware of the sub-tree alignment problem and tried to
explore solutions (Tinsley, Zhechev, Hearne, & Way, 2007; Sun, Zhang, & Tan, 2010b,
2010a). For example, they proposed to judge whether two nodes should be aligned or not. In
their work, the alignment confidence is first calculated using lexical translation probabilities
or classifiers trained on labeled data, and then the final alignment is determined according to
node-level alignment score. However, the inference of sub-tree alignment in these approaches
relies on heuristic algorithms, and their models are essentially not optimized within a unified
probabilistic framework.
Moreover, when the alignment result is applied to tree-to-tree translation, most systems
suffer from another problem that translation rules are extracted using the 1-best alignment
only (Zhang et al., 2008; Liu et al., 2009a; Chiang, 2010). This problem significantly affects
736

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

the rule-set coverage rate due to alignment errors. A simple solution to this issue is to use
k-best alignments instead. However, k-best alignments often have few variations and many
redundancies. Most of them differ in only a few alignment links. It is obviously inefficient
to extract rules from those similar alignments.
In this article we address the sub-tree alignment issue in a principled way and investigate
methods to effectively apply the sub-tree alignment result to tree-to-tree MT. In particular,
‚Ä¢ We develop an unsupervised approach to learning a probabilistic sub-tree alignment
model from bi-lingual parsed data.
‚Ä¢ We investigate different methods for integrating sub-tree alignment to tree-to-tree
machine translation. Specifically, we develop a sub-tree alignment matrix encoding
an exponentially large number of diverse sub-tree alignments, and extract multiple
alternative translation rules using alignment posteriors from the sub-tree alignment
matrix.
The advantages of our approach are three-fold. First, our approach does not rely on
heuristic algorithms or labeled data. Second, the developed sub-tree alignment model has
the same structure as the model used in MT, i.e., both are based on synchronous tree
substitution grammars. It means that MT systems can directly make benefits from the subtree alignment model, especially for rule extraction and MT parameter estimation. Third,
by accessing the sub-tree alignment matrix which encodes a large number of alignments,
we can efficiently obtain rules that are often filtered out due to the errors within the 1best/k-best alignment result. We experiment with our approach in Chinese-English subtree alignment and translation tasks. For sub-tree alignment, it significantly outperforms
three state-of-the-art baselines. For machine translation, our approach obtains significant
improvements for a tree-to-tree system in both rule quality and translation quality. For
example, it yields a +1.0 BLEU improvement and a -0.9 TER reduction on the NIST MT
evaluation corpora. Finally, our system even outperforms a state-of-the-art hierarchical
phrase-based system when equipped with tree binarization (Wang, Knight, & Marcu, 2007b)
and fuzzy decoding (Chiang, 2010) techniques.
The rest of the article is structured as follows. Section 2 briefly introduces the subtree alignment task. Section 3 describes our unsupervised approach to sub-tree alignment.
Then, Section 4 investigates effective methods for applying our alignment model to tree-totree translation. Then, Section 5 presents experimental evaluation of our approach. After
reviewing the related work in Section 6, some interesting issues are discussed in Section 7.
Finally, the article is concluded with a summary in Section 8.

2. Problem Statement
In general, sub-tree alignment can be defined as a task that we find an alignment from the
nodes in a tree to the nodes of another tree.3 While we restrict ourselves to machine translation in this article, sub-tree alignment is actually not a task that must be tightly coupled
with specific applications. For example, in addition to machine translation, there are other
3. In this work term tree refers to a data structure that can be defined recursively as a collection of nodes
starting at a root node. Each node has a list of edges pointing to nodes (or its children), with the
constraint that no edge is duplicated or points to the root (Knuth, 1997).

737

Xiao & Zhu

NLP tasks which can make benefits from sub-tree alignment, including sentence simplification (Cohn & Lapata, 2009; Woodsend & Lapata, 2011), paraphrasing (Das & Smith,
2009), question answering (Wang, Smith, & Mitamura, 2007a), and parser adaptation and
projection (Smith & Eisner, 2009).
Ideally, we would like a sub-tree alignment system that is language independent and
application independent. Given a parallel corpus of training examples, we should be able
to learn an alignment model and use it to infer the syntactic correspondence for any tree
pairs. Broadly speaking, any alignments between paired linguistic tree structures can be
regarded as instances of sub-tree alignment. For example, the alignment can be performed
between dependency trees (Eisner, 2003; Nakazawa & Kurohashi, 2011) or phrase structure
trees (Tinsley et al., 2007; Sun et al., 2010b).
Although the sub-tree alignment problem includes a number of tasks that seek alignments between syntactic tree structures, we are particularly interested in aligning the tree
nodes of phrase structure trees in this work. We focus on phrase structure sub-tree alignment because: 1) phrase structure parsing is one of the most popular syntactic analysis
formalisms. Several state-of-the-art full parsing models/tools have been developed for many
languages; 2) phrase structure trees are the basis of many successful syntax-based MT systems. While other alternatives, such as dependency trees, can also benefit MT systems,
the constituency-based models are of interest to a relatively larger portion of the MT community and show state-of-the-art performance in recent tree-to-tree systems (Zhang et al.,
2008; Liu et al., 2009a; Chiang, 2010).
In natural language processing, a phrase structure parse tree is an ordered and rooted
tree. It represents the syntactic structure of a sentence according to some phrase structure grammars (or constituency grammars) which describe the way words combine to form
phrases and sentences (Chiswell & Hodges, 2007). Generally, phrase structure parse trees
distinguish between terminal and non-terminal nodes. The leaf nodes are labeled by terminal categories (or words), while the internal nodes are labeled by non-terminal categories of
the grammar (or phrasal categories). For example, in the English parse tree in Figure 2(b),
‚Äùimports‚Äù is a terminal, while nodes ‚ÄùNP‚Äù and ‚ÄùNNS‚Äù are two non-terminals indicating
the noun phrase and the plural form of nouns respectively.4 In the following description
and experiments, we take the Penn Treebank for the standard of tree annotation. Here we
choose the Penn Treebank because it is one of the most popular tree-annotated corpora
used in syntactic parsing and of good quality and quantity for several languages, such as
Chinese and English.
Based on the above definition, a sub-tree alignment can be defined as the alignments
between non-terminals in the source and target-language (phrase structure) parse trees.5
More formally, given a source-language parse tree S and a target-language parse tree T , a
sub-tree alignment (denoted as A(S, T ) or A for short) is a set of node-to-node links between
S and T . For any node pair (u, v) in (S, T ), a good alignment should follow three criteria
(Tinsley et al., 2007):
1. u (or v) can only be aligned once (indicating 1-to-1 alignment).
4. Note that the non-terminals that are always followed by leaf nodes are also called pre-terminals and
labeled by part-of-speech tags. E.g., the ‚ÄùNNS‚Äù node is followed by the terminal node ‚Äùimports‚Äù and
thus is a pre-terminal.
5. In contrast, a word alignment can be regarded as the alignments between terminals in two languages.

738

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

2. if u is aligned to v, the descendants of u can only be aligned to the descendants of v.
3. if u is aligned to v, the ancestors of u can only be aligned to the ancestors of v.
Such criteria prevent from aligning constituents that cross each other. This property
is very similar to that of some bi-parsing formalisms, such as synchronous context free
grammars and synchronous tree substitution grammars. Its advantage is that it enables the
use of powerful synchronous grammars in modeling the sub-tree alignment problem. As is
shown in the very next section, based on the above constraints we can take synchronous
tree substitution grammars as the basis of our proposed model.
According to Tinsley et al.‚Äôs (2007) work, the alignments satisfying the above criteria
are called well-formed alignments. An alignment is ill-formed when it violates any of these
criteria. In this work we focus on the well-formed alignments. Hence the sub-tree alignment
task can be stated as: given a pair of parse trees (S, T ), we search for the most likely wellformed alignment between S and T
AÃÇ = arg max P(A | S, T )

(1)

A‚àà‚Ñ¶(S,T )

where ‚Ñ¶(S, T ) is the set of well-formed alignments, and P(A | S, T ) can be viewed as an
alignment model which predicts the probability for every alignment A given S and T .
In what follows, we describe our approach to sub-tree alignment for tree-to-tree translation, including the alignment model, the training and inference methods, and the effective
use of our model in tree-to-tree MT systems.

3. Unsupervised Sub-tree Alignment
In this section we present our unsupervised sub-tree alignment model. We first define
the base model of sub-tree alignment in the framework of synchronous tree substitution
grammars, and then describe the model parameterization, training and inference methods.
3.1 Base Model
The fundamental question of sub-tree alignment is how to define the correspondence between
nodes of the source-language parse tree and nodes of the target-language parse tree. Here we
address the issue using Synchronous Tree Substitution Grammars (STSGs) which have been
widely adopted to model the transformation process between source and target-language
parse trees in MT (Zhang et al., 2008; Liu et al., 2009a; Chiang, 2010). In the general
framework of STSGs (Chiang & Knight, 2006), it is assumed that a pair of source and
target parse trees can be simultaneously generated using a derivation of STSG rules (or
tree-to-tree transfer rules). For example, the grammar in Figure 1 is an STSG and the
rules in it can be used to generate a pair of sentences. More formally, an STSG is a system
hNs , Nt , Ws , Wt , Œ®i, where Ns and Nt are sets of non-terminals in the source and target
languages, Ws and Wt are sets of terminals (or words) in the source and target languages,
Œ® is a finite set of productions. Each production is an STSG rewrite rule (denoted as r) for
a pair of source and target-language non-terminals (snt , tnt ):
hsnt , tnt i ‚Üí hsr , tr , œÜr i
739

Xiao & Zhu

where sr is a source-language tree-fragment, whose frontier nodes are either words in Ws or
non-terminals in Ns (labeled by x); tr is the corresponding target-language tree-fragment;
and œÜr is a set of 1-to-1 alignments that connect the frontier non-terminals of sr to the
frontier non-terminals of tr . For example, for r5 in Figure 2(a), we have
snt = IP
tnt = S
sr = IP(NN:x VP(AD:x VP(VV:x AS:x)))
tr = S(NP(DT:x NNS:x) VP(VBP(have) ADVP(RB:x VBN:x)))
œÜr = {1-2, 2-3, 3-4, 4-1}
Note that the non-terminals on the left-hand side of the rule are actually the roots of
the corresponding tree-fragments on the right hand side. This means that the rule contains
exactly the same information no matter whether the root nodes (snt , tnt ) are explicitly
represented or not. So in the following parts of this article we use hsr , tr , œÜr i for a simpler representation of STSG rules. Beyond this, STSG rules can be written in a more
compact form where the alignment œÜr is encoded in the numbers assigned to the frontier
non-terminals of sr and tr . For example, in Figures 1 and 2, the subscripts on both language
sides of the STSG rules indicate the aligned pairs of frontier non-terminals.
In the STSG model, frontier non-terminals are also called substitution nodes. When
applying STSGs, we can rewrite an aligned pair of substitution nodes with the tree-fragment
pair encoded in an STSG rule. The only constraint in this operation is that the labels of
the substituted non-terminals must match the root labels of the rewrite rules. For example,
the round-head lines in Figure 1 show the substitution operations used in a derivation.
By using STSG rules, we can parse any tree pair and generate the corresponding derivations. The generation process is trivial: we start with the pair of root symbols and repeatedly rewrite pairs of non-terminal symbols using STSG rules. For example, for the tree pair
in Figure 2(b), we start with the root labels of the source and target-language parse trees
(the superscript indicates the node index in the tree)
h IP[1] , S[1] i
Then we apply rule r9 .
IP[1] ‚áîS[1]

‚àí‚àí‚àí‚àí‚àí‚àí‚Üí h IP(NN[2] VP[3] ), S(NP[2] VP[3] ) i
r9

IP[1] ‚áîS[1]

where ‚àí‚àí‚àí‚àí‚àí‚àí‚Üí represents the operation that rewrites the aligned node pair IP[1] and
r9

S[1] with r9 (denoted as IP[1] ‚áî S[1] ). This process proceeds by repeatedly rewriting the
remaining frontier non-terminals until we get the complete source and target-language trees,
like so:
740

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

NN[2] ‚áîNP[2]

‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí
r7

VP[3] ‚áîVP[3]

‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí
r8

h IP(NN(ËøõÂè£) VP[3] ), S(NP(DT(the) NNS(imports)) VP[3] ) i
h IP(NN(ËøõÂè£) VP(AD

[4]

[5]

VP(VV

AS[6] ))),

S(NP(DT(the) NNS(imports)) VP(VBP
AD[4] ‚áîRB[4]

‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí
r3

h IP(NN(ËøõÂè£) VP(AD(Â§ßÂπÖÂ∫¶) VP(VV

[5]

S(NP(DT(the) NNS(imports)) VP(VBP
[5]

VV

[6]

ADVP(RB

[4]

VBN[5] ))) i

AS[6] ))),

[6]

ADVP(RB(drastically) VBN[5] ))) i

[5]

‚áîVBN

‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí h IP(NN(ËøõÂè£) VP(AD(Â§ßÂπÖÂ∫¶) VP(VV(ÂáèÂ∞ë) AS[6] ))),
r4

S(NP(DT(the) NNS(imports)) VP(VBP

[6]

ADVP(RB(drastically) VBN(fallen)))) i
AS[6] ‚áîVBP[6]

‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí
r6

h IP(NN(ËøõÂè£) VP(AD(Â§ßÂπÖÂ∫¶) VP(VV(ÂáèÂ∞ë) AS(‰∫Ü)))),
S(NP(DT(the) NNS(imports)) VP(VBP(have)
ADVP(RB(drastically) VBN(fallen)))) i

In the above process, each rewrite rule indicates a node alignment. More importantly,
derivations from this model have two very nice properties: first, for each node u in the
source-language (or target-language) parse tree, there is at most one node of the targetlanguage (or source-language) parse tree which is aligned with u; second, the hierarchical
structure behind the alignment avoids links between constituents that cross each other.
Consequently, for any well-formed sub-tree alignment A, we can always find a derivation d
that encodes the alignment A. It means that the sub-tree alignment problem is essentially
the same as the problem of finding the most likely STSG derivation. Thus the sub-tree
alignment task (see Equation (1)) can be restated as finding the most likely derivation for
a given pair of parse trees.
To model the derivation probability, we follow the formulation adopted in statistical
word alignment (Brown, Pietra, Pietra, & Mercer, 1993; Vogel, Ney, & Tillmann, 1996).
The transformation from a source-language tree S to a target-language tree T is described
by the following equation.
X
P(T | S) =
PŒ∏ (T, d|S)
(2)
d‚ààD(S,T )

where D(S, T ) is the set of all derivations transforming S into T (say, aligning the nodes
of S to the nodes of T ), PŒ∏ (T, d|S) is the probability of transforming from S to T using a
derivation d ‚àà D(S, T ), and Œ∏ is the parameters of the model. Here we use the notation
PŒ∏ (¬∑) to express the dependence of the model on the parameters. In general, the optimal
value of Œ∏ is learned from parsed parallel data by some training criteria. For example, in
the context of unsupervised learning, we can optimize the model parameters by maximizing
the probability of the observed data (known as maximum likelihood training).
Given a set of optimal parameters Œ∏ÃÇ, the best sub-tree alignment for (S, T ) is determined
P (T,d|S)
by choosing a derivation for which PŒ∏ÃÇ (d | S, T ) is greatest. Since PŒ∏ÃÇ (d | S, T ) = PŒ∏ÃÇ (T |S)
Œ∏ÃÇ

741

Xiao & Zhu

and PŒ∏ÃÇ (T | S) is a constant for given (S, T ) and Œ∏ÃÇ, finding the best derivation dÀÜ is the same
as finding a derivation so as to make PŒ∏ÃÇ (T, d | S) as large as possible. Hence we reach the
fundamental equation of sub-tree alignment.
dÀÜ = arg max PŒ∏ÃÇ (T, d | S)

(3)

d‚ààD(S,T )

The above formulation implies three fundamental issues of sub-tree alignment, including
modeling of derivation probability (i.e., PŒ∏ (T, d|S)), learning of model parameters (i.e., Œ∏ÃÇ)
and finding the best alignment given the learned model (i.e., the arg max operation). In
the following parts of this section, we describe our solutions to these issues.
3.2 Parameterization
In the simplest case, our alignment model has one parameter for each instance of derivation.
However, this model would have an unmanageable set of parameters since the number of
derivations is exponential in the length of the input sentences. Here we choose a simple
solution to this issue which decomposes the base model into a product of trainable submodels. We start with an assumption that rules are conditionally independent for the given
source-language parse tree S, then the probability P(T, d | S) can be defined as a product
of rule probabilities (for conciseness, we will drop the subscript Œ∏ from now on).
Y
P(T, d | S) ‚â°
P(r | S)
(4)
r‚ààd

Nevertheless complex tree-to-tree mappings still result in an extremely large number of
rules, which causes both the computational problem and the degenerate analysis of the
data.6 To control the number of parameters at a reasonable level, we further decompose
the rule probability into simpler probability factors under independence assumptions.
First we assume that the generation of a rule r is independent of the input tree S, when
conditioned on the source-language side of the rule, that is,
P(r | S) ‚â° P(r | sr )

(5)

Note that this is a strong assumption that the generation of a synchronous grammar
rule depends only on its source-language side. It is similar to those used in statistical
modeling of machine translation (Brown et al., 1993; Koehn, Och, & Marcu, 2003; Galley
et al., 2004; Chiang, 2005) where the generation of atomic alignment/translation units are
conditioned on the associated source-language words or tree-fragments, rather than the
whole input sentence or tree. In SMT, the independence assumptions based on phrases or
translation rules are generally used to decompose the parallel corpus into manageable units
for parameter estimation. As they have been successfully used in most of modern SMT
systems, we adopt a similar assumption here to ease the parameter estimation process of
our model.
Then we further decompose P(r | sr ) with additional assumptions. Since r = hsr , tr , œÜr i,
P(r | sr ) can be written into another form using the chain rule:
6. Here degenerate analysis refers to the case where using models that are too complex results in overfitting
and a poor generalization ability on unseen data.

742

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

P(r | sr ) = P(sr , tr , œÜr | sr )
= P(œÜr | sr , tr ) √ó P(tr | sr )

(6)

Equation (6) indicates two sub-models, including a reordering model of frontier nonterminals P(œÜr | sr , tr ), and a tree-fragment translation model P(tr | sr ).
To model P(œÜr | sr , tr ), we view frontier non-terminal reordering as a problem of aligning
the elements between two vectors of non-terminals. Let vnt(¬∑) be a function that returns
the vector of leaf non-terminals for a given tree-fragment. œÜr defines a 1-to-1 alignment
between the non-terminals in vnt(sr ) and vnt(tr ). For example, for r5 in Figure 2(a), the
frontier non-terminal vectors of sr5 and tr5 are:
vnt(sr5 ) = (NN, AD, VV, AS)
vnt(tr5 ) = (DT, NNS, RB, VBN)
Then œÜr5 = {1-2, 2-3, 3-4, 4-1} indicates an alignment between vnt(sr5 ) and vnt(tr5 ), say,
NN is aligned to NNS, AD is aligned to RB and so on. Here we opt for a simple model
for selecting œÜr . It models the non-terminal reordering probability on the condition of the
frontier non-terminal vectors on both language sides, as follows7
P(œÜr | tr , sr ) ‚â° Preorder (œÜr | vnt(sr ), vnt(tr ))

(7)

We then turn to the problem of modeling the tree-fragment translation P(tr | sr ) (i.e.,
the second sub-model defined in Equation (6)). We define that a tree-fragment Œ± consists of
two parts: words lex(Œ±) (i.e., terminals of Œ±) and a tree structure tree(Œ±) without lexicons
involved. For example, for r5 in Figure 2(a), the target-language tree-fragment contains
two elements lex(tr5 ) and tree(tr5 ):
lex(tr5 ) = have
tree(tr5 ) = S(NP(DT:x NNS:x) VP(VBP ADVP(RB:x VBN:x)))
Let root(¬∑) be a function that returns the root for a given tree-fragment. We can write
P(tr | sr ) as:
P(tr | sr ) = P(lex(tr ), tree(tr ) | sr )
= P(root(tr ) | sr ) √ó
P(tree(tr ) | root(tr ), sr ) √ó
P(lex(tr ) | tree(tr ), root(tr ), sr )

(8)

It is worth noting that Equation (8) is not an approximation. Here we just choose
one of the many ways in which P(tr | sr ) can be written as the product of a series of
7. The reordering model defined here ensures that arbitrary 1-to-1 alignments can be handled. But it might
result in a very large model with sparse parameter distributions if big tree-fragments are involved. In
considering this issue, we choose several pruning methods for better control of rule size in our sub-tree
alignment system. See Section 5.2.2 for the pruning settings in this work.

743

Xiao & Zhu

conditional probabilities. We simply assert this equation that when generating a targetlanguage tree-fragment for a source-language tree-fragment, first we can choose the root
symbol of the target-language tree-fragment given the source-language tree-fragment (in
probability of P(root(tr ) | sr )). Then we can choose the tree-structure of the target-language
tree-fragment given its root symbol and the source-language tree-fragment (in probability of
P(tree(tr ) | root(tr ), sr )). Then we can choose the target-language terminals associated with
the tree-fragment given the target-language tree-structure, target-language root symbol and
source-language tree-fragment (in probability of P(lex(tr ) | tree(tr ), root(tr ), sr )).
Another note is that Equation (8) actually does not reduce the model complexity. For
example, P(lex(tr ) | tree(tr ), root(tr ), sr ) essentially indicates all the combinations of source
and target-language tree-fragments. A simpler model is required for a feasible solution
for parameter estimation. To do this, we introduce additional assumptions to relax the
conditions of these probabilities and reduce the number of parameters to a reasonable level.
1. P(root(tr ) | sr ) depends only on root(sr ), i.e.,
P(root(tr ) | sr ) ‚â° Pnt (root(tr ) | root(sr ))

(9)

This assumption implies the node correspondence between the source and targetlanguage parse trees.
2. P(tree(tr ) | root(tr ), sr ) depends only on root(tr ), i.e.,
P(tree(tr ) | root(tr ), sr ) ‚â° Ptree (tree(tr ) | root(tr ))

(10)

The second assumption results in a monolingual model of generating target-language
tree-structures, where the generation of a tree-fragment is only conditioned on its
root. It can be viewed as an analogy to the generative model used in standard TSGs.
3. P(lex(tr ) | tree(tr ), root(tr ), sr ) only depends on source words lex(sr ), i.e.,
P(lex(tr ) | tree(tr ), root(tr ), sr ) ‚â° Plex (lex(tr ) | lex(sr ))

(11)

This allows us to directly model the terminal correspondence between the two languages.
Then, we substitute Equations (9)-(11) into Equation (8), and get
P(tr | sr ) ‚â° Pnt (root(tr ) | root(sr )) √ó
Ptree (tree(tr ) | root(tr )) √ó
Plex (lex(tr ) | lex(sr ))
By using Equations (6), (7) and (12), Equation (4) can be finally written as:
744

(12)

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

id

rule

probability

r3

AD(Â§ßÂπÖÂ∫¶) ‚Üí RB(drastically)

Pnt (RB | AD) ¬∑ Plex (drastically | Â§ßÂπÖÂ∫¶)

r4

VV(ÂáèÂ∞ë) ‚Üí VBN(fallen)

Pnt (VBN | VV) ¬∑ Plex (fallen | ÂáèÂ∞ë)

r6

AS(‰∫Ü) ‚Üí VBP(have)

Pnt (VBP | AS) ¬∑ Plex (have | ‰∫Ü)

r7

NN(ËøõÂè£) ‚Üí

Pnt (NP | NN) ¬∑ Plex (the imports | ËøõÂè£)¬∑

NP(DT(the) NNS(imports))

Ptree (‚ÄùNP(DT NNS)‚Äù | NP)

VP(AD1 VP(VV2 AS3 )) ‚Üí

Pnt (VP | VP) ¬∑ Ptree (‚ÄùVP(VBP ADVP(RB VBN))‚Äù | VP)¬∑

VP(VBP3 ADVP(RB1 VBN2 ))

Preorder (‚Äù1-2, 2-3, 3-1‚Äù | (AD, VV, AS), (VBP, RB, VBN))

IP(NN1 VP2 ) ‚Üí S(NP1 VP2 )

Pnt (S | IP) ¬∑ Ptree (‚ÄùS(NP VP)‚Äù | S)¬∑

r8
r9

Preorder (‚Äù1-1, 2-2‚Äù | (NN, VP), (NP, VP))

Table 1: Rule probabilities for the sample derivation d = {r3 , r4 , r6 , r7 , r8 , r9 } in Figure 2(b)
P(T, d | S) ‚â°

Y

Pnt (root(tr ) | root(sr )) √ó

r‚ààd

Ptree (tree(tr ) | root(tr )) √ó
Plex (lex(tr ) | lex(sr )) √ó
Preorder (œÜr | vnt(sr ), vnt(tr ))

(13)

This is a simplified model for the generative story described in this section. It takes
the rule generation probability as a product of four probability factors: Pnt (¬∑) is the nonterminal mapping probability, which roughly captures the syntactic correspondence of subtrees between the two languages; Ptree (¬∑) is the probability of generating the tree structure
of T ; Plex (¬∑) is the probability of the terminal mappings between the two language sides of
a rule; and Preorder (¬∑) is the probability of the frontier non-terminal reordering encoded in
a rule. See Table 1 for rule probabilities of a sample derivation.
In our model all parameters are assumed to be multinomial distributions. The calculation of Pnt (¬∑), Ptree (¬∑) and Preorder (¬∑) is straightforward: they can be directly used
without any further decompositions and assumptions. To calculate Plex (¬∑), we choose the
form adopted in the popular models of word alignment (Och & Ney, 2004; Thayer, Ettelaie, Knight, Marcu, Munteanu, Och, & Tipu, 2004), where the probability is defined as a
product of word-based translation probabilities:
l
m
Y
1 X
Plex (t1 ...tl | s1 ...sm ) ‚â° Plength (l | m)
Pw (ti | sj )
m
i=1

(14)

j=1

where ti is a target word, and sj is a source word. Plength (¬∑) is used to control the number of
target words produced from a given number of source words. Pw (¬∑) is the word translation
probability. This sub-model is in principle doing something rather similar to conventional
word-based translation tables, as in IBM Models (Brown et al., 1993).
3.3 Node Deletion and Insertion
Word (or sub-tree) deletion/insertion is common in real-world alignment and translation
tasks. To add flexibility to modeling this problem, we allow for the production of empty
745

Xiao & Zhu

sub-trees on either source or target-language side of a rule in our model. More formally, for
a rule whose target-language side is an empty sub-tree, its probability is defined as:
P(r | S) ‚â° Pnt (root(Œµ) | root(sr )) √ó
Ptree (tree(Œµ) | root(Œµ)) √ó
Plex (lex(Œµ) | lex(sr )) √ó
Preorder (œÜŒµ | vnt(sr ), vnt(Œµ))

(15)

where Œµ is a special symbol that indicates nothing. Factors Pnt (root(Œµ) | root(sr )) and
Plex (lex(Œµ) | lex(sr )) model the deletion probability at different levels of a tree-fragment.
Ptree (tree(Œµ) | root(Œµ)) is the probability of generating an empty tree-fragment. Factor
Preorder (œÜŒµ | vnt(sr ), vnt(Œµ)) regards Œµ as a special reordering pattern œÜŒµ which aligns all
frontier non-terminals on the source side to a virtual node NULL. Obviously, the values of
Ptree (tree(Œµ) | root(Œµ)) and Preorder (œÜŒµ | vnt(sr ), vnt(Œµ)) are both simply 1.
Similarly, for a rule whose source side is an empty sub-tree, its probability is defined as:
P(r | S) ‚â° Pnt (root(tr ) | root(Œµ)) √ó
Ptree (tree(tr ) | root(tr )) √ó
Plex (lex(tr ) | lex(Œµ)) √ó
Preorder (œÜŒµ | vnt(Œµ), vnt(tr ))

(16)

where the value of Preorder (œÜŒµ | vnt(Œµ), vnt(tr )) is also 1.
It is worthwhile to note that word deletion and insertion problems are very important
in MT in spite of relatively less discussion in recent studies on tree-to-tree translation.
What we are doing here is actually an analogy to the NULL-alignment used in IBM Models
(Brown et al., 1993). For word/phrase-based models, removing some words from alignment
can leave more space for correctly aligning other words in the sentence.8 This is even more
necessary for (1-to-1) sub-tree alignment because the alignment has to respect the syntactic
constraints on both language sides, e.g., sub-tree alignments are not allowed to break the
constraints imposed by neighbouring parts of the tree. In some cases, we cannot obtain a
correct 1-to-1 alignment for the tree pair due to only one or two ‚Äùbad‚Äù nodes which are not
necessarily to be aligned with a valid node in the counterpart tree. Instead, some nodes
can be ‚Äùskipped‚Äù in alignment and thus do not impose ‚Äùbad‚Äù constraints to other parts of
the tree if node deletion/insertion is allowed. This is especially true when we align sentence
pairs with very flat tree structures or free translations. In this work we found that node
deletion and insertion operations were necessary to achieve satisfactory sub-tree alignment
result. We therefore used them in our implementation by default.
3.4 Training
We now turn to the training problem. As discussed in Section 3.1, we focus on unsupervised
learning of model parameters, that is, the optimal values of parameters are estimated given
8. Note that current phrase-based approaches (Koehn et al., 2003; Och & Ney, 2004) allow NULL-aligned
words to appear at the boundary of a phrase, which can be viewed as a way of implicit modeling of the
word insertion/deletion problem

746

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

a collection of tree pairs without any annotation of sub-tree level alignment. In this work we
choose two approaches for estimating parameters of the sub-tree alignment model, including
the Maximum Likelihood Estimation (MLE) approach and the Bayesian approach.
3.4.1 Maximum Likelihood Training
MLE is one of the most popular methods of parameter estimation for statistical models. Its
basic idea is that, given a model and a set of parameters, the MLE method selects the values
of parameters to generate a distribution that gives the highest probability to the observed
data. MLE is a general approach to parameter estimation which has been widely adopted in
many AI and NLP tasks, such as part-of-speech tagging. In the case of sub-tree alignment,
MLE can be simply described as finding the optimal values of parameters that lead to the
maximum probability of aligning the tree nodes from a source-language parse tree to a
target-language parse tree. More formally, given a set of tree pairs {(S1 , T1 ), ..., (Sn , Tn )},
the objective of the MLE-based training is defined to be:
Œ∏ÃÇ = arg max
Œ∏

n
Y

X

PŒ∏ (Ti , d | Si )

(17)

i=1 d‚ààD(Si ,Ti )

We choose here Expectation Maximization (EM, Dempster, Laird, & Rubin, 1977) as
the algorithm to solve the above optimization problem. Basically the EM algorithm is an
iterative training method for finding the maximum likelihood estimates of model parameters,
where it is assumed that the observed data depends on some latent variables. The algorithm
performs by iteratively calling two sub-routines, namely the Expectation (E)-step and the
Maximization (M)-step. In the E-step, it calculates the expected value of the likelihood
function associated with the parameters and observed data, with respect to the distribution
of latent variables given the observed data and current estimates of parameters. In the
M-step, it seeks for the parameters that maximize the expected likelihood found in the
E-step.
When applying the EM algorithm to our case, we can view the input pairs of parse
trees {(S1 , T1 ), ..., (Sn , Tn )} as observed data, the underlying derivations of rules as latent
variables, and the distributions Pnt (¬∑), Ptree (¬∑), Preorder (¬∑) and Plex (¬∑) (i.e., Plength (¬∑) and
Pw (¬∑)) as unknown parameters. See Figure 3 for the pseudo-code of the training algorithm
for Pnt (¬∑) (denoted as Œ∏tnt |snt ). Because this algorithm is directly applicable to the estimation
of all parameters in our model, we skip the description of learning the remaining parameters
here. For a more detailed description of the EM-based training of all model parameters we
refer the reader to the appendix.
In the algorithm, snt and tnt represent a source-language non-terminal symbol and a
target-language non-terminal symbol, u and v represent a source-language tree node and
a target-language tree node, EC(¬∑) represents the expected count of the given variable,
PŒ∏(k) (T, d | S) represents the derivation probability based on the parameters obtained in
the k-th round. In each EM iteration, the E-step of the algorithm accumulates the expected
count over all pairs of parse trees. Then, the M-step finds the maximum likelihood estimate
using this quantity. The only nontrivial part in this algorithm is the computation of the
expected count in the E-step. Roughly speaking, the physical meaning of the right-hand
side of line 9 is the relative probability that a derivation contains rule r (with root node
747

Xiao & Zhu

1: Function TrainModelWithEM ({(S1 , T1 ), ..., (Sn , Tn )})
(0)
2: Set {Œ∏tnt |snt } = an initial model
3: For k = 0 to K ‚àí 1 do
4:
Foreach non-terminal symbol pair (snt , tnt ) do
5:
EC(Œ∏tnt |snt ) = 0
6: E-step:
6:
Foreach tree pair (S, T ) in sequence {(S1 , T1 ), ..., (Sn , Tn )} do
7:
Foreach node pair (u, v) with symbol pair (tnt , snt ) in (S, T ) do
8:
Foreach rule r rooted
P at (u, v) do
P

is rooted at (u,v) Œ∏
9:
EC(Œ∏tnt |snt ) + = d: r‚ààd ‚àß r P
0
d0 PŒ∏ (k) (T,d |S)
8: M-step:
10:
Foreach non-terminal symbol pair (snt , tnt ) do

11:
12:

(k+1)

Œ∏tnt |snt =

P

(k) (T,d|S)

EC(Œ∏tnt |snt )
EC(Œ∏t0 |s )

t0nt

nt

nt

(K)

return {Œ∏tnt |snt }
Figure 3: The EM-based training algorithm (for Pnt (¬∑))

P
pair (u, v)). The numerator d: r‚ààd ‚àß r is rooted at (u,v) PŒ∏(k) (T, d | S) is the probability sum
P
over all the derivations that involve r , while the denominator d0 PŒ∏(k) (T, d0 | S) is the
overall probability of the alignment from S to T . However, the brute-force computation of
expected counts is very inefficient because it requires the sum over all possible derivations
whose number is exponential in the length of the input sentences.
In this work we use the bilingual version of the inside and outside probabilities (Manning
& SchuÃàtze, 1999) to avoid the naive enumeration of all possible derivations in computing
various probabilities. The inside probability of (u, v) (denoted as Œ≤(u, v)) measures how
likely we generate the sub-tree pair inside the node pair (u, v). The outside probability
(denoted as Œ±(u, v)) is a dual of the inside probability. It measures how likely we generate
the remaining parts of the tree pair (S, T ) from the start symbols. Like the formulation
used in monolingual parsing (Manning & SchuÃàtze, 1999), Œ≤(u, v) and Œ±(u, v) can be defined
using the following recursive forms:


X
Y
Œ≤(u, v) =
P(r | S) √ó
Œ≤(p, q)
(18)
‚àÄr:root(r)=(u,v)

Œ±(u, v) =

X

(p,q)‚ààyield(r)



Œ±(root(r)) √ó P(r | S) √ó

‚àÄr:(u,v)‚ààyield(r)

Y

Œ≤(p, q)



(19)

(p,q)‚ààyield(r)
‚àß (p,q)6=(u,v)

where root(r) is the abbreviation of the node pair (root(sr ), root(tr )), and yield(r) is the
set of the aligned frontier non-terminal pairs yielded by r. Based on the above recursive
definitions, both Œ≤(u, v) and Œ±(u, v) can be efficiently computed with dynamic programming.
By using the inside and outside probabilities, it is easy to address the computation
problem mentioned above. Let Œ≥(u, v) denote the probability that the tree node u is aligned
with the tree node v. This probability can be expressed in an inside-outside fashion:
748

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

Œ≥(u, v) =

X

P(T, d | S)

‚àÄd: (u,v) is
aligned in d

= Œ≤(u, v) √ó Œ±(u, v)

(20)

In this way, the overall alignment probability from S to T (i.e., the denominator of the
right-hand side of line 9) can be simply written as:
X

P(T, d | S) = Œ≤(root(S), root(T )) √ó Œ±(root(S), root(T ))

(21)

d

For the numerator of the right-hand side of line 9, let us view it in another angle. In the
E-Step of the algorithm, the expected count is accumulated over rules whose root is (u, v).
As all the rules rooted at (u, v) indicate the same node alignment between u and v, lines
8-9 in principle imply the probability of all derivations aligning u to v, or more precisely
the node alignment probability of (u, v). This probability can be written in a very simple
form using the inside and outside probabilities:
X
X
P(T, d | S) = Œ≥(u, v)
r: r is rooted d: r‚ààd
at (u,v)

= Œ≤(u, v) √ó Œ±(u, v)

(22)

Together with the result in Equation (21), the E-step can be efficiently implemented by
replacing lines 8-9 with the following equation
EC(Œ∏tnt |snt ) + =

Œ≤(u, v) √ó Œ±(u, v)
Œ≤(root(S), root(T )) √ó Œ±(root(S), root(T ))

(23)

where (snt , tnt ) is the symbol pair of (u, v). Note that for each (snt , tnt ), the E-step step
Œ≤(u,v)√óŒ±(u,v)
increases EC(Œ∏tnt |snt ) by the sum of Œ≤(root(S),root(T
))√óŒ±(root(S),root(T )) over all node pairs (u, v)
whose symbols are snt and tnt . This means that if (snt , tnt ) is aligned at different positions
in the input tree pair, the above method considers the alignment of (snt , tnt ) for multiple
times and updates EC(Œ∏tnt |snt ) accordingly.
It is also worth noting that there are several methods for initializing the model parameters before the EM-style training begins. For example, the model can be initialized by
uniform or random distributions. In this work we initialize all parameters in our sub-tree
alignment model by the model obtained using the word alignment result. This is a standard way adopted in many unsupervised models where a ‚Äùsimpler‚Äù model is used for a good
starting point in the training process. It is very helpful when the optimization procedure is
sensitive to the initial setting of model parameters (e.g., EM for non-convex objective functions). In our experiments we found that using the GIZA++ word alignment for parameter
initialization resulted in better performance and fewer iterations for convergence than the
uniform initial distributions. As the word alignment can be obtained in an unsupervised
manner, it does not change the training condition of our approach. Thus we chose this
method for initializing the model parameters in our implementation.
749

Xiao & Zhu

3.4.2 The Bayesian Approach
While MLE is one of the standard approaches to training unsupervised models, it is well
known for its tendency to overfit the data. The overfitting problem becomes more severe
for complex models since they have more parameters and fit the training data better. In
the case of STSGs, this is likely to result in the degenerate analysis of the data, i.e., rare
and big rules dominate the ML solution of STSGs, while they are considered to be noisy
and generalize poorly on the unseen data (Cohn & Blunsom, 2009; Liu & Gildea, 2009).
A natural solution to this problem is to incorporate constraints or proper priors into the
training process. Here we take the Bayesian approach as an alternative solution for the
training problem.
Unlike MLE, the Bayesian approach does not plug a single optimum point estimate of
the parameter into the distribution of a data point, but instead account for any uncertainty
in the value of the parameter. In Bayesian models, the parameters are assumed to be
drawn from some probability distributions or priors. The parameters of these extra prior
distributions are called hyperparameters, and are denoted by œâ. As the parameters of
our model are viewed mathematically as multinomials, we choose Dirichlet distributions
(Ferguson, 1973) for the prior over model parameters. The advantage of using Dirichlet
distributions is that they are conjugate to multinomial distributions and inference with
such priors is easier.
Following the previous description, we use Œ∏ to denote the model parameters which are
multinomial with outcomes {1, ..., K} (i.e., Œ∏k is the probability of outcome k ‚àà {1, ..., K}).
From this multinomial distribution we sample a set of outcomes {x1 , ..., xn } with probability
P(xi = k) = Œ∏k . As the Dirichlet prior is a distribution over multinomials, each sample
from the prior is actually a set of parameter values Œ∏. Therefore the distribution can be
modeled as:
xi | Œ∏ ‚àº Multinomial(Œ∏)

(24)

Œ∏ | œâ ‚àº Dirichlet(œâ)

(25)

Here Equation (24) means that xi is distributed according to a multinomial with parameters
Œ∏. Similarly, Equation (25) can be read as Œ∏ is distributed according to a Dirichlet distribution with parameters œâ. œâ = {œâ1 , ..., œâK } is the hyperparameter vector corresponding to the
outcomes. In this work we use a symmetric Dirichlet prior ( i.e., œâ1 , ..., œâK share the same
value), and use œâ to represent the single hyperparameter instead of the hyperparameter
vector.
Using this model, we can compute the conditional distribution of a new observation
xn+1 given previous observations {x1 , ..., xn } and the hyperparameter œâ, as follows:
Z
P(xn+1 | x1 , ..., xn , œâ) = P(xn+1 | x1 , ..., xn , Œ∏) P(Œ∏ | œâ) dŒ∏
(26)
The big advantage of the Bayesian approach is to introduce a prior distribution over
the unknown parameters of the model, which is meant to capture the knowledge and beliefs
about the model before seeing the data (Neal, 1998). It is especially important in our case
where we need a ‚Äùbias‚Äù towards some preferred situations. For example, we expect that
our model can favor high frequency rules and dislike rare and big rules. This goal can be
750

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

easily achieved by using the Bayesian approach and an appropriate choice of priors, say, a
Dirichlet prior with a low concentration parameter œâ. However, the introduction of priors
generally makes it intractable to estimate the posterior analytically. In practical systems
based on the Bayesian approach, a widely-used solution is to use approximate methods to
seek a compromise between exact inference and computational resources. In this work we
choose Variational Bayes for approximate inference. Variational Bayes is a good method
that preserves the benefits of introducing the prior but with a tractable inference procedure
(Attias, 2000; Beal, 2003). It has been successfully applied to several NLP-related models,
such as Hidden Markov Models (HMMs) and IBM Models (Beal, 2003; Riley & Gildea,
2010). One more good thing is that Variational Bayes can be seen as an extension of the
EM algorithm and resembles the usual forms used in EM. The resulting procedure looks a lot
like the EM algorithm with a modified M-step, which is very convenient for implementation.
Here we follow the approach presented in previous work (Beal, 2003; Riley & Gildea, 2010)
where variational Bayesian algorithms are applied to similar tasks. All we need is only a
very slight change to the M-step of the original EM algorithm presented in Section 3.4.1.
In the original EM algorithm (see Figure 3), the M-step normalizes the expected counts
collected in the E-step as standard MLE. The variational Bayesian version of the M-step
slightly modifies this formula and performs an inexact normalization by passing counts
through function f (x) = exp(œà(x)).

Œ∏tnt |snt =

f (EC(Œ∏tnt |snt ) + œâ)
P
f ( t0 (EC(Œ∏t0nt |snt ) + œâ))

(27)

nt

where œà(x) is the digamma function (Johnson, 2007). It has an approximate effect of
subtracting 0.5 from its argument. The choice of œâ controls the behavior of this estimation.
When œâ is set to a low value, it performs estimation as a way of ‚Äùanti-smoothing‚Äù. As
about 0.5 is subtracted from the rule counts, small counts corresponding to rare events are
penalized heavily, while large counts corresponding to frequent events are not be affected
very much. For example, low values of œâ make Equation (27) favor the non-terminal pairs
which are aligned frequently and distrust the non-terminal pairs which are aligned rarely.
In this way, the variational Bayesian method could control the overfitting caused by abusing
rare events. On the other hand, a larger œâ can be used when smoothing is required.
The above method is applicable to training all the parameters in our model. It only
requires a replacement of the M-step in Figure 3 with the variational Bayesian M-step (as
in Equation (27)). In our implementation, after the variational Bayes-based training, we
perform an additional round of normalization without variational Bayes to normalize rule
probabilities to sum to one.9
9. The additional normalization process makes the posterior probabilities directly comparable with those
obtained in other training methods, such as the EM-based training. Note that here we convert the result
of Bayesian inference into some probability distributions for a good explanation of various probability
factors in our model. On the other hand, this technical trick results in a pseudo-Bayesian procedure
that is not doing Bayesian inference exactly though it shows good results in our empirical study. One
can remove the additional round of normalization for a pure Bayesian approach. But all these changes
do not affect the overall pipeline of our approach (from a practical standpoint).

751

Xiao & Zhu

1: Function Decode
(S, T )

2:
Œ≤[¬∑], Œ±[¬∑] = GetInsideOutsideProbabilities (S, T )
3:
Foreach node u in S in bottom-up order do
4:
Foreach node v in T in bottom-up order do
5:
Œ≥[u, v] = Œ≤[u, v] √ó Œ±[u, v]
6:
Foreach tree-fragment sr rooted at u do
7:
Foreach tree-fragment tr rooted at v do
8:
Foreach frontier non-terminal alignment a between sr and ts do
9:
r = CreateRule(s
Q r , tr , a)
10:
score = P(r | S) ¬∑ (p,q)‚ààyield(r) P(d[p, q])
11:
If score > P(d[u, v]) then
12:
d[u, v] = CreateDerivation(r, {d[p, q] : (p, q) ‚àà yield(r)})
13: return (d[¬∑], Œ≥[¬∑])
14: Function GetInsideOutsideProbabilities (S, T )
15: Foreach node u in S in bottom-up order do
16:
Foreach node v in T in bottom-up order do
17:
Set Œ≤[u, v] according to Equation (18)
18: Foreach node u in S in top-down order do
19:
Foreach node v in T in top-down order do
20:
Set Œ±[u, v] according to Equation (19)
21: return (Œ≤[¬∑], Œ±[¬∑])
Figure 4: Decoding algorithm of the proposed sub-tree alignment model for both 1-best
and posterior-based outputs
3.5 Decoding
Inference with our model is straightforward. The simplest case is inferring the 1-best subtree alignment. Given a set of learned parameters, we first visit every node pair (u, v) in
a bottom-up fashion, and compute the posterior probability of aligning the sub-tree pair
rooting at (u, v). This procedure is the same as the dynamic program used in the trainer.
We then select the derivation with the maximum sub-tree alignment probability for the
input tree pair. Also, we can generate a list of k-best derivations in a similar manner.
In addition to the 1-best/k-best output, our model is able to output the alignment
posterior probability for every pair of tree nodes. To do this, we only need to record the
probability Œ≥(u, v) for each node pair after we obtain the inside and outside probabilities.
Note that outputting alignment posterior probabilities is also commonly used in statistical
word and phrasal aligners. It provides a flexible way of making use of the alignment result
for the downstream components, such as the rule extraction system. As is presented in the
very next sections, tree-to-tree MT systems can make great benefits from the posteriorbased alignment output, which results in a very effective rule extraction method as well as
better translation results.
Figure 4 depicts the pseudo-code of the decoding algorithm for both 1-best and posteriorbased outputs. In this algorithm, d[x, y] is a data structure that records the best derivation rooted at (x, y). Œ≤[x, y], Œ±[x, y] and Œ≥[x, y] are data structures that record the inside
probabilities, output probabilities and alignment posterior probabilities, respectively. Cre752

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

ateRule(¬∑) creates a rule with a pair of tree-fragments (sr , tr ) and a frontier non-terminal
alignment a, and calculates the rule probability. CreateDerivation(¬∑) builds a derivation
using the input rules. For output, we can access the 1-best alignment by traversing from
d[root(S), root(T )], and access the alignment posterior through Œ≥[¬∑].
Given a pair of trees (S, T ), the outer two loops of the algorithm iterates over each pair
of nodes in the two trees, resulting in time complexity of O(|S| ¬∑ |T |) where | ¬∑ | represents the
2 ), where N
size of the input tree. Generating all pairs of tree-fragments requires O(Ntree
tree
is the maximum number of tree-fragments given a tree node. Computing the alignment
between (sr , tr ) requires O(L!) where L is the maximum number of leaf non-terminals in a
2
rule. Therefore the time complexity of this algorithm is O(|S| ¬∑ |T | ¬∑ Ntree
¬∑ L!), quadratic
in the size of the input trees. Note that the actual time complexity of this algorithm could
be very high if all potential alignments are considered. For example, Ntree is generally an
exponential function of the depth of the input tree-fragment, and a very deep tree could
results in an extremely large space of alignments. To make practical sub-tree alignment
systems, pruning techniques are taken into account in this work. For example, in our
implementation, we restrict the depth of tree-fragment to a reasonable number (see Section
5.2.2). In addition, as is commonly-used in phrasal alignment and related tasks, we consider
word alignments in pruning and discard the sub-tree alignments which violate a certain
number of word alignments. For example, we throw away the sub-tree alignments if there
are more than two word alignment links outside the spans covered by the aligned sub-trees.

4. Applying Sub-tree Alignment to Tree-to-Tree Translation
Once sub-tree alignment is obtained, current tree-to-tree systems can directly learn translation rules from node-aligned tree pairs. In this section we investigate methods of applying
sub-tree alignment to tree-to-tree rule extraction.
4.1 Rule Extraction Using 1-best/k-best Sub-tree Alignments
To data, several methods have been developed for tree-to-tree rule extraction (Zhang et al.,
2008; Liu et al., 2009a; Chiang, 2010). The most popular of these is the GHKM-like
method which extends the idea of extracting syntactic translation rules from string-tree pairs
(Galley et al., 2004). In GHKM-like extraction, we first compute the set of the minimallysized translation rules that can explain the mappings between the source-language tree
and the target-language tree while respecting the alignment and reordering between the
two languages. Larger rules are then learned by composing two or more minimal rules. For
example, in Figure 2(b), r7 and r9 are two minimal rules extracted according to the sub-tree
alignment. We can compose these rules to form a larger rule, like this:
IP(NN(ËøõÂè£) VP1 ) ‚Üí S(NP(DT(the) NNS(imports)) VP1 )
In this work we use the tree-to-tree version of GHKM-like extraction which is described
in Liu et al.‚Äôs (2009a) work. See Figure 5(a) for the pseudo-code of rule extraction with
1-best sub-tree alignment. We choose this method because it has been widely used in
most tree-to-tree systems. Note that rule extraction in tree-to-tree translation is generally
not restricted to be performed on the 1-best sub-tree alignment result. The GHKM-like
753

Xiao & Zhu

1: Function OneBestExtract (S, T , A)
2:
Foreach node u in S do
3:
Foreach node v in T do
4:
Foreach tree-fragment pair (sr , tr )
4:
rooted at (u, v) do
5:
a = OneToOneAlign(sr , tr , A)
6:
If a is not empty then
7:
r = CreateRule(sr , tr , a)
8:
rules.Add(r)
9:
return rules
10: Function OneToOneAlign(sr , tr , A)
11: If frontier non-terminals of (sr , tr ) have
11:
1-to-1 alignments in A then
12:
return frontier alignment of (sr , tr )
13: Else
14:
return œÜ

1: Function MatrixExtract (S, T , M )
2:
Foreach node u in S do
3:
Foreach node v in T do
4:
If IsExtractable({(u, v)}, M ) do
5:
next loop
6:
Foreach tree-fragment pair (sr , tr )
6:
rooted at (u, v) do
7:
Foreach frontier alignment a
7:
between (sr , tr ) do
8:
If IsExtractable(a, M ) then
9:
r = CreateRule(sr , tr , a)
10:
rules.Add(r)
11: return rules
12: Function IsExtractable(a, M )
13: Foreach alignment (p, q) in a do
14:
If probability of (p, q) in M < Pmin then
15:
return false
16: return true

(a) 1-best Extraction

(b) Matrix-based Extraction

Figure 5: The 1-best and matrix-based rule extraction algorithms
extraction method can be employed when a list of k-best sub-tree alignments is provided.
In k-best extraction we only need to repeat the procedure of 1-best extraction for each
sub-tree alignment in the k-best list.
4.2 Rule Extraction Using Sub-tree Alignment Matrices
Previous work has pointed out that current MT systems suffer from error propagation due
to the alignment errors made within 1-best alignment (Venugopal, Zollmann, Smith, &
Stephan, 2008). As sub-tree alignment is an early-stage step in the training pipeline, the
errors in 1-best alignment are likely to be propagated to translation rule extraction and
parameter estimation of the translation model. Though this problem can be alleviated by
using k-best alignments, the limited scope of k-best alignments still results in inefficient
learning of translation rules. For example, our preliminary experiment shows that 95.8% of
the extracted rules are redundant when 100-best alignments are involved.
Here we instead present a simple but efficient method, namely matrix-based rule extraction. In this method, we use the posterior-based output of our aligner and represent the
sub-tree alignment with a compact structure - call it sub-tree alignment matrix or alignment
matrix for short (Liu, Xia, Xiao, & Liu, 2009b; de Gispert, Pino, & Byrne, 2010).
See Figure 6(a) for two example sub-tree alignment matrices made from a pair of sentence segments. In the matrices, each entry is indexed by a pair of source and target nodes.
The score in an entry is the posterior probability of the alignment between the corresponding node pair, i.e., the Œ≥(u, v) probability defined in Equation (20). This probability is
straightforwardly accessible in the output of the inference algorithm described in Section
3.5. In principle Œ≥(u, v) can be viewed a measure of sub-tree alignment confidence: a higher
value indicates a more confident alignment between the two nodes. In this way we can
754

have

RB

[4]

VBN

drastically

Â§ßÂπÖÂ∫¶

1

fallen

ÂáèÂ∞ë

‰∫Ü

VV[4]

AS[5]

AD[2]

.1

AS[5]

4]

5]

VP[1]

.1

AD[2]

.8

.1

.1

.6

.1

.2

VP[3]

.3

.7

VV[4]

.4

AS[5]

1 VV[4]
1

VB
N[

1]

VB
P [2]
AD
VP [
3]
RB [

.9

AD[2]
VP[3]

VP[3]
VP[1]

VP[1]

1

[5]

VP [

ADVP[3]

VB

VBP[2]

VP [

1]

VP[1]

P [2]
AD
VP [
3]
RB [
4]
VB
N [5]

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

.6

 = fixed alignment

 = possible alignment

Matrix 1: 1-best alignment

Matrix 2: posterior

(a) Sub-tree alignment matrices for a sample sub-tree pair
Minimal Rules
Extracted from Matrix 2 (posterior)
r3
AD(Â§ßÂπÖÂ∫¶) ‚Üí RB(drastically)
r4
VV(ÂáèÂ∞ë) ‚Üí VBN(fallen)
r6
AS(‰∫Ü) ‚Üí VBP(have)
r8
VP(AD1 VP(VV2 AS3 )) ‚Üí
VP(VBP3 ADVP(RB1 VBN2 ))
r10 VP(VV(ÂáèÂ∞ë) AS(‰∫Ü)) ‚Üí VBN(fallen)
r11 VP(AD1 VP2 ) ‚Üí VP(VBP1 ADVP2 )

Minimal Rules
Extracted from Matrix 1 (1-best)
r3 AD(Â§ßÂπÖÂ∫¶) ‚Üí RB(drastically)
r4 VV(ÂáèÂ∞ë) ‚Üí VBN(fallen)
r6 AS(‰∫Ü) ‚Üí VBP(have)
r8 VP(AD1 VP(VV2 AS3 )) ‚Üí
VP(VBP3 ADVP(RB1 VBN2 ))

...
(b) Rules extracted using 1-best alignment and alignment posterior
Figure 6: Matrix-based representation of sub-tree alignment and sample rules extracted.
Matrix 1 shows the case of 1-best sub-tree alignment, and Matrix 2 shows the
case of sub-tree alignment posterior.
access all possible sub-tree alignments (with different probabilities), rather than a limited
number of them.
We then extract rules using the sub-tree alignment matrix. The method is simple: we
collect the rules associated with each entry from the matrix. The core algorithm of this
method is in essential the same as that used in 1-best/k-best extraction. The only difference
from 1-best/k-best extraction is that the matrix-based method considers all possible node
pairs for extraction, rather than visiting some of them only. See Figure 5(b) for the pseudocode of the sub-tree alignment matrix-based rule extraction algorithm, where M represents
a sub-tree alignment matrix for the pair of trees (S, T ). Compared to extracting rules from
k-best alignments, this method can efficiently obtain additional rules whose extraction is
blocked in k-best extraction. For example, on the right side of Figure 6(b) two new rules
r10 and r11 are extracted, which cannot be obtained from the 1-best alignment result. To
prevent the extraction of a great number of noisy rules with low alignment probabilities, we
755

Xiao & Zhu

prune away those rules whose alignment probabilities are below a pre-specified threshold.
More formally, given a pair of nodes (u, v), rule extraction can be executed at (u, v) only
when it satisfies:
Œ≥(u, v)
< Pmin
(28)
Œ≥(root(S), root(T ))
This expression measures the relative probability of alignment (u, v) with respect to the
sum of probabilities over all possible derivations. Pmin is an empirical threshold to control
how often rules to be pruned (a larger Pmin means more rules are thrown away). In this
work, it is set to 10‚àí7 by default. Therefore, all those entries with a zero score in Figure
6(a) (denoted as a dot) are excluded in rule extraction.
However, discarding rules with relatively low probabilities in turn results in an incompleteness problem, that is, the extracted rules might be unable to transform a given source
parse-tree, even in the training set. Nonetheless, this problem is not very severe in our
case. In our experiments we observed that most parse-tree pairs (over 90%) in the training
corpus could be recovered by the extracted rules when Pmin chose its default value, and
the contribution to translation accuracy from those low confidence rules was very limited
(generally less than 0.1 BLEU points).
Another note on sub-tree alignment matrix-based extraction. The advantage of this
method is that it follows the general and well-developed framework of syntax-based MT,
i.e., word/syntactic alignment + rule extraction/parameter estimation + MT decoding. All
we need is to replace the rule extraction component with our sub-tree alignment matrixbased system, while preserve other components of the pipeline. This means that we can still
use some heuristics to obtain additional useful rules from the result of sub-tree alignment
matrix-based extraction, such as rule composing (Galley et al., 2006) and SPMT extraction
(Marcu, Wang, Echihabi, & Knight, 2006). Also, the posterior probability encoded in the
matrix can be used for better estimation of various MT-oriented features.10
Note that the basis of our approach is the STSG model, and all rules in the sub-tree
alignment model resemble the general forms of the translation rules used in tree-to-tree MT
systems. So, as an alternative but simple way of rule induction, we can directly infer translation rules from our sub-tree alignment model and take the corresponding rule probabilities
as features of the translation model for MT decoding. However, in tree-to-tree MT this
method suffers from several problems. First, our sub-tree alignment model requires computation of all possible aligned tree-fragments, which results in very high time complexity
for both training and decoding procedures. As a result, aggressive pruning has to be used
for a reasonable size of search space, e.g., we consider only relatively small tree-fragments
in our implementation for acceptable running speed. As a side effect, many relatively large
rules (e.g., composed rules and SPMT rules) are absent in our sub-tree alignment model,
while they are available if we use the traditional alignment + extraction heuristics pipeline.
From an engineering standpoint, it is not efficient to directly infer translation rules from
the sub-tree alignment model, compared to inferring rules using a pruned and fixed subtree alignment matrix plus some heuristics. Second, the rule probability and optimization
objective for sub-tree alignment is very different from those used in MT systems. For example, we use a generative model and a maximum-likelihood/Bayesian approach in sub-tree
10. See Section 4.3 for more detailed discussion of the parameter estimation issue.

756

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

alignment, but use a discriminative model and minimum error rate training in MT. Many
features employed in the MT decoder are not considered in our sub-tree alignment model.
All the above issues might lead to unsatisfactory MT performance. As shown in our experiments (see Section 5.3.5), directly inferring translation rules from the sub-tree alignment
model does not achieve promising results.
4.3 Learning Features for Machine Translation
In previous work on syntax-based MT, it is proved that syntax-based systems can make great
benefits from MT-oriented features, even some of them are not necessarily well explained
in the syntactic parsing viewpoint (e.g., phrase-based translation probabilities). However,
most of these features are not available in the word/sub-tree alignment model. Instead we
need to learn these features using an additional step of parameter estimation for MT. To
do this, we follow the commonly-used framework which estimates values of various MToriented features on the extracted rule set using MLE. This procedure is simple: once all
translation rules are extracted, we obtain the maximum-likelihood (or relative-frequency)
estimate of parameters according to the definition of each feature function.
However, in traditional tree-to-tree systems each rule extracted from a tree pair has
a count of unit one, which is then used to calculate the values of various features. Such
a approach might enlarge the influence of noisy rules extracted from sub-tree alignment
matrices. E.g., a rule with a high alignment probability has an equal weight as a rule with
a low alignment probability, and thus has a unreasonably large impact on MT systems. A
more desired solution is that a rule extracted from a derivation having a low probability is
penalized accordingly in feature learning. Motivated by this idea, we use fractional counts
to estimate the appearance for each rule (Mi & Huang, 2008). Given a node pair (u, v) in
(S, T ), the alignment probability of a rule r rooted at (u, v) is defined to be (denoted as
Œ≥(r; u, v)):
X
Œ≥(r; u, v) =
P(T, d | S)
(29)
d‚ààD(S,T )
‚àß r‚ààd

where Œ≥(r; u, v) is regarded as the probability sum over all derivations involving r at (u, v).
Also, we can rewrite Equation (29) in an inside-outside fashion:
Y
Œ≥(r; u, v) = Œ±(u, v) √ó
Œ≤(p, q) √ó P(r | S)
(30)
(p,q)‚ààyield(r)

Then we define the probability that r is involved in the derivations of (S, T ) as:
X
Œ≥(r) =
Œ≥(r; u, v)

(31)

u,v

Equation (31) is the sum of probabilities of r over all node pairs. This means that the
rule probability can be considered for multiple times if some particular derivations contain
r more than once. By using Œ≥(r), the fractional count of r is defined to be:
c(r) =

Œ≥(r)
Œ≥(root(S), root(T ))

757

(32)

Xiao & Zhu

Equation (32) reflects the probability how likely r is involved in a derivation given a
pair of trees. For a set of bilingual parse trees, c(r) can be accumulated over each tree pair.
Obviously, c(r) can be used to estimate the parameters of the MT model, that is, once
translation rules are weighted, the parameter estimation procedure can proceed as usual,
but with weight counts. In this work c(r) is employed to learn five features used in the
MT decoder, including the bi-directional phrase-based conditional translation probabilities
(Marcu et al., 2006) and three syntax-based conditional probabilities (Mi & Huang, 2008).
Let œï(¬∑) be a function that returns the sequence of frontier nodes for an input tree-fragment.
These probabilities can be computed by the following equations:
P
00
r00 :œï(sr00 )=œï(sr )‚àßœï(tr00 )=œï(tr ) c(r )
P
Pphrase (tr | sr ) =
(33)
0
r0 :œï(sr0 )=œï(sr ) c(r )
P
00
r00 :œï(sr00 )=œï(sr )‚àßœï(tr00 )=œï(tr ) c(r )
P
Pphrase (sr | tr ) =
(34)
0
r0 :œï(t 0 )=œï(tr ) c(r )
r

c(r)

P(r | root(r)) =

P

P(r | sr ) =

P

r0 :root(r0 )=root(r) c(r

c(r)
r0 :sr0 =sr

P(r | tr ) =

c(r0 )

c(r)
P

r0 :tr0 =tr

c(r0 )

0)

(35)
(36)
(37)

5. Experiments
For evaluation, we first experimented with our approach on a Chinese-English sub-tree
alignment task, then tested its effectiveness in a state-of-the-art tree-to-tree MT system.
5.1 Baselines
Three unsupervised sub-tree alignment methods were chosen as baselines in our experiments.
‚Ä¢ WordAlign-1 : WordAlign-1 is based on a GHKM-like method (Galley et al., 2004)
that uses word alignments to infer syntactic correspondences. In our implementation,
both the GIZA++ toolkit and the ‚Äùgrow-diag-final-and‚Äù method were used to obtain
the symmetric word alignment from sentence pairs. The sub-tree alignments were
then heuristically induced by selecting those node correspondences that are consistent
with the word alignment result (i.e., sub-tree alignments that do not violate any word
alignments). We chose this method because it has been widely adopted in modern
tree-to-tree systems.
‚Ä¢ WordAlign-2 : the second baseline is essentially the same as WordAlign-1. The only
difference from WordAlign-1 is that we improved the word alignment system using
link-deletion techniques (Fossum et al., 2008). The basic idea is to delete harmful
alignment links from an initial word alignment result (e.g., deleting the link between
‚Äù‰∫Ü‚Äù and ‚Äùthe‚Äù in Figure 2(a)). In our experiments we only considered the most likely
deletion between the top-10 most common Chinese words (including {ÁöÑ, Âú®, Âíå, ÊòØ,
758

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

‰∫Ü, ‰∏Ä, ÂØπ, Êúâ, ‰∏≠, ‰πü}) and the top-10 most common English words (including {the,
of, and, to, in, a, is, that, for, on}).
‚Ä¢ HeuristicAlgin: HeuristicAlgin is a re-implementation of the approach proposed in
Tinsley et al.‚Äôs (2007) work. In this method the alignment confidence of every node
pair is first computed with lexical translation probabilities, and then used to obtain
node correspondences via a heuristic algorithm. Because this method does not require
a training process and has been successfully adopted in several translation tasks, such
as French-English translation, it was chosen as another baseline for comparison.
5.2 Experimental Setup
The settings of our experiments are described as follows.
5.2.1 Data Preparation
Our bilingual corpus consists of 1.06 million sentence pairs.11 As mentioned above, we
used GIZA++ and the ‚Äùgrow-diag-final-and‚Äù heuristics to generate 1-best/k-best word
alignments, which were then used as our baseline word alignment results. The parse trees in
both Chinese and English were generated using the Berkeley Parser.12 A publicly available
corpus was used to evaluate the sub-tree alignment result.13 It consists of 736 node-aligned
sentence pairs (with gold-standard parse trees on both language sides) in LDC2003E07
which is also included in our bilingual data. This corpus was divided into two parts: a
held-out set used for finding an appropriate setting of hyperparameters (99 sentences in
articles 301-309), and a test set used for evaluating the sub-tree alignment systems (637
sentences in articles 001-066). For MT experiments, a 5-gram language model was trained
on the Xinhua portion of the Gigaword corpus in addition to the English part of the LDC
bilingual training data.14 We used the NIST 2003 MT evaluation corpus as our development
set (919 sentences) and the newswire portion of the NIST 2004-2006 MT evaluation corpora
as our test set (3,486 sentences).
5.2.2 Sub-tree Alignment
All parameters of the sub-tree alignment model were initialized with the add-one smoothing
on the rule-set extracted using word alignments (i.e., the WordAlign-1 baseline). Then, the
model was trained on the parse trees of the bilingual corpus using the EM algorithm or
the Variational Bayes (VB) approach. In our implementation of the VB-based training, all
hyperparameters are assumed to share the same value.15 This leads to a setting of œâ = 0.01
11. LDC category: LDC2003E14, LDC2005T10, LDC2003E07, LDC2005T06, LDC2005E83, LDC2006E26,
LDC2006E34, LDC2006E85, LDC2006E92 and LDC2004T08. See http://www.ldc.upenn.edu/ for more
details.
12. Note that for the LDC2003E07 corpus we reused the gold-standard parse trees provided in the Chinese
and English treebanks.
13. Available from http://www.nlplab.com/resources/nodealigned-bitreebank.html
14. LDC category of the English Gigaword corpus: LDC2003T05
15. Although we could adopt different hyperparameters for finer control over the priors of model parameters, we found that setting those hyperparameters to the same value could also lead to satisfactory
performance.

759

Xiao & Zhu

which is an optimal value on the held-out set. By default, we trained our model for 5 EM or
Variational EM iterations. To speed-up the training process and further avoid degenerate
analysis caused by too large rules, we restricted ourselves to rules with reasonable sizes rules with at most five frontier non-terminals and depth of three. For rules having more
than five frontier non-terminals, we only considered the tree-fragments of depth one but did
not restrict the number of frontier non-terminals involved, that is, for flat tree structures,
we only used the associated height-one tree-fragments. Besides, we discarded the sub-tree
alignment between every node pair whose terminals are aligned outside the corresponding
spans for more than two times in WordAlign-1.
5.2.3 Machine Translation
We used the NiuTrans open-source toolkit (Xiao, Zhu, Zhang, & Li, 2012) to build our
tree-to-tree MT system. For rule extraction, we used an extension of the GHKM method
to extract minimal tree-to-tree transformation rules (Liu et al., 2009a) and obtained larger
rules by composing two or three minimal rules (Galley et al., 2006). We used a CKY-style
decoder with cube pruning (Huang & Chiang, 2005) and beam search to decode Chinese
sentences. By default the beam size was set to 50. In addition to the features described in
Equations (33)-(37), we also used several other features in our MT system, including the
5-gram language model, the rule number bonus, the target length bonus and two binary
features - lexicalized rule and low frequency rule (Marcu et al., 2006). These features are
combined in a log-linear fashion and optimized using Minimum Error Rate Training (MERT,
Och, 2003).
5.3 Results
In the following part of this section, we present our experimental results, including evaluations of sub-tree alignments, extracted rules, and MT systems. Also, we show results of
several improved methods for the effective use of our approach in tree-to-tree MT.
5.3.1 Evaluation of Alignments
First we evaluated the alignment quality of various sub-tree alignment approaches in terms
of precision (P), recall (R) and F-1 score.16 See Table 2 for results of the three baseline
systems and our sub-tree alignment system. By those measures, our VB-based system
significantly improves both the overall recall and F-1 score, slightly degrading in precision
compared to WordAlign-1/2. Also, the VB-based training outperforms the EM-based counterpart due to the priors introduced into the learning process. The interesting observation
here is that, though the EM training of our model suffers from the degenerate analysis of the
data, it does not show extremely bad results in our experiment. This phenomenon is due
to our restriction on the size of tree-fragment in training. As described in Section 5.2.2, we
restricted the translation rules to those reasonable-size tree-fragments in several ways (e.g.,
16. Let predicted be the number of alignments in system output, correct be the number of correct alignments
in system output, gold be the number of alignments in gold-standard. The measure of precision, recall
2
)√óprecision√órecall
correct
and F-Œ≤ score can be defined as: precision = predicted
, recall = correct
and F-Œ≤ = (1+Œ≤
.
gold
Œ≤ 2 √óprecision+recall
Here Œ≤ is a parameter that controls the preference for recall (i.e., Œ≤ > 1) or precision (i.e., 0 ‚â§ Œ≤ < 1).
In most NLP tasks Œ≤ is set to 1, indicating equal weights of recall and precision.

760

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

Entry
Overall
NP ‚Üî NP
NN ‚Üî NN
VP ‚Üî VP
PU ‚Üî ,
IP ‚Üî S
PU ‚Üî .
NP ‚Üî NN
NP ‚Üî PP
NN ‚Üî NNS
NR ‚Üî NNP
NN ‚Üî NP
PP ‚Üî PP
NN ‚Üî JJ
P ‚Üî IN
QP ‚Üî NP

WordAlign-1
P
R
F-1
75.4 63.6 69.0
86.9 59.0 70.3
83.9 75.6 79.5
75.3 61.9 68.0
84.7 76.5 80.4
92.5 87.5 89.9
98.5 98.7 98.6
77.6 71.5 74.4
46.8 63.8 54.0
84.2 76.0 79.9
69.4 41.2 51.8
65.1 59.8 62.4
84.6 68.4 75.7
90.7 76.5 83.0
81.5 69.8 75.2
72.2 64.9 68.3

WordAlign-2
P
R
F-1
76.3 64.5 69.9
87.0 62.1 72.5
83.6 77.0 80.2
74.9 61.9 67.8
84.7 76.5 80.4
92.3 87.7 89.9
98.5 98.7 98.6
83.0 71.5 76.8
49.7 63.5 55.7
83.8 76.5 80.0
69.9 41.7 52.3
65.9 61.0 63.3
85.1 69.2 76.3
90.4 76.3 82.7
82.3 68.3 74.7
72.6 65.2 68.7

HeuristicAlgin
P
R
F-1
65.7 67.7 66.7
79.1 73.6 76.3
76.2 74.1 75.1
71.3 71.8 71.6
69.6 71.3 70.3
90.6 90.7 90.6
98.5 98.7 98.6
59.3 77.5 67.2
53.1 31.9 39.8
77.8 75.5 76.7
63.4 57.4 60.2
71.8 50.4 59.2
79.3 72.6 75.8
83.9 81.7 82.8
81.2 72.2 76.4
67.1 65.6 66.4

Ours (EM)
P
R
F-1
79.8 46.2 58.5
84.2 48.2 61.3
81.8 63.7 71.6
80.5 49.0 60.9
82.7 67.7 74.5
90.4 76.8 83.0
94.7 86.8 90.6
75.4 62.3 68.2
43.2 42.1 42.6
83.7 58.3 68.7
57.7 41.5 48.3
70.5 48.1 57.2
85.6 56.9 68.4
84.2 69.1 75.9
79.9 57.9 67.1
78.3 42.2 54.8

Ours (VB)
P
R
F-1
72.6 75.1 73.8
88.7 75.3 81.4
81.1 79.9 80.5
75.7 75.8 75.7
82.5 80.7 81.6
90.0 92.4 91.2
98.5 98.5 98.6
75.9 78.9 77.4
54.5 70.1 61.3
81.0 77.6 79.2
67.2 56.3 61.3
71.1 67.7 69.4
85.4 82.5 83.9
85.9 81.2 83.5
84.7 76.1 80.2
74.9 71.7 73.3

Table 2: Evaluation results of sub-tree alignment for our system and the baselines. All
measures are reported in percentage.
we set a parameter of maximum depth). While such constraints reduce the number of rules
involved in training, it prevents the use of rare and large rules. Our result here indicates
the fact that the tree-fragment size constraint is actually not only important for efficiency
but also crucial for learning. As discussed in previous work, without these constraints or
imposing a proper prior, the solution of EM is degenerate (Marcu & Wong, 2002; DeNero,
Gillick, Zhang, & Klein, 2006).
In addition, Table 2 shows the result for the 15 most common types of sub-tree alignment. As expected, the VB-based system achieves the best F-1 score in most cases. More
interestingly, it is observed that our approach obtains significantly better performance in
handling the PP (Prepositional Phrase) alignment that seems to be a difficult problem for
baselines due to the unclear boundary indicators in aligning the PP structures. We attribute
this to the better use of syntactic information on both language sides in our model, which
are generally ignored in traditional models based on surface heuristics and word alignments.
5.3.2 Evaluation of Extracted Rules
We then applied the sub-tree alignment result to our tree-to-tree system to study the impact
of sub-tree alignment on MT. As discussed in Section 4, rule extraction is a downstream
component of sub-tree alignment in the current tree-to-tree MT pipeline. We therefore
chose to evaluate the quality of the rules obtained from various sub-tree alignment results.
To determine the goodness of extracted grammars, we computed the rule precision, recall,
and F-1 scores for our approach and the baseline approaches on the same test set used in
the (1-best) alignment quality evaluation. To make a gold-standard grammar, we chose
the method used in Fossum et al.‚Äôs (2008) work where the grammar was automatically
generated from the manually-annotated alignment result, that is, the rules extracted using
the annotated sub-tree alignments were regarded as the gold-standard in computing various
evaluation scores. Table 3 shows the evaluation result for the grammars extracted with
761

matrix

1best

Xiao & Zhu

Entry
WordAlign-1
WordAlign-2
HeuristicAlgin
Ours (EM)
Ours (VB)
Ours (VB + Pmin
Ours (VB + Pmin
Ours (VB + Pmin
Ours (VB + Pmin

= 10‚àí5 )
= 10‚àí6 )
= 10‚àí7 )
= 10‚àí8 )

Rule P
51.9
52.3
55.8
61.9
54.9
79.6
53.0
41.3
34.9

Rule R
60.8
61.8
55.3
49.2
65.2
34.5
70.0
75.6
79.5

Rule F-1
55.9
56.6
55.5
54.8
59.6
48.2
60.3
53.4
48.5

Table 3: Evaluation results of rules obtained from various sub-tree alignment approaches.
All measures are reported in percentage.
different sub-tree alignment approaches. We see that the improvements persist when our
sub-tree alignments are employed in translation rule extraction. Our VB-based approach
produces grammars with a higher rule F-1 score than all three of the baselines.
In addition to the 1-best extraction, we studied how rule extraction behaves under the
sub-tree alignment matrix-based extraction method. Table 3 also shows the result of the
sub-tree matrix-based extraction method with different choices of the pruning parameter
Pmin . We see that smaller values of Pmin result in grammars with higher rule recall. Also,
better rule F-1 scores can be achieved by adjusting Pmin and seeking a good balance between
rule precision and rule recall , e.g., Pmin = 10‚àí6 or 10‚àí7 .
The above scores are informative as a measure of grammar quality, but we also investigated some of the differences in the rule sets obtained from our model compared to the
baseline approaches, following Levenberg, Dyer, and Blunsom‚Äôs (2012) method. Figure 7
shows the most probable rules (frequency ‚â• 2) obtained from our bilingual corpus using
the VB-based alignment approach that do not appear in the model from the WordAlign-2
alignment and vice versa. We asked two annotators of sub-tree alignment to estimate the
rule quality based on the syntactic correspondence and adequacy of frontier node sequence
between the two languages sides. A rule was labeled as ‚Äùgood‚Äù only if both judges considered it to be of good quality. From the figure, we see that eight of the top-10 rules extracted
using our approach but absent in the WordAlign-2 grammar are good rules. In contrast,
only four of the top-10 rules in the baseline model are of good quality in a sense of human
preference. Furthermore, we examined the top-100 most probable rules that appear in the
two grammars individually. Again, the top-100 rules extracted using our proposed model
are of better quality. It results in 61 good rules. By contrast, only 44% of the top-ranking
rules induced using the WordAlign-2 alignment are good translation rules.
5.3.3 Evaluation of Translations
We also evaluated the translations generated by the MT system for different sub-tree alignment approaches. Since the VB-based training shows the best performance in the previous
experiments, we chose it as a default setting of our approach in the following experiments.
Table 4 shows the evaluation result where the translation quality is estimated using caseinsensitive IBM-version BLEU4 (Papineni, Roukos, Ward, & Zhu, 2002) and TER (Snover,
762

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

The
1*
2*
3*
4
5*
6*
7*
8*
9*
10

top-10 highest probability rules (for MT) in our approach but absent in WordAlign-2
NP(DNP1 NN(ÊèêÈ´ò)) ‚Üí VP(ADVP1 VP(VBD(improved)))
NP(PU( ‚Äú) NP(CD(‰∏§) NN(‰ºö)) PU(‚Äù)) ‚Üí NP(DT(the) CD(two) NNS(sessions))
NP(NP(QP1 NP(NN(‰ª£Ë°®))) NP2 ) ‚Üí NP(X2 NP(CD1 NP(NNS(represents))))
NP(NN(Ê∏¥Êúõ) NP1 ) ‚Üí VP(VB(desire) NNP1 )
NP(PU(‚Äú) NP(NR1 NN(Áã¨Á´ã)) PU(‚Äù)) ‚Üí NP(‚Äù(‚Äù) NP(NNP1 NN(independence)) ‚Äù(‚Äù))
NP(VP1 DEC(ÁöÑ) NP(NN(ÊÄùÊÉ≥) NN(Êñó‰∫â)))
‚Üí NP(ADJP(ADJP1 JJ(ideological)) NN(struggle))
NP(NP(QP1 NP2 ) NP(ADJP(JJ(ÈáçË¶Å)) NP(NN(ÊÄùÊÉ≥))))
‚Üí NP(NP(DT(the) JJ(important) NN(thinking)) IN(of) SBAR(WHNP1 S2 ))
NP(IP1 DEG(ÁöÑ) NP(NN(Áé∞ÂÆû) NN(ÊÑè‰πâ))) ‚Üí NP(ADJP(ADJP1 JJ(practical))
NN(significance))
NP(NP(PU(‚Äú) NP(QP1 NN(‰ª£Ë°®)) PU(‚Äù)) NP(ADJP2 NN(ÊÄùÊÉ≥)))
‚Üí NP(NP(DT(the) JJ2 NN(idea)) PP(IN(of) NP(DT(the) CD1 NNS(represents))))
NP(PU(‚Äú) NN(ÂÖ•Â∏Ç) PU1 ) ‚Üí VP(VBG(joining) NP(DT(the) NN1 ))

The top-10 highest probability rules (for MT) in WordAlign-2 but absent in our approach
1
LCP(QP1 LC(‰ª•‰∏ä)) ‚Üí ADJP(JJ1 )
2*
NP(DNP1 NN(ÂèòÂåñ)) ‚Üí VP(ADVP1 VBP(changes))
3*
NP(NN(‰∏âÈÄö) NN1 ) ‚Üí NP(CD(three) NNS(links) X1 )
4
NP(DNP(IP1 DEC(ÁöÑ)) NP(NN(ÊÑè‰πâ))) ‚Üí NP(ADJP1 NN(significance))
5
VP(ADVP1 VP(VV2 NP(NN(Áæ§‰ºó) NN3 )))
‚Üí VP(ADVP1 VP(VP(VV2 ) NP(DT(the) JJ(mass) NN3 )))
6
IP(NP1 VP(VV(Êç¢) NP(NN(ÂíåÂπ≥) NN2 ))) ‚Üí NP(NP(NNS1 ) PP(IN(for) NP2 ))
7
NP(VP1 DEG(ÁöÑ) NN(Âêà‰Ωú)) ‚Üí ADJP(JJ1 )
8
NP(NP(PU(‚Äú) NT1 PU(‚Äù)) NP(NN(ËÆ≤ËØù)) NR(‰∏≠))
‚Üí NP(NP(PRP$(his)) QP(CD1 ) NN(speech))
9*
VP(VP(ADVP1 VP(VV(Âä†Âº∫) CC(Âíå) VV(ÊîπËøõ))) NP2 )
‚Üí VP(ADVP1 VP(VP(VB(strengthen) CC(and) VB(improve)) NP2 ))
10* NP(NP(PU(‚Äú) NN(Âè∞Áã¨) PU(‚Äù)) NP1 )
‚Üí NP(NP(‚Äù(‚Äù) NP(NN(taiwan) NN(independence)) ‚Äù(‚Äù)) NNS1 )

Figure 7: The top-10 highest probability rules built from the proposed sub-tree alignment
approach that are not in the WordAlign-2 baseline grammar, and the top-10 rules
in the WordAlign-2 baseline grammar that are not obtained using the proposed
sub-tree alignment approach. * = a good translation rule.
Dorr, Schwartz, Makhoul, Micciula, & Weischedel, 2005), and the significance test is performed using the bootstrap resampling method (Koehn, 2004). Moreover, the efficiency of
rule extraction is reported in terms of rule-set-size/extraction-time. For comparison, we
also report the result of rule extraction using word alignment matrices (Liu et al., 2009b)
on WordAlign-1 and WordAlign-2.
Table 4 indicates that our approach outperforms the baselines by the BLEU and TER
measures for both 1-best and 30-best extraction. In addition, the matrix-based method is
much more efficient than the k-best method. For example, compared with 30-best extraction, extracting rules from sub-tree alignment matrices is 9 times more efficient. However,
when all rules are counted as unit one in parameter estimation of the translation model,
using alignment matrices does not show significant BLEU improvements or TER reductions in comparison with the 30-best counterpart (see rows marked with unitcount). This
is because many of those additionally extracted rules are not utilized in real translation.
For example, we observed that only 7.3% of the rules used in generating the final (1-best)
763

Xiao & Zhu

Entry
WordAlign-1 (1-best)
WordAlign-2 (1-best)
HeuristicAlgin (1-best)
WordAlign-1 (30-best)
WordAlign-2 (30-best)
HeuristicAlgin (30-best)
WordAlign-1 (matrix)
WordAlign-2 (matrix)
Ours (1-best + unitcount)
Ours (30-best + unitcount)
Ours (matrix + unitcount)
Ours (1-best + posterior)
Ours (30-best + posterior)
Ours (matrix + posterior)

Dev

Test

BLEU4[%] TER[%]

BLEU4[%] TER[%]

36.2
36.2
35.7
36.3
36.4
35.4
36.9*
36.8*
36.7*
36.8*
36.9*
36.9*
37.0*
37.4**

34.2
34.2
33.8
34.4
34.6*
33.9
35.0*
35.1*
34.9*
35.0*
35.3**
35.0*
35.2**
35.6**

57.0
56.9
57.2
57.2
57.0
57.2
56.5
56.6
56.6
56.6
56.3*
56.4*
56.2**
55.9**

58.3
58.1
58.3
58.2
58.0
58.0
57.9*
57.7*
57.8
57.6*
57.5*
57.4*
57.0**
57.1**

Rule-set
size
24.8M
25.3M
22.7M
32.7M
33.0M
32.4M
50.2M
53.8M
27.0M
37.4M
54.9M
27.0M
37.4M
54.9M

Efficiency
(rule/sec)

75.4
75.9
72.0
3.8
3.9
3.8
35.8
37.9
78.8
4.1
37.7
78.8
4.1
37.7

Table 4: Evaluation of translations for different alignment approaches. For BLEU, higher
is better. For TER, lower is better. unitcount means that we take each rule
occurrence as unit one in parameter estimation, and posterior means that we use
rule posterior probabilities as fractional counts in parameter estimation. * or **
= significantly better than all three of the 1-best baselines (p < 0.05 or 0.01).
translations were indeed extracted from the alignments that were not seen in the 30-best
alignments. It thus indicates the fact that naively increasing the number of rules might not
be effective for improving the translation quality.
The last three rows in Table 4 show the result of using alignment posterior probabilities
in parameter estimation (i.e., the method described in Section 4.3). We see that alignment
posterior probabilities are very helpful in improving translation quality because the system
can weight more on those rules with more confidence (entries with unitcount vs. entries
with posterior ). By using sub-tree alignment matrices in rule extraction and alignment
posterior probabilities in parameter estimation, our approach finally achieves a +1.0 BLEU
improvement and a -0.9 TER reduction over the 30-best case of the baselines. It even
outperforms the word alignment matrix-based counterpart by +0.5 BLEU points and -0.6
TER points (both are significant at p < 0.05).
Further, the effectiveness of the proposed approach is demonstrated in terms of BLEU
and TER scores under the same rule-set size. Figure 8 compares our approach and the
baseline approaches in different numbers of unique rules extracted.17 Clearly, in the same
number of unique rules, the proposed sub-tree alignment approach leads to better translations than those of the baselines.
5.3.4 The Impact of Alignment and Grammar Quality on MT Performance
The above experiments demonstrate the effectiveness of the proposed approach in terms
of different measures individually. The next natural question is how sub-tree alignment
17. To do this, we adjusted Pmin to obtain grammars with different sizes for our approach. For other
approaches, we used different k-best lists for rule extraction.

764

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

43

1 - TER[%]

BLEU4[%]

36

35

34

HeuristicAlgin
WordAlign-2
WordAlign-1
Ours

42

HeuristicAlgin
WordAlign-2
WordAlign-1
Ours
41

33
10

20

30

40

50

60

70

10

20

30

40

50

60

70

Rule-set size (million)

Rule-set size (million)

Figure 8: BLEU and 1-TER against rule-set size
and rule extraction affect the translation quality. The study of this issue is very important
when we optimize the upstream systems of MT decoding and select appropriate evaluation
metrics for a good prediction of MT performance.
We therefore carried out another set of experiments which compares the translation
quality in different sub-tree alignment and rule extraction settings. To generate diverse
sub-tree alignment and rule extraction results, we varied the values of œâ and Pmin for
sub-tree alignment and rule extraction respectively. In this way, we obtained ensembles of
sub-tree alignments and grammars with different precision and recall scores.18 We chose
F-Œ≤ score as the evaluation metric for both the sub-tree alignment system and the rule
extraction system. Instead of fixing Œ≤ to be 1, we varied the Œ≤ value from 0.5 to 3. Since
the parameter Œ≤ can control the bias towards precision or recall, choosing different values for
Œ≤ is very helpful in seeking a good tradeoff between precision and recall. Then we can find
an appropriate evaluation measure of sub-tree alignment and rule extraction for predicting
MT performance well.
Figures 9 and 10 plot the F-Œ≤ scores as measures of MT performance for sub-tree alignment and rule extraction. From Figure 10, we see that the rule F-3 score correlates best
with the translation quality measures, which indicates that the MT system prefers rule
recall-biased metrics. This agrees with our observation in Figure 8 that the MT system
can make benefits from more rules. On the other hand, the curves in Figure 9 show a
better correlation between sub-tree alignment F-2/F-3 score and translation quality measures, implying a preference for relatively higher sub-tree alignment recall. This result is
reasonable because in our framework more node alignment links can result in more aligned
tree-fragments (or rules) extracted. A high-recall sub-tree alignment generally results in a
big grammar with high rule recall, and thus better BLEU and TER results. We also com18. For example, a larger value of œâ generally results in higher alignment precision, while a small value
prefers higher alignment recall. For rule extraction, a larger value of Pmin generally leads to a grammar
with higher rule precision, while choosing a smaller Pmin can generate a grammar with higher rule recall.

765

Xiao & Zhu

80

sub-tree alignment F-Œ≤[%]

sub-tree alignment F-Œ≤[%]

80

70

60

F-0.50
F-0.75
F-1.00
F-2.00
F-3.00

50

40
33.5

34

34.5

35

35.5

70

60

F-0.50
F-0.75
F-1.00
F-2.00
F-3.00

50

40

36

41

BLEU4[%]

42

43

1 - TER[%]

70

70

60

60

rule F-Œ≤[%]

rule F-Œ≤[%]

Figure 9: BLEU and 1-TER against sub-tree alignment F-Œ≤ measure

50
40

F-0.50
F-0.75
F-1.00
F-2.00
F-3.00

30
20
34

34.5

35

50
40

F-0.50
F-0.75
F-1.00
F-2.00
F-3.00

30
20

35.5

41.5

BLEU4[%]

42

42.5

43

1 - TER[%]

Figure 10: BLEU and 1-TER against rule F-Œ≤ measure

puted the Pearson‚Äôs correlation coefficients between sub-tree alignment/rule F-3 score and
BLEU/TER. For sub-tree alignment F-3, its correlation coefficients with BLEU and TER
are 0.971 and -0.962 respectively. For rule F-3, its correlation coefficients with BLEU and
TER are 0.983 and -0.963 respectively. Both of them show good correlations with the translation quality measures. Another interesting observation here is that the MT performance
is more sensitive to the change of rule F-Œ≤ score than to the change of sub-tree alignment
F-Œ≤ score. This may lie in that rule extraction is a direct upstream step of decoding and
impacts more on the output of MT systems. In contrast, sub-tree alignment is a front-end
step of the MT pipeline and has an indirect effect on the actual translation process.
766

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

System
Hierarchical phrase-based
Tree 1-best word alignment (WordAlign-2)
to
Word alignment matrix
tree Sub-tree alignment matrix

Dev

Test

BLEU4[%] TER[%]

BLEU4[%] TER[%]

37.2
36.8
37.0
37.9*

35.2
35.3
35.2
36.0**

57.3
56.4*
56.3*
55.8**

58.0
57.7
57.5*
56.8**

Table 5: MT Evaluation results of rules obtained from various alignment approaches. For
BLEU, higher is better. For TER, lower is better. * or ** = significantly better
than the hierarchical phrase-based baseline (p < 0.05 or 0.01).
5.3.5 Further Improvements
Previous work has pointed out that the straightforward implementation of tree-to-tree MT
suffers from the problems of too few rules and too few derivations in either rule extraction or
decoding process (Chiang, 2010). To further advance the tree-to-tree system and compare
it with the state-of-the-art, we employed tree binarization (Wang et al., 2007b) and fuzzy
decoding (Chiang, 2010) in our system. As our alignment approach can be equipped with
the general framework of tree-to-tree translation, it is trivial to conduct another set of
experiments to investigate the effectiveness of our approach in a stronger system.19 Table
5 shows the BLEU and TER scores of our system enhanced with the above methods.20 For
comparison, we also report the result of a state-of-the-art MT system that implements the
hierarchical phrase-based model (Chiang, 2007) and our tree-to-tree system that extracts
rules using the word alignment matrices (Liu et al., 2009b). Table 5 indicates the superiority
of our approach when tree binarization and fuzzy decoding are involved. It significantly
outperforms the hierarchical phrase-based system (+0.7 BLEU points and -1.2 TER points)
and the tree-to-tree system based on the word alignment matrices (+0.8 BLEU points and
-0.7 TER points).
As discussed in Section 4, the transfer rules in our sub-tree alignment model resembles
the general form of STSGs which can be directly used in MT. Instead of resorting to an
explicit step of rule extraction, we can use the rules in the sub-tree alignment model for
MT decoding, i.e., sub-tree alignment is cast as a grammar induction step. We therefore
built another system which directly acquires translation rules from the sub-tree alignment
step. To do this, we only need to output all the rules from the derivation forest generated
by our alignment model. All rule probabilities can be obtained using the inside and output
probabilities, and pruning is performed by throwing away rules whose probability is below
Pmin . In addition to rule probability, we reused the n-gram language model, the rule number
bonus, the target length bonus, the lexicalized rule and low frequency rule indicators in our
base tree-to-tree system as additional features for a fair comparison. To obtain a good and
reasonable result, we employed both fuzzy decoding and tree binarizaiton in the experiment.
19. We did not choose this setting in the previous experiments because our gold-standard alignment annotation was on the Penn Treebank-style trees only. It was difficult to evaluate the alignment and grammar
quality on binarized trees due to the lack of benchmark data. In our experiments we first conducted the
experiments on each individual tasks (see Sections 5.3.1-5.3.3), and studied their correlations in a simple
but reasonable setting for a consistent result of sub-tree alignment and MT (see Section 5.3.4). Then we
investigated the effectiveness of our approach on an advanced tree-to-tree system (see Section 5.3.5).
20. In our implementation all parse trees were binarized in a head-out fashion.

767

Xiao & Zhu

Entry
Baseline (explicit rule extraction)
Rules from the sub-tree alignment model
Rules from the sub-tree alignment model + MERT
Baseline + sub-tree alignment features

Dev

Test

BLEU4[%] TER[%]

BLEU4[%] TER[%]

37.9
36.2
36.7
38.2

36.0
34.3
34.9
36.1

55.8
57.9
57.3
55.8

56.8
58.8
58.0
56.9

Table 6: MT Evaluation results of obtaining rules from the sub-tree alignment model and
obtaining rules with the traditional rule extraction pipeline
Table 6 compares the results of sub-tree alignment matrix-based rule extraction and inducing rules from the alignment model (Row 1 vs. Row 2). Unfortunately, straightforwardly
inferring rules and their probabilities from the sub-tree alignment model underperforms the
baseline. This might be attributed to several reasons. First, due to the large derivation
space, we cannot enumerate all relatively large tree-fragments in the sub-tree alignment
step, instead we only access the tree-fragments with limited depths. By contrast, our baseline system extracts basic rules using sub-tree alignment matrices and then obtains more
large rules with some heuristics (e.g., rule composing). The additional rules obtained in
our baseline framework of rule extraction are in general very useful to modern syntax-based
systems (Galley et al., 2006; Marcu et al., 2006; DeNeefe et al., 2007). Second, the rule
probability in our sub-tree alignment model is defined as a product of probability factors
for a good generation story. However, MT systems usually use features which are not required to form a generative model, such as the features shown in Equations (33)-(37). In
consequence, many well-developed features can be used by the baseline system but they
are not available in our sub-tree alignment model. Third, our sub-tree alignment model
is trained by maximizing the likelihood or other criteria, which is not consistent with that
adopted by the MT system (i.e., minimizing an evaluation-related error rate function). To
further study these issues, we improved the system in two ways. First, we treated all four
of the probability factors in the sub-tree alignment model (See Equation (13)) as different
features in the MT decoder, and tuned their weights using MERT. Row 3 in Table 6 shows
that this method achieves better results than the system employing unweighted probability
factors. However, its performance is still worse than that of the baseline, which indicates
that the MT-oriented features and rule extraction heuristics are crucial to the success of
our tree-to-tree system. Finally we added the probabilistic factors of our sub-tree alignment
model to the baseline system as additional features. As shown in the last row of Table 6,
the enhanced system yields modest BLEU improvements over the baseline, but no TER
improvement is achieved. All the above results give us two interesting messages - 1) rule
extraction heuristics, MT-oriented features and objectives of learning are key factors contributing to a good tree-to-tree system; 2) and it is better to use our sub-tree alignment
model as an upstream module of rule extraction and decoding, rather than using it as a
simple step for grammar induction.
The last issue we investigate here is whether our sub-tree alignment model can make
benefits from labeled data. Although we focus on unsupervised learning in this work,
the proposed model does not require a strictly unsupervised condition. Instead it can be
enhanced with the use of labeled data. The idea is simple: we combine the probability
factors of our sub-tree alignment model in a log-linear weighted fashion. It means that
768

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

Entry
Unweighted
Weighted (weights are learned on labeled data)

Dev

Test

BLEU4[%] TER[%]

BLEU4[%] TER[%]

37.9
38.3

36.0
36.1

55.8
55.6

56.8
56.9

Table 7: Comparison of the unweighted and weighted sub-tree alignment models
all probability factors of our sub-tree alignment model are taken as real valued feature
functions, and their feature weights can be learned on labeled data by supervised methods.
In this way, our unweighted generative model (i.e., each factor has a weight of one) is
transformed into a weighted model (i.e., each factor has an individual weight). Note that
this weighted model has almost the same form as those used in SMT systems. The only
difference from the SMT model is that no language model is needed because the targetlanguage side is fixed in the sub-tree alignment step. To avoid bias towards too few or
too many rules, we also added the rule number as an additional feature to our new model.
For training and test, we divided our node-aligned gold-standard data into two parts - the
first 310 sentences were selected for weight training, and the remaining 327 sentences were
selected for testing the system. To learn feature weights in a supervised manner, we chose
MERT which is one of the most powerful tools for training log-linear models. The error
function used in MERT is defined by one minus sub-tree alignment F-1 score.
On the 327-sentence test data (with the tree annotation of the Penn Treebanks), the
weighted model achieves an alignment F-1 score of 75.4% and a rule F-1 score of 60.0%,
respectively. This result is better than that of the unweighed (and unsupervised) model
which obtains an alignment F-1 score of 72.4% and a rule F-1 score of 59.2% on the same
data set. Finally we tested the MT performance in our best setting (i.e., sub-tree alignment
matrix-based rule extraction + tree binarization + fuzzy decoding).21 Table 7 shows that
the weighted sub-tree alignment model leads to a better BLEU score on the tuning set but
does not show promising improvements on the test data. As the size of our labeled corpus
is small, we expect better results if more labeled data is available. Also it is worth studying
more sophisticated supervised methods to learn better weights, such as the kernel-based
methods (Sun et al., 2010b). As supervised/semi-supervised learning is not the focus of
this work, we leave these interesting issues to future investigations.

6. Related Work
Syntax-based approaches have been widely adopted in machine translation over the last
ten years. Many successful syntactic MT systems have been developed and shown good
results on several translation tasks (Eisner, 2003; Galley et al., 2004, 2006; Liu et al.,
2006; Huang et al., 2006; Zhang et al., 2008; Liu et al., 2009a; Chiang, 2010). Despite
differences in modeling and implementation details, all these models require an ‚Äùalignment‚Äù
step to acquire the syntactic correspondence between the source and target languages. As
is standard in SMT, most syntax-based MT systems use word alignments to infer syntactic
alignments from string-tree/tree-tree pairs. However, word alignments are generally not of
good quality from the viewpoint of syntactic alignment. It makes more sense to directly
21. As we did not have sub-tree-aligned data for binarized trees, we reused the weights learned on the Penn
Treebank-style trees for all four of the probability factors in our sub-tree alignment model.

769

Xiao & Zhu

induce sub-tree level alignments from pairs of sentences with the syntactic information on
either language side or both. This is especially true for tree-to-tree MT where what we
actually need is the alignment between sub-trees in two languages, rather than the surface
alignment of words. There are several lines of work that address the syntactic alignment
problem and make better use of various alignment results for tree-to-tree translation.
6.1 Word and Sub-tree Alignment for Machine Translation
The earliest efforts in syntactic alignment focus on enhancing word alignment models with
syntactic information. To date, several research groups (Fraser & Marcu, 2007; DeNero
& Klein, 2007; May & Knight, 2007; Fossum et al., 2008; Haghighi, Blitzer, DeNero, &
Klein, 2009; Burkett, Blitzer, & Klein, 2010; Riesa, Irvine, & Marcu, 2011) have proposed
syntax-augmented models to advance their word alignment systems. Although these models
achieved promising improvements, they still address the alignment problem in word level.
As discussed in Section 1, such methods might not be desirable choices for learning the
correspondence between tree nodes in two languages. As an alternative and more straightforward solution, researchers tried to infer sub-tree level alignments for pairs of syntactic
trees. For example, Imamura (2001), Groves, Hearne, and Way (2004), and Tinsley et al.
(2007) defined several scoring functions to measure the similarity between the source and
target sub-trees, and aligned the tree nodes with greedy algorithms. Their approaches,
though simple to implement, are not derived in a principled way. For example, all these
models do not have an explicit optimization procedure, as in a general framework of statistical learning. Instead, the model parameters are obtained using additional alignment
models or lexicons. In another line of research, Sun et al. (2010a, 2010b) attempted to address the sub-tree alignment problem with supervised/semi-supervised models. They used
tree kernels and various syntactic features to advance their sub-tree alignment system and
showed promising results on Chinese-English translation tasks. However, this approach still
relies on heuristic algorithms for inferring node correspondences between two parse trees.
Beyond this, to train the tree kernels, their approach requires additional labeled data which
is generally very expensive to build. Unlike these studies, we derive our sub-tree model in a
principled way and develop an unsupervised sub-tree alignment framework for tree-to-tree
MT.
6.2 Unsupervised Syntactic Alignment
There are also previous studies that do not resort to labeled data for sub-tree alignment.
The earliest of these was Eisner‚Äôs (2003) work. He designed an unsupervised approach
to modeling the sub-tree alignment problem in the STSG formalism. However, since no
detailed derivation and model decomposition is provided, this model is computationally
expensive, even difficult to be applied to current tree-to-tree systems where complex tree
structures are involved. Gildea (2003) also applied STSGs to tree-to-tree/tree-to-string
alignment. He developed a ‚Äùloosely‚Äù tree-based alignment method to address the issue of
parse-tree isomorphism in bitext. But his work only targets the word alignment rather
than modern syntactic MT systems. Recently Nakazawa and Kurohashi (2011) proposed
a Bayesian approach for sub-tree alignment between dependency trees, and tested it in a
Japanese-English MT system. Actually their model has much in common with the model
770

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

presented in this work. For example, they both apply unsupervised learning methods and
Bayesian models to sub-tree alignment. On the other hand, the two studies differ in some
important aspects. First, Nakazawa and Kurohashi (2011) restricted themselves to sub-tree
alignment between dependency trees, which is very different from aligning tree nodes in
phrase structure trees. Since phrase structure trees involve more complex structures and
syntactic categories, the alignment problem in phrase structure trees are relatively more
difficult than the dependency-based counterpart. Second, our model makes benefits from
the recent advances in STSGs and is directly applicable to current state-of-the-art tree-totree systems.
Another related work to what is presented here is Pauls, Klein, Chiang, and Knight‚Äôs
(2010) work. They factored a node-to-string alignment model over components that each
generates a target side of a synchronous rule from a source side. Moreover, the probability of
a rule fragment was factored into a lexical and structural component in their work. Actually,
their model and our proposed model are two variants on a theme. But there appear to
be obvious differences between them. First, our focus is sub-tree alignment for tree-to-tree
translation, while Pauls et al. (2010) addressed the alignment issue for tree-to-string/stringto-tree translation. In our model, we parse both language sides independently, rather than
parsing only one side and projecting syntactic categories. As a result, inference is faster
in this work since we do not need to consider all possible parse trees of the unparsed side
during alignment. Second, the permutation model presented in this work is more general
in order to handle non-ITG trees. Third, we investigate methods for the effective use of
sub-tree alignment in MT. In particular, we present a rule extraction approach to obtaining
additional translation rules using sub-tree alignment posteriors, rather than learning rules
only from the 1-best sub-tree alignment.
6.3 Rule Extraction Using Various Alignment Results
In machine translation, word and syntactic alignments are used to extract translation rules
or phrases. In the traditional pipeline of rule and phrase extraction, only the 1-best alignment result is considered, which suffers from the limited scope of the single alignment. To
efficiently obtain diverse alignment/parsing results, packed data structures were adopted to
improve 1-best pipeline MT systems in recent years (Mi & Huang, 2008; Liu et al., 2009a;
Zhang, Zhang, Li, Aw, & Tan, 2009). For example, Liu et al. (2009b) and de Gispert et al.
(2010) used alignment posterior probabilities for phrase or hierarchical phrase extraction.
The development of sub-tree alignment matrices is actually motivated by a similar idea
from word alignment matrices. The difference from the above work is that we use sub-tree
on both language sides to infer alignment posterior probabilities, while these probabilities
are calculated in word/phrase-level in previous work (Liu et al., 2009b; de Gispert et al.,
2010). Moreover, to our knowledge, the effectiveness of sub-tree alignment matrix has not
been systematically studied in the case of tree-to-tree translation.
Note that the approach presented in this work is also doing something similar to synchronous grammar induction. For example, our model results in an STSG which has the
same formalism as that used in MT. Recent studies on Bayesian models (Blunsom, Cohn,
Dyer, & Osborne, 2009; Cohn & Blunsom, 2009; Levenberg et al., 2012) have shown very
promising results in directly learning synchronous grammars from bilingual data for hierar771

Xiao & Zhu

chical phrase-based and string-to-tree systems, rather than extracting synchronous grammar
rules based on an explicit word/syntactic alignment step. However it is rare to see related
work on tree-to-tree MT. In principle this article is different from previous work on synchronous grammar induction. For example, the aim of this work is to learn a sub-tree
alignment model, which can be applied to many potential applications except MT, such as
sentence compression for paraphrasing and test summarization (Jing, 2000; Cohn & Lapata,
2009). Unlike synchronous grammar induction where the alignment is implicitly encoded
in the learning process, we treat sub-tree alignment as a separate task. This eases the
development and tuning of the alignment system because we actually do not resort to MT
systems which are ‚Äùslow‚Äù and difficult to optimize. Another advantage is that our approach
can make benefits from more compact models, rather than those used in MT where a great
number of rules are involved. Take our implementation as instance. The alignment model
is learned on a relatively small set of grammar rules (rules with limited depths), while the
MT system accesses a much larger grammar where many additional rules are involved by
rule composing. Such a method can result in an efficient alignment system and is likely to
alleviate the degenerate analysis of the data, with no cost of degrading in MT performance.

7. Discussion
The underlying assumption of our proposed model is that 1-to-1 sub-tree alignments can
be achieved based on the constraints imposed by neighboring parts of the tree (see Section
2). This makes sense in the standpoint of linguistically-motivated models, yet it in turn
faces a problem that the constraints make it difficult to align some sentences/trees correctly,
particularly if they are free translations. There are several reasons that can explain why
our approach works nice with tree-to-tree MT and why it does not suffer greatly from
the structure divergence between languages. First, our model is ‚Äùflexible‚Äù and allows for
node deletion/insertion in alignment. It means that in some levels of the tree it is not
necessary to require that every node is aligned to a valid node in the other language side,
instead nodes can be ‚Äùdropped‚Äù as needed. The advantage of such a method is that if
we cannot confidently align a node to any node in the counterpart tree, we can align it
to a virtual node and do not enforce bad constraints to aligning other parts of the tree.
This is very useful when there are very flat tree structures or partial translations which
are not syntactically well-formed. Second, the main purpose of our approach is to infer
sub-tree alignment probabilities which can be used in pruning sub-tree alignment matrices
and extracting rules for MT systems. Though 1-to-1 alignment is required for training the
sub-tree alignment model, what we actually do is to access a large number of alignment
alternatives for rule extraction, even if some of them cannot appear in the same derivation
due to our alignment constraints. Third, our model can work with any phrase structure
trees. Instead of the Penn Treebank-style trees which are difficult for alignment in some
cases, our sub-tree alignment system works well with binarized trees and shows promising
improvements over various baselines. Note that tree binarization is a very effective method
to alleviate the structure divergence problem, especially for Chinese-English translation.
Also, it might be interesting to investigate other methods for dealing with differences in
syntactic structures between languages, such as the forest-based methods (Mi & Huang,
2008; Liu et al., 2009a).
772

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

Another note on our approach. If implemented naively, the speed of the sub-tree alignment system will be very slow since our model needs the calculation of the alignment probability over all pairs of tree-fragments. Fortunately, with the thought of computation, several
optimizations can make the system much more efficient in practice. First, as is described in
this work, pruning methods can be employed to restrict the number of tree-fragments to a
reasonable level. In our experiments, the system with pruning achieved a speed of 1.8‚àº2.2
sentence/second on a single core of the Intel Xeon 3.16-GHz CPU. Another way for speed
improvement is parallel processing. A very good property of the EM-style algorithms is
that the E-step can be easily implemented in parallel computation environment. What we
need is to divide the training data set into a number of ‚Äùsmaller‚Äù parts, and then run the
inside-outside algorithm on these parts in parallel (i.e., a Map procedure). The expected
counts of model parameters can be accumulated over the results of all the parts (i.e., a
Reduce procedure). Then the M-step can be performed as usual. In our implementation
we used 40 threads for parallel training. The running time of one training iteration over
our 1-million-sentence corpus was about 14-17 hours. Note that further system speed-up
can be expected if more powerful distributed infrastructures are available (e.g., clusters +
Hadoop), and it is not difficult to scale up our approach to handle millions of sentence pairs
using the current training framework.

8. Conclusions
We have proposed an unsupervised probabilistic sub-tree alignment approach for tree-totree translation. By factoring the alignment model over several components, the resulting
model can be easily learned using the EM algorithm and the variational Bayesian approach.
Also, we have investigated different ways of applying the proposed model to tree-to-tree
translation. In particular, we developed a sub-tree alignment matrix which encodes an
exponentially large number of alignments. From this representation of sub-tree alignment,
desirable rules can be extracted more efficiently than using the k-best sub-tree alignment
result. Our experiments showed that the proposed model achieved significant improvements
in both alignment quality and grammar quality over several baselines. On the NIST ChineseEnglish evaluation corpora, it achieved a +1.0 BLEU improvement and a -0.9 TER reduction
on top of a state-of-the-art tree-to-tree system. The improved MT system even significantly
outperformed a state-of-the-art hierarchical phrase-based system when equipped with tree
binarization and fuzzy decoding.

Acknowledgments
This work was supported in part by the National Science Foundation of China (Grants
61073140 and 61272376), the Natural Science Foundation for the Youth of China (Grant
61300097), the China Postdoctoral Science Foundation (Grant 2013M530131), the Specialized Research Fund for the Doctoral Program of Higher Education (Grant 20100042110031),
and the Fundamental Research Funds for the Central Universities (Grant N100204002). The
authors would like to thank the anonymous reviewers for their pertinent and insightful comments, Keh-Yih Su for his great help in improving the early version of this article, Ji Ma for
773

Xiao & Zhu

helpful discussions, and Chunliang Zhang and Tongran Liu for language refinement. The
corresponding author of this article is Jingbo Zhu.

Appendix A. Part-of-speech Tags and Phrase Structure Labels
In this work the annotation of POS tagging and phrase structure parsing follows the standard defined in the Penn English and Chinese Treebanks (Marcus et al., 1993; Xue et al.,
2005). See Tables 8-11 for lists of POS tags and constituent labels used in the example
trees in this article.
POS Tag
AD
AS
NN
NR
P
PN
PU
VV

Description
Adverb
Aspect Particle
Noun (except proper nouns and temporal nouns)
Proper Noun
Preposition
Pronoun
Punctuation
Verb (except stative verbs, copulas, and the main
verbs of ‚ÄùÊúâ‚Äù, ‚ÄùÊ≤°‚Äù and ‚ÄùÊó†‚Äù)

Table 8: Chinese POS tags used in the examples
POS Tag
DT
IN
JJ
NNP
NNS
PRP
RB
VBD
VBN
VBP
,
.

Description
Determiner
Preposition
Adjective
Proper noun (singular)
Noun (plural)
Personal Pronoun
Adverb
Verb (past tense)
Verb (past participle)
Verb (non-3rd person singular present)
Comma
Period

Table 9: English POS tags used in the examples
Syntactic Label
IP
NP
PP
QP
VP

Description
Single Clause
Noun Phrase
Preposition Phrase
Quantity Phrase
Verb Phrase

Table 10: Chinese constituent labels used in the examples

774

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

Syntactic Label
ADVP
NP
PP
S
VP

Description
Adverb Phrase
Noun Phrase
Preposition Phrase
Sentence
Verb Phrase

Table 11: English constituent labels used in the examples
Distribution
Pnt (¬∑)
Ptree (¬∑)
Preorder (¬∑)

Notation
Œ∏tnt |snt
Œ∏ttree |tnt
Œ∏tvnt |svnt

Plength (¬∑)
Pw (¬∑)

Œ∏l|m
Œ∏tw |sw

Description
snt and tnt are source and target-language non-terminal symbols
ttree is a target-language tree-fragment
svnt and tvnt are vectors of non-terminal symbols in source
and target-languages
m and l are numbers of source and target terminals (or words)
sw and tw are source and target terminals (or words)

Table 12: Notations of model parameters

Appendix B. EM-based Training for the Sub-tree Alignment Model
As described in Section 3, the proposed sub-tree alignment model has five types of parameters, including the non-terminal mapping probability Pnt (¬∑), the target-language treefragment generation probability Ptree (¬∑), the frontier non-terminal reordering probability
Preorder (¬∑), the word number probability Plength (¬∑) and the word mapping probability Pw (¬∑).
For convenience we use a new set of notations to denote these model parameters in the following description. See Table 12 for a symbol list.
Here we follow the same framework of the EM-based training as that described in Figure
3. See Figure 11 for a complete version of the EM algorithm for all parameters of the model.
In this algorithm, EC(¬∑) represents the expected count of the input variable. Œ¥(X = x) is
a 0-1 function that returns 1 if variable X takes a value of x, 0 otherwise. Œ≥ (k) (r; u, v)
and Œ≥ (k) (S, T ) are the rule probability (see Equation (29)) and the probability of the subtree alignment between S and T (see Equation (20)), where k indicates that all these
probabilities are calculated based on the parameters in the k-th iteration. tree(¬∑), vnt(¬∑)
and lex(¬∑) are the functions that return the tree-structure, frontier non-terminal vector, and
terminal sequence of the input tree-fragment, respectively (see Section 3.2).
The basic idea of the E-step is that we check each rule r (given a pair of tree nodes u
Œ≥(r;u,v)
and v) and update EC(¬∑) by its relative probability Œ≥(root(S),root(T
)) . This can be applied
to the update rules for the parameters Œ∏tnt |snt , Œ∏ttree |tnt , Œ∏tvnt |svnt and Œ∏l|m (see lines 8-11).
The only exception is Œ∏tw |sw . As defined in Equation (14), Pw (ti | sj ) is not a direct
product factor,Pinstead we use the sum over all terminals of the source-language treefragment (i.e., m
j=1 Pw (ti | sj )). Here we follow the result of IBM Model 1 and make the
P|lex(s )|
update magnitude proportional to Pw (ti | sj )/ j 0 =1 r Pw (ti | sj 0 ). We refer the reader
to Brown et al.‚Äôs (1993) work for detailed derivation of the expected count in IBM Model
1. It is also worth noting that the above algorithm performs parameter update based on
different choices of (u, v) and r in the E-step. This means that if a rule instance is involved
in a particular derivation for more than one time (e.g., the same tree-fragment appears at
775

Xiao & Zhu

1: Function TrainModelWithEM ({(S1 , T1 ), ..., (Sn , Tn )})
(0)
(0)
(0)
(0)
(0)
2: Initialize {Œ∏tnt |snt , Œ∏ttree |tnt , Œ∏tvnt |svnt , Œ∏l|m , Œ∏tw |sw }
3: For k = 0 to K ‚àí 1 do
4:
Set EC(¬∑) = 0 for all model parameters
6: E-step:
5:
Foreach tree pair (S, T ) in sequence {(S1 , T1 ), ..., (Sn , Tn )} do
6:
Foreach node pair (u, v) in (S, T ) do
7:
Foreach rule r rooted at (u, v) do
Œ≥ (k) (r;u,v)¬∑Œ¥(snt =u)¬∑Œ¥(tnt =v)
Œ≥ (k) (root(S),root(T ))

8:

EC(Œ∏tnt |snt )

+=

9:

EC(Œ∏ttree |tnt ) + =

Œ≥ (k) (r;u,v)¬∑Œ¥(tnt =v)¬∑Œ¥(ttree =tree(tr ))
Œ≥ (k) (root(S),root(T ))

10:

EC(Œ∏tvnt |svnt ) + =

Œ≥ (k) (r;u,v)¬∑Œ¥(svnt =vnt(sr ))¬∑Œ¥(tvnt =vnt(tr ))
Œ≥ (k) (root(S),root(T ))

11:

EC(Œ∏l|m )

Œ≥ (k) (r;u,v)¬∑Œ¥(m=|lex(sr )|)¬∑Œ¥(l=|lex(tr )|)
Œ≥ (k) (root(S),root(T ))

12:

Foreach word pair (sj , ti ) in position (j, i) of (lex(sr ), lex( tr )) do

+=

(k)
P
(ti |sj )
¬∑Œ¥(sw =sj )¬∑Œ¥(tw =ti )
r P(k) (t |s )
w
i j0
j 0 =1

Œ≥ (k) (r;u,v)¬∑ P|lex(sw)|

13:

EC(Œ∏tw |sw ) + =

Œ≥ (k) (root(S),root(T ))

10: M-step:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:

Foreach non-terminal symbol pair (snt , tnt ) do
(k+1)

Œ∏tnt |snt

=

EC(Œ∏tnt |snt )
P

t0nt



EC Œ∏t0

nt |snt

Foreach target non-terminal symbol tnt and tree-fragment structure ttree do
EC(Œ∏ttree |tnt )

(k+1)

Œ∏ttree |tnt =

P

t0tree



EC Œ∏t0

tree |tnt

Foreach pair of non-terminal symbol vectors (svnt , tvnt ) do
EC(Œ∏tvnt |svnt )

(k+1)

Œ∏tvnt |svnt =

P

t0vnt



EC Œ∏t0

vnt |svnt

Foreach pair of word numbers (m, l) do
(k+1)

Œ∏l|m

=

EC(Œ∏l|m )
P

l0

EC Œ∏l0 |m



Foreach pair of words (sw , tw ) do
(k+1)

Œ∏tw |sw

(K)

=

EC(Œ∏tw |sw )
P

t0w

(K)

EC Œ∏t0



w |sw

(K)

(K)

(K)

return {Œ∏tnt |snt , Œ∏ttree |tnt , Œ∏tvnt |svnt , Œ∏l|m , Œ∏tw |sw }
Figure 11: The EM-based training algorithm for all model parameters

different positions), the update of the corresponding parameters would be carried out for
multiple times.
Another note on the EM algorithm. The expected counts of all the parameters can be
efficiently calculated using the inside and outside probabilities according to lines 8-11 and
776

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

13. But for some parameters there are more efficient ways. For example, as is discussed in
Section 3.4.1, the expected count of Œ∏tnt |snt can be obtained without checking each individual
rule, that is, we can omit the loop for r in this case. This technique can be considered for
further speed-up of the sub-tree alignment system.

References
Attias, H. (2000). A variational bayesian framework for graphical models. In Solla, S. A.,
Leen, T. K., & K., M. (Eds.), Advances in Neural Information Processing Systems 12,
pp. 209‚Äì215. MIT Press.
Beal, M. J. (2003). Variational algorithms for approximate bayesian inference. Master‚Äôs
thesis, University College London.
Blunsom, P., Cohn, T., Dyer, C., & Osborne, M. (2009). A gibbs sampler for phrasal
synchronous grammar induction. In Proceedings of the Joint Conference of the 47th
Annual Meeting of the ACL and the 4th International Joint Conference on Natural
Language Processing of the AFNLP (ACL-IJCNLP), pp. 782‚Äì790, Suntec, Singapore.
Brown, P. E., Pietra, S. A. D., Pietra, V. J. D., & Mercer, R. L. (1993). The mathematics
of statistical machine translation: Parameter estimation. Computational Linguistics,
19, 263‚Äì311.
Burkett, D., Blitzer, J., & Klein, D. (2010). Joint parsing and alignment with weakly synchronized grammars. In Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics
(HLT:NAACL), pp. 127‚Äì135, Los Angeles, California, USA.
Chiang, D. (2005). A hierarchical phrase-based model for statistical machine translation.
In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL), pp. 263‚Äì270, Ann Arbor, Michigan, USA.
Chiang, D. (2007). Hierarchical phrase-based translation. Computational Linguistics, 33,
45‚Äì60.
Chiang, D. (2010). Learning to translate with source and target syntax. In Proceedings
of the 48th Annual Meeting of the Association for Computational Linguistics (ACL),
pp. 1443‚Äì1452, Uppsala, Sweden.
Chiang, D., & Knight, K. (2006). An introduction to synchronous grammars. In Tutorials of
the 21st International Conference on Computational Linguistics and the 44th Annual
Meeting of the Association for Computational Linguistics (COLING-ACL).
Chiswell, I., & Hodges, W. (2007). Mathematical Logic. Oxford University Press.
Cohn, T., & Blunsom, P. (2009). A Bayesian model of syntax-directed tree to string grammar induction. In Proceedings of the 2009 Conference on Empirical Methods in Natural
Language Processing (EMNLP), pp. 352‚Äì361, Singapore.
Cohn, T., & Lapata, M. (2009). Sentence compression as tree transduction. Journal of
Artificial Intelligence Research, 34, 637‚Äì674.
Das, D., & Smith, N. A. (2009). Paraphrase identification as probabilistic quasi-synchronous
recognition. In Proceedings of the Joint Conference of the 47th Annual Meeting of the
777

Xiao & Zhu

ACL and the 4th International Joint Conference on Natural Language Processing of
the AFNLP (ACL-IJCNLP), pp. 468‚Äì476, Suntec, Singapore.
de Gispert, A., Pino, J., & Byrne, W. (2010). Hierarchical phrase-based translation grammars extracted from alignment posterior probabilities. In Proceedings of the 2010
Conference on Empirical Methods in Natural Language Processing (EMNLP), pp.
545‚Äì554, Cambridge, MA, USA.
Dempster, A., Laird, N., & Rubin, D. (1977). Maximum likelihood from incomplete data via
the em algorithm. Journal of the Royal Statistical Society. Series B (Methodological),
39, 1‚Äì38.
DeNeefe, S., Knight, K., Wang, W., & Marcu, D. (2007). What can syntax-based MT
learn from phrase-based MT?. In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language
Learning (EMNLP-CoNLL), pp. 755‚Äì763, Prague, Czech Republic.
DeNero, J., Gillick, D., Zhang, J., & Klein, D. (2006). Why generative phrase models underperform surface heuristics. In Proceedings on the Workshop on Statistical Machine
Translation (WMT), pp. 31‚Äì38, New York city, USA.
DeNero, J., & Klein, D. (2007). Tailoring word alignments to syntactic machine translation. In Proceedings of the 45th Annual Meeting of the Association of Computational
Linguistics (ACL), pp. 17‚Äì24, Prague, Czech Republic.
Eisner, J. (2003). Learning non-isomorphic tree mappings for machine translation. In The
Companion Volume to the Proceedings of 41st Annual Meeting of the Association for
Computational Linguistics (ACL), pp. 205‚Äì208, Sapporo, Japan.
Ferguson, T. S. (1973). A bayesian analysis of some nonparametric problems. The Annals
of Statistics, 1, 209‚Äì230.
Fossum, V., Knight, K., & Abney, S. (2008). Using syntax to improve word alignment
precision for syntax-based machine translation. In Proceedings of the Third Workshop
on Statistical Machine Translation (WMT), pp. 44‚Äì52, Columbus, Ohio, USA.
Fraser, A., & Marcu, D. (2007). Getting the structure right for word alignment: LEAF. In
Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language
Processing and Computational Natural Language Learning (EMNLP-CoNLL), pp. 51‚Äì
60, Prague, Czech Republic.
Galley, M., Graehl, J., Knight, K., Marcu, D., DeNeefe, S., Wang, W., & Thayer, I. (2006).
Scalable inference and training of context-rich syntactic translation models. In Proceedings of the 21st International Conference on Computational Linguistics and the
44th Annual Meeting of the Association for Computational Linguistics (COLINGACL), pp. 961‚Äì968, Sydney, Australia.
Galley, M., Hopkins, M., Knight, K., & Marcu, D. (2004). What‚Äôs in a translation rule?. In
Susan Dumais, D. M., & Roukos, S. (Eds.), Proceedings of the 2004 Human Language
Technology Conference of the North American Chapter of the Association for Computational Linguistics (HLT:NAACL), pp. 273‚Äì280, Boston, Massachusetts, USA.
778

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

Gildea, D. (2003). Loosely tree-based alignment for machine translation. In Proceedings of
the 41st Annual Meeting of the Association for Computational Linguistics (ACL), pp.
80‚Äì87, Sapporo, Japan.
Groves, D., Hearne, M., & Way, A. (2004). Robust sub-sentential alignment of phrasestructure trees. In Proceedings of the 20th International Conference on Computational
Linguistics (COLING), pp. 1072‚Äì1078, Geneva, Switzerland.
Haghighi, A., Blitzer, J., DeNero, J., & Klein, D. (2009). Better word alignments with
supervised itg models. In Proceedings of the Joint Conference of the 47th Annual
Meeting of the ACL and the 4th International Joint Conference on Natural Language
Processing of the AFNLP (ACL-IJCNLP), pp. 923‚Äì931, Suntec, Singapore.
Huang, L., & Chiang, D. (2005). Better k-best parsing. In Proceedings of the Ninth International Workshop on Parsing Technology (IWPT), pp. 53‚Äì64, Vancouver, British
Columbia, Canada.
Huang, L., Kevin, K., & Joshi, A. (2006). Statistical syntax-directed translation with
extended domain of locality. In Proceedings of the 7th Conference of the Association for
Machine Translation in the Americas (AMTA), pp. 66‚Äì73, Cambridge, Massachusetts,
USA.
Imamura, K. (2001). Hierarchical phrase alignment harmonized with parsing. In Proceedings
of the 6th NLP Pacific Rim Symposium, pp. 377‚Äì384.
Jing, H. (2000). Sentence reduction for automatic text summarization. In Proceedings of
the 6th Applied Natural Language Processing Conference, pp. 310‚Äì315.
Johnson, M. (2007). Why doesn‚Äôt EM find good HMM POS-taggers?. In Proceedings of
the 2007 Joint Conference on Empirical Methods in Natural Language Processing and
Computational Natural Language Learning (EMNLP-CoNLL), pp. 296‚Äì305, Prague,
Czech Republic.
Knuth, D. (1997). The Art of Computer Programming: Fundamental Algorithms. AddisonWesley.
Koehn, P. (2004). Statistical significance tests for machine translation evaluation. In Lin,
D., & Wu, D. (Eds.), Proceedings of the 2004 Conference on Empirical Methods in
Natural Language Processing (EMNLP), pp. 388‚Äì395, Barcelona, Spain.
Koehn, P., Och, F., & Marcu, D. (2003). Statistical phrase-based translation. In Proceedings of the 2003 Human Language Technology Conference of the North American
Chapter of the Association for Computational Linguistics (HLT:NAACL), pp. 48‚Äì54,
Edmonton, Canada.
Levenberg, A., Dyer, C., & Blunsom, P. (2012). A bayesian model for learning scfgs with
discontiguous rules. In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning
(EMNLP-CoNLL), pp. 223‚Äì232, Jeju Island, Korea.
Liu, D., & Gildea, D. (2009). Bayesian learning of phrasal tree-to-string templates. In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing
(EMNLP), pp. 1308‚Äì1317, Singapore.
779

Xiao & Zhu

Liu, Y., Liu, Q., & Lin, S. (2006). Tree-to-string alignment template for statistical machine
translation. In Proceedings of the 21st International Conference on Computational
Linguistics and the 44th Annual Meeting of the Association for Computational Linguistics (COLING-ACL), pp. 609‚Äì616, Sydney, Australia.
Liu, Y., LuÃà, Y., & Liu, Q. (2009a). Improving tree-to-tree translation with packed forests.
In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and
the 4th International Joint Conference on Natural Language Processing of the AFNLP
(ACL-IJCNLP), pp. 558‚Äì566, Suntec, Singapore.
Liu, Y., Xia, T., Xiao, X., & Liu, Q. (2009b). Weighted alignment matrices for statistical
machine translation. In Proceedings of the 2009 Conference on Empirical Methods in
Natural Language Processing (EMNLP), pp. 1017‚Äì1026, Singapore.
Manning, C. D., & SchuÃàtze, H. (1999). Foundations of Statistical Natural Language Processing. The MIT Press.
Marcu, D., Wang, W., Echihabi, A., & Knight, K. (2006). Spmt: Statistical machine translation with syntactified target language phrases. In Proceedings of the 2006 Conference
on Empirical Methods in Natural Language Processing (EMNLP), pp. 44‚Äì52, Sydney,
Australia.
Marcu, D., & Wong, D. (2002). A phrase-based,joint probability model for statistical machine translation. In Proceedings of the 2002 Conference on Empirical Methods in
Natural Language Processing (EMNLP), pp. 133‚Äì139.
Marcus, M. P., Santorini, B., & Marcinkiewicz, M. A. (1993). Building a large annotated
corpus of english: The penn treebank. Computational Linguistics, 19, 313‚Äì330.
May, J., & Knight, K. (2007). Syntactic re-alignment models for machine translation.
In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP-CoNLL),
pp. 360‚Äì368, Prague, Czech Republic.
Mi, H., & Huang, L. (2008). Forest-based translation rule extraction. In Proceedings of the
2008 Conference on Empirical Methods in Natural Language Processing (EMNLP),
pp. 206‚Äì214, Honolulu, Hawaii, USA.
Nakazawa, T., & Kurohashi, S. (2011). Bayesian subtree alignment model based on dependency trees. In Proceedings of 5th International Joint Conference on Natural Language
Processing (IJCNLP), pp. 794‚Äì802, Chiang Mai, Thailand.
Neal, R. (1998). Philosophy of Bayesian Inference. http://www.cs.toronto.edu/‚àºradford/
res-bayes-ex.html.
Och, F. (2003). Minimum error rate training in statistical machine translation. In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics
(ACL), pp. 160‚Äì167, Sapporo, Japan.
Och, F., & Ney, H. (2004). The alignment template approach to statistical machine translation. Computational Linguistics, 30, 417‚Äì449.
Papineni, K., Roukos, S., Ward, T., & Zhu, W. (2002). Bleu: a method for automatic
evaluation of machine translation. In Proceedings of the 40th Annual Meeting of the
780

Unsupervised Sub-tree Alignment for Tree-to-Tree Translation

Association for Computational Linguistics (ACL), pp. 311‚Äì318, Philadelphia, Pennsylvania, USA.
Pauls, A., Klein, D., Chiang, D., & Knight, K. (2010). Unsupervised syntactic alignment
with inversion transduction grammars. In Proceedings of Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association
for Computational Linguistics (HLT:NAACL), pp. 118‚Äì126, Los Angeles, California,
USA.
Riesa, J., Irvine, A., & Marcu, D. (2011). Feature-rich language-independent syntax-based
alignment for statistical machine translation. In Proceedings of the 2011 Conference
on Empirical Methods in Natural Language Processing (EMNLP), pp. 497‚Äì507, Edinburgh, Scotland, UK.
Riley, D., & Gildea, D. (2010). Improving the performance of giza++ using variational
bayes. Tech. rep., University of Rochester.
Smith, D. A., & Eisner, J. (2009). Parser adaptation and projection with quasi-synchronous
grammar features. In Proceedings of the 2009 Conference on Empirical Methods in
Natural Language Processing (EMNLP), pp. 822‚Äì831, Singapore.
Snover, M., Dorr, B., Schwartz, R., Makhoul, J., Micciula, L., & Weischedel, R. (2005).
A Study of Translation Error Rate with Targeted Human Annotation. Tech. rep.
LAMP-TR-126,CS-TR-4755,UMIACS-TR-2005-58, University of Maryland, College
Park and BBN Technologies.
Sun, J., Zhang, M., & Tan, C. L. (2010a). Discriminative induction of sub-tree alignment
using limited labeled data. In Proceedings of the 23rd International Conference on
Computational Linguistics (COLING), pp. 1047‚Äì1055, Beijing, China.
Sun, J., Zhang, M., & Tan, C. L. (2010b). Exploring syntactic structural features for sub-tree
alignment using bilingual tree kernels. In Proceedings of the 48th Annual Meeting of
the Association for Computational Linguistics (ACL), pp. 306‚Äì315, Uppsala, Sweden.
Thayer, I., Ettelaie, E., Knight, K., Marcu, D., Munteanu, D., Och, F., & Tipu, Q. (2004).
The isi/usc mt system. In Proceedings of International Workshop on Spoken Language
Translation 2004, pp. 59‚Äì60.
Tinsley, J., Zhechev, V., Hearne, M., & Way, A. (2007). Robust language pair-independent
sub-tree alignment. In Proceedings of Machine Translation Summit XI, pp. 467‚Äì474,
Copenhagen, Denmark.
Venugopal, A., Zollmann, A., Smith, N. A., & Stephan, V. (2008). Wider pipelines: n-best
alignments and parses in mt training. In Proceedings of the Eighth Conference of the
Association for Machine Translation in the Americas (AMTA), pp. 192‚Äì201.
Vogel, S., Ney, H., & Tillmann, C. (1996). Hmm-based word alignment in statistical translation. In Proceedings of the 16rd International Conference on Computational Linguistics (COLING), pp. 836‚Äì841.
Wang, M., Smith, N. A., & Mitamura, T. (2007a). What is the Jeopardy model? a quasisynchronous grammar for QA. In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language
Learning (EMNLP-CoNLL), pp. 22‚Äì32, Prague, Czech Republic.
781

Xiao & Zhu

Wang, W., Knight, K., & Marcu, D. (2007b). Binarizing syntax trees to improve syntaxbased machine translation accuracy. In Proceedings of the 2007 Joint Conference
on Empirical Methods in Natural Language Processing and Computational Natural
Language Learning (EMNLP-CoNLL), pp. 746‚Äì754, Prague, Czech Republic.
Woodsend, K., & Lapata, M. (2011). Learning to simplify sentences with quasi-synchronous
grammar and integer programming. In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing (EMNLP), pp. 409‚Äì420, Edinburgh,
Scotland, UK.
Xiao, T., Zhu, J., Zhang, H., & Li, Q. (2012). Niutrans: An open source toolkit for phrasebased and syntax-based machine translation. In Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics System Demonstrations (ACL),
pp. 19‚Äì24, Jeju Island, Korea.
Xue, N., Xia, F., Chiou, F.-d., & Palmer, M. (2005). The penn chinese treebank: Phrase
structure annotation of a large corpus. Natural Language Engineering, 11, 207‚Äì238.
Zhang, H., Zhang, M., Li, H., Aw, A., & Tan, C. L. (2009). Forest-based tree sequence to
string translation model. In Proceedings of the Joint Conference of the 47th Annual
Meeting of the ACL and the 4th International Joint Conference on Natural Language
Processing of the AFNLP (ACL-IJCNLP), pp. 172‚Äì180, Suntec, Singapore.
Zhang, M., Jiang, H., Aw, A., Li, H., Tan, C. L., & Li, S. (2008). A tree sequence alignmentbased tree-to-tree translation model. In Proceedings of the 46th Annual Meeting
of the Association for Computational Linguistics: Human Language Techonologies
(ACL:HLT), pp. 559‚Äì567, Columbus, Ohio, USA.

782

Journal of Artificial Intelligence Research 48 (2013) 175-230

Submitted 05/13; published 10/13

An Online Mechanism for Multi-Unit Demand and its
Application to Plug-in Hybrid Electric Vehicle Charging
Valentin Robu
Enrico H. Gerding
Sebastian Stein

vr2@ecs.soton.ac.uk
eg@ecs.soton.ac.uk
ss2@ecs.soton.ac.uk

University of Southampton, SO17 1BJ, Southampton, UK

David C. Parkes

parkes@eecs.harvard.edu

Harvard University, Cambridge, MA 02138, USA

Alex Rogers

acr@ecs.soton.ac.uk

University of Southampton, SO17 1BJ, Southampton, UK

Nicholas R. Jennings

nrj@ecs.soton.ac.uk

University of Southampton, SO17 1BJ, Southampton, UK
King Abdulaziz University, Jeddah, Saudi Arabia

Abstract
We develop an online mechanism for the allocation of an expiring resource to a dynamic agent population. Each agent has a non-increasing marginal valuation function for
the resource, and an upper limit on the number of units that can be allocated in any
period. We propose two versions on a truthful allocation mechanism. Each modifies the
decisions of a greedy online assignment algorithm by sometimes cancelling an allocation of
resources. One version makes this modification immediately upon an allocation decision
while a second waits until the point at which an agent departs the market. Adopting a
prior-free framework, we show that the second approach has better worst-case allocative
efficiency and is more scalable. On the other hand, the first approach (with immediate
cancellation) may be easier in practice because it does not need to reclaim units previously allocated. We consider an application to recharging plug-in hybrid electric vehicles
(PHEVs). Using data from a real-world trial of PHEVs in the UK, we demonstrate higher
system performance than a fixed price system, performance comparable with a standard,
but non-truthful scheduling heuristic, and the ability to support 50% more vehicles at the
same fuel cost than a simple randomized policy.

1. Introduction
Designing mechanisms for allocating scarce resources to self-interested agents is a central
research topic in artificial intelligence (Sandholm, 2002; Engel & Wellman, 2010). The
aim of this work is to devise mechanisms that satisfy certain desirable properties, such
as truthfulness and efficiency. Many settings where such mechanisms can be applied are
characterised by dynamic supply and demand, i.e., agents arrive and leave the market over
time, and the availability of supply also changes over time. This has led the field of online
mechanism design, in which agents are incentivised to report truthfully not only their value
c
2013
AI Access Foundation. All rights reserved.

Robu, Gerding, Stein, Parkes, Rogers & Jennings

for a given allocation, but also the period they are available in the market (Parkes, 2007).
However, to date, most of the existing work in this field assumes that the valuations of
the agents for a certain allocation can be described by a single parameter, the so-called
single-valued domains. Existing approaches that do consider multi-valued domains rely on
access to a probabilistic model of supply and demand and the ability to compute an optimal
allocation policy, which becomes computationally infeasible for realistic settings.
To address these shortcomings, we extend the state of the art by developing a novel
model-free mechanism (i.e., which assumes no knowledge of future demand or supply) for
multi-valued demand. In particular, we consider domains with multi-unit demand and
agents with non-increasing marginal values. In such domains, the first units allocated to an
agent have a higher (or equal) marginal value for this agent compared to any subsequent
units. In the online settings we consider, resources are continuously produced and perishable,
thus the available supply must be allocated in each period. Moreover, the supply available
in each period is not known in advance, but only at the start of that period.
Examples of settings with non-increasing marginal values and perishable resources occur in many real-life settings. One such example is cloud computing, where jobs arrive
over time and perishable computational resources must be allocated to these jobs (Porter,
2004; Stein, Gerding, Rogers, Larson, & Jennings, 2011). In particular, the non-increasing
marginal value model applies naturally to large-scale data processing or optimisation with
any-time computation. In such a setting, the first unit of computation provides a solution
of a certain quality, while subsequent units allow improving this solution, up to a level
when further computation is no longer useful. Hence, the first units are more valuable, as
they already provide a good approximation of the desired solution, while subsequent units
increase this value, but by a marginally non-increasing amount. Another example is online
advertising, where impressions need to be allocated as soon as users visit a webpage (Constantin, Feldman, Muthukrishnan, & Pal, 2009). The non-increasing marginal values also
applies in this setting, since additional exposure of a set of users to the same ad will likely
have a decreasing impact.
A third example, studied extensively in this paper, is the allocation of electricity for the
charging of plug-in hybrid electric vehicles (PHEVs). Similar to pure (non-hybrid) electric
vehicles (pure EVs), these vehicles can be charged directly at an electric charging point. The
difference is that PHEVs have both an electric motor and an internal combustion engine,
and are widely seen as a solution to the problem of range anxiety, i.e., fear that a car will run
out of electricity in the middle of nowhere (Eberle & von Helmolt, 2010).1 However, with
the associated increase in demand for electricity, there are significant concerns within the
electricity distribution industries regarding the widespread use of such vehicles, since the
high charging rates that PHEVs require (up to three times the maximum current demand of
a typical home) could overload local electricity distribution networks at peak times (Fairley,
2010). One approach to address this concern (e.g., adopted by the Pacific Gas and Electric
Company in California) is to introduce time-of-use pricing plans that seek to shift demand.
A more sophisticated approach that takes into account the valuations of self-interested
owners, is to design an online mechanism which schedules access dynamically in order to
prevent network overload. The assumption of decreasing marginal values is justified here
1. Practical examples of PHEVs include versions of cars such as the Toyota Prius and Honda Insight, that
can drive on petrol, but whose batteries can also be charged directly at an electrical charging point.

176

An Online Mechanism for Multi-Unit Demand

because a vehicle owner is more likely to use the first units of electricity, and can always
use the combustion engine as an alternative in case she runs out of electricity (and so the
car can still be used even if it is not fully charged). Against this background, the main
contributions of our work are:
‚Ä¢ We develop a new model-free online mechanism for settings where participating agents
have non-increasing marginal values for units of a perishable good. We adopt a greedy
algorithm coupled with a method to modify the allocation to ensure incentive compatibility. This involves cancelling part of the proposed allocation, and we explore
two ways of performing this cancellation: immediately, i.e., at each time step before a resource is actually allocated, or on departure of an agent from the market
(at which point we must take back allocated items). Both variants are (weakly)
dominant-strategy incentive compatible (DSIC), so that participants have no incentive
to misreport their valuations or arrival-departure dynamics.
‚Ä¢ We analyse the worst-case performance achieved by the mechanisms relative to the
optimal offline allocation, considering both the number of units that need to remain
unallocated in order to achieve incentive compatibility and the total value of the
allocation (i.e., the allocative efficiency). The variation with on-departure cancellation
results in higher allocative efficiency, and is more tractable, but may involve additional
practical challenges. For example, in the PHEV charging domain, this occasionally
requires a vehicle‚Äôs battery to be partially discharged prior to departure.
‚Ä¢ We evaluate the online mechanism through numerical simulations of an abstract domain and the PHEV charging domain, and compare the results to several benchmarks
that assume non-strategic agents, including an optimal offline solution, a scheduling
heuristic and a greedy algorithm without cancellation. The simulations of the PHEV
domain are based on real data from a large-scale trial of (pure) EVs in the UK. Valuations are derived from real monetary savings, by considering factors such as fuel prices,
the distance that the owner expects to travel, and the energy efficiency of the vehicle. The results establish that the mechanism outperforms a fixed-price mechanism
in terms of allocative efficiency in both domains, while performing only slightly worse
than the non-incentive compatible scheduling solutions. In addition, the mechanism
with on-departure cancellation scales easily to hundreds of agents.
We focus on allocative efficiency rather than revenue, as this is appropriate to many
domains of interest. For example, in the PHEV charging domain, it is reasonable that
the goal is to allocate capacity efficiently in order to maximise value to the user base of a
power company, given the significant constraints on charging capacity. Moreover, in many
cloud computing applications (for example, in large-scale scientific computing), the goal is
to allocate capacity to the jobs that are most urgent or important. However, if in practice
the seller wants to guarantee a a minimum revenue from each unit sold, it would be easy
to include a reserve price. If this minimum price is set the same for all units and all time
points, this would not affect the properties of our mechanism.
The remainder of this paper is organised as follows. We first discuss related work
(Section 2), before formally introducing the model (Section 3). In Section 4, we define the
177

Robu, Gerding, Stein, Parkes, Rogers & Jennings

online mechanisms and study their strategic properties. Then, in Section 5, we develop the
worst-case analytical results, followed in Section 6 by a discussion of how to compute the
allocations and payments in practice. Using both real and synthetic input data, we present
the results of the experimental evaluation of our mechanisms in Section 7, and we conclude
in Section 8.

2. Related Work
In this section, we first review existing work on online mechanism design (Section 2.1), and
then provide a background to the PHEV charging application, along with an overview of
previous work that considers this problem (Section 2.2).
2.1 Online Mechanism Design
One line of work in online mechanism design aims to develop online variants of the VickreyClarke-Groves (VCG) mechanism. In this context, Parkes and Singh (2003) consider the
problem of maximising the long-term allocative efficiency of a system of self-interested agents
that arrive and depart dynamically. They model the online mechanism design problem as a
Markov decision process (MDP), whose solutions can be used to implement optimal policies
in a truth-revealing Bayes-Nash equilibrium. In related work, Gershkov and Moldovanu
(2010) examine the allocation of a set of goods to a dynamic population of randomly arriving
buyers. They consider two settings: one in which there is a common deadline for allocating
objects to all buyers, and a second one without a firm deadline, but in which buyers are
impatient, assigning higher value to items allocated sooner.
Unlike both Parkes and Singh (2003), and Gershkov and Moldovanu (2010), the mechanism proposed in this paper is ‚Äúmodel-free‚Äù (which has the advantage that no prior knowledge or distribution is required about the other agents‚Äô types or future allocations), and we
focus on the stronger concept of dominant-strategy incentive compatibility (where reporting truthfully is a best response regardless of what other agents are doing, even if they are
irrational). Such an approach requires fewer assumptions, and makes computing allocations
more tractable compared to VCG-like approaches. This is because VCG generally requires
the allocations to be optimal in expectation (perhaps in a constrained space of policies),
whereas, as we will show, we can use greedy heuristics.
Model-free settings are considered by Hajiaghayi et al. (2005), Parkes (2007) and Porter
(2004). The work of Porter examines the scheduling of jobs on a single machine and proposes
an incentive compatible mechanism for this setting. However, his work assumes a setting
where the results of a job are released to an agent only on completion or by the agent‚Äôs
reported deadline. While this assumption is reasonable for scheduling computational jobs
on a server, it is not suitable for our setting, since the ‚Äúgoods‚Äù (i.e. electricity units) must
be allocated instantly when they become available.
The work which considers an online setting most similar to the one we consider is by
Hajiaghayi et al. (2005). They study the problem of online scheduling of a single, re-usable
resource over a finite time period, in which each agent has an arrival-departure window
when they are active in the market. Agents may misreport both their valuation, as well
as their arrival and departure, subject to an assumption of ‚Äúlimited misreports‚Äù (i.e., no
early arrival or later departure misreports are possible). For this setting, they characterise
178

An Online Mechanism for Multi-Unit Demand

truthful allocation and payment policies, and prove worst-case approximation ratios with
respect to the optimal offline allocation. A key limitation is that the mechanism proposed by
Hajiaghayi et al. concerns single-valued domains, whereas we consider a multi-unit setting
with decreasing marginal values. We show that their mechanism does not directly apply to
the multi-unit case, requiring, in some cases, additional cancellation rules to be applied to
ensure truthfulness.
Multi-unit demand is considered in the work of Lavi and Nisan (2004), who propose an
online auction model in which the mechanism is required to make decisions about each bid
as it is received. They provide a characterisation of incentive compatibility in such domains
in terms of supply curves, a concept which relates closely to our threshold mechanism
characterisation. However, in their online auctions model, the auctioneer must respond
to each bid immediately, before considering other bids. In this response, the mechanism
determines both the quantity to be sold and the price to be paid. This would not be
applicable to the setting presented in this paper, where there is a limit on the number of
perishable units that can be allocated in each time interval. Moreover, the window-based
allocation allows the prices to be determined dynamically, based on the bids observed from
the other agents until departure. In a similar vein, Babaioff, Blumrosen, and Roth (2010)
consider an online auction model where future supply is unknown, and characterise several
subclasses of truthful mechanisms. Their domain is different from ours, as bidders in their
model do not specify multi-dimensional demands and non-increasing marginal values.
Other related work on online mechanism design adapts the consensus algorithm for
online stochastic optimisation proposed by Bent and Van Hentenryck (2004) to a setting
with self-interested agents. In this context, Parkes and Duong (2007), and Constantin and
Parkes (2009) first propose the idea of modifying the decision of an algorithm by cancelling
part of the allocation in order to ensure incentive compatibility. Unlike the present paper,
the setting assumes single-valued private information and the approaches are not applicable
to agents with non-increasing marginal values. Also for single-valued settings and for the
pure EV domain, Stein, Gerding, Robu, and Jennings (2012) propose a model-based online
mechanism that assumes knowledge of future supply and uses pre-commitment to ensure
online allocations are truthful.
2.2 Electric Vehicle Charging
Multi-agent systems and AI techniques are increasingly used to address challenges in the
Smart Grid (e.g., Vytelingum, Voice, Ramchurn, Rogers, & Jennings, 2011; Robu, Kota,
Chalkiadakis, Rogers, & Jennings, 2012), and EV charging is one of the most important
application areas. Work on the automatic scheduling of EV charging typically allows individual vehicle owners to indicate the times at which the car will be available for charging,
enabling automatic scheduling while satisfying the constraints of the distribution network.
In this vein, Clement, Haesen, and Driesen (2009) propose a centralised scheduler, which
makes optimal use of the network capacity when vehicle owners report their expected future
vehicle use to the system. Sundstrom and Binding (2012) tackle the problem of charging
multiple electric vehicles considering distribution grid constraints, formalise the underlying optimisation problem and propose a novel method based on load flow to solve it. But
strategic behaviour remains possible in these approaches; e.g., an owner may indicate an
179

Robu, Gerding, Stein, Parkes, Rogers & Jennings

earlier departure time or further travel distances in order to receive preferential charging.
This can result in a high cognitive load for car owners, and may lead to inefficient schedules
that are not based on actual user requirements, leading to an efficiency loss.
The potential for speculation by strategic agents has been identified as a crucial problem
in other scheduling problems, such as scheduling computational jobs on a cluster (Porter,
2004), scheduling of computation-intensive services on the cloud (Stein et al., 2011) or
market-based scheduling of loads in transportation logistics (Robu, Noot, La PoutreÃÅ, & van
Schijndel, 2011). With the increase in the number of EVs requiring charging, the potential
for manipulation will become an increasingly pressing problem in PHEV scheduling as well.
Other approaches to EV scheduling include the lottery-based solution proposed by Vasirani and Ossowski (2011), in which the decision of whether to charge a vehicle or not is
determined through a lottery system, designed to ensure a level of fairness in the resulting
allocation. Unlike our work, however, the authors do not use game-theoretic principles
to prove that participating vehicles have an incentive to report their preferences truthfully,
thus in their scheme agents may have an incentive to speculate. Moreover, the experimental
analysis reported by Vasirani and Ossowski does not adopt real data to derive EV driving
patterns, charging capacities or network constraints.
Other recent work investigates using grid-integrated electric vehicles (GIVs) to sell power
and storage capacity back to the grid ‚Äì a concept known as vehicle-to-grid (V2G) (c.f.
Kamboj, Kempton, & Decker, 2011). That work is different from ours, as it does not study
the problem of coordinated charging of PHEVs under local network capacity constraints.
In subsequent work to the model in the present paper (which first appeared as Gerding,
Robu, Stein, Parkes, Rogers, & Jennings, 2011, and Robu, Stein, Gerding, Parkes, Rogers,
& Jennings, 2011), we study the problem of charging pure EVs, that must receive a set
amount of charge, otherwise they derive no value from the allocation (Stein et al., 2012). A
second paper studies the problem of two-sided markets, where both PHEVs and charging
stations compete to be matched (Gerding, Stein, Robu, Zhao, & Jennings, 2013). Unlike
the present model, these papers only consider single-minded bidders, and the work of Stein
et al. assumes access to a probabilistic model of the environment.

3. The Model
We consider an online mechanism design setting with discrete time steps, where in each
period, multiple indivisible units of a perishable good are being sold, and each agent requires
multiple units within a certain period. As we will show in Section 3.1, this model can also be
used for continuously available resources, such as electricity and computational resources.
In that case, an allocation decision consists of the amount of resource to be consumed by
each agent over the next period until the following time point.
For convenience, an overview of the notation is provided in Table 1. Formally, let S(t)
denote the supply available at time t. Let I(t) = {1, 2, . . .} denote the set of agents that
are in the market at time t or have already left the market. We do not assume access
to a probabilistic model of future arrivals, departures or future supply beyond the current
time period t. Agents are numbered according to their arrival time. An agent i ‚àà I(t)‚Äôs
type is described by the tuple Œ∏i = hvi , ai , di , ri i ‚àà Œò, where vi is the marginal valuation
vector, ai and di , with di ‚â• ai , are the arrival and departure times (the earliest and latest
180

An Online Mechanism for Multi-Unit Demand

times that the agent is available in the market), ri is the maximum consumption rate (i.e.,
the maximum number of units agent i can consume at any time t), and Œò is the set of
all admissible types. Upon arrival, an agent needs to report a valuation function and a
maximum consumption rate. These two aspects of an agent‚Äôs reported type are required to
remain unchanged while the agent is present, although her departure time can be modified
(it only becomes known to the mechanism on the actual departure).
Each element vi,k of valuation vi is called a marginal valuation, and represents the
agent‚Äôs willingness to pay for the k th unit of the good, given that it has acquired k ‚àí 1 units.
We require:
Assumption 1. Marginal valuations are non-increasing, i.e., ‚àÄi, k : vi,k ‚â• vi,k+1 .
Given this, an agent‚Äôs utility functionPis U (k, x, Œ∏i ) = V (k, Œ∏i ) ‚àí x, where x is the agent‚Äôs
payment to the mechanism, V (k, Œ∏i ) = kj=1 vi,j is the total value derived given its type,
and k is the number of units allocated to this agent between its arrival and departure.
A mechanism asks agents to report their types and, based on this information, decides
on an allocation of the supply and a payment for units received. Since agents can misreport
their type, our aim is to design a mechanism that incentivises the agents to make truthful
reports. We denote the reported type by Œ∏ÃÇi = hvÃÇi , aÃÇi , dÀÜi , rÃÇi i. Our results use a common
assumption in the online mechanism design literature (Hajiaghayi et al., 2005), that agents
cannot report an earlier arrival or a later departure. In addition, we assume that agents
cannot misreport a higher maximum consumption rate.
Assumption 2. Limited Misreports: Agents cannot report an earlier arrival, a later
departure, or a higher maximum consumption rate, i.e., aÃÇi ‚â• ai , dÀÜi ‚â§ di , rÃÇi ‚â§ ri must hold.
In the following, reports that satisfy both Assumption 1 and Assumption 2 are said to be
admissible. Given this assumption, our aim is to develop a mechanism which is dominantstrategy incentive compatible (DSIC), i.e., agents are best off reporting Œ∏ÃÇi = Œ∏i , no matter
what other agents report.
Formally, let Œ∏I = {Œ∏i |i ‚àà I(t)} denote the types of all agents at time t, and Œ∏‚àíi =
{Œ∏j |j ‚àà I(t), j 6= i} the types of all agents except i, and similarly, Œ∏ÃÇI and Œ∏ÃÇ‚àíi denote the
corresponding reported types. Note that, for brevity, we remove the dependence on t in this
hti
notation. Furthermore, ki denotes the endowment (or number of units allocated so far)
hti hti
at the beginning of time t, not including the allocation at time t, and khti = hk1 , k2 , . . .i.
ÀÜ
hd+1i

Furthermore, ki = ki

denotes agent i‚Äôs endowment upon its reported departure.
hti

A mechanism is defined by an allocation policy, œÄi (Œ∏ÃÇI |khti ), i ‚àà I(t), which determines
the number of units allocated to agent i at time t given the current endowment, and a
payment policy, xi (Œ∏ÃÇ‚àíi |ki ), i ‚àà I(t), which calculates the total payment for the allocated
units. The allocation is made online, but the payment only needs be finalised upon the
ht+1i
hti
hti
reported departure of an agent. Note that ki
= ki + œÄi (Œ∏ÃÇI |khti ). We also use œÄi (Œ∏ÃÇi ) =
PdÀÜi
hti
hti
t=aÃÇi œÄi (Œ∏ÃÇI |k ) to denote the total number of units allocated to agent i, given its reported
type.
The aim is to find a mechanism satisfying the following property:
181

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Definition 1. (Dominant-Strategy Incentive Compatible (DSIC)) A mechanism is DSIC if
reporting truthfully, i.e., Œ∏ÃÇi = Œ∏i , is a weakly dominant strategy. Formally, for all agents i,
all admissible Œ∏i , Œ∏ÃÇi ‚àà Œò and for all Œ∏ÃÇ‚àíi :
V (œÄi (Œ∏i ), Œ∏i ) ‚àí xi (Œ∏ÃÇ‚àíi |œÄi (Œ∏i )) ‚â• V (œÄi (Œ∏ÃÇi ), Œ∏i ) ‚àí xi (Œ∏ÃÇ‚àíi |œÄi (Œ∏ÃÇi ))

(1)

3.1 Application to Plug-In Hybrid Electric Vehicle Charging
In applying the model to the PHEV charging domain, agents compete for a limited charging
capacity on behalf of their EV owners within a neighbourhood. We assume that the market
for electricity for PHEV charging is separate from that for regular household consumption.
Given this, the available supply, S(t), for charging the PHEV is the residual supply once
regular household consumption has been removed. The supply can also include electricity
from uncertain sources, such as a shared renewable generator, e.g., a shared neighbourhood
wind turbine or a solar panel installation.
In this scenario, a unit of electricity is defined as the amount of kWh when charging at
the lowest rate during that interval (e.g., if the lowest rate is 6.5 A, then for 230 V and
hourly slots, a unit is 6.5 A ¬∑ 230 V ¬∑ 1 h = 1.495 kWh). Charging points typically allow
for the charging to occur at different rates, and so the maximum consumption rate, ri ,
refers to the maximum charging rate of the charging point given the battery. Since units
are indivisible, this means that the charging rate needs to be a multiple of the lowest rate.
For example, if an agent is allocated 2 units in a single time step, then the charging rate is
twice the lowest charging rate for that time interval. Given the focus on network capacity,
supply is assumed perishable and capacity left unused at time t cannot be allocated later.
The time between arrival, ai , and departure, di , refers to the interval where the vehicle
is available for charging (i.e., it is at home and not being used). However, if the agent
believes that it can benefit from delaying its arrival, then it can wait before plugging the
vehicle into the electricity network. Therefore, the arrival report aÃÇi is the time at which
the owner physically plugs a vehicle into the electricity network, and a misreport consists of
not plugging in on arrival. Similarly, the reported departure, dÀÜi , simply represents the time
when the vehicle is unplugged from the electricity network. Although arrival and departure
are modeled as part of the reported type, in practice these do not need to be communicated
in advance to the mechanism, and are simply observed as they occur, i.e., when the owner
plugs in or unplugs the vehicle.
The limited misreports assumption (Assumption 2) is reasonable in this context, since
agents cannot physically plug in the EV if it is not at home. The requirement that rÃÇi ‚â§ ri is
also natural for PHEV charging. While most electric batteries can be configured to charge
at a slower rate, charging them at a faster rate than the one allowed by the manufacturer
might destroy them.
At the time of arrival, an agent needs to report its marginal valuation vector vÃÇi . There
is a clear interpretation of the marginal valuation because PHEVs can always use petrol
as a substitute for electricity. The marginal value for an additional unit of charge is the
expected money saved by not having to incur the cost of petrol.2 In determining the exact
value, we also need to consider the amount of purchased electricity the owner will use in
2. Note that we implicitly assume that petrol (i.e. gasoline) is always available as a substitute, and that
there are sufficient refueling points so that the vehicle does not run out of petrol.

182

An Online Mechanism for Multi-Unit Demand

v1 = h10, 4i
v2 = h5i

Agent 1
Agent 2
Agent 3

v3 = h2i
S(t1 ) = 1

S(t2 ) = 1

Figure 1: Example showing arrivals, departures, and valuation vectors of 3 agents.
expectation. For example, if she is certain to use the first unit of electricity, her maximum
willingness to pay would be equal to the equivalent cost of petrol. As units become less likely
to be used, their expected value decreases. The value of a marginal unit is the expected
savings compared to using the petrol alternative. In Section 7 we provide a detailed analysis,
confirming the non-increasing marginal value (Assumption 1) for hybrid EVs.

4. The Online Mechanism
In this section, we first present a simple greedy allocation policy, that we show cannot be
coupled with a payment rule to provide truthfulness. Continuing, we combine it with two
variations on the idea of modifying the allocation generated by the greedy rule, and provide
a theoretical analysis of their properties.
4.1 Greedy Allocation Policy
hti

Let the vector vÃÇi

= hvÃÇi,khti +1 , . . . , vÃÇi,khti +rÃÇ i denote agent i‚Äôs reported marginal values for
i

i

i

hti

the next rÃÇi units, given its endowment ki at time t. This is the agent‚Äôs reported willingness
hti
to pay for any units available at time t and, in what follows, we refer to vector vÃÇi as the
active (reported) marginal valuations at time t. Furthermore, let V hti denote the multiset
of such values from all agents that are present in the market at time t, i.e., from all i ‚àà I(t)
such that aÃÇi ‚â§ t ‚â§ dÀÜi . Next, we define a set operator maxhki V to return the highest k
elements of multiset V (or, if |V| < k, to return V). Then, the greedy allocation policy is:
Definition 2 (Greedy Allocation Policy). At each time step t, allocate the S(t) units so
that every agent receives one unit of the good for each of its active marginal valuations
included in maxhS(t)i V hti .
We ignore issues with tie breaking throughout this paper to simplify the exposition.
We note, however, that all results presented hold when implementing either a random tie
breaking rule, or a ‚Äúfirst come, first served‚Äù rule, that breaks ties in favour of the agent
that arrived in the market first.
To provide an example for the greedy allocation, consider the active marginal valuations
given in Table 2. In this case, the multiset of active marginal valuations consists of V hti =
h7, 6i ‚à™ h10, 6, 6i ‚à™ h8i = h7, 6, 10, 6, 6, 8i (in no particular order). Then, if S(t) = 3, the
highest active marginal values it will allocate the resources to are the agents with marginal
values 10, 8, and 7. Thus, in this example, each agent will receive 1 unit.
In order to show why greedy is not always DSIC, consider the example illustrated in
Figure 1, involving 2 time steps and 3 agents. Suppose that supply is S(t) = 1 at each time
183

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Supply, Agents and Preferences (Section 3)
Supply of perishable units at time t
The set of agents who have arrived so far at time t
Type of agent i
Marginal valuation vector, where vi,k is the value for the k th unit
Arrival time, departure time, and maximum consumption rate
Set of all admissible types, i.e., subject to Assumptions 1 and 2
The types of all agents i ‚àà I(t)

S(t)
I(t) = {1, 2, ...}
Œ∏i = hvi , ai , di , ri i
vi = hvi,1 , vi,2 , ...i
a i , d i , ri
Œò
Œ∏I = {Œ∏i |i ‚àà I(t)}
Œ∏‚àíi = {Œ∏j |j ‚àà I(t),
j 6= i}
Œ∏ÃÇ, Œ∏ÃÇI , Œ∏ÃÇ‚àíi
P
V (k, Œ∏i ) = kj=1 vi,j
U (k, x, Œ∏i ) =
V (k, Œ∏i ) ‚àí x
hti
ki
hti hti
khti = hk1 , k2 , ...i
ÀÜ
hd+1i
ki = ki

The types of all agents j ‚àà I(t) except i
Reported types
Total value given k units are allocated to i between ai and di
Agent utility, where x is the payment to the mechanism
General Mechanisms (Section 3)
Agent i‚Äôs endowment at the beginning of time t
The endowment of all agents i ‚àà I(t) at the beginning of time t

Agent i‚Äôs endowment on reported departure
Allocation policy, i.e., number of units allocated to i at time t
hti
œÄi (Œ∏ÃÇI |khti )
given all agents‚Äô reports Œ∏ÃÇI and current endowments khti
Payment policy, i.e., agent i‚Äôs payment given the reported types
xi (Œ∏ÃÇ‚àíi |ki )
of other agents, and agent i‚Äôs endowment on departure.
Greedy Policy and DSIC Mechanism (Sections 4 and 4.2)
hti
vÃÇi =
Agent i‚Äôs reported active marginal values
hvÃÇi,khti +1 , ..., vÃÇi,khti +rÃÇ i
i

i

i

V‚àíi‚à™0

Multiset of reported active marginal values (where the union operator is used as a multiset operator throughout the paper)
Active reported marginal values if agent i would never have been
present in the market
hti
Zeros are added to this multiset to ensure that |V‚àíi‚à™0 | ‚â• S(t)

max V, min V

Returns the highest respectively lowest k elements of multiset V

V hti =

S

hti
i‚ààI(t) vÃÇi

hti

V‚àíi
hti

hki

hki

 Externality imposed by agent i on others, i.e., the marginal valuations of those that are missing out due to agent i being allocated
= min max
hri i
hS(t)i
min(ri , S(t)) units at time t
Ô£´
Ô£∂
hti
Vector of marginal payments at time t, where pi,k is the price that
t
[
‚Ä≤
hti
ht i
pi = incr Ô£≠
Ei Ô£∏ agent i is charged for the k th unit, and the operator incr orders
t‚Ä≤ =aÃÇi
elements from a multiset in increasing order

hti
Ei



hti
V‚àíi‚à™0

hdÀÜi i

pi = pi

Marginal payment vector on reported departure of agent i

Table 1: Main notation with references to sections where it is first introduced.
184

An Online Mechanism for Multi-Unit Demand

agent (i)
1
2
3

rÃÇi
2
3
1

vÃÇi
h8, 7, 6, 5i
h10, 6, 6, 4, 4i
h9, 8, 8, 7i

hti

ki
1
0
2

hti

vÃÇi
h7, 6i
h10, 6, 6i
h8i
hti

Table 2: Example of three agents‚Äô active marginal valuations vÃÇi , given their marginal
hti
valuations vÃÇi , endowments ki , and maximum consumption rates rÃÇi .

step and ri = 1 for all agents i. Assuming truthful agents, greedy would then allocate both
units to agent 1, because agent 1 has the highest active marginal value at both time steps
h1i
h1i
h2i
h2i
(vÃÇ1 = h10i > vÃÇ2 = h5i, and vÃÇ1 = h4i > vÃÇ3 = h2i).
Now, consider the question of finding a payment policy that makes the greedy allocation
policy DSIC. How much should agent 1 pay? To answer this, note that the payment for the
unit allocated at time t = 1 has to be at least 5. Otherwise, if agent 1 were present in the
market only at time t = 1 and had a valuation v1,1 ‚àà (5 ‚àí «´, 5), it would have an incentive
to misreport vÃÇ1,1 > 5 and still win. Similarly, the payment for the unit allocated at time
t = 2 has to be at least 2. Thus, the minimum payment of agent 1 if allocated two units is
x1 (Œ∏ÃÇ|œÄ1 = 2) = 7.
On the other hand, how much should agent 1 pay if it were allocated only one unit
instead? We argue no more than 2. Suppose, for contradiction, that the payment were set
at some larger value x1 (Œ∏ÃÇ|œÄ1 = 1) = 2 + «´ (where «´ > 0). Then if the agent‚Äôs first marginal
value v1,1 were instead 2 < v1,1 < 2 + «´ (with remaining marginal values zero), then it
would win in period 2, but it would pay 2 + «´ and hence have negative utility. However,
if x1 (Œ∏ÃÇ|œÄ1 = 2) ‚â• 7 and x1 (Œ∏ÃÇ|œÄ1 = 1) ‚â§ 2, then agent 1 wants only one unit, not two,
as allocated by the greedy mechanism (its utility for one unit is greater than for two, as
10 ‚àí 2 > 10 + 4 ‚àí 7). Hence, the greedy allocation policy cannot be made DSIC by setting
payments.
The above example shows that the problem is not with a particular payment policy, but
is intrinsic to the greedy allocation policy. In particular, the problem is that the allocation
policy does not satisfy the necessary property of W-MON (Bikhchandani, Chatterji, Lavi,
Mu‚Äôalem, Nisan, & Sen, 2006):
Definition 3 (Weak Monotonicity (W-MON)). An allocation policy œÄ, is W-MON if, for
every i ‚àà I(t), Œ∏i = hvi , ai , di , ri i, Œ∏i‚Ä≤ = hvi‚Ä≤ , a‚Ä≤i , d‚Ä≤i , ri‚Ä≤ i ‚àà Œò, Œ∏‚àíi ‚àà ŒòN ‚àí1 , where Œò is the set of
all types subject to non-increasing marginal valuations, the following equation holds:
V (œÄi (Œ∏i‚Ä≤ ), Œ∏i‚Ä≤ ) ‚àí V (œÄi (Œ∏i ), Œ∏i‚Ä≤ ) ‚â• V (œÄi (Œ∏i‚Ä≤ ), Œ∏i ) ‚àí V (œÄi (Œ∏i ), Œ∏i )

(2)

In words, if changing an agent i‚Äôs type (while keeping the types of other agents fixed)
from a type Œ∏i to another type Œ∏i‚Ä≤ changes the allocation of i from œÄi (Œ∏i ) to œÄi (Œ∏i‚Ä≤ ), then
the resulting difference in utilities of the new and original outcomes evaluated at the new
type of agent i (denoted by function V (¬∑, Œ∏i‚Ä≤ )) must be no less than this difference in utilities
185

Robu, Gerding, Stein, Parkes, Rogers & Jennings

evaluated at the original type of agent i (denoted by function V (¬∑, Œ∏i )). Using this notion
we will now demonstrate that the greedy allocation policy is not DSIC in our setting.
Theorem 1. The greedy allocation policy is not DSIC in multi-valued domains with nonincreasing marginal valuations.
Proof. From Bikhchandani et al. (2006, Lemma 1) we know that a necessary condition for
any DSIC allocation policy is that it should satisfy W-MON (see Definition 3). If Equation 2
is true, then it can be shown that the following must hold:
œÄi (Œ∏i‚Ä≤ )

if

œÄi (Œ∏i‚Ä≤ )

> œÄi (Œ∏i ) then

X

œÄi (Œ∏i‚Ä≤ )
‚Ä≤
vi,k

‚â•

k=œÄi (Œ∏i )+1

X

vi,k

(3)

k=œÄi (Œ∏i )+1

In words, more units should only be allocated to one type compared to another type, if
that type also has higher marginal values for those units. Consider again the example in
Figure 1, where we look at the W-MON condition for agent 1 by varying its type. We keep
the arrival and departure fixed, i.e., a‚Ä≤i = ai , d‚Ä≤i = di . Suppose that v1‚Ä≤ = h10, 4i as in the
example, but v1 = h4 + «´, 4 + «´i, where 0 < «´ < 1. Note that œÄ1 (Œ∏1‚Ä≤ ) = 2, and œÄ(Œ∏1 ) = 1
(agent 1 is not allocated the unit in the first time step if its type were changed from Œ∏1‚Ä≤ to
Œ∏1 ). Since Œ∏1‚Ä≤ is allocated an additional unit (compared to Œ∏1 ), W-MON requires that Œ∏1‚Ä≤
‚Ä≤ < v , thereby
values the second unit higher or equal to Œ∏1 . However, we can see that v1,2
1,2
violating Equation 3. This example demonstrates that the greedy allocation policy is not
W-MON, and therefore not DSIC.
4.2 Achieving Truthfulness Through Cancellation
Addressing the problem with W-MON, we consider two types of modifications to the allocation decision of the greedy policy, both designed to achieve monotonicity. The first
is immediate cancellation, where units are simply left unallocated, i.e., none of the agents
receive the unit, even if there is a demand. The second is on-departure cancellation, where
units are initially allocated using the greedy approach, but then on departure of the agent,
any overallocated units are removed.3
The model with on-departure cancellation is more efficient because it generally requires
fewer cancellations, and is also more computationally efficient in calculating the payments
and allocations. However, depending on the domain, it may not always be possible to
remove units once they are allocated.
In the following, we detail the allocation policies and explain how payments are computed. We then give an example that shows the difference between the two mechanisms
and, lastly, we provide an analysis of the economic properties of the mechanisms.
In defining the allocation policies, we show how we can compute an agent‚Äôs marginal
payment vector, which determines, for each additional unit, the price the agent would need
to pay for that unit. These marginal payments are then used to determine both when to
cancel an allocation, as well as an agent‚Äôs total payment for a given allocation.
3. In the PHEV setting, this corresponds to first charging the battery and later discharging any overallocated
units.

186

An Online Mechanism for Multi-Unit Demand

A necessary condition for truthfulness is that payments cannot depend on an agent‚Äôs
report except on the effect it has on the allocation; e.g., see the work of Nisan, Roughgarden,
hti
Tardos, and Vazirani (2007, Proposition 9.27). To this end, let V‚àíi denote the multiset of
the active marginal valuations of all agents in the market at time t, if agent i were removed
and the market were rerun from aÃÇi ‚â§ t onwards.
hti
We cannot simply derive V‚àíi from V hti since removing agent i could affect the endowments of the other agents at earlier time steps. For example, for the setting from Table 2,
both agents 1 and 3 have endowments at time t and therefore removing either of these agents
is likely to increase the endowments of the other agents, thereby changing the dynamics of
hti
the entire market. To ensure that V‚àíi is truly independent of agent i, the market needs
to be re-run from the very point when agent i first entered the market, and this process
needs to be repeated for each agent i ‚àà I(t) such that aÃÇi ‚â§ t ‚â§ dÀÜi , whose payments we are
computing.
hti
In case |V‚àíi | < S(t), we furthermore add a number of zero-valued bids and refer to this
hti

hti

enlarged set as V‚àíi‚à™0 , to ensure that |V‚àíi‚à™0 | ‚â• S(t). Next, similar to the operator maxhki ,
we define the set operator minhki V to return the lowest k elements of multiset V (or, if
|V| < k, to return V). We define the externality that agent i would impose on other agents
if it won min(ri , S(t)) out of S(t) units at time t as:


hti
hti
Ei = min max V‚àíi‚à™0
hri i

hS(t)i

hti

hti

Note that the cardinality of Ei is equal to |Ei | = min(ri , S(t)). Intuitively, the multiset
hti
Ei contains the marginal values from other agents that would lose out if agent i were to
hti
win ri units at time t. For example, let V‚àí1 = h1, 4, 5, 7, 9, 10i (sorted for convenience),
hti

S(t) = 4, and r1 = 2. Then, E1 = h5, 7i.
If an agent were active for only a single time step, then the externality would specify the
payment for each unit. That is, using the same example, if agent 1 were allocated a single
unit by the mechanism, its payment would be 5. On the other hand, if it were allocated 2
units, its payment would be 5 + 7 = 12. The intuition here is the same as in the regular
Vickrey-Clarke-Groves (VCG) mechanism, because the total payment corresponds to the
sum of the externalities.
To compute the overall payments online, we need to combine these externalities across
all time steps in the agent‚Äôs active period up to current time t. To do this, we define an
hti
ordered vector of marginal payments, pi , as follows:

S
ht‚Ä≤ i
hti
t
E
,
pi = incr
‚Ä≤
t =aÃÇi i
where ‚Äòincr‚Äô is an operator that orders elements from a multiset in increasing order, and we
use the union symbol to denote the union of multisets (and so the same element can appear
multiple times).
hti
Now, pi,k is the price that agent i is charged for the k th unit of the good. Intuitively, this
is the minimum valuation that the agent could report for winning this unit by time t. These
prices are adjusted in each time step. In particular, since the vector is in increasing order,
187

Robu, Gerding, Stein, Parkes, Rogers & Jennings

hti

and elements are only added as time increases, pi,k either stays the same or decreases for a
given k, but can never increase. In the following, we use pi,k to denote agent i‚Äôs marginal
payment of the k th unit at time dÀÜi .
Given this, the decision and payment policies are defined as follows:
‚Ä¢ Allocation Policy The decision to allocate consists of two stages:
Stage 1 At each time step t, pre-allocate using the greedy allocation policy (see
Definition 2).
Stage 2 We consider two variations of how to decide to cancel the pre-allocation:
‚Äì Immediate Cancellation (IM). Leave any unit unallocated whenever the marginal payment at time t for this unit is greater than the marginal value, i.e.,
whenever:
hti

hti

hti

hti

vÃÇi,k < pi,k for ki < k ‚â§ ki + œÄi

‚Äì On-Departure Cancellation (OD). For each departing agent, cancel the allocation of any unit k ‚â§ ki where vÃÇi,k < pi,k .
‚Ä¢ Payment Policy Payment always occurs on reported departure. Given that ki units
are allocated to agent i, the payment collected from i is:
xi (Œ∏ÃÇ‚àíi |ki ) =

Xki

k=1

pi,k

(4)

In the following, we refer to our two mechanisms with immediate and on-departure
cancellation by IM and OD respectively, and the corresponding allocation policies by œÄ im
and œÄ od . If no distinction between the two mechanisms is made, œÄ is used.
The payment policy mirrors the allocation policy. For example, if immediate cancellation
hti
is used, then for each agent i and for all times t, the values of the pi vector are computed
by re-running the market, in the absence of agent i using immediate cancellation, based on
the reports of the other agents. Conversely, if on-departure cancellation is used, the same
policy should be used in computing the pi prices.
4.3 Examples
To demonstrate how the two mechanisms work, we present two examples. The aim of the
first example is to show the difference between immediate and on-departure cancellation.
The second example illustrates the effect of changing the maximum consumption rates. The
example shows that in specific instances, increasing an agent‚Äôs maximum consumption rate
can actually increase the number of cancellations.
4.3.1 Example 1
The first example extends the setting shown in Figure 1 to include a third time step, t = 3.
Both agents 1 and 3 remain in the market at t = 3 (i.e., d1 = d3 = 3) and no new agents
arrive. Furthermore, S(t) = 1 in t ‚àà {1, 2, 3}, and so there are now three units to be
allocated in total. As before, we suppose that ri = 1 for all agents. Table 3 shows the
188

An Online Mechanism for Multi-Unit Demand

t=1

t=2

t=3
IM

t=3
OD

agent 1:
a1 = 1, d1 = 3,
v1 = h10, 4i, r1 = 1
h1i
h1i
k1 = 0, v1 = h10i
h1i
h1i
V‚àí1 = E1 = h5i
h1i
p1 = h5i
imh1i
odh1i
œÄ1
= œÄ1
=1
h2i
h1i
k1 = 1, v1 = h4i
h2i
h2i
V‚àí1 = E1 = h2i
h2i
p1 = h2, 5i
imh2i
œÄ1
=0
odh2i
œÄ1
=1
h3i
h1i
k1 = 1, v1 = h4i
h3i
h3i
V‚àí1‚à™0 = E1 = h0i
h3i
p1 = h0, 2, 5i
imh3i
œÄ1
=1
h3i

agent 2:
a2 = 1, d2 = 1,
v2 = h5i, r2 = 1
h1i
h1i
k2 = 0, v2 = h5i
h1i
h1i
V‚àí2 = E2 = h10i
h1i
p2 = h10i
imh1i
odh1i
œÄ2
= œÄ2
=0

agent 3:
a3 = 2, d3 = 3,
v3 = h2i, r3 = 1

h2i

h1i

h3i

h1i

h3i

h1i

k3 = 0, v3 = h2i
h2i
h2i
V‚àí3 = E3 = h4i
h2i
p3 = h4i
imh2i
odh2i
œÄ3
= œÄ3
=0
k3 = 0, v3 = h2i
h3i
h3i
V‚àí3 = E3 = h4i
h3i
p3 = h4, 4i
imh3i
œÄ3
=0

h1i

k1 = 2, v3 = hi
h3i
h3i
V‚àí1‚à™0 = E1 = h0i
h3i
p1 = h0, 2, 5i
odh3i
œÄ1
=0

k3 = 0, v3 = h2i
h3i
h3i
V‚àí3‚à™0 = E3 = h0i
h3i
p3 = h0, 4i
odh3i
œÄ3
=1

Table 3: Example run of the mechanism with 3 agents and 3 time steps for the IM and
OD mechanisms. Grey cells indicate different values for IM and OD policies.
hti

hti

hti

endowments ki , the active marginal valuations V‚àíi , the externalities, Ei , the marginal
hti

hti

payments pi , and the allocation decisions œÄi at different time steps.
We start by considering the allocations and payments using immediate cancellation.
At time t = 1, Stage 1 of the mechanism pre-allocates the unit to agent 1, and since
h1i
v1,1 = 10 ‚â• p1,1 = 5, this pre-allocation is not cancelled in the second stage. At time
t = 2, the unit again gets pre-allocated to agent 1 since its active marginal value is greater
h2i
h2i
h2i
than that of agent 3, i.e., v1 = h4i > v3 = h2i. However, V‚àí1 = h2i is inserted at the
h2i

h2i

beginning of the p1 vector, and as a result v1,2 = 4 < p1,2 = 5 (at these prices, agent
1 prefers to be allocated one unit instead of two). Consequently, this pre-allocation gets
cancelled and the unit goes to neither of the agents.
h3i
At time t = 3, the active marginal value of agent 1 is still v1 = h4i, since its endowment
is unchanged, and since agent 1 still has the highest active marginal value, it is again preallocated the unit. To calculate the marginal payment of agent 1, recall that the allocation
policy needs to be recomputed with agent 1 entirely removed from the market. In that case
agent 3 would have been allocated a unit at time t = 2, and thus at time t = 3 the active
h3i
marginal value of this agent is 0. Thus, the value of 0 is inserted in the p1 vector. At
h3i
t = 3, however, now v1,2 = 4 ‚â• p1,2 = 2, and therefore the pre-allocation is not cancelled.
An interesting exercise is to see what happens to the marginal payment vector of agent
3 at t = 3. To calculate this, we have to remove agent 3 and rerun the market from t = 2. In
189

Robu, Gerding, Stein, Parkes, Rogers & Jennings

agent1
agent2
agent3

v1 = h10, 8, 3i
v2 = h7i
v3 = h1i
S(t1 ) = 2

S(t2 ) = 1

Figure 2: Example showing arrivals, departures, and valuation vectors of 3 agents.

h2i

this case, at time t = 2, the marginal payment vector of agent 1 becomes p1 = h0, 5i. Since
h2i
the marginal payment for the second unit, p1,2 , remains unchanged, the pre-allocation is
still cancelled! Therefore, even when agent 3 is not in the market, the second unit remains
h3i
unallocated, and agent 1‚Äôs active marginal value at t = 3 is again v1 = h4i, and so
h3i
h3i
V‚àí3 = h4i. Given this, agent 3‚Äôs marginal payments become p3 = h4, 4i. Note that the
marginal payment for the first unit (4) is higher than the marginal value for this unit (2),
and this is consistent with the allocation. Otherwise, if the marginal payment had been
lower, agent 3 would have an incentive to overreport and ‚Äòwin‚Äô the unit at t = 3.
So, in case of immediate cancellation, two out of three units are allocated to agent 1,
h3i
h3i
and that agent pays x1 = p1,1 + p1,2 = 0 + 2 = 2. The third unit is not allocated to any
agent. Note that this unit cannot go to agent 3, because the payment would have been
h3i
p3,1 = 4, resulting in a negative utility for agent 3.
Now consider the same setting but with on-departure cancellation. The first two time
steps are as before, except that there is no cancellation at t = 2 (since this will be done on
departure if needed). This changes the endowment state of agent 1 at t = 3, and therefore
h3i
the active marginal value of agent 1 at t = 3 is equal to v1 = hi, and this is the same if
agent 3 is removed from the market. Therefore, the unit is pre-allocated to agent 3, and the
h3i
h3i
payment for this unit is p3,1 = p3,1 = 0. The vector p1 remains unchanged compared to the
immediate case. At this point, there is no longer a need to cancel one of the pre-allocations
of agent 1, since it has received k = 2 units, the same allocation as with the immediate
cancellation policy, and note that v1,2 > p1,2 .
No pre-allocations are cancelled with the on-departure policy, and so this policy is more
efficient. As we will show in the remainder of the paper, the on-departure policy never
cancels more, and typically cancels fewer pre-allocations compared to the immediate one.
Still, it is possible to construct examples where, in the worst case, half of the pre-allocations
need to be cancelled, even with the on-departure policy.
Furthermore, note that some units are given away for free (i.e., the payment for these
units is zero). This is a standard problem with auctions if there is insufficient competition,
and can be trivially resolved by e.g. introducing a minimum price or reserve price for each
unit of the good. However, this will reduce efficiency since units will remain unallocated
if they fall below the reserve price. We do not consider reserve prices in this paper, but
the economic properties of the mechanism continue to hold with reserve prices, as long as
the reserve prices are the same for all time points (otherwise there could be an incentive to
misreport the arrival time).
190

An Online Mechanism for Multi-Unit Demand

4.3.2 Example 2
The next example, depicted in Figure 2, again shows a setting with two time steps and three
agents, but with different preferences and now the supply in the first step is two units, and
we change the maximum consumption rate of agent 1. We consider two cases:
The maximum consumption rate of agent 1 is r1 = 1.4 In this case, at most one marginal
value is taken from each agent per time step. At time t1 , marginal valuations v1,1 = 10 of
agent 1, and v2,1 = 7 of agent 2 are pre-allocated, while at time t2 , marginal value v1,2 = 8
of agent 1 is pre-allocated. The prices charged to agent 1 are: p1 = h0, 1i, because without
agent 1 in the market, there would be a free, spare unit at time t1 and the available unit at
t2 would sell to agent 3 for 1. No pre-allocation gets cancelled in this case, and the actual
allocation is equivalent to the optimal offline allocation.
The maximum consumption rate of agent 1 is r1 = 2. Then, at time t1 , the greedy
policy described above allocates the two marginal values of agent 1: v1,2 = 10 and v1,2 = 8,
as they are both higher than v2,1 = 7, and agent 2 drops out of the market. At time t2 , the
unit is again pre-allocated to agent 1 (due to the marginal value of 3 being higher than 1).
However, now the marginal payments vector required from agent 1 is p1 = h0, 1, 7i, while
the marginal valuations are v1 = h10, 8, 3i. Given the prices, agent 1 prefers two units to
three (because 10 + 8 ‚àí 1 > 10 + 8 + 3 ‚àí 1 ‚àí 7), so the third is cancelled. The overall
efficiency is lower, as the pre-allocation of the third available unit is now cancelled, whereas
with r1 = 1 it was allocated to agent 2. Note, however, that although the efficiency is much
lower, agent 1 has an incentive to declare its true maximum consumption rate r1 = 2 as, in
this case, its payment does not change.
4.4 Establishing Truthfulness
In this section we prove that the above mechanisms are DSIC under the assumptions of
non-increasing marginal valuations (Assumption 1) and limited misreports (Assumption 2).
In the following, we will first establish DSIC with respect to valuations only, and prove
truthful reporting of arrival and departure times separately. In more detail, we proceed in
the following 3 stages:
(i) We define the concept of a threshold policy, and show that, when coupled with an
appropriate payment policy, and given any admissible pair haÃÇi , dÀÜi i, if an allocation policy is
a threshold policy, then the mechanism is DSIC with respect to the valuations (Lemma 1).
(ii) We show that our allocation policy is a threshold policy (Lemma 2).
(iii) We show that if agents truthfully report their valuations, reporting aÃÇi = ai , dÀÜi = di ,
and rÃÇi = ri is a weakly dominant strategy (Lemma 3).
These results are combined in Theorem 2 to show that our mechanism is DSIC.
Definition 4 (Threshold Policy). An allocation policy œÄ is a threshold policy if, for a given
agent i with fixed haÃÇi , dÀÜi , rÃÇi i and Œ∏ÃÇ‚àíi , there exists a marginally non-decreasing threshold
vector œÑ , independent from the report vÃÇi made by agent i, such that following holds: ‚àÄk, vÃÇi :
œÄi (Œ∏ÃÇi , Œ∏ÃÇ‚àíi ) ‚â• k if and only if vÃÇi,k ‚â• œÑk .
4. Note that the other two agents only desire one unit, so their maximum consumption rate is irrelevant in
this example.

191

Robu, Gerding, Stein, Parkes, Rogers & Jennings

In other words, a threshold policy has a potentially different threshold œÑk for each k,
such that agent i will receive at least k units if and only if its reported valuation for the k th
item is at least œÑk .
A threshold policy satisfies W-MON, which is sufficient for DSIC in this domain since
we have bounded agent valuations and the domain is completely ordered, meaning that all
payoff types agree on the same weak preference ordering on all allocations (i.e., more is
always weakly better than less), and indifference to the way goods are allocated to other
agents (Bikhchandani et al., 2006). We show that our allocation policy has the threshold property, and thus satisfies W-MON, and that it also handles misreports of arrivals,
departures and maximum charging rates.
Importantly, the vector œÑ has to be non-decreasing, i.e., œÑk+1 ‚â• œÑk , and should be
independent of the reported valuation vector vÃÇi . Both of these properties are satisfied by
the pi vector, and we will use this to show that our mechanism is a threshold policy.
First, however, we show that a threshold policy with appropriate payments is DSIC with
respect to the valuations:
Lemma 1. Fixing admissible haÃÇj , dÀÜj , rÃÇj i for all j ‚àà I and fixing Œ∏ÃÇ‚àíi , if œÄ is a threshold
policy coupled with a payment policy:
xi (Œ∏ÃÇi , Œ∏ÃÇ‚àíi ) =

PœÄi (Œ∏ÃÇi ,Œ∏ÃÇ‚àíi )
k=1

œÑk ,

then if vi is marginally non-increasing, reporting vi truthfully is a weakly dominant strategy.
Proof. Agent i‚Äôs utility can be rewritten as:
PœÄi (Œ∏ÃÇi ,Œ∏ÃÇ‚àíi )
ui (Œ∏ÃÇi ; Œ∏i ) = k=1
(vi,k ‚àí œÑk )

Since œÑ is independent of vÃÇi , agent i can only potentially benefit by changing the allocation,
œÄi (Œ∏ÃÇi , Œ∏ÃÇ‚àíi ). Since the values of œÑk+1 ‚â• œÑk (non-decreasing threshold vector) and vi,k+1 ‚â§ vi,k
(non-increasing marginal values), by Definition 4 we have vi,k ‚àí œÑk ‚â• 0 for any k ‚â§ œÄi (Œ∏i )
and vi,k ‚àí œÑk ‚â• 0 for any k > œÄi (Œ∏i ). Suppose that, by misreporting agent i is allocated
œÄi (Œ∏ÃÇi ) > œÄi (Œ∏i ), then ui (Œ∏ÃÇi ; Œ∏i ) < ui (Œ∏i ; Œ∏i ) since:
PœÄi (Œ∏ÃÇi ,Œ∏ÃÇ‚àíi )

k=œÄi (Œ∏i ,Œ∏ÃÇ‚àíi )+1

(vi,k ‚àí œÑk ) < 0

Similarly, misreporting such that œÄi (Œ∏ÃÇi , Œ∏ÃÇ‚àíi ) < œÄi (Œ∏i , Œ∏ÃÇ‚àíi ) results in ui (Œ∏ÃÇi ; Œ∏i ) < ui (Œ∏i ; Œ∏i )
since:
PœÄi (Œ∏i ,Œ∏ÃÇ‚àíi )
(vi,k ‚àí œÑk ) ‚â• 0
k=œÄi (Œ∏ÃÇi ,Œ∏ÃÇ‚àíi )+1

If misreporting has no effect on the allocation, the utility remains the same. Therefore,
there is no incentive for agent i to misreport its valuations.

Note that the greedy allocation policy is not a threshold policy. Indeed, we have shown
already that it does not satisfy W-MON. The next lemma shows that the threshold condition
holds if we cancel some allocations according to our policies, and if we set the threshold
values to œÑk = pi,k .
192

An Online Mechanism for Multi-Unit Demand

Lemma 2. Given non-increasing marginal valuations, the allocation policy œÄ in Section 4.2
is (for either cancellation policy) a threshold policy where œÑk = pi,k .
hti

hti

Proof. First, from the definition of vector pi and pi from Section 4.2, the values of pi are
independent of the reports vÃÇi made by agent i. This is because each of its component values
haÃÇ i
hti
V‚àíii , . . . , V‚àíi are computed based only on the reports of the other agents, by first removing
hti

agent i from the market. Note that pi and pi are also affected by the reported arrival
time, departure time, and maximum consumption rate of agent i, but in this lemma we
are only concerned with truthful reporting of the agent‚Äôs valuations, and take the reported
arrival and deadline as given, and do not require these to be truthful at this point.
Second, we need to show two inequalities, thus the proof is done in two parts. Part 1:
Whenever vi,k ‚â• pi,k , œÄi allocates at least k units to agent i. Part 2: Whenever vi,k < pi,k ,
œÄi allocates strictly fewer than k units to agent i.
Part 1: Let vi,k ‚â• pi,k . Suppose that agent i has uniform marginal values, vi,k , for the
hti
first k units (i.e., vi,1 = vi,2 = . . . = vi,k ). Note that externality Ei contains the marginal
values at time t that agent i will displace when winning up to ri units of the good in time
step t (that is, these marginal values will reappear in the next time step if the same agents
remain in the market). Given this, as long as agent i has fewer than k units then, in Stage
1 of the mechanism, and at each time step that agent i is in the market, it will win exactly
hti
those units where the marginal values in Ei are less than vi,k , i.e. it will win all units
hti
hti
1 ‚â§ j ‚â§ |Ei | where vi,k ‚â• Ei,j (ignoring tie breaking). Note that the externalities (and
thus the marginal payments) are calculated by removing agent i from the market from the
very first time it entered, and so do not contain any displaced marginal values. However,
even when, by winning a unit, agent i displaces the losing marginal value to a future time
step, since this value is less or equal to vi,k , it will not affect the allocations of the first k
units in future time steps for agent i since it will continue to have a higher marginal value.
Now, because pi,j ‚â§ pi,k for j ‚â§ k (by definition), there must be at least k units for which
hti
hti
pi,k ‚â• Ei,j , 1 ‚â§ j ‚â§ |Ei | in the period aÃÇi ‚â§ t ‚â§ dÀÜi , and since vi,k ‚â• pi,k , agent i wins at
least k units in Stage 1.
Furthermore, whenever j units are won at a particular time step, the marginal payments
for those units appear as within the first k ‚Ä≤ + j first elements of the pti vector, where k ‚Ä≤ is
the number of units won at earlier time steps (since these are the values with the the lowest
clearing payment, and they are ordered ascendingly). Because agent i wins a unit with
hti
hti
externality Ei,j in Stage 1 if and only if vi,k ‚â• Ei,j (given uniform valuations), it follows
that vi,k = vi,j ‚â• pi,j whenever it wins a unit in Stage 1. Therefore, no pre-allocations are
cancelled in Stage 2.
The above holds if agent i has uniform marginal values of vi,k for the first k units. In
fact, however, because of non-increasing valuations, we have vi,j ‚â• vi,k , for all 1 ‚â§ j ‚â§ k,
and thus the allocation policy will allocate at least k units to agent i.
Part 2: Let vi,k < pi,k . First consider the on-departure cancellation case. As per the
definition of Stage 2 of the mechanism, the allocation of unit k is cancelled. However, we still
need to show that any pre-allocated units j > k are cancelled as well. Since pi,j ‚â• pi,k (by
definition) and vi,j ‚â§ vi,k (since valuations are marginally non-increasing by assumption)
for all j > k, it follows that vi,j < pi,j for all j > k. Therefore even if Stage 1 pre-allocates
193

Robu, Gerding, Stein, Parkes, Rogers & Jennings

k or more units, these will be cancelled in Stage 2, and thus strictly fewer than k units
remain.
hti
Now consider the immediate cancellation case. Note that pi,k ‚â§ pi,k for tk ‚â§ t ‚â§ di ,
where tk is the time when the k th unit was allocated. That is, marginal payment values can
ht i
only decrease over time. Since vi,k < pi,k (by assumption) and pi,k ‚â§ pi,kk , it follows that
ht i

hti

vi,k ‚â§ pi,kk . Thus it follows that vi,k < pi,k for any (ai + k ‚àí 1) ‚â§ t ‚â§ di . Consider a case
where, at time tk , the k th unit is allocated in Stage 1. As a result, pre-allocation of the k th
unit will always be cancelled at time tk in Stage 2 of the allocation policy. Therefore, the
final result is an allocation of strictly fewer than k units.
By setting œÑk = pi,k , the payment policy in Equation 4 corresponds to the payment
policy in Lemma 1. Therefore the proposed mechanism is shown to be DSIC in valuations.
We complete the proof by showing that truthful reporting of the arrival and departure
times are also DSIC given limited misreports, now assuming truthful reporting of vi .
Lemma 3. Given limited misreports, and assuming that truthfully reporting vÃÇi = vi is a
dominant strategy for any given arrival,departure and maximum consumption rate reports
haÃÇi , dÀÜi , rÃÇi i, then (subject to limited misreports) it is a dominant strategy to report aÃÇi = ai ,
dÀÜi = di , and rÃÇi = ri .
haÃÇ ,dÀÜ ,rÃÇ i

Proof. Let pi i i i denote the vector of increasingly ordered marginal clearing values (computed without i), given the agent reports Œ∏ÃÇi = hvi , aÃÇi , dÀÜi , rÃÇi i. By reporting type Œ∏ÃÇi , the agent
PœÄi (Œ∏ÃÇi ) haÃÇi ,dÀÜi ,rÃÇi i
is allocated œÄi (Œ∏ÃÇi ) items, and its total payment is:
. For each agent i, misj=1 pi,j
reporting from Œ∏i to Œ∏ÃÇi results in one of two cases:
œÄi (Œ∏ÃÇi ) = œÄi (Œ∏i ): Misreporting by agent i cannot change the values in pi , but can
only ever decrease the size of the pi vector. In particular, due to limited misreports we
haÃÇ ,dÀÜ ,rÃÇ i
have aÃÇi ‚â• ai , dÀÜi ‚â§ di and rÃÇi ‚â§ ri , and thus p i i i contains a subset of the elements
i

hai ,di ,ri i

from pi

. As these vectors are by definition increasingly ordered, it follows that
haÃÇi ,dÀÜi ,rÃÇi i
hai ,di ,ri i
pi,j
‚â• pi,j
, ‚àÄj ‚â§ (dÀÜi ‚àí aÃÇi + 1). Since the payment consists of the first ki = kÃÇi
elements, this can only increase by misreporting.
œÄi (Œ∏ÃÇi ) 6= œÄi (Œ∏i ): First, we show that œÄi (Œ∏ÃÇi ) > œÄi (Œ∏i ) could never occur. Since the
threshold values remain the same, but the agent can win fewer units per time step (when
reporting a lower maximum consumption rate), and/or the number of time steps in which
allocations occur decreases (when reporting a later arrival and/or earlier deadline), Stage
1 of the mechanism can only allocate fewer or equal numbers of units. Furthermore, since
haÃÇ ,dÀÜ ,rÃÇ i

ha ,d ,r i

pi,ji i i ‚â• pi,ji i i , the possibility of cancelling can only increase in Stage 2. Thus, it
always holds that œÄi (Œ∏ÃÇi ) ‚â§ œÄi (Œ∏i ).
Now, we consider the case œÄi (Œ∏ÃÇi ) < œÄi (Œ∏i ). First, as shown for the case œÄi (Œ∏ÃÇi ) = œÄi (Œ∏i )
PœÄi (Œ∏ÃÇi ) hai ,di ,ri i PœÄi (Œ∏ÃÇi ) haÃÇi ,dÀÜi ,rÃÇi i
above, we know that j=1
pi,j
‚â§ j=1 pi,k
(i.e., the payment for those units
won can only increase by misreporting arrival and/or departure). Furthermore, we know
that the allocation œÄi (Œ∏i ) is preferable to any other allocation œÄi (Œ∏ÃÇi ) < œÄi (Œ∏i ), otherwise
reporting the true valuation vector vi would not be a dominant strategy. Since the payment
for these items is potentially even higher when misreporting, the agent cannot benefit by
winning fewer items.
194

An Online Mechanism for Multi-Unit Demand

Theorem 2. Given non-increasing marginal valuations and limited misreports, both the ondeparture cancellation and immediate cancellation policies with payment policy according to
Equation 4 are DSIC.
Proof. The proof of this theorem follows directly from the above lemmas. Lemmas 1 and
2 show that, for any triple of arrival/departure/consumption rate (mis)-reports, haÃÇi dÀÜi , rÃÇi i,
the allocation policy is truthful in terms of the valuation vector vi , given an appropriate
payment policy. Furthermore, the payments in Equation 4 correspond to those in Lemma 2,
and therefore they truthfully implement the mechanism. Finally, Lemma 3 completes this
reasoning, by showing that, for a truthful report of valuation vector vi , agents cannot benefit
from misreporting arrivals/departures.
4.5 Implications for the PHEV Domain
Since we assume the units to be perishable, it may not always be possible to cancel units
once they are allocated. Whereas this is not a problem for immediate cancellation, since
units are never allocated to begin with, the on-departure cancellation policy requires the
battery to be partially discharged before departure of the vehicle. Although this may be
undesirable, it is in the agent‚Äôs best interest to avoid paying for these units given the design
of the mechanism, since the marginal value for these units is less than the marginal payment.
An agent could avoid discharging by unplugging before the units are discharged, but then
the agent will end up paying for these relatively expensive units. This noted, in Section 7,
in addition to comparing the IM and OD mechanisms, we also evaluate to what extent the
mechanisms would be manipulable if they were designed with the simple greedy allocation
policy, and without assuming any cancellation.

5. Theoretical Bounds on Allocative Efficiency
An important question given the online nature of the allocation is how the allocative efficiency compares to that of an optimal offline allocation, assuming full knowledge of the
future. As discussed in Sections 3 ‚Äì 4.2, in our online setting, it is not possible to achieve an
optimal allocation, because agents arrive and leave the market continuously. Moreover, in a
multi-dimensional online setting, the allocation of some units needs to be cancelled in order
to maintain truthfulness. Nevertheless, the optimal offline allocation represents a useful
upper bound of what could be achieved in terms of allocative efficiency, if the preferences
and availability constraints of all agents were known in advance.
To this end, in the following, we study the theoretical worst-case performance of both
IM and OD. More precisely, for each of these policies, we consider two types of inefficiencies:
‚Ä¢ Worst-case cancellation ratio. This is the fraction of units from those allocated to any
single agent that need to be cancelled in the worst case (and, to maintain the incentive
properties, cannot be allocated to any other agent). Formally, let I be the set of all
agents present in the market at any time point during the time interval over which
the bound is computed. Denote by œÄipre (Œ∏I ) the total number of units pre-allocated
to agent i ‚àà I in Stage 1 of the policy over the entire active period of this agent, and
by œÄicanc (Œ∏I ) = œÄipre (Œ∏I ) ‚àí œÄi (Œ∏I ) the number of units that were cancelled in Stage 2.
195

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Given this, the cancellation ratio for a specific agent i is RC,i (Œ∏I ) =

œÄicanc (Œ∏I )
.
œÄipre (Œ∏I )

Then

we define the worst-case cancellation ratio over all agents i ‚àà I and types Œ∏I ‚àà Œò|I|
as:
œÄ canc (Œ∏I )
max
.
RC
= max max ipre
Œ∏I ‚ààŒò|I| i‚ààI œÄi (Œ∏I )
‚Ä¢ Competitive ratio of allocative efficiency. Whereas the cancellation ratio considers the
worst-case for an individual agent, the competitive ratio compares the social welfare of
our mechanism with the social welfare achieved by the optimal offline mechanism, with
full information about future arrivals. Here, social welfare is defined as the sum of the
valuations obtained by all agents (i.e., the sum of utilities excluding any payments). In
more detail, following the work of Parkes (2007), the competitive ratio for our setting
is defined as follows. Let œÄion (Œ∏I ) denote the number of units allocated by our online
mechanism on departure of agent i given the types of all agents, Œ∏I ‚àà Œò|I| , and œÄiof f (Œ∏I )
denote the number of units allocated by the optimal offline mechanism to agent i. The
P PœÄion
social welfare of the allocations is then defined as: V on (Œ∏I ) = i‚ààI k=1
vi,k for the
of f
P
P
œÄi
online case, respectively V of f (Œ∏I ) =
i‚ààI
k=1 vi,k for the offline case. Now, a
competitive analysis assumes the existence of an ‚Äúadversary‚Äù that can choose from
a set of inputs, and in our case the adversary can choose any set of agent types
Œ∏I ‚àà Œò|I| . Given this, an online mechanism is said to be onc-competitive for efficiency,
if there exists a constant c ‚â• 1 such that: ‚àÄŒ∏I ‚àà Œò|I| : VVof f(Œ∏(Œ∏I )) ‚â• 1c . We can also say
I

that our online mechanism is guaranteed to achieve within a fraction of
of the optimal offline algorithm.

1
c

of the value

Our motivation for studying these two metrics is as follows. First, as outlined in Section
4.2, both variants of the mechanism we propose require that part of the allocation of some
agents is sometimes cancelled, in order to ensure truthfulness. It is natural to ask what is
the worst-case fraction of the number of units allocated to any agent that will need to be
cancelled, under both types of mechanisms (i.e., with immediate and on-departure cancellation), for any market set-up. For the second criteria (i.e., the competitive ratio of allocative
efficiency), we follow the metric proposed by Hajiaghayi et al. (2005) and Parkes (2007) for
online domains, with the caveat that deriving this bound for the multi-dimensional case is
considerably more involved than for the single-dimensional one, due to the required cancellations. In Section 5.1 we study these issues for the mechanism with immediate cancellation,
and in Section 5.2 for the mechanism with on-departure cancellation.
5.1 Worst-Case Bounds for the Mechanism with Immediate Cancellation
The following theorem shows that, when using the online mechanism with immediate cancellation, the worst-case cancellation ratio goes to 1 as the number of units required by a
single agent goes to infinity.
max = 1, where n is the maximum
Theorem 3. Using the IM allocation policy, limn‚Üí‚àû RC
demand.

Proof. The proof is by example. Consider the following setting consisting of an agent A
with marginal valuation vector vA = hv1 , v2 , ...vn i, where these values are strictly decreasing,
196

An Online Mechanism for Multi-Unit Demand

i.e., v1 > v2 > .... > vn . We assume that this agent arrives at time aA = 1, departs at dA ,
where dA = n ¬∑ (n + 1)/2, and has a maximum charging speed of rA = 1. Agent A faces a
sequence of cursory (i.e. local) agents, where each of these agents desires exactly one unit,
is present in the market for only one timestep and departs immediately afterwards. At any
one time there is exactly one of these cursory agents in the market. The valuations of these
agents are as follows. The first agent has a valuation of v1 = hv1 ‚àí «´i, the next two agents,
i = 2 and i = 3, have valuations of vi = hv2 ‚àí «´i, the next three agents, i ‚àà {4, 5, 6}, have
valuations vi = hv3 ‚àí «´i, the next four agents, i ‚àà {7, 8, 9, 10}, vi = hv4 ‚àí «´i, etc. Thus, in
total, there is a sequence of n ¬∑ (n + 1)/2 of these agents. Here, «´ is sufficiently small such
that v1 ‚àí «´ > v2 . As a result, agent A imposes the following externality at each timestep:
hv1 ‚àí «´, v2 ‚àí «´, v2 ‚àí «´, v3 ‚àí «´, v3 ‚àí «´, v3 ‚àí «´, v4 ‚àí «´, v4 ‚àí «´, v4 ‚àí «´, v4 ‚àí «´, ...i (noting that, since the
cursory agents are only present in the market for a single time step, cancelling an allocation
does not affect the externality, nor the marginal payment).
The allocation for this settings then proceeds as follows. In the first time step, the unit
is pre-allocated to agent A (since v1 > v1 ‚àí «´) and there is no cancellation. In the second
time step, the unit is again pre-allocated to agent A (since v2 > v2 ‚àí «´), but at this point
h2i
the marginal payment is pi = hv2 ‚àí «´, v1 ‚àí «´i. Since the marginal value for the second unit
is less than the marginal payment for this unit, i.e., v2 < v1 ‚àí «´, the unit gets cancelled.
Therefore, at time t = 3, the marginal value of agent A is still v2 , and the third unit also
gets allocated to the agent, and this time it is not cancelled. However, in the next two
time-steps, the units are pre-allocated and cancelled both times. To see this, note that
h2i
the marginal payment at time t = 5 is pi = hv3 ‚àí «´, v3 ‚àí «´, v2 ‚àí «´, v2 ‚àí «´, v1 ‚àí «´i. Since
h2i
v3 < pi,3 = v2 ‚àí «´, this unit gets cancelled.
More generally, for every k th unit which is allocated and not cancelled, the marginal
value of agent A becomes vk+1 , and the next k units will be first pre-allocated (since the
marginal value of the cursory agents are vk+1 ‚àí «´), but then subsequently cancelled (since
these all have a marginal payment of vk ‚àí «´). Only the (k + 1)th unit will be allocated and
not cancelled, but then the next k + 1 units will be cancelled, and so on.
pre
= 1 + 2 + 3 + 4 + . . . + n = n ¬∑ (n + 1)/2 units will be pre-allocated.
As a result, all œÄA
canc = 0 + 1 + 2 + 3 + . . . + (n ‚àí 1) = (n ‚àí 1) ¬∑ n/2 will be cancelled, and
Of those units œÄA
œÄA = n will remain allocated. Therefore, the ratio of number of units cancelled as n ‚Üí ‚àû
is:
canc
œÄA
n‚àí1
n2 ‚àí n
= lim
=1
pre = lim
n‚Üí‚àû œÄ
n‚Üí‚àû n + 1
n‚Üí‚àû n2 + n
A

RC,A = lim

The above theorem shows that the worst-case result for an individual agent is unbounded. We can use this result (and the example constructed in the proof) to derive a
similarly negative result for the allocative efficiency (i.e., the overall efficiency of the system):
Theorem 4. For the mechanism with immediate cancellation, the competitive ratio of the
allocation efficiency is unbounded. That is, there exists no finite c, such that:
‚àÄŒ∏I ‚àà Œò|I| :

1
V on (Œ∏I )
‚â•
of
f
c
V
(Œ∏I )
197

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Proof. Generally, there are two potential sources of inefficiency w.r.t. the offline allocation:
either the units are pre-allocated and subsequently cancelled, or some units are allocated to
agents that have less utility for them than the agents who would be allocated in the offline
case. Our proof is based on the former source of inefficiency and uses the same example
given in Theorem 3.
In the example of Theorem 3 we showed that it is possible to construct an example
where, given n ¬∑ (n + 1)/2 units of supply, (n ‚àí 1) ¬∑ n of these are cancelled (and thus not
allocated to any agent) and n are allocated. Now, suppose that the valuations for these
units by all agents (including agent A) are between [v, v], where v/v = r is a finite constant.
Since using the optimal offline allocation all units will be allocated, the total value will be
at least: V of f ‚â• v ¬∑ n ¬∑ (n + 1)/2. On the other hand, the online allocation using the online
allocation using immediate cancellation will have a value of at most: V on ‚â§ v ¬∑ n.
Given this, the following holds:
2r
v¬∑n
V on
‚â§ lim
= lim
=0
n‚Üí‚àû v ¬∑ n ¬∑ (n + 1)/2
n‚Üí‚àû n + 1
n‚Üí‚àû V of f
lim

Therefore, for any constant c, it is always possible to find a counter example where the
worst-case efficiency is lower than 1/c.
Thus, there is no theoretical bound on the efficiency loss when using the immediate
cancellation allocation policy. However, the proof relies on there being an agent who is
infinitely patient, has infinite demand, and has a higher valuation than all other bidders
for each unit. In practice, such an extreme situation would never occur. To consider more
practical scenarios, therefore, in Section 7 we use simulations to investigate realistic settings. After showing the worst-case bounds with immediate cancellation, in the remainder
of Section 5 we derive theoretical bounds for the on-departure cancellation mechanism.
Specifically, we will show that this mechanism provides much better bounds. In fact, the
competitive bounds for the efficiency are the same as those for single-unit demand settings,
where no cancellation occurs.
5.2 Worst-Case Bounds for the Mechanism with On-Departure Cancellation
This section is divided into two parts: in Section 5.2.1 we discuss the worst-case cancellation
ratio for a particular agent and provide a tight bound, while in Section 5.2.2 we consider
the bound on allocative efficiency for the entire market.
5.2.1 Worst-Case Cancellation Ratio
This section is organised as follows. First, we show that at most half of the units are
cancelled for any particular agent. Then we go on to show that there exist examples where
half of them are cancelled. Note that, for convenience, the following lemma is formulated
in terms of units retained instead of units cancelled.
Lemma 4. Using on-departure cancellation, suppose that an agent i is pre-allocated n units
by the departure time di , and k of these units are kept in Stage 2 (and so the mechanism
cancels n ‚àí k units). Then, for any type profile Œ∏I ‚àà Œò|I| , and any agent i ‚àà I, k ‚â• ‚åàn/2‚åâ
(i.e., at least half of the units are allocated).
198

An Online Mechanism for Multi-Unit Demand

Proof. To prove this property, we start by deriving two inequalities which hold for any value
of k. First, since k is defined as the number of units kept, and the remaining ones (n ‚àí k)
are cancelled, it must hold that vi,k+1 < pi,k+1 (otherwise the (k + 1)th unit would not be
cancelled, contradicting the definition).
The second inequality is given by vi,k+1 ‚â• pi,n‚àík and is less obvious. To see why this
always holds, we need an observation about how greedy allocation works. Recall that n
is the number of units pre-allocated by the greedy allocation policy. Therefore, each of
the active marginal values, vi,1 , . . . , vi,n , were at some point t ‚àà [ai , di ] among the top S(t)
highest marginal values. Consequently, the lowest marginal value of the ones pre-allocated,
vi,n , must be greater than the marginal payment of at least one unit (otherwise it could
not have won the unit). Since the marginal payments are sorted in an increasing order,
it must therefore hold that vi,n ‚â• pi,1 . Similarly, for the next-lowest value, it must hold
that vi,n‚àí1 ‚â• pi,2 , and so on. In general we can write vi,n‚àíj+1 ‚â• pi,j , j ‚àà {1, n}. If we set
j = n ‚àí k, we get vi,k+1 ‚â• pi,n‚àík .
Therefore, in order for the greedy policy to allocate n units and for the mechanism to
subsequently cancel the units from positions k + 1 to n (assuming k + 1 < n, otherwise
no cancelling will take place on departure of agent i), the following inequalities must be
satisfied:
(
vi,k+1 < pi,k+1
(5)
vi,k+1 ‚â• pi,n‚àík
Given this, we now show that k ‚â• ‚åàn/2‚åâ by contradiction. Suppose that k = ‚åàn/2‚åâ ‚àí 1,
i.e., strictly more than ‚åàn/2‚åâ are cancelled. Then the above conditions become:
(
vi,‚åàn/2‚åâ < pi,‚åàn/2‚åâ
(6)
vi,‚åàn/2‚åâ ‚â• pi,n‚àí‚åàn/2‚åâ+1
To show the contradiction, we need to consider separately the cases where n is even and
where n is odd. If n is even, then we have n = ‚åàn/2‚åâ + ‚åàn/2‚åâ, and the above system
becomes:
(
vi,‚åàn/2‚åâ < pi,‚åàn/2‚åâ
(7)
vi,‚åàn/2‚åâ ‚â• pi,‚åàn/2‚åâ+1
This implies pi,‚åàn/2‚åâ+1 < pi,‚åàn/2‚åâ , but since the marginal price vector pi is weakly increasing
by definition, this leads to a contradiction. For the case where n is odd, we have that
n = ‚åàn/2‚åâ + ‚åàn/2‚åâ ‚àí 1, and the conditions become:
(
vi,‚åàn/2‚åâ < pi,‚åàn/2‚åâ
(8)
vi,‚åàn/2‚åâ ‚â• pi,‚åàn/2‚åâ
Clearly, both equations cannot be satisfied simultaneously, leading to a contradiction.
Note that any value of k < ‚åàn/2‚åâ would lead to such a contradiction due to pi being
increasing, hence we necessarily have that k ‚â• ‚åàn/2‚åâ, completing the proof.
To complete our analysis, we show that this bound is tight, i.e., that there exist settings
in which half of the units allocated to an agent are cancelled.
199

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Lemma 5. There exist settings in which the mechanism with on-departure cancellation
cancels the allocation of ‚åàn/2‚åâ units, or no more than ‚åàn/2‚åâ units are kept, on departure of
an agent i, where n is the number of pre-allocated units.
Proof. The proof for this is done by constructing such a worst-case example. Consider a
single agent, A, who is in the market for n time periods, and has a demand for n units, where
n is even. The first n/2 marginal valuations are equal to 4, and the remaining ones are 2. For
example, for n = 8, the marginal valuation vector becomes vA = h4, 4, 4, 4, 2, 2, 2, 2i. Similar
to the proof of Theorem 3, this agent is faced, in each time step, by a different, single cursory
agent, which participates only in that time step. The valuations of the first n/2 cursory
agents in the sequence is given by vi = h3i, and the second half of the agents has vi = h1i.
Thus, for n = 8, the marginal payment of agent A would be p‚àíA = h1, 1, 1, 1, 3, 3, 3, 3i. In
such a setting, the mechanism with on-departure cancellation would pre-allocate all units
to agent A (since vA,k = 4 > vk,1 = 3 for k ‚â§ n/2 and vA,k = 2 > vk,1 = 1 for k > n/2).
However, on departure of agent A, exactly half of the units allocated are cancelled (since
vA,k = 2 < p‚àíA,k = 3 for k > n/2).
Finally, we unify the results from Lemmas 4 and 5 in the following theorem.
Theorem 5. In a setting with on-departure cancellation and non-increasing marginal values, for any number of units and agents present, the worst case cancellation-ratio for the
max = 1 .
number of units allocated to an agent i is RC
2
Proof. Lemma 4 shows that, regardless of set-up, no more than half of the units allocated
max ‚â§ 1 , regardless of the setting
to any agent can be cancelled on its departure, thus RC
2
(i.e., the possible input types of the agents). Lemma 5 shows there exist settings where the
max = 1 , completing the proof.
cancellation ratio is exactly RC
2
Note that in practice and for smaller settings, significantly fewer than half of the units
are cancelled. The worst case cancellation ratio 1/2 allocations occurs only in a very specifically constructed example, and, as shown in the experimental analysis, for most realistic
distributions in our application domain, the actual performance is much better.
5.2.2 Competitive Bound on Allocative Efficiency
The previous section discusses the cancellation problem from the perspective of single
agents, not the whole market. In this section, we show that, in the case that agents have
weakly decreasing marginal values, the allocation returned by the on-departure cancellation
mechanism is 2-competitive with the optimal offline allocation. This result means that the
multi-unit demand case with on-departure cancellation is no worse in terms of worst-case
competitive bound than the single-unit demand problem discussed by Hajiaghayi et al.
(2005), and Parkes (2007), despite the fact that for a single unit demand there is no need
for cancellation to ensure incentive compatibility. Formally, we can state this through the
following theorem:
Theorem 6. The mechanism with on-departure cancellation is 2-competitive with the optimal offline allocation, for a setting with non-increasing marginal values.
200

An Online Mechanism for Multi-Unit Demand

Proof. In order to establish a competitive bound with the optimal offline allocation, we use
a ‚Äúcharging argument‚Äù similar to that of Hajiaghayi et al. (2005).5 The basic idea is to
‚Äúcharge‚Äù (or match) all the marginal value units of each agent that are allocated in the
offline case with another, higher-valued unit that is allocated both offline and online. This
is either the unit itself, or the higher value unit that causes it not to be allocated in the
online market. Formally, consider all units vi,p (belonging to some agent i in position p)
which are allocated both in the offline and online case. If each such unit vi,p can be charged
at most twice, once to itself, and once to a lower valued unit allocated offline but not online,
then it follows that the worst-case social welfare ratio between the the online vs. offline
allocation cannot drop below 1:2.
Now, for agents with single-unit demand (such as the case discussed by Hajiaghayi et al.,
2005), it is easy to see this property always holds, because each unit vi,p can be allocated
online at most once, thus it can displace at most one other unit vj,q . Crucially, no units are
cancelled. In a multi-unit demand setting, the argument becomes more involved, because
each unit vi,p (allocated both online and offline) can affect the online market in several ways:
‚Ä¢ It can displace another unit vj,q that would be allocated offline, where by ‚Äúdisplace‚Äù
we mean specifically that unit vj,q is never pre-allocated online (hence cancellation
does not apply to it).
‚Ä¢ It can cause the cancellation of another unit vj,q . In this second case, unit vj,q is
pre-allocated, but its allocation is cancelled due to the presence of unit vi,p in the
market (meaning that its pre-allocation would not have been cancelled on departure
of agent j, if unit vi,p were not present).
The main issue that remains to be shown is that unit vi,p can only displace or cause
the cancellation of at most one other unit that would be allocated offline. Thus, it cannot
displace two or more other units that are allocated offline, but are not allocated online, due
to the presence of unit vi,p .
We show this by contradiction. Formally, suppose there are three units: vi,p , vj,q and
vk,r all allocated in the offline case (with vj,q < vi,p and vk,r < vi,p ). Unit vi,p is allocated in
the online case (i.e., pre-allocated and not cancelled). Units vj,q and vk,r are not allocated
in the online case if unit vi,p is present, but are allocated online if unit vi,p is not present.
Given this set-up, there are three possible cases:
1. Neither units vj,q or vk,r are pre-allocated online when unit vi,p is present (hence, there
is no cancellation of either vj,q or vk,r ).
2. Unit vj,q is never pre-allocated online, but unit vk,r is pre-allocated and its allocation
is cancelled later (i.e., on departure of agent k from the market), if unit vi,p is present.
3. Both units vj,q and vk,r are pre-allocated, but their pre-allocations are cancelled on
the departure from the market agents j, respectively k, if unit vi,p is present.
5. Here the term ‚Äúcharging‚Äù does not refer to electricity charging, but represents the name of a proof device
used in online mechanism design.

201

Robu, Gerding, Stein, Parkes, Rogers & Jennings

In all cases, if unit vi,p is not present, both units vj,q and vk,r are pre-allocated and not cancelled in the online case. In order to complete the proof we need to show, by contradiction,
that each of these three cases could not occur.
Case 1 is very similar to the case of single unit demand discussed by Hajiaghayi et al.
(2005), as no cancellation occurs for these units. It is relatively straightforward to see this
cannot occur, as any unit vi,p can be pre-allocated at most once (at some time t), thus it
can displace at most one other unit that would have been allocated otherwise. This can be
either the unit allocated online at time time t, if this unit is allocated online later on, the
unit which is, in turn, displaced by it.
Case 2: Suppose that vj,q (belonging to some agent j active between [aj , dj ]) is the
unit assumed not pre-allocated at all when vi,p is present, and unit vk,r is the unit that
is allocated and then cancelled. There are two subcases to consider here, which require
separate discussion.
Case 2A: First, consider that vj,q > vk,r . In this case, agent k has a lower marginal
value than that of agent j, but its value vk,r is still pre-allocated by our essentially greedy
allocation policy, while vj,q is not. This means that agent k must be more patient than
agent j, hence dj < dk , otherwise vj,q would have been pre-allocated instead.
Now, if we denote by pk the payment vector of agent k, defined as in Section 4.2. For
unit vk,r to be cancelled it must hold that vk,r < pk,r . Now, denote by pk<‚àíi> the vector
of marginal payments of agent k when agent i is not present in the market, and recall our
assumption that now the value vj,q is allocated. Thus, we have:
pk<‚àíi> = incr(pk \{vi,p } ‚à™ {vj,q })
where incr is the operator that orders elements in increasing order. Since vj,q > vk,r , it
<‚àíi>
follows that vk,r
< pk,r , thus the allocation of unit vk,r would still be cancelled, even
without unit vi,p .
Case 2B: For the second subcase, we consider vj,q ‚â§ vk,r , i.e., the value of the unit
that is displaced by agent i is lower than that the one pre-allocated and cancelled. First
note that, for this case to occur, unit vj,q but be allocated online within [ak , dk ], the active
window of agent k. This is an obvious condition: if agent j is allocated online outside this
window (and is displaced there when agent i is in the market, but the displacement occurs
outside [ak , dk ]), then units vj,q or vi,p cannot influence the cancellation of unit vk,r (because
each unit can be pre-allocated at most once, and in this case the pre-allocation of vi,p would
happen outside [ak , dk ]).
As previously, recall the condition for unit vk,r < pk,r , required for unit vk,r to be
cancelled. Note that this means there are at least k units between [ak , dk ] that are higher in
value than unit vk,r , and thus, in an offline allocation (which is our benchmark) would need
to take priority over it. In our setting, one of these units is vi,p . But even after removing
vi,p from it, vector pk<‚àíi> = incr(pk \{vi,p } ‚à™ {vj,q }) must contain at least k ‚àí 1 values higher
than vk,r . In an offline allocation without unit vi,p , these k ‚àí 1 values must be given priority,
together with at least unit vk,r . However, this means that unit vj,q cannot be allocated
offline between [ak , dk ], being lower in value than vk,r . This gives a contradiction with
our initial assumption that both units vi,j and vk,r are allocated offline (as well as online)
without unit vi,p present.
202

An Online Mechanism for Multi-Unit Demand

To explain this intuitively, what this means is that a unit vi,p can cause both the displacement (non-allocation) of a unit vj,q and the cancellation of another one vk,r , but it‚Äôs
not possible that both of these units were high enough value to be allocated in the offline
case as well. Thus, at most one other offline-allocated unit is not allocated online because
of the presence of unit vi,p in the market.
Case 3: In this final case, both units would need to be pre-allocated and cancelled, in
the absence of value vi,p . The contradiction for this case can be shown similarly to Case 2A
from above. Considering the marginal price vectors of agents j and k without vi,p in the
market:
pj<‚àíi> = incr(pj \{vi,p } ‚à™ {vk,r })
pk<‚àíi> = incr(pk \{vi,p } ‚à™ {vj,q })
It is easy to see that, regardless whether the value vj,q or vk,r is lower, for that value
the cancellation would still occur on departure in a market without agent i, leading to a
contradiction.
To summarise, we have now exhaustively shown that the contradiction holds in all
possible cases. Thus, a unit vi,p allocated both online and offline can at most displace
(or lead to the cancellation of) one other unit allocated offline. Thus, at most two units
allocated offline can be charged to any unit allocated online, completing the proof.

6. Computational Aspects
In this section, we consider the implications of implementing the mechanisms in practice, including the computational complexity of our algorithms. We will examine both on-departure
and immediate cancellation separately, as they differ fundamentally in their complexity.
6.1 Implementing On-Departure Cancellation
Algorithm 1 briefly outlines an implementation of our mechanism with on-departure cancellation (OD). Here, we assume that the first time step is denoted by t0 , the second by
t1 = t0 + 1, and so on. For simplicity, we use I throughout this section to denote the
full set of all agents arriving over all time points, but we note that no algorithm explicitly
uses information about future arrivals. Initially, the algorithm sets the endowments of all
agents to 0 (line 2), as no units have been allocated. Then, for every time step t, the
algorithm first pre-allocates units using the greedy allocation policy (line 4). This can be
done in O(N ¬∑rmax ) using the well known linear-time selection algorithm described by Blum,
Floyd, Pratt, Rivest, and Tarjan (1973), where N = |I| is the total number of agents and
rmax = maxi‚ààI rÃÇi is the maximum consumption rate.
Next, the algorithm computes the marginal payments up to time step t by rerunning
the market without each active agent (line 6). In rerunning the market for a particular
hti
agent i, it is important to note that only the pre-allocations have an effect on pi ‚Äî any
cancellations are irrelevant, because they do not affect the future development of the market.
Therefore, it is only necessary to compute the greedy allocation with each agent i removed,
which has a total run-time, for all active agents, in O(N 2 ¬∑ rmax ) (assuming results from
hti
previous time steps are re-used). Updating pi with the new marginal payments can be
203

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Algorithm 1 Mechanism with On-Departure Cancellation (OD).
1: procedure OnDepartureMechanism(Œ∏I , S)
ht i
2:
kht0 i ‚Üê h0, 0, . . . , 0i
‚ä≤ Initial endowments, ki 0 = 0, for all i ‚àà I
3:
for all t ‚àà {t0 , t1 , . . .} do
4:
kht+1i ‚Üê GreedyAllocation(Œ∏I , S(t), khti )
‚ä≤ Run greedy allocation
ÀÜ
5:
for all i ‚àà {j ‚àà I|aÃÇj ‚â§ t ‚àß dj ‚â• t} do
‚ä≤ Iterate through active agents
hti
6:
update pi using Œ∏‚àíi
‚ä≤ Run market without i
7:
if dÀÜi = t then
‚ä≤ If agent is departing
ht+1i hti
8:
k i , pi ‚Üê k i
, pi
‚ä≤ Final pre-allocation and marginal payments
9:
while vi,ki < pi,ki do
10:
ki ‚Üê ki ‚àí 1
‚ä≤ Cancel units while necessary
11:
end while P
i
pi,k
‚ä≤ Final payment for agent i
12:
xi (Œ∏‚àíi |ki ) ‚Üê kk=1
13:
end if
14:
end for
15:
end for
16: end procedure

done using a simple insertion algorithm, and, noting that only the lowest |vi | payments for
each agent i need to be kept, this can be done, for all agents, in O(N ¬∑ rmax ¬∑ vmax ), where
vmax is the maximum length of any agent‚Äôs valuation vector.
Finally, on departure, in lines 8‚Äì11, any units that have a lower valuation than their
corresponding marginal payments are cancelled, and the final payment is calculated in
line 12. This can be done in O(N ¬∑ vmax ) by simply iterating through the values.
In summary, the time complexity of our algorithm for the OD mechanism is O(N 2 ¬∑rmax +
N ¬∑ rmax ¬∑ vmax + N ¬∑ vmax ) for each time step. If rmax and vmax are assumed to be constant6 ,
this simplifies to O(N 2 ). Generally, this means that the algorithm can be executed quickly,
even for large numbers of agents.
6.2 Implementing Immediate Cancellation
Next, we consider our mechanism with immediate cancellation (IM), as shown in Algorithm 2. The key difference to the OD mechanism here is that units are potentially cancelled
at every time step that an agent is active (lines 7‚Äì9), rather than only on departure. This
small modification has a significant impact on the computational tractability of the mechanism. Unlike the previous mechanism, when computing the marginal payments in line 6, the
cancellations of other agents now affect the payments. This feature was already highlighted
in the example in Section 4.3.1, where the cancellation of the second unit pre-allocated to
agent 1 causes a change in the marginal payments to agent 3. More generally, cancellations
have an immediate effect on the endowments of agents and this directly affects the active
marginal valuations V hti in subsequent time steps.
6. This is reasonable, as they are limited by technological constraints in practice. In particular, rmax is
limited by battery and infrastructure constraints, while vmax is related to the petrol savings achievable
by an EV (as will be detailed in Section 7.3.3).

204

An Online Mechanism for Multi-Unit Demand

Algorithm 2 Mechanism with Immediate Cancellation (IM).
1: procedure ImmediateMechanism(Œ∏I , S)
ht i
2:
kht0 i ‚Üê h0, 0, . . . , 0i
‚ä≤ Initial endowments, ki 0 = 0, for all i ‚àà I
3:
for all t ‚àà {t0 , t1 , . . .} do
4:
kht+1i ‚Üê GreedyAllocation(Œ∏I , S(t), khti )
‚ä≤ Run greedy allocation
ÀÜ
5:
for all i ‚àà {j ‚àà I|aÃÇj ‚â§ t ‚àß dj ‚â• t} do
‚ä≤ Iterate through active agents
hti
6:
update pi using Œ∏‚àíi
‚ä≤ Run market without i
hti
7:
while vi,kht+1i < p ht+1i do
i

8:
9:
10:
11:
12:
13:
14:
15:
16:

ht+1i
ki

i,ki
ht+1i
ki
‚àí1

‚Üê
end while
if dÀÜi = t then
ht+1i hti
k i , pi ‚Üê k i
,p
P ii
xi (Œ∏‚àíi |ki ) ‚Üê kk=1
pi,k
end if
end for
end for
end procedure

‚ä≤ Cancel units immediately
‚ä≤ If agent is departing
‚ä≤ Final allocation and marginal payments
‚ä≤ Final payment for agent i

Now, in order to determine cancellations when rerunning the market without each active
agent i, it is necessary to again compute the marginal payments for all agents in those
markets (effectively executing the full algorithm again with Œ∏‚àíi ). Clearly, this leads to a
recursion that potentially sees all possible subsets of agents evaluated. In the worst case,
therefore, the cancellation decisions need to be executed for every agent in every possible
subset of I, or N ¬∑ 2(N ‚àí1) times.7 Simplifying and again assuming vmax and rmax to be
constant, this leads to a runtime complexity of O(N ¬∑ 2N ).
A runtime that is exponential in the number of agents is clearly a problem when applying
the mechanism in realistic settings with more than a handful of agents. However, to tackle
such problems, it is possible to use a technique akin to branch-and-bound that enters the
recursion in line 6 only when necessary. We present this in the following section.
6.3 Speeding Up Immediate Cancellation Using Bounds
To obtain a faster algorithm for the IM mechanism, instead of calculating all marginal
hti
payments pi at every time step, we find and iteratively refine lower and upper bounds
for these payments. The intuition behind this approach is to choose initial bounds that
are easily calculated without resorting to recursion. If an agent‚Äôs reported valuation for a
pre-allocated unit, vi,k , lies outside the bounds, we can immediately determine whether the
unit is cancelled or not. On the other hand, if vi,k lies between the bounds, we further refine
7. In practice, this recursion only occurs over the set of agents that are active at the same time as the
agent i that is being evaluated, as previous decisions are not affected by agent i‚Äôs presence and similarly
agents arriving after dÀÜi have no affect on i. This means that settings with large numbers of agents may
still be tractable if there is little overlap between the active agents, but for the sake of the analysis in
this section, we assume the worst case, that all N agents are active concurrently.

205

Robu, Gerding, Stein, Parkes, Rogers & Jennings

them by iteratively calculating the actual marginal payments for some of the agent‚Äôs active
time steps until the cancellation decision is unambiguous.
‚Üìht,si
‚Üëht,si
In more detail, we use pi
and pi
to denote the lower and upper bounds, respechti
tively, for pi . Here, s indicates the level of refinement, or up to which time step the actual
marginal payments have been calculated, with aÃÇi ‚àí 1 ‚â§ s ‚â§ t. Analogous to the actual
hti
‚Üìht,si
‚Üëht,si
pi vector, pi
and pi
are vectors in increasing order, and they represent bounds
hti
‚Üìht,si
hti
‚Üëht,si
for pi , such that pi,k ‚â§ pi,k ‚â§ pi,k , for all k and s. As the level of refinement, s, is
hti

increased, the bounds become tighter, eventually converging to pi,k . In the following, we
describe in detail how to calculate the initial bounds (with s = aÃÇi ‚àí 1, indicating that no
actual payments have been calculated yet):
‚Üìht,aÃÇ ‚àí1i

‚Ä¢ In order to calculate the initial lower bounds, pi i , we rerun the market without
i from aÃÇi to t using only the greedy allocation policy without cancellations. The
marginal payments in this market (as described in Section 4.2) are then used as lower
hti
bounds. These payments are not necessarily the same as the actual payments pi , as
there may be cancellations in the latter, which cause the active marginal valuations
to change in subsequent time steps. However, it can be seen easily that they indeed
represent a lower bound. Specifically, any cancellations either have no influence or
cause an increase in one or more elements in the externality vector E hti (since agents
have a lower endowment after cancellations and therefore an equal or higher value for
obtaining additional units).
‚Üëht,aÃÇ ‚àí1i

‚Ä¢ To calculate the initial upper bounds, pi i , we now consider the actual market including agent i from time step aÃÇi to t, calculate the externality that agent i
would impose on others for winning each available unit throughout this time interval and then use these to derive upper bounds for the payments. More formally, we
‚Üëhti
define a new multiset set of valuations, V‚àíi‚à™0 , which is derived by simply removing
all elements corresponding to agent i from V hti and padding it with zeroes, if necessary, until its size is at least S(t). Then, we proceed in a similar manner as in
Section 4.2 by defining the externality agent i would impose on others in time step
‚Üëhti
‚Üëhti
t as Ei = minhri i (maxhS(t)i V‚àíi‚à™0 ). Given this, the final vector of upper bounds is
S
‚Üëht,aÃÇ ‚àí1i
‚Üëht‚Ä≤ i
then pi i
= incr( tt‚Ä≤ =aÃÇi Ei ).

Unlike the actual marginal payments, these upper bounds now include the effect agent
i has on the market, as it may be allocated units that would have been allocated to
others, or, through its presence, cause the cancellation of other units, which, in turn,
affect the active valuations of other agents in subsequent time steps. However, as its
only effect is to reduce the supply available to other agents, including agent i in the
‚Üëht,aÃÇ ‚àí1i
market can only increase the active valuations of other agents, and therefore pi i
hti
is an upper bound for pi .

Given these bounds, we can now quickly test if an agent‚Äôs marginal valuation vi,k for
‚Üìht,aÃÇ ‚àí1i
a pre-allocated unit falls outside these bounds. If vi,k < pi,k i , then the unit is can‚Üëht,aÃÇi ‚àí1i

celled immediately, while if vi,k ‚â• pi,k

, it is definitely not cancelled. However, if

206

An Online Mechanism for Multi-Unit Demand

Algorithm 3 Mechanism with Immediate Cancellation (IM) and Bounds.
1: procedure BoundedImmediateMechanism(Œ∏I , S)
ht i
2:
kht0 i ‚Üê h0, 0, . . . , 0i
‚ä≤ Initial endowments, ki 0 = 0, for all i ‚àà I
3:
for all i ‚àà I do
4:
si ‚Üê aÃÇi ‚àí 1
‚ä≤ Initial refinement of bounds
5:
end for
6:
for all t ‚àà {t0 , t1 , . . .} do
7:
kht+1i ‚Üê GreedyAllocation(Œ∏I , S(t), khti )
‚ä≤ Run greedy allocation
8:
for all i ‚àà {j ‚àà I|aÃÇj ‚â§ t ‚àß dÀÜj ‚â• t} do
‚ä≤ Iterate through active agents
‚Üëht,s i
‚Üìht,s i
9:
Calculate pi i and pi i
‚ä≤ Add initial bounds for time t
10:
repeat
‚Üìht,si i
then
11:
if vi,kht+1i < p ht+1i
i

ht+1i
ki

12:

‚Üê

else if vi,kht+1i

13:

i

15:
16:
17:

i

19:
20:
21:
22:
23:
24:
25:
26:
27:

‚ä≤ Unit definitely cancelled

i,ki

‚ä≤ Refine bounds

i,ki

if dÀÜi = t then
‚ä≤ If agent is departing
ht+1i
ki ‚Üê ki
‚ä≤ Final allocation
‚Üìht,si i
‚Üëht,si i
while ‚àÉx ‚àà {1, 2, . . . , ki }, pi,x
6= pi,x
do
si ‚Üê si + 1
‚ä≤ Refine for final payments
end while P
‚Üëht,s i
i
‚ä≤ Final payment for agent i
pi,k i
xi (Œ∏‚àíi |ki ) ‚Üê kk=1
end if
end for
end for
end procedure

‚Üìht,aÃÇi ‚àí1i

pi,k

‚àí1
‚Üëht,si i
< p ht+1i
then

si ‚Üê si + 1
‚Üìht,s i
‚Üëht,s i
Update pi i and pi i
end if
‚Üëht,si i
until vi,kht+1i ‚â• p ht+1i

14:

18:

i,ki
ht+1i
ki

‚Üëht,aÃÇi ‚àí1i

‚â§ vi,k < pi,k

, then the bounds are ambiguous and need to be further refined.
‚Üìht,si

‚Üëht,si

We obtain these refined bounds pi
and pi
by computing the actual marginal payments up to some specified time s, after which the bounds are calculated as above. This
effectively replaces some of the initial bounds with actual marginal payments, resulting in
‚Üìht,si
hti
‚Üëht,si
more accurate overall bounds. Eventually, when s = t, we have pi
= pi = pi
.
S
‚Üìht,si
ht‚Ä≤ i
More formally, the refined lower bounds are calculated as pi
= incr(( st‚Ä≤ =aÃÇi Ei ) ‚à™
S
‚Üìht‚Ä≤ i
hti
( tt‚Ä≤ =aÃÇi +1 Ei )), where Ei is the externality vector in the market without i, using imme‚Üìhti

diate cancellations (as used for actual payments), while Ei is the corresponding vector in
the market without i and without any cancellations. Similarly, the refined upper bounds
S
S
‚Üëht,si
ht‚Ä≤ i
‚Üëht‚Ä≤ i
‚Üëhti
are calculated as pi
= incr(( st‚Ä≤ =aÃÇi Ei ) ‚à™ ( tt‚Ä≤ =aÃÇi +1 Ei )), where Ei
is as defined
above.
207

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Full details for the IM mechanism using bounds are given in Algorithm 3. This keeps
track of the level of refinement for the bounds of each agent i (as si , which is initialised to
aÃÇi ‚àí 1 in line 4). Then, instead of updating the actual payments, lines 10‚Äì17 repeatedly
compare the marginal valuation of the last unit that was pre-allocated (vi,kht+1i ) to the
i
current upper and lower bounds, refining them as necessary. Note here, that previous
calculations of the bounds can be reused, as the algorithm checks them iteratively, either
increasing t (when the next time step is calculated) or si by 1 (when the bounds are refined).
In each case, this means that only the active valuations of one additional time step have to
be added to the existing bounds. This loop repeats until the statement in line 17 becomes
true, which captures both cases when the last pre-allocated unit is definitely not cancelled
(in which case any other pre-allocated units will also not be cancelled, as their marginal
valuations will be at least as high, while their respective payments will be equal or lower),
or when all pre-allocated units in this time step are cancelled.
Finally, when an agent departs, its final allocation and payments are calculated in
lines 18‚Äì24. Here, it is now important to calculate the actual marginal payments for all
ki allocated units. This is achieved by further refining the bounds until the first ki upper
and lower bounds are equal. While this can incur further computational effort, it is not
hti
equivalent to computing the complete pi vector as in Algorithm 2. The payments only
need to be calculated for the units that are actually allocated on departure, the upper and
lower bounds may be equal without needing to compute actual payments, and importantly,
they are only required for the full set of agents and not recursively for all subsets of agents.
In practice, this algorithm with bounds significantly reduces the computational runtime of the mechanism (typically by 99% or more throughout the experiments conducted
in Section 7), as it often avoids re-running the market with all possible subsets of agents.
However, it is important to note that the worst-case run-time is still equivalent to Algorithm 2, i.e., O(N ¬∑ 2N ), or exponential in the number of agents. In the best case, when no
recursion is necessary, the run-time reduces to O(N 2 ).

7. Experimental Evaluation
In this section, we quantify the performance of our mechanisms, as compared to a number of
benchmarks, by applying them to a range of settings. While we investigated the theoretical
performance bounds of our mechanisms in Section 5, the purpose of this section is to evaluate
their performance in realistic settings.
Specifically, in Section 7.2, we consider a general setting that is easily reproducible and
show how our mechanisms perform as we vary both supply and demand for a good. Then,
in Section 7.3, we turn to the PHEV domain. For this, we first show how we can derive an
agent‚Äôs preferences based on the vehicle owner‚Äôs driving behaviour. Then, we use real data
collected during the first large-scale trial of pure electric vehicles (EVs) in the UK to show
that the same trends continue to hold in a realistic application setting. Furthermore, we look
at how the gradual introduction of fast-charging PHEVs would affect a neighbourhood with
limited electricity supply, both in terms of social welfare (which translates to the overall fuel
savings within the neighbourhood) and the financial savings of individuals. Throughout the
experiments, we also consider a simpler greedy allocation mechanism without cancellation
and quantify the potential benefits an agent would be able to achieve by misreporting in such
208

An Online Mechanism for Multi-Unit Demand

a mechanism. This demonstrates whether there is actually scope for strategic misreporting
in realistic settings and whether cancellation is needed in practice.
Before we consider the two specific settings, we briefly outline the common parameters
and benchmarks used in all experiments.
7.1 Experimental Setup
To evaluate our mechanisms, we simulate different settings where a number of agents compete for a limited supply of a good that is allocated on an hourly basis over a 24-hour
period. In order to test scenarios with varying supply and demand, we sample these agents
randomly from fixed probability distributions and use a range of supply functions (these
are outlined in more detail in Sections 7.2 and 7.3). In order to ensure statistical significance of our results, we re-sample the agents 1,000 times for each setting, and we plot 95%
confidence intervals throughout this section.
In addition to the two mechanisms proposed in this paper, with immediate cancellation
(IM) and on-departure cancellation (OD), we evaluate a number of benchmark mechanisms:
‚Ä¢ Fixed is a fixed-price mechanism that allocates units to those agents that have a
valuation of at least a given constant p, and the price they pay for each unit is p.
When demand exceeds supply, each unit is allocated to an agent chosen uniformly at
random from the set of all agents with a sufficiently high valuation. Here, an agent
may receive multiple units, up to its maximum consumption rate, rÃÇi . This mechanism
is DSIC and so it constitutes a direct comparison to our mechanisms. However, to
optimise the performance of the fixed-price mechanism, p must be carefully chosen.
Thus, for each given setting, we test all possible values (in steps of ¬£0.01) and select the
p that achieves the highest average efficiency (over 1,000 trials). Thus, when showing
the results of Fixed, this constitutes an upper bound of what could be achieved with
this mechanism.
‚Ä¢ Random is a special case of Fixed, with p = 0. Thus, using this baseline benchmark,
units are allocated randomly and agents do not pay anything.
‚Ä¢ Greedy is a simple greedy allocation policy, as described in Section 4. Payments
are calculated using pi prices (as for IM and OD), but there are no cancellations.
Thus, this mechanism is not truthful, but it constitutes an interesting comparison to
our mechanisms, as it allows us to quantify the loss of efficiency that is caused by
cancellations, as well as the potential benefits an agents has when misreporting in the
absence of cancellations.
‚Ä¢ Heuristic allocates units such that a weighted combination of an agent‚Äôs valuation
and urgency (proximity to its departure time) is maximised. Here, an Œ± ‚àà [0, 1]
parameter denotes the importance of the urgency, such that Œ± = 1 corresponds to the
well-known earliest-deadline-first heuristic in scheduling (Pinedo, 2008), while Œ± = 0
indicates that units are always allocated to the agent with the highest valuation. This
is not a truthful mechanism and we do not impose payments here, as its primary
purpose is as a benchmark for our approach. Again, we always select the best Œ± by
testing all values in steps of 0.01 for each setting.
209

Robu, Gerding, Stein, Parkes, Rogers & Jennings

‚Ä¢ Optimal assumes complete knowledge of all future arrivals and supply, then allocates
units to agents to maximise the overall allocative efficiency. Clearly, this mechanism
is not possible because it assumes knowledge of the future and it is also not truthful
(again we impose no payments), but it serves as an upper bound for the efficiency
that could be achieved.
7.2 General Allocation Setting
First, we consider a general synthetic setting, in which we generate agents and the supply
function from simple distributions. The main reason for examining such a scenario before
turning to a more realistic setup is to generate results that are easily reproducible and that
are not tied to a specific application domain. In the following, we outline the distributions
from which we sample the supply and agents (Section 7.2.1), and then we discuss our results
(Section 7.2.2).
7.2.1 Synthetic Setup
In this setting, we generate the supply function S(t) by randomly drawing from the discrete
uniform distribution on {1, 2, 3, . . . , s}, where we vary s in our experiments to represent
different amounts of a good that is being produced. For each agent i, we sample its arrival
time ai from the discrete uniform distribution on {0, 1, 2, . . . , 23} and its departure time
from {ai , ai + 1, . . . , 23}. We sample its maximum consumption rate ri from {1, 2, 3, 4, 5},
and finally, we generate vi by first selecting a number of required units uniformly at random from {1, 2, 3, . . . , 20}. Then, the first valuation vi,1 is sampled from an exponential
distribution with rate 1, and the remaining valuations are drawn uniformly at random from
the continuous interval [0, vi,1 ] (ordered appropriately to ensure non-increasing marginal
valuations).
7.2.2 Synthetic Results
In Figure 3, we examine the allocative efficiency of the mechanisms as we increase the number of agents competing for a limited supply of electricity. The figure shows the allocative
efficiency both of a setting with low supply (left), where s = 1, i.e., one unit is available per
time step, and of a setting with high supply (right), where s = 20, i.e., up to 20 units are
available per time step. We choose these two extreme settings to show the full spectrum of
potential supply scenarios (and focus on supply settings based on real data in Section 7.3).
Note that due to its run-time complexity, we plot IM only in the smaller setting with one
unit of supply. When supply is very high (s = 20), each agent is typically allocated a large
hti
number of units, causing IM to require more frequent refinements of the bounds for the pi
vectors and thus leading to a computational bottleneck. As the non-truthful Heuristic approach consistently achieves around 99% of the Optimal with full information when s = 1,
we do not plot it for readability, and we also use it as an approximation of the Optimal
when s = 20 (where Optimal also becomes computationally infeasible).
Several trends emerge in these results. First, when s = 1, the simple but not truthful
Greedy approach performs very well (around 99% of the Optimal). Next, we note that both
our truthful mechanisms, IM and OD also perform well, achieving around 95% and 96% of the
210

An Online Mechanism for Multi-Unit Demand

Allocative Efficiency (% of Optimal)

Approximate Allocative Efficiency (% of Heuristic)

100%

100%

90%

90%

80%

80%
Greedy
OD
IM
Fixed
Random

70%
60%
50%

70%
60%
50%

40%

40%

30%

30%

20%

20%
0

25

50 75 100 125 150 175 200
Number of Agents

0

25

50 75 100 125 150 175 200
Number of Agents

Figure 3: Allocative efficiency in synthetic setting (low supply, with s = 1, on the left, and
high supply, with s = 20, on the right).

Optimal, respectively. This is slightly lower than Greedy, which indicates that about a 3‚Äì
4% loss in efficiency is incurred due to cancellations. The difference in performance between
IM and OD is as expected here, as IM can cancel more units (see Section 5); however, despite
the unfavourable worst-case performance of IM, it is surprising that the difference is not
significant in practice. Overall, the results are promising, indicating that our mechanisms
work well in these settings, because the specific conditions that cause cancellations (i.e.,
when the valuations of allocated units effectively cross over with the marginal payments)
do not occur frequently in practice.
The fixed price mechanism, Fixed, performs significantly worse than our proposed mechanisms, achieving only 81% ‚Äì 83% of the Optimal. This is because, in order to remain
truthful, the mechanism sets a single fixed price that does not respond dynamically to
changes in supply and demand from time step to time step. This also explains why the
mechanism performs worst when there is some, but not much, competition, e.g., around
30 agents. Here, the fixed price starts to rise, to ensure agents with higher valuations are
allocated first, but there is still considerable variance in the valuations at each time step,
sometimes leaving high-value agents unallocated, while other times units are not allocated
at all. In contrast to this, both IM and OD always allocate all available units to the agents
with the highest valuations. Furthermore, it should be noted that Fixed, unlike IM and OD,
assumes a priori knowledge of the distributions from which agents are drawn. This may not
always be available in practice, which can further decrease its performance.
Finally, the Random mechanism performs worst of all, which is not surprising, as it uses
no information about the agents‚Äô valuations at all. However, its poor performance demon211

Robu, Gerding, Stein, Parkes, Rogers & Jennings

10%

Proportion of Pre‚àíAllocated Units Cancelled
10%
OD
IM

OD

5%

5%

0%

0%
0

50

100

150

200

Number of Agents

0

50

100

150

200

Number of Agents

Figure 4: Proportion of initially allocated units cancelled (s = 1 on the left, and s = 20 on
the right).

strates clearly the potential perils of using poorly designed non-truthful mechanisms, where
strategically misreported valuations may have no relation to the agents‚Äô actual valuations.
In the setting with more abundant supply, when s = 20, the same broad trends are
observed. The OD mechanism still achieves around 97% of the near-optimal Heuristic and
slightly less than Greedy, while the Fixed and Random perform significantly worse. However,
the gap in performance is smaller this time, as there is less competition and often there
are sufficient units to satisfy most of the agents. In such settings, the benefit of always
allocating to the agents with the highest valuations is generally lower. Note that while IM
was infeasible in these settings due to its high run-time complexity, OD took, on average,
less than 100ms to execute all 24 time steps in even the most complex settings with s = 20
and 200 agents.
Next, to further illustrate that actual cancellations by the IM and OD mechanisms are far
from the worst-case bounds established in Section 5, Figure 4 shows the average proportion
of pre-allocated units cancelled. This is generally low, ranging from 0% to 7%. As expected,
the OD mechanism cancels fewer units than the IM mechanism. Furthermore, there is a
general trend to cancel few units when competition is low (as there are usually sufficient
hti
units to satisfy all agents, leading to mostly 0 valuations in the pi vectors). Cancellations
then peak for medium levels of competition, after which they start to drop again slightly.
hti
This peak can be explained by the large variations in the pi vectors in these settings
and also because agents are generally allocated more units than in settings with more
competition (leading similarly to a higher variation in the valuations of an agent‚Äôs allocated
units).
In Figure 5, we next consider the potential benefits of misreporting when no cancellations
are used (as in the Greedy mechanism). We measure this by computing the utility of each
agent had on-departure cancellations been used and compare this to the actual utility gained
in the Greedy mechanism. This constitutes the best deviation a single agent could have
achieved with perfect hindsight of the actual pi prices. Here we plot the proportion of
cases where an agent can achieve any gain from misreporting (light blue), the conditional
212

An Online Mechanism for Multi-Unit Demand

Potential Gain in Utility When Misreporting
25%

25%

20%

20%

15%

15%

10%

10%

5%

5%

0%

Proportion of Gains
Conditional Utility Increase
Overall Utility Increase

0%
0

25

50

75 100 125 150 175 200
Number of Agents

0

25

50

75 100 125 150 175 200
Number of Agents

Figure 5: Potential gains when misreporting in the Greedy mechanism (s = 1 on the left,
and s = 20 on the right).

proportional increase in utility when a gain from misreporting exists (dark red), and the
product of the two, i.e., the overall average proportional increase in utility, including cases
where there is no gain (light red).
The results indicate that without cancellations, there are often cases where an agent can
benefit from misreporting ‚Äî in up to 6‚Äì7% of all cases when s = 1 and up to 20% of cases
when s = 20. This provides a clear motivation for using incentive compatible mechanisms
in these settings. However, although individual gains can lead to an average increase in
utility of up to 15‚Äì20%, when considering the overall average utility increase (including
cases where agents do not benefit), this is only up to 1‚Äì2% and significantly less in many
specific settings. This offers some promise for settings where cancellations are infeasible,
for example because immediate cancellations are not computationally feasible in very large
settings, or because on-departure cancellations cannot practically be implemented. For
low expected gains of 1‚Äì2% or less, an agent may not wish to exert additional efforts to
strategise. Furthermore, these gains represents an upper bound of what can be achieved
with perfect foresight of the prices, which is likely to be unavailable in practice. We also
note that the expected gain from misreporting fluctuates significantly, depending on the
specific setting ‚Äî similar to the cancellations, this fluctuation is caused by variations in the
pi vectors and also in the valuations of the allocated units.
To conclude this section, Figure 6 further explores the performance gap between our
proposed mechanisms and the benchmarks as supply is increased. Here, we fix the number
of agents at 50 and then vary the maximum number of available units of the good per
time step, s, from 1 to 70. Due to the complexity of this setting, we again omit Optimal
and IM from our analysis. It is clear here that the relative benefit the OD mechanism has
over the other truthful benchmarks decreases as supply is increased. This is not surprising,
as eventually all agents can be completely satisfied, even in a random allocation policy.
213

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Approximate Allocative Efficiency (% of Heuristic)
100%
90%
80%
Greedy
OD
Fixed
Random

70%
60%
50%
40%
30%
0

10

20

30
40
Supply (Maximum Units)

50

60

70

Figure 6: Approximate allocative efficiency as the maximum supply per time step (s) is
increased.

However, there is still a significant benefit in using OD up to relatively high supply levels of
around s = 45, and it is never outperformed by the truthful benchmarks, while consistently
performing close to the near-optimal Heuristic (over 99% in some cases) and close to the
Greedy mechanism without cancellations. In terms of potential gains for deviations, similar
trends as discussed previously are observed and so we omit a detailed figure.
So far, we have concentrated on describing the general performance of our mechanisms
in a synthetic, easily reproducible setting. In the following, we apply it to data from a real
EV setting.
7.3 PHEV Setting
In this section, we use data from a real (pure) EV trial to simulate typical charging patterns.8 Doing this allows us to verify that the trends discussed in the previous section
continue to hold in a realistic setting. Furthermore, basing our experiments on actual
PHEV characteristics enables us to quantify the actual utility of drivers in real terms (i.e.,
as a monetary gain or the fuel saved). We will also investigate whether the introduction
of faster charging speeds will lead to any benefits in the settings we consider. Such an
investigation is interesting, because fast chargers are already available for domestic settings
and allow vehicles to charge at twice the normal rate (or faster).9 However, their impact in
our settings is unclear, as they are still constrained by the overall supply of electricity.
In the following, we first present a principled approach for deriving an agent‚Äôs marginal
valuation vector and show that this approach satisfies the non-increasing marginal valuation
assumption (Section 7.3.1). We then describe the real-world data that we use for our
8. Note that, whereas the simulation is based on PHEVs, it uses real-world experimental data from pure
EVs. However, we believe it is reasonable to assume that the charging behaviour would be similar.
9. See, for example, http://www.pod-point.com/ or http://www.charging-solutions.com/.

214

An Online Mechanism for Multi-Unit Demand

experiments (Section 7.3.2), followed by an outline of how this is used to sample PHEVs
(Section 7.3.3). Finally, we discuss our results (Section 7.3.4).
7.3.1 Deriving an Agent‚Äôs Marginal Valuation Vector
An important part of our overall model is a method for computing the marginal valuation
vector, vi , based on real data. To do so, we combine data about the sampled car‚Äôs actual
journey distances with a principled approach for calculating the expected economic benefit
of charging for PHEVs. In detail, we first derive a probability density function, p(m), from
the data, which describes the probability of the distance travelled to be m miles (described
in Sections 7.3.2 and 7.3.3). Given this distribution, the price of fuel (in ¬£/litre), pp , the
internal combustion engine efficiency (in miles/litre), ep , and the efficiency of the electric
engine (in miles/kWh), ee , we can then calculate the expected utility of a certain amount
of charge (in kWh), ce , as follows:
Z ‚àû
Z ‚àû
pp
pp
¬∑ m ¬∑ p(m)dm ‚àí
¬∑ (m ‚àí ce ¬∑ ee ) ¬∑ p(m)dm,
(9)
E(u(ce )) =
e
p
ce ¬∑ee ep
0
where the first term is the expected fuel cost without any charge, and the second term is
the expected cost with a battery charge of ce . Therefore, the utility function represents the
expected savings in terms of real money for a given battery charge (without taking the cost
of the charge into account). Given this, and a unit size (in kWh), se , it is straight-forward
to calculate the marginal valuation of the k th unit as follows:
vk = E(u(k ¬∑ se )) ‚àí E(u((k ‚àí 1) ¬∑ se ))

(10)

Recall that, in our model, we assume that valuations are marginally non-increasing. We
now show that, using the above approach, this assumption is automatically satisfied. To do
so, we need to show that Equation 9 is non-decreasing (i.e., the first derivative is positive)
and concave (i.e., the second derivative is negative). The first derivative is given by:
Z ‚àû
pp
dE(u(ce ))
=
¬∑ ee ¬∑
p(m)
(11)
dce
ep
ce ¬∑ee
The second derivative is given by:
pp
d2 E(u(ce ))
= ‚àí ¬∑ ee 2 ¬∑ p(ce ¬∑ ee )
dce 2
ep

(12)

Clearly, both conditions are satisfied, which means that the valuations are always positive
and marginally non-increasing. In what follows, we describe how we derive the experimental
settings, such as the supply function, the arrival and departure of agents, and the travel
distance probability distributions from a real-world dataset. We also provide examples of
the marginal valuation vectors using this data.
7.3.2 The CABLED Dataset
We base our experiments on data gathered by the CABLED (Coventry And Birmingham
Low Emissions Demonstration) project,10 which is the first large-scale endeavour in the
10. See http://cabled.org.uk/.

215

Robu, Gerding, Stein, Parkes, Rogers & Jennings

All Cars

Frequency

15 %

Arrivals
Departures

10 %

5%

0%

:
22

:
20

:
18

:
16

:
14

:
12

:
10

:
08

:
06

:
04

:
02

:
00

00

00

00

00

00

00

00

00

00

00

00

00

Time

Figure 7: Distributions of arrival and departure times for all 56 EVs in the CABLED dataset
(assigning equal weight to each EV).

UK to record and study the driving and charging behaviours of EV owners. As part of
this project, 110 EVs were loaned to the public and equipped with GPS and data loggers
to record comprehensive usage information, such as trip durations and distances, home
charging patterns and energy consumption.
From this data, we focus on the period from March to June 2011, for which we were
provided with information from 63 distinct vehicles, with a total of 13,273 journeys. For
each journey, this includes the times when the ignition was turned on and off again, the total
mileage (as derived from GPS readings that were taken every 60 seconds), as well as labels
for the starting and end location, when this was available (such as ‚Äúhome‚Äù or ‚Äúwork‚Äù).
The vehicles in the CABLED trial were charged at various locations ‚Äî mostly at home,
but also at work. For the purpose of our experiments, we will assume that all charging
of the vehicles takes place at a single location. This is because our work focuses on coordinating the charging of EVs within a specific neighbourhood and considering the effect
of multiple markets for electricity is beyond the scope of this work. When available, we
choose this charging location to be the one labeled ‚Äúhome‚Äù in the data.11 Given this, and
since we are only interested in the arrival and departure times at this charging location, as
well as the consumption patterns between visits to the charging location, we aggregate all
intermediate journeys between the departure from a charging location until the next return
to this location into a single journey.
Aggregating the data in this way and discarding vehicles without a clear charging location results in 4,302 distinct journeys for 56 different EVs, covering a total distance travelled
of close to 72,500 miles. The overall distribution of all recorded arrival and departure times
11. Some vehicles in the dataset lack this, as they were used as shared fleet vehicles for an organisation ‚Äî
in these cases, we use an appropriate alternative location label, where most of the charging took place,
or discard the vehicle when no suitable label can be identified.

216

An Online Mechanism for Multi-Unit Demand

Frequency

EV 1

EV 2

Arrivals
Departures

30 %

30 %

20 %

20 %

10 %

10 %

0%

0%

Frequency

EV 4

30 %

30 %

20 %

20 %

10 %

10 %

0%

0%

0

:0

20
0

:0

16
0

:0

12
0

:0

08
0

:0

04
0

:0

00

0

:0

20
0

:0

16
0

:0

12
0

:0

08
0

:0

04
0

:0

00

EV 5
Frequency

0

:0

20
0

:0

16
0

:0

12
0

:0

08
0

:0

04
0

:0

00

0

:0

20
0

:0

16
0

:0

12
0

:0

08
0

:0

04
0

:0

00

EV 3

EV 6
60 %

40 %

40 %
20 %

20 %

0%

0%

Time

Figure 8: Example distributions of arrival and departure times for six EVs.

217

0

0

:0

20

0

:0

16

0

:0

12

0

:0

08

0

:0

04

:0

00

0

0

:0

20

0

:0

16

0

:0

12

0

:0

08

0

:0

04

:0

00

Time

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Empirical Distribution Function (CDF)

1
0.9
0.8
0.7
0.6

All Cars
Car 1
Car 2
Car 3
Car 4
Car 5
Car 6

0.5
0.4
0.3
0.2
0.1
0
0.01

0.1

1

10

100

1000

Miles per Journey

Figure 9: Empirical distribution functions of distances travelled between successive visits
to home charging locations. Six example EVs and the combined summary of all
56 EVs, with equal weights assigned to all cars (in red), are shown.

at the charging location is shown in Figure 7.12 Here, almost all arrivals happen between
9am and 11pm, with a clear peak in the late afternoon and evening (4pm ‚Äì 9pm). Departures take place throughout the day with a peak around 8am ‚Äì 10am. To show how
individual driving patterns vary between the recorded cars, Figure 8 details the arrival and
departure time distributions for six individual EVs from the data set. Most of these reflect
the general trends shown in the previous figure, with arrivals generally occurring in the
evening and most departures in the morning. However, EVs 2 and 3 deviate from this
pattern. This is because those vehicles are shared fleet vehicles, which are collected and
returned to their main charging location throughout the day.
Figure 9 shows the distribution of the distances the vehicles travelled between visits to
their home charging location (red line), as well as the corresponding functions of the six
EVs from Figure 8 (interrupted lines).13 Overall, the average distance travelled is about 41
miles, while the median is around 9 miles (assigning uniform probabilities to each car type).
The six sample EVs here show significantly different typical travel distances, ranging from
an average of 4.19 miles (EV 1) to over 100 miles (EV 6).
In the following, we discuss how we use the data from the CABLED project to instantiate
our EV charging simulations.
12. As we will allocate electricity in hourly units, all arrival and departure times are here rounded up to the
next full hour.
13. Note that the distance of some journeys here exceeds the range of typical electric cars. This is because
they were charged at alternative locations during the CABLED trial, which we ignore in our experiments.
Since we focus on PHEVs in this work, in practice, the shortfall here would be made up by the combustion
engine.

218

An Online Mechanism for Multi-Unit Demand

Units (3 kWh each)

15

High Supply
Low Supply

10
5
0

0
:0
00
0
:0
22
0
:0
20
0
:0
18
0
:0
16
0
:0
14
0
:0
12
0
:0
10
0
:0
08
0
:0
06
0
:0
04
0
:0
02
0
:0
00
Time

Figure 10: Number of 3 kWh units available for PHEV charging in two scenarios with
varying supply (high and low ), based on a neighbourhood of 30 households.

7.3.3 Generating Experiments
For each experimental run, we simulate a small neighbourhood of 30 households with a
variable number of PHEVs over a 24-hour period, starting at 8:00 am in the morning until
8:00 am the following day. We assume that electricity is allocated in hourly time steps,
where each unit corresponds to 3 kWh (which is the approximate energy obtained through
a standard 13 A BS 1363 household socket in the UK when charging for an hour).
To obtain the supply function S(t), we first compute the overall average electricity
consumption throughout the neighbourhood (without PHEVs), based on the average consumption of a single UK household during a weekday in high summer.14 Then, we assume
that overall electricity supply is limited by the capacity of the local transformer, such that
the electricity available for PHEV charging, S(t), is the difference between this capacity
(possibly including some additional safety margin) and the current overall consumption.
In more detail, we consider two possible scenarios: (1) a high supply scenario, where the
capacity limit is set such that it covers 150% of the peak consumption (at about 10:00 pm),
resulting in 615 kWh available for PHEV charging; and (2) a low supply scenario, where the
capacity limit is 80% of peak consumption, resulting in 99 kWh available for charging.15
The corresponding units available for PHEV charging in these two scenarios are shown in
Figure 10.
Furthermore, we use the specific empirical distribution of journey distances corresponding to that car‚Äôs type as that car‚Äôs travel distance distribution, p(m) (for example, if the
sampled car is based on car 3, we use the dashed dark blue distribution function in Figure 9). We then use Equations 9 and 10 to derive the marginal valuations. In this case, as
the empirical distribution function is discrete, the integrals in Equation 9 are replaced by
sums over the data points. Furthermore, we will initially assume that ri is drawn uniformly
14. We used the data available at http://data.ukedc.rl.ac.uk/browse/edc/Electricity/LoadProfile/
data.
15. Local transformers are often undersized in this way since prior to PHEV use, they could cool during
overnight periods of low demand.

219

Robu, Gerding, Stein, Parkes, Rogers & Jennings

at random from the discrete set ri ‚àà {1, 2, 3, 4}, that is, cars can charge between one to four
units of electricity per hour (corresponding to 3 ‚Äì 12 kWh).
To generate agents with a variety of marginal valuations, we note that ee and ep depend
on the specific make and type of the PHEV. To simulate this, we draw ee uniformly at
random from 2 ‚Äì 4 miles/kWh and ep is drawn from 9 ‚Äì 18 miles/litre. Next, we draw
the capacity of a car battery from 15 ‚Äì 25 kWh. These are realistic values modelled on
the Chevrolet Volt, the first mass-produced PHEV. However, we include some variance to
account for other vehicle types. Throughout the experiments, we hold the price of petrol
constant at pp = ¬£1.30 per litre.
Table 4 shows example valuations corresponding to the same six cars considered previously (fixing ep = 13.5 miles/litre, ee = 3 miles/kWh and the battery capacity at 20 kWh).
These highlight how longer expected journeys generally translate to higher marginal valuations, but also how variable the valuations can be for an individual agent. As an example,
car 4 values the first 3 kWh of electricity at ¬£0.67, but the seventh unit is only worth
¬£0.038, as it is far less likely to be used.
Car
1
2
3
4
5
6
..
.

vi,1
0.340
0.304
0.481
0.670
0.727
0.839
..
.

vi,2
0.136
0.178
0.157
0.453
0.620
0.797
..
.

vi,3
0.001
0.162
0.073
0.333
0.582
0.767
..
.

vi,4

vi,5

vi,6

vi,7

0.114
0.062
0.312
0.540
0.711
..
.

0.033
0.035
0.263
0.498
0.630
..
.

0.134
0.445
0.555
..
.

0.038
0.445
0.540
..
.

Table 4: Example marginal valuations (in ¬£).
To set up an experimental run, we then randomly generate a set of N PHEV agents,
where we vary N from 1 to 60 to simulate different levels of demand.16 For each agent i, we
first choose one of the 56 available cars uniformly at random from the CABLED dataset,
which we base that agent‚Äôs type on. Then, we randomly select one of the car‚Äôs recorded
journeys and use the time of day of the car‚Äôs arrival at the charging location as ai (at or after
8:00 am in the time window we consider). To ensure that the correlation between arrival
times and subsequent departure times in the dataset are preserved, we use the departure
time of the journey immediately following the sampled journey as di (or 10 hours after
arrival, whichever is sooner).
7.3.4 PHEV Results
First, we are interested in general trends of the mechanisms and whether these are similar to
the trends discussed in Section 7.2.2. To this end, Figure 11 shows the allocative efficiency
for all mechanisms in a setting with low supply (where it is feasible to run both the Optimal
16. Note that this is a realistic number of PHEVs within a neighbourhood served by a single distribution
transformer (Huang & Infield, 2010).

220

An Online Mechanism for Multi-Unit Demand

Allocative Efficiency (% of Optimal)
100%

90%
Optimal
Heuristic
Greedy
OD
IM
Fixed
Random

80%

70%

60%
0

5

10

15

20

25

30

35

40

45

50

55

60

Number of EVs

Figure 11: Allocative efficiency in a small neighbourhood of 30 households.
and the IM mechanisms). This demonstrates the same broad trends as in our previous
synthetic setup ‚Äî the OD and IM mechanisms clearly dominate the other truthful mechanism
(with IM achieving slightly worse results due to its higher cancellation rates). This, again,
is due to the ability of the mechanisms to always allocate to the agents with the highest
valuations.
However, although they still consistently achieve around 90% of the Optimal, the relative
performance of the OD and IM mechanisms here is slightly lower. This drop in performance,
also witnessed by the Heuristic and Greedy mechanism, is due to the more constrained
real-world settings, where electricity is only available in abundance at certain times (i.e.,
during the night), and where some agents are significantly less patient than others. In such
settings, it can often pay off to delay more patient agents, even if they have higher valuations,
in favour of less patient ones. Furthermore, because valuations are directly related to the
fuel costs saved by a unit of electricity, there is less variance in the real-world valuations,
causing the gap between the OD and IM mechanisms and the other truthful benchmarks to
narrow slightly. Turning to the potential gains of misreporting in this setting, Figure 12
again confirms the same patterns observed previously. The magnitude of the gains are
slightly higher here due to the different setting (reaching up to 3% in terms of overall gains
and up to 30% in the conditional case).
A key advantage of applying the mechanisms to real-world data is that it allows us to
determine the actual fuel savings agents could achieve in these settings. Thus, Figure 13
shows the average fuel savings of each agent under the various mechanisms, or, in other
words, the average amount each agent would have spent on fuel, had they not been allocated
any electricity. Initially, this is high (around ¬£1.15), as there is little competition, but starts
dropping as more PHEV owners compete for the same amount of electricity. Of key interest
here is the horizontal separation between the different mechanisms. For a given fuel saving
per agent, our mechanism can sustain a significantly larger number of agents than the other
truthful mechanisms. For example, to save at least ¬£0.40 per agent, Random can support
221

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Potential Gain in Utility When Misreporting
35%

Proportion of Gains
Expected Benefit on Gain
Expected Benefit Overall

30%
25%
20%
15%
10%
5%
0%
5

10

15

20

25

30

35

40

45

50

55

60

Number of EVs

Figure 12: Potential gains when misreporting in the Greedy mechanism in a small neighbourhood of 30 households.

Fuel Savings per Agent per Day (in ¬£)
Optimal
Heuristic
Greedy
OD
IM
Fixed
Random

¬£1.25

¬£1

¬£0.75

¬£0.5

¬£0.25
0

5

10

15

20

25

30

35

40

45

50

55

60

Number of EVs

Figure 13: Saving per agent per day in a small neighbourhood of 30 households.
up to 40 PHEV owners, while IM and OD achieve the same threshold for around 60 PHEV
owners (an approximately 50% improvement).
Finally, we consider in more detail how the presence of fast-charging vehicles affects
the overall neighbourhood, in terms of overall fuel savings, the occurrence of cancellations
and the utilities of individual agents. To this end, we now fix the number PHEVs at 60
222

An Online Mechanism for Multi-Unit Demand

Social Welfare / Fuel Savings (per Day, in ¬£)
¬£90
¬£30

Optimal
Heuristic
Greedy
OD

IM
Fixed Price
Random

¬£85
¬£80

¬£25

¬£75
¬£20

¬£70
¬£65
0

10
20 30 40 50 60
Number of Fast‚àíCharging EVs

0

10 20 30 40 50 60
Number of Fast‚àíCharging EVs

Figure 14: Social welfare when introducing fast-charging cars into a neighbourhood with
low supply (left) and high supply (right).

Units Cancelled per Day (% of Total Allocated)
30%

30%

IM
OD

20%

20%

10%

10%

0%

0%
0

10 20 30 40 50 60
Number of Fast‚àíCharging EVs

0

10
20
30
40
50
Number of Fast‚àíCharging EVs

60

Figure 15: Cancellations when introducing fast-charging cars into a neighbourhood with
low supply (left) and high supply (right).

and consider both the low and high demand settings shown in Figure 10. Due to their
computational cost, we again only test the Optimal and IM mechanisms in the setting with
low supply. To investigate the impact of fast-charging, we assume there are two agent types
‚Äî the first, normal, can charge a single unit of 3 kWh per time step, while the second,
fast, are equipped with fast chargers that can charge up to four such units per time step.
223

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Utility Per Agent (per Day, in p = ¬£0.01)
¬£1.25

14p

12p

¬£1

10p
OD (Fast)
OD (Normal)
Greedy (Fast)
Greedy (Normal)

8p

¬£0.75

¬£0.5
0

10 20 30 40 50 60
Number of Fast‚àíCharging EVs

0

10 20 30 40 50 60
Number of Fast‚àíCharging EVs

Figure 16: Individual agent utility when introducing fast-charging cars into a neighbourhood with low supply (left) and high supply (right).

Throughout the experiments, we vary the number of fast-charging PHEVs (out of the total
60). Figure 14 first shows the resulting social welfare (i.e., overall fuel savings) for both
supply scenarios with low supply (left) and high supply (right). First, we note that the
trends for the two scenarios are different ‚Äì when supply is low, the introduction of more
fast-charging vehicles has little effect on overall social welfare for most mechanisms, while
when supply is high, most mechanisms display increased savings. This happens because the
first scenario is highly constrained, with the low supply resulting in few occasions where an
agent could charge more than a single unit per time step. In contrast, when supply is high,
agents are often allocated multiple units, thus enabling impatient agents in particular to
achieve higher overall fuel savings.
In addition to this, it is interesting to note that our proposed mechanisms OD and IM
benefit in both settings (achieving additional fuel savings of almost two litres per day in
the low supply setting, and up to seven litres in the high supply setting). The reason
for this becomes evident when considering the proportion of units cancelled as more fastcharging PHEVs are introduced ‚Äî for both mechanisms and in both settings, the number
of units cancelled are consistently reduced by around 70‚Äì80% as all cars are replaced by
fast-charging PHEVs (shown in Figure 15). This occurs mainly because there are more
hti
active marginal valuations at each time step to populate the pi vectors, thus reducing the
number of cancellations. This also causes the gap between our mechanisms and the Greedy
mechanism to shrink, as fewer cancellations take place.
With respect to the utility of individual agents (including payments to the mechanism),
Figure 16 shows that agents in both settings always have an incentive to switch to fast224

An Online Mechanism for Multi-Unit Demand

Potential Gain in Utility When Misreporting
40%

40%

Proportion of Gains
Conditional Utility Increase
Overall Utility Increase

35%

35%

30%

30%

25%

25%

20%

20%

15%

15%

10%

10%

5%

5%

0%

0%
0

10
20 30 40 50 60
Number of Fast‚àíCharging EVs

0

10 20 30 40 50 60
Number of Fast‚àíCharging EVs

Figure 17: Potential gains when misreporting in the Greedy mechanism in a neighbourhood
with low supply (left) and high supply (right).

charging PHEVs (e.g., by purchasing a domestic fast charger), and this applies for both the
OD mechanism and the Greedy mechanism. With low supply, the expected daily saving when
switching to a fast-charging PHEV is approximately ¬£0.02‚Äì0.03, while with high supply,
this is around ¬£0.20‚Äì0.25. In both cases, this benefit is the result of increasing available
supply per time step, as well as increasing the size of the price vector. Furthermore, even
if the entire population were to switch from slow charging PHEVs to fast-charging PHEVs,
individuals would, on average, achieve a higher utility. Note that the differences between the
utility in the OD and Greedy mechanisms are significantly smaller for fast-charging vehicles,
indicating that fast-charging agents can expect lower gains from misreporting when there
are no cancellations.
Figure 17 further investigates the individual gains from misreporting when there are no
cancellations. This shows an interesting trend ‚Äî while initial gains are high (reaching over
8% in one setting), they decrease significantly as more fast-charging PHEVs are introduced
(to around 0.2% in the same setting). This is clearly due to the significant reduction in
cancellations that are witnessed in those settings. Furthermore, we note, by comparing OD
and Greedy in Figure 16, that the agents who can gain from misreporting tend to be only the
slow-charging ones. Overall, this is a promising result for settings where cancellations are
not feasible ‚Äî by increasing the consumption rate of PHEVs (within realistic parameters
that are achievable by current technological trends), the scope and potential benefits from
strategising in a simple greedy mechanism can be reduced significantly. In this particular
example, when supply is high, a fast-charging PHEV can expect to gain less than ¬£1 over
the course of an entire year by strategising optimally.
225

Robu, Gerding, Stein, Parkes, Rogers & Jennings

8. Conclusions
The contributions in this paper are both theoretical and practical. On the theoretical
side, we propose a novel online, model-free mechanism for perishable goods where agents
have multi-unit demand and non-increasing marginal valuations. We show that, in order
to ensure dominant strategy incentive compatibility in such a setting, our mechanism occasionally requires units to remain unallocated (we say their pre-allocation is cancelled),
even if there is demand for these units. We define two ways in which cancellation can be
performed: immediate, i.e., before the actual allocation, or on departure of the agent from
the market. We study the properties of these two variants, both in terms of their incentives
and allocative efficiency. Furthermore, we present algorithms for computing the payments
and allocations of both mechanisms, and analyse their computational tractability.
The on-departure cancellation mechanism has better computational tractability, and has
the same worst-case competitive bound, in terms of allocation efficiency, as the single-unit
demand case. However, this mechanism requires any cancellations to be done on departure
of an agent from the market which is not always feasible. A naƒ±Ãàve approach to computing
payments in the mechanism with immediate cancellations requires time that is exponential
in the number of agents. To address this, we proposed a branch-and-bound algorithm that
allows payments to be computed in the immediate cancellation policy for many realistically
sized settings. Another potential problem with the immediate cancellation policy is that
there is no worst-case bound in terms of the efficiency of the allocation.
On the practical side, we show how our mechanism can be applied within the smart grid
to solve the important problem of integrating an increasing number of high-consumption
PHEVs into the electricity grid. In addition to a synthetic setting, we empirically evaluate
our mechanism using real-world data from a large-scale trial of electric vehicles in the UK.
We show that the proposed mechanism is highly robust, scalable (in particular, the ondeparture variant) and achieves better allocative efficiency than any fixed-price benchmark,
while only being slightly less efficient than an established cooperative scheduling heuristic.
Specifically, we demonstrate that our mechanism can sustain up to 50% more vehicles at the
same fuel cost than can be achieved using a simple randomised mechanism. Both variants
also consistently achieve an efficiency of around 90%, compared to a hypothetical optimal
offline solution. Given the theoretical results regarding their bounds, this is a surprising
result, suggesting that the specific conditions that cause cancellations do not often occur
in practice and that our allocation policies perform well in realistic settings. Furthermore,
we consider the introduction of fast chargers within a neighbourhood, and we show that
this leads to a significant increase in overall fuel savings and that it further reduces the
occurrence of cancellations. Finally, since on-departure cancellation requires discharging
the battery of the PHEV, we consider the the potential gains from misreporting if the units
are not cancelled (and assuming full knowledge of the types of other agents). From the
settings we considered, the average potential gain is between 1% and 8% overall, but could
go up to 30% on average when only considering those cases where misreporting is beneficial,
and could be even higher for individual cases. The gain becomes smaller as the number of
competing agents increases and, interestingly, fast-charging PHEVs have particularly low
incentives for misreporting.
226

An Online Mechanism for Multi-Unit Demand

Taken together, our mechanisms represent a versatile range of tools, some of which may
be more suitable for specific scenarios than others. For example, in medium-sized settings
where allocations cannot be cancelled on departure, the IM mechanism may be the most
suitable (e.g., in the low-supply PHEV settings outlined in Section 7.3). In other settings
where on-departure cancellation is feasible, the OD mechanism leads to a higher average and
worst-case efficiency, and is also more scalable. Here, it is also important to emphasize that
on-departure cancellation only occurs when this is in the user‚Äôs best interest‚Äî thus, it is
entirely possible to achieve through an optional action. Finally, as we show in the results,
even when both IM and OD are infeasible, a mechanism without cancellations may still be
viable in some settings, and it may even be possible to significantly reduce the scope for
manipulation by adjusting some of the system parameters; e.g., by introducing fast chargers
in the PHEV setting or by increasing supply.
There are several directions for extending this work. In related work, Stein et al. (2012)
discuss an alternative model, which uses probabilistic information about future arrivals and
is designed to elicit truthful reporting from pure EVs, rather than PHEVs. That model,
however, requires knowledge about future supply and assumes single-minded bidders; i.e.,
the preferences are single-dimensional and so it is not possible to specify different values
for different amounts of charge received. In future work, we intend to explore mechanisms
that combine the benefits of both approaches.
In addition, we intend to test our mechanism using a real-world trial. As we have seen
(see Section 7.3), we can design an agent which elicits information regarding the intended use
(a probability distribution of the driving distance), and combines this with other information
such as the price of petrol and the efficiency of the vehicle, to derive the owner‚Äôs marginal
valuation vector. Such an agent can also participate in the mechanism on the owner‚Äôs behalf,
avoiding the need for the owner to understand the details of the mechanism. This is in the
spirit of the work on hidden market design (Seuken, Parkes, Horvitz, Jain, Czerwinski, &
Tan, 2012), where the aim is to design the user interface such that the user‚Äôs cognitive
load is reduced by hiding details of the underlying market. In the trial, we intend to
approach participants owning regular (non EV) cars, and install GPS trackers in these cars.
Participants will then be asked to predict their driving requirements, and their agent will
use this information, as well as learned historic driving patterns, to derive the user‚Äôs utility
function and participate in the mechanism on their behalf. Although the trial will be with
regular cars, the users will be able to see how much they would have hypothetically saved
by providing accurate (and truthful) information about their intended use.

Acknowledgments
This work was supported by the iDEaS (www.ideasproject.info) and ORCHID (www.orchid.ac.uk )
projects at the University of Southampton. David Parkes was supported in part through
the Harvard SEAS TomKat fund.

References
Babaioff, M., Blumrosen, L., & Roth, A. (2010). Auctions with online supply. In Proceedings
of the 11th ACM Conference on Electronic Commerce (EC‚Äô10), pp. 13‚Äì22.
227

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Bent, R., & Van Hentenryck, P. (2004). The value of consensus in online stochastic scheduling. In Proceedings of the 14th International Conference on Automated Planning and
Scheduling (ICAPS‚Äô04), pp. 219‚Äì226.
Bikhchandani, S., Chatterji, S., Lavi, R., Mu‚Äôalem, A., Nisan, N., & Sen, A. (2006). Weak
monotonicity characterizes deterministic dominant-strategy implementation. Econometrica, 74 (4), 1109‚Äì1132.
Blum, M., Floyd, R. W., Pratt, V., Rivest, R. L., & Tarjan, R. E. (1973). Time bounds for
selection. Journal of Computer and System Sciences, 7 (4), 448 ‚Äì 461.
Clement, K., Haesen, E., & Driesen, J. (2009). Coordinated charging of multiple plug-in hybrid electric vehicles in residential distribution grids. In Proceedings of the IEEE/PES
Power Systems Conference and Exposition (PSCE‚Äô09), pp. 1‚Äì7.
Constantin, F., Feldman, J., Muthukrishnan, S., & Pal, M. (2009). An online mechanism for
ad slot reservations with cancellations. In Proceedings of the ACM-SIAM Symposium
on Discrete Algorithms (SODA‚Äô09), pp. 1265‚Äì1274.
Constantin, F., & Parkes, D. C. (2009). Self-correcting sampling-based dynamic multi-unit
auctions. In Proceedings of 10th ACM Conference on Electronic Commerce (EC‚Äô09),
pp. 89‚Äì98.
Eberle, U., & von Helmolt, R. (2010). Sustainable transportation based on electric vehicle
concepts: a brief overview. Energy & Environmental Science, 3, 689‚Äì699.
Engel, Y., & Wellman, M. P. (2010). Multiattribute auctions based on generalized additive
independence. Journal of Artificial Intelligence Research (JAIR), 37, 479‚Äì525.
Fairley, P. (2010). Speed bumps ahead for electric-vehicle charging. IEEE Spectrum, 47 (1),
13‚Äì14.
Gerding, E., Stein, S., Robu, V., Zhao, D., & Jennings, N. R. (2013). Two-sided online
markets for electric vehicle charging. In Proceedings of 12th International Confernece
on Autonomous Agents and Multiagent Systems (AAMAS‚Äô13), pp. 989‚Äì996.
Gerding, E., Robu, V., Stein, S., Parkes, D., Rogers, A., & Jennings, N. (2011). Online
mechanism design for electric vehicle charging. In Proceedings of the 10th International
Conference on Autonomous Agents and Multi-Agent Systems (AAMAS‚Äô11), pp. 811‚Äì
818.
Gershkov, A., & Moldovanu, B. (2010). Efficient sequential assignment with incomplete
information. Games and Economic Behavior, 68 (1), 144‚Äì154.
Hajiaghayi, M., Kleinberg, R., Mahdian, M., & Parkes, D. C. (2005). Online auctions with
re-usable goods. In Proceedings of 6th ACM Conference on Electronic Commerce
(EC‚Äô05), pp. 165‚Äì174.
Huang, S., & Infield, D. (2010). The impact of domestic plug-in hybrid electric vehicles on
power distribution system loads. In Proceedings of the International Conference on
Power System Technology (POWERCON 2010), pp. 1‚Äì7.
Kamboj, S., Kempton, W., & Decker, K. S. (2011). Deploying power grid-integrated electric
vehicles as a multi-agent system. In Proceedings of the 10th International Conference
on Autonomous Agents and Multiagent Systems (AAMAS‚Äô11), pp. 13‚Äì20.
228

An Online Mechanism for Multi-Unit Demand

Lavi, R., & Nisan, N. (2004). Competitive analysis of incentive compatible on-line auctions.
Theoretical Computer Science, 310, 159‚Äì180.
Nisan, N., Roughgarden, T., Tardos, E., & Vazirani, V. (2007). Algorithmic Game Theory.
Cambridge University Press.
Parkes, D. C. (2007). Online mechanisms. In Nisan, N., Roughgarden, T., Tardos, E., &
Vazirani, V. (Eds.), Algorithmic Game Theory, pp. 411‚Äì439.
Parkes, D. C., & Duong, Q. (2007). An ironing-based approach to adaptive online mechanism design in single-valued domains. In Proceedings of the 22nd National Conference
on Artificial Intelligence (AAAI‚Äô07), pp. 94‚Äì101.
Parkes, D. C., & Singh, S. (2003). An MDP-based approach to online mechanism design. In Proceedings of the 17th Conference on Neural Information Processing Systems
(NIPS‚Äô03), pp. 791‚Äì798.
Pinedo, M. (2008). Scheduling: Theory, Algorithms, and Systems (3rd edition). Springer.
Porter, R. (2004). Mechanism design for online real-time scheduling. In Proceedings of the
5th ACM Conference on Electronic Commerce (EC‚Äô04), pp. 61‚Äì70.
Robu, V., Stein, S., Gerding, E., Parkes, D., Rogers, A., & Jennings, N. (2011). An online mechanism for multi-speed electric vehicle charging. In Proceedings of the 2nd
International Conference on Auctions, Market Mechanisms and their Applications
(AMMA‚Äô11), pp. 100‚Äì112.
Robu, V., Kota, R., Chalkiadakis, G., Rogers, A., & Jennings, N. R. (2012). Cooperative
virtual power plant formation using scoring rules. In Proceedings of the 22nd AAAI
Conference on Artificial Intelligence (AAAI‚Äô12).
Robu, V., Noot, H., La PoutreÃÅ, J. A., & van Schijndel, W. (2011). A multi-agent platform
for auction-based allocation of loads in transportation logistics. Expert Systems with
Applications, 38 (4), 3483‚Äì3491.
Sandholm, T. (2002). Algorithm for optimal winner determination in combinatorial auctions. Artificial Intelligence, 135 (1-2), 1‚Äì54.
Seuken, S., Parkes, D. C., Horvitz, E., Jain, K., Czerwinski, M., & Tan, D. (2012). Market user interface design. In Proceedings of the 13th ACM Conference on Electronic
Commerce, pp. 898‚Äì915. ACM.
Stein, S., Gerding, E., Robu, V., & Jennings, N. R. (2012). A model-based online mechanism
with pre-commitment and its application to electric vehicle charging. In Proceedings
of the 11th International Conference on Autonomous Agents and Multiagent Systems
(AAMAS‚Äô12), pp. 669‚Äì676.
Stein, S., Gerding, E., Rogers, A., Larson, K., & Jennings, N. R. (2011). Algorithms and
mechanisms for procuring services with uncertain durations using redundancy. Artificial Intelligence, 175, 2021‚Äì2060.
Sundstrom, O., & Binding, C. (2012). Flexible charging optimization for electric vehicles
considering distribution grid constraints. IEEE Transactions on the Smart Grid, 3 (1),
26‚Äì37.
229

Robu, Gerding, Stein, Parkes, Rogers & Jennings

Vasirani, M., & Ossowski, S. (2011). A computational monetary market for plug-in electric
vehicle charging. In Proceedings of the 2nd International Conference on Auctions,
Market Mechanisms and their Applications (AMMA‚Äô11), pp. 88‚Äì99.
Vytelingum, P., Voice, T., Ramchurn, S. D., Rogers, A., & Jennings, N. R. (2011). Theoretical and practical foundations of large-scale agent-based micro-storage in the smart
grid. Journal of Artificial Intelligence Research (JAIR), 42, 765‚Äì813.

230

Journal of Artificial Intelligence Research 48 (2013) 475-511

Submitted 04/13; published 11/13

Horn Clause Contraction Functions
James P. Delgrande

jim@cs.sfu.ca

School of Computing Science,
Simon Fraser University,
Burnaby, B.C., V5A 1S6
Canada

Renata Wassermann

renata@ime.usp.br

Dept. of Computer Science
University of SaÃÉo Paulo
05508-090 SaÃÉo Paulo,
Brazil

Abstract
In classical, AGM-style belief change, it is assumed that the underlying logic contains
classical propositional logic. This is clearly a limiting assumption, particularly in Artificial
Intelligence. Consequently there has been recent interest in studying belief change in approaches where the full expressivity of classical propositional logic is not obtained. In this
paper we investigate belief contraction in Horn knowledge bases. We point out that the
obvious extension to the Horn case, involving Horn remainder sets as a starting point, is
problematic. Not only do Horn remainder sets have undesirable properties, but also some
desirable Horn contraction functions are not captured by this approach. For Horn belief set
contraction, we develop an account in terms of a model-theoretic characterisation involving
weak remainder sets. Maxichoice and partial meet Horn contraction is specified, and we
show that the problems arising with earlier work are resolved by these approaches. As
well, constructions of the specific operators and sets of postulates are provided, and representation results are obtained. We also examine Horn package contraction, or contraction
by a set of formulas. Again, we give a construction and postulate set, linking them via a
representation result. Last, we investigate the closely-related notion of forgetting in Horn
clauses. This work is arguably interesting since Horn clauses have found widespread use in
AI; as well, the results given here may potentially be extended to other areas which make
use of Horn-like reasoning, such as logic programming, rule-based systems, and description
logics. Finally, since Horn reasoning is weaker than classical reasoning, this work sheds
light on the foundations of belief change.

1. Introduction
The area of belief change in knowledge representation studies how a rational agent may
alter its beliefs in the presence of new information. The best-known approach in this area
is the so-called AGM paradigm (AlchourroÃÅn, GaÃàrdenfors, & Makinson, 1985; GaÃàrdenfors,
1988), named after the original developers. This work focused primarily on two belief
change operations, belief contraction, in which an agent may reduce its stock of beliefs, and
belief revision, in which new information is consistently incorporated into the agent‚Äôs belief
corpus. A fundamental assumption of this approach is that the underlying logic governing
c
2013
AI Access Foundation. All rights reserved.

Delgrande & Wassermann

the agent‚Äôs beliefs subsumes classical propositional logic. However, in artificial intelligence
(AI) a major concern is with efficient, limited, and ideally tractable reasoning. Hence
there has been significant effort in studying limited reasoners, including Horn clause based
approaches, limited epistemic reasoning involving explicit belief (Lakemeyer & Levesque,
2000), and description logics (Baader, Calvanese, McGuiness, Nardi, & Patel-Schneider,
2007). Moreover, since a knowledge base will evolve, it is crucially important that change
in a knowledge base be managed in a principled fashion. However, the AGM approach
cannot be used as a guide to change in any approach, such as those mentioned above, that
does not subsume classical propositional logic.
In this paper we address belief change in the expressively-weak language of Horn clauses,
where a Horn clause can be written as a rule in the form a1 ‚àß a2 ‚àß ¬∑ ¬∑ ¬∑ ‚àß an ‚Üí a for n ‚â• 0,
and where a, ai (1 ‚â§ i ‚â§ n) are atoms. (Thus, expressed in conjunctive normal form,
a Horn clause will have at most one positive literal.) In our approach, an agent‚Äôs beliefs
are represented by a Horn clause knowledge base, and the input is a conjunction of Horn
clauses. We focus on belief contraction (and, later, operators related to contraction) in
which the agent‚Äôs stock of beliefs decreases.
The topic of Horn clause contraction (and the general topic of Horn belief change in
general) is interesting for several reasons. First, Horn clause reasoners constitute an important class of AI systems, and Horn clauses have found extensive use in artificial intelligence
and database theory, in areas such as logic programming, truth maintenance systems, and
deductive databases. Horn clause belief change also sheds light on the theoretical underpinnings of belief change, in that it weakens the assumption that the underlying logic contains
propositional logic. Hence results obtained here may be relevant to belief change in other
areas of limited reasoning. For example, approaches to explicit belief often derives much of
their inspiration from relevance logic (Anderson & Belnap Jr., 1975); and description logics,
while constituting fragments of classical first-order logic, nonetheless in many cases do not
support full propositional reasoning.1
Creignou, Papini, Pichler, and Woltran (2012) provide further motivation for the study
of belief change in tractable fragments of propositional logic:
In many applications, the language is restricted a priori. For instance, a rulebased formalization of expert knowledge is much easier to handle for standard
users. In case users want to revise some rules, they indeed expect that the
outcome is still in the easy-to-read format they are used to. Many fragments
of propositional logic allow for efficient reasoning methods. Suppose an agent
who frequently has to answer queries about his beliefs. This should be done
efficiently thus the beliefs are stored as a formula known to be in a tractable
class. In case the beliefs of the agent are undergoing a revision, it is desired that
the result of such an operation yields a formula in the same fragment. Hence,
the agent still can use the dedicated solving method he is equipped with for this
fragment. In case such changes are performed rarely, we do not bother whether
the revision itself can be performed efficiently, but it is more important that the
outcome can still be evaluated efficiently.
1. In fact, as Booth, Meyer, and Varzinczak (2009) point out, results here are also relevant to belief change
in description logics, a topic that has also elicited recent interest.

476

Horn Clause Contraction Functions

Horn clause contraction has become a topic of interest in belief change in recent years
(Delgrande, 2008; Delgrande & Wassermann, 2010, 2011; Booth et al., 2009; Booth, Meyer,
Varzinczak, & Wassermann, 2011; Zhuang & Pagnucco, 2010a, 2011, 2012). As we discuss
in the next section, most of this work centers on the notion of a remainder set, or a maximal
subset of a knowledge base that fails to imply a given formula. We show that remainder
sets in the Horn case are too restricted and cannot give all feasible contraction operators.
As well they yield contraction operators with undesirable properties.
We propose the notion of a weak remainder set that serves as a basis for generating
all Horn maxichoice contraction operators. Contraction is also considered in terms of the
underlying model theory, a viewpoint that proves highly enlightening for studying Horn
belief change. Given a specification for maxichoice contraction based on weak remainders,
we go on to develop a specification for partial meet Horn contractions, and consider package
contraction and forgetting. In all the contraction operators developed, we provide postulate
sets along with constructions, and show representation results. Consequently we present a
comprehensive exploration of the landscape of Horn contraction.
The next section introduces belief change while the following section discusses reasoning
in Horn clause theories. The main approach is presented in Section 4, while Section 5
discusses considerations pertaining to the supplementary contraction postulates. Section 6
covers the related operators of package contraction and forgetting on Horn theories. The
paper concludes with a discussion and a concluding section. Proofs are given in an appendix.
Some of this material was presented previously by Delgrande (2008) and Delgrande and
Wassermann (2010, 2011).

2. Background
In this section, we introduce the main concepts of the area of Belief Change which we will
need throughout the paper.
2.1 Belief Change
As previously mentioned, the AGM approach (AlchourroÃÅn et al., 1985; GaÃàrdenfors, 1988)
is the original and best-known approach to belief change.2 The goal in this approach is to
describe belief change at the knowledge level, that is, on an abstract level and independent of
how beliefs are represented and manipulated. Belief states are modelled by sets of sentences,
called belief sets, closed under the logical consequence operator of a logic that includes
classical propositional logic in a language L. Thus a belief set K satisfies the constraint:
If K logically entails œÜ then œÜ ‚àà K.
The central operators3 addressed are contraction, in which an agent reduces its set of beliefs,
and revision, in which an agent consistently incorporates a new belief. In revision, since the
new belief may be inconsistent with an agent‚Äôs beliefs, some beliefs may need to be dropped
in order to maintain a consistent set of beliefs. A third operator, belief expansion was also
2. As well, Peppas (2008) provides an excellent survey.
3. In this paper, we use the terms operator and f unction interchangeably when refering to belief change
operations.

477

Delgrande & Wassermann

introduced: For belief set K and formula œÜ, the expansion of K by œÜ, denoted K + œÜ, is
the deductive closure of K ‚à™ {œÜ}. Expansion captures the simplest form of belief change; it
can be reasonably applied when new information is consistent with a belief set
These operators are characterised by two means. On the one hand, a set of rationality
postulates for a belief change function may be provided; these postulates stipulate constraints that should govern any rational belief change function. On the other hand, specific
constructions for a belief change function are given. Representation results are then provided, showing that a set of rationality postulates exactly captures the operator given by a
particular construction.
We review these notions for belief contraction. Informally, the contraction of a belief set
by a formula is a belief set in which that formula is not believed. Formally, a contraction
function ‚àíÃá is a function from 2L √ó L to 2L satisfying the following postulates.
(K ‚àíÃá1) K ‚àíÃáœÜ is a belief set.
(K ‚àíÃá2) K ‚àíÃáœÜ ‚äÜ K.
(K ‚àíÃá3) If œÜ 6‚àà K, then K ‚àíÃáœÜ = K.
(K ‚àíÃá4) If 6` œÜ, then œÜ 6‚àà K ‚àíÃáœÜ.
(K ‚àíÃá5) If œÜ ‚àà K, then K ‚äÜ (K ‚àíÃáœÜ) + œÜ.
(K ‚àíÃá6) If œÜ ‚â° œà, then K ‚àíÃáœÜ = K ‚àíÃáœà.
(K ‚àíÃá7) K ‚àíÃáœÜ ‚à© K ‚àíÃáœà ‚äÜ K ‚àíÃá(œÜ ‚àß œà).
(K ‚àíÃá8) If œà 6‚àà K ‚àíÃá(œÜ ‚àß œà) then K ‚àíÃá(œÜ ‚àß œà) ‚äÜ K ‚àíÃáœà.
Thus, contraction yields a belief set (K ‚àíÃá1) in which the sentence for contraction œÜ is
not believed (unless œÜ is a tautology) (K ‚àíÃá4). No new sentences are believed (K ‚àíÃá2), and
if the formula is not originally believed then contraction has no effect (K ‚àíÃá3). The fifth
postulate, the so-called recovery postulate, states that nothing is lost if one contracts and
expands by the same sentence. This postulate is controversial, as discussed, for example
by Hansson (1999). The sixth postulate asserts that contraction is independent of how
a sentence is syntactically expressed. The last two postulates express relations between
contracting by conjunctions and contracting by the constituent conjuncts. Hence (K ‚àíÃá7)
says that if a formula is in the result of contracting by each of two formulas then it is in
the result of contracting by their conjunction. (K ‚àíÃá8) says that if a conjunct is not in the
result of contracting by a conjunction, then, in the presence of (K ‚àíÃá7), contracting by that
conjunct is the same as contracting by the conjunction. The first six postulates are referred
to as the basic postulates while the last two are referred to as the supplementary postulates.
Revision represents the situation in which new information may be inconsistent with
the reasoner‚Äôs beliefs K, and needs to be incorporated in a consistent manner, the one
exception being when the formula for revision itself is inconsistent. A revision function
‚àó is a function from 2L √ó L to 2L satisfying a set of postulates analogous to those for
contraction. Contraction is usually taken as being the more fundamental operator for belief
478

Horn Clause Contraction Functions

change. Moreover, revision and contraction are interdefinable. Revision can be defined in
terms of contraction by means of the Levi Identity:
K ‚àó œÜ = (K ‚àíÃá¬¨œÜ) + œÜ.

(1)

Thus, to revise by œÜ, make K consistent with œÜ then expand by œÜ. Contraction can be
similarly defined in terms of revision by the Harper identity:
K ‚àíÃáœÜ = K ‚à© (K ‚àó ¬¨œÜ).
Since we do not consider revision functions in this paper, we refer the reader to to the work
of GaÃàrdenfors (1988) and Peppas (2008) for details.
Various constructions have been proposed to characterise belief change. The original
construction was in terms of remainder sets, where a œÜ-remainder of K is a maximal subset
of K that fails to imply œÜ. Formally:
Definition 1 Let K ‚äÜ L and let œÜ ‚àà L.
K ‚Üì œÜ is the set of sets of formulas s.t. K 0 ‚àà K ‚Üì œÜ iff
1. K 0 ‚äÜ K
2. K 0 6` œÜ
3. For any K 00 s.t. K 0 ‚äÇ K 00 ‚äÜ K, it holds that K 00 ` œÜ.
Each K 0 ‚àà K ‚Üì œÜ is a œÜ-remainder of K.
Thus K ‚Üì œÜ is the class of all maximal œÜ-nonimplying subsets of K. When there is no
ambiguity, we will also refer to K 0 ‚àà K ‚Üì œÜ as simply a remainder of K.
Two classes of contraction functions are relevant for our concerns. In maxichoice contraction, contraction is defined to correspond to a single selected remainder. In partial meet
contraction, contraction corresponds to the intersection of some subset of the remainders.
Consequently, any maxichoice contraction is a partial meet contraction but not vice versa.
From a logical point of view, the œÜ-remainders comprise equally-good candidates for
a contraction of œÜ from K. Selection functions are introduced to reflect the extra-logical
factors that need to be taken into account, to obtain the ‚Äúbest‚Äù or most plausible remainders.
In maxichoice contraction, the selection function determines a single selected remainder as
the contraction. In partial meet contraction, the selection function returns a subset of the
remainders, the intersection of which constitutes the contraction. Thus if the selection
function is denoted by Œ≥(¬∑), then the contraction of K by formula œÜ can be expressed by
\
K ‚àíÃáœÜ =
Œ≥(K ‚Üì œÜ).
(2)
For belief set K and function ‚àíÃá from 2L √ó L to 2L , it proves to be the case that ‚àíÃá is a
partial meet contraction function iff it satisfies the basic contraction postulates (K ‚àíÃá1)‚Äì
(K ‚àíÃá6). Last, let  be a transitive relation on 2K , and let the selection function be defined
by:
Œ≥(K ‚Üì œÜ) = {K 0 ‚àà K ‚Üì œÜ | ‚àÄK 00 ‚àà K ‚Üì œÜ, K 00  K 0 }.
Œ≥ is a transitively relational selection function, and ‚àíÃá defined in terms of such a Œ≥ is a
transitively relational partial meet contraction function. Then we have:
479

Delgrande & Wassermann

Theorem 1 (AlchourroÃÅn et al., 1985) Let K be a belief set and let ‚àíÃá be a function from
2L √ó L to 2L . Then
1. ‚àíÃá is a partial meet contraction function iff it satisfies the contraction postulates
(K ‚àíÃá1)‚Äì(K ‚àíÃá6).
2. ‚àíÃá is a transitively relational partial meet contraction function iff it satisfies the contraction postulates (K ‚àíÃá1)‚Äì(K ‚àíÃá8).
The second major construction for contraction functions is called epistemic entrenchment. The general idea is that extra-logic factors related to contraction are given by an
ordering on formulas in the agent‚Äôs belief set, reflecting how willing the agent would be to
give up a formula. Then a contraction function can be defined in terms of removing less
entrenched formulas from the belief set. GaÃàrdenfors and Makinson (1988) show that for
logics including classical propositional logic, the two types of constructions, selection functions over remainder sets and epistemic entrenchment orderings, capture the same class of
contraction functions.
Two other constructions were also proposed in the literature and shown to be equivalent
to transitively relational partial meet contraction: safe contraction (Alchourron & Makinson, 1985; Rott, 1992) and systems of spheres (Grove, 1988). We do not address either
construction in this paper.
2.2 Belief Change and Horn Clause Theories
Earlier work on belief change and Horn theories focussed on specific aspects of the problem,
rather than on a general characterisation of Horn clause belief change. For example, the
complexity of specific approaches to revising knowledge bases has been addressed by Eiter
and Gottlob (1992). This includes the case where the knowledge base and formula for
revision are conjunctions of Horn clauses, although the results of revision may not be Horn.
Not unexpectedly, results are generally better in the Horn case. Liberatore (2000) considers
the problem of a compact representation for revision in the Horn case. Given a knowledge
base K and formula œÜ, both Horn, the main problem addressed is whether the knowledge
base, revised according to a given operator, can be expressed by a propositional formula
whose size is polynomial with respect to the sizes of K and œÜ.
Langlois, Sloan, SzoÃàreÃÅnyi, and TuraÃÅn (2008) approach the study of revising Horn formulas by characterising the existence of a complement of a Horn consequence; such a complement corresponds to the result of a contraction operator. This work may be seen as a specific
instance of a general framework developed by Flouris, Plexousakis and Antoniou (2004).
They study belief change under a broad notion of logic. In particular, they give a criterion
for the existence of a contraction operator satisfying the basic AGM postulates in terms of
decomposability.
The present paper builds on and extends (Delgrande, 2008; Delgrande & Wassermann,
2010, 2011). Delgrande (2008) addresses maxichoice belief contraction in Horn clause theories, where contraction is defined in terms of remainder sets, using Definition 1, but expressed in terms of derivations among Horn clauses. Booth, Meyer, and Varzinczak (2009)
and then Booth, Meyer, Varzinczak, and Wassermann (2011) further develop this area, by
480

Horn Clause Contraction Functions

considering other versions of contraction, all based on remainder sets: partial meet contraction, a generalisation of partial meet, and package contraction. Horn contraction based on
remainders was found to be inadequate by Delgrande and Wassermann (2010), and instead
they developed a notion of weak remainder. The work by Zhuang and Pagnucco (2010a,
2012) follows another line, focusing on epistemic entrenchment and model-based constructions. These approaches are discussed and compared in more detail once we have introduced
our overall approach.
Recently, revision operations for Horn theories have also been developed (Delgrande &
Peppas, 2011), and revision in other fragments of propositional logic has also been explored
(Creignou et al., 2012). However the relation of this work with the contraction operations
described in this paper is still unclear.

3. Horn Clause Theories
We will deal with languages based on finite sets of atoms, or propositional letters P =
{a, b, c, . . . }, where P includes the distinguished atom ‚ä•. L is the language of propositional
logic over P and with the usual connectives ¬¨, ‚àß, ‚à®, and ‚Üí.4 LHC is the restriction of L
to Horn formulas, where a Horn formula is a finite conjunction of Horn clauses. LHC is the
least set given by:
1. a1 ‚àß a2 ‚àß ¬∑ ¬∑ ¬∑ ‚àß an ‚Üí a, where n ‚â• 0, and a, ai (1 ‚â§ i ‚â§ n) are atoms, is a Horn clause.
2. Every Horn clause is a Horn formula.
3. If œÜ and œà are Horn formulas then so is œÜ ‚àß œà.
As well, for convenience, > will be taken as denoting a ‚Üí a for some specific atom a. For
a Horn clause r as in 1 above, if n = 0 then r is a fact, and ‚Üí a is also written as a.
For a Horn clause r as in 1 above, head(r) is a, and body(r) is the set {a1 , a2 , . . . , an }. If
a is a fact, then head(r) is a, and body(r) is empty. If for a Horn clause r we have that
head(r) = ‚ä•, then r is an integrity constraint. Allowing conjunctions of clauses, as given in
3, adds nothing of interest to the expressibility of the language with respect to reasoning.
However, it adds to the expressibility of contraction, as we are able to contract by more
than a single Horn clause.
Semantics: An interpretation of L is a function from P to {true, f alse} such that ‚ä•
is assigned f alse. Sentences of L are true or false in an interpretation according to the
standard rules of propositional logic. An interpretation M is a model of a sentence œÜ (or set
of sentences), written M |= œÜ, just if œÜ is true in M . M od(œÜ) is the set of models of formula
(or set of formulas) œÜ; thus M od(>) is the set of interpretations of L. An interpretation is
usually identified with the atoms true in that interpretation. Thus, for the language given by
P = {p, q, r, s}, the interpretation expressed by {p, q} is that in which p and q are true and
r and s are false. For convenience, we also will express interpretations by juxtaposition of
atoms. Thus the set of interpretations {{p, q}, {p}, {}} will usually be written as {pq, p, ‚àÖ}.
All of these notions are inherited by the corresponding Horn formula language LHC . A
key point concerning Horn theories is that such theories are characterised semantically by
4. To avoid clutter, and because no ambiguity results, we don‚Äôt parameterize L by P.

481

Delgrande & Wassermann

the fact that their models are closed under intersections of positive atoms in an interpretation. That is, a Horn theory H satisfies the constraint:
If M1 , M2 ‚àà M od(H) then M1 ‚à© M2 ‚àà M od(H).
This leads to the notion of the characteristic models (Khardon, 1995) of a Horn formula or
set of formulas: M is a characteristic model of formula œÜ just if for every M1 , M2 ‚àà M od(œÜ),
M1 ‚à© M2 = M implies that M = M1 or M = M2 . Thus for example, {p ‚àß q ‚Üí ‚ä•, r}
has models {pr, qr, r} and characteristic models {pr, qr}. Since pr ‚à© qr = r, r isn‚Äôt a
characteristic model of œÜ.
Proof Theory: We assume a suitable inference relation ` for classical propositional logic.
The following axioms and rules give an inference relation for Horn formulas, where for
simplicity, a and b, possibly subscripted, are taken as ranging over atoms.
Axioms:

‚ä•‚Üía

a‚Üía

Rules:
1. From a1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß an ‚Üí a and b1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß bn ‚Üí a1
infer b1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß bn ‚àß a2 ‚àß ¬∑ ¬∑ ¬∑ ‚àß an ‚Üí a
2. From a1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß an ‚Üí a infer a1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß an ‚àß b ‚Üí a
3. For Horn clauses r1 , r2 , if body(r1 ) = body(r2 ) and head (r1 ) = head (r2 ) then
from r1 infer r2 .
4. (a) From
(b) From

œÜ ‚àß œà infer œÜ and œà
œÜ and œà infer œÜ ‚àß œà

Rule 1 is an extended version of modus ponens, while Rule 2 is strengthening of the antecedent. Rule 3 states that the order of atoms in the body of a Horn clause is irrelevant,
as are repeated atoms.
A formula œà can be derived from a set of formulas A, written A `HC œà, just if œà can
be obtained from A by a finite number of applications of the above rules and axioms; for
simplicity we drop the subscript and write A ` œà. If A = {œÜ} is a singleton set then we
just write œÜ ` œà. A set of formulas A ‚äÜ LHC is inconsistent just if A ` ‚ä•. We use œÜ ‚â° œà
to represent logical equivalence, that is œÜ ` œà and œà ` œÜ.
Notation: We collect here for reference notation that is used in the paper. Lower-case
Greek characters œÜ, œà, . . ., possibly subscripted, denote arbitrary formulas of either L or
LHC . Upper case Roman characters A, B, . . . , possibly subscripted, denote arbitrary sets
of formulas. H, H1 , H 0 , etc. denote Horn belief sets, so that œÜ ‚àà H iff H `HC œÜ.
Cn(A) is the (classical, propositional) deductive closure of A where A is a formula or
set of formulas of propositional logic. Cnh (A) is the deductive closure of a Horn formula
or set of formulas A under Horn derivability. For set of formulas A, Horn(A) = {œÜ ‚àà A |
œÜ is a Horn formula}.
We use m (possibly subscripted) to denote a maximal consistent Horn theory; that
is, m 6` ‚ä• and for every Horn formula œÜ, either œÜ ‚àà m or m ‚à™ {œÜ} ` ‚ä•. Hence such a
482

Horn Clause Contraction Functions

m has exactly one model. We often use maximal consistent sets of formulas in place of
interpretations, as it makes the statement and proof of various results easier. |œÜ| is the set
of maximal, consistent Horn theories that contain œÜ.
M (M1 , M 0 , etc.) will denote (classical, propositional) interpretations over some understood language. M od(A) is the set of models of A. Arbitrary sets of interpretations will
be denoted M (M0 etc.). Cl‚à© (M) is the intersection closure of a set of interpretations M;
that is, Cl‚à© (M) is the least set of interpretations such that
1. M ‚äÜ Cl‚à© (M) and
2. M1 , M2 ‚àà Cl‚à© (M) implies that M1 ‚à© M2 ‚àà Cl‚à© (M).
Note that M denotes an interpretation expressed as a set of atoms, while m denotes
a maximal consistent set of Horn formulas. Thus the logical content is the same, in that
an interpretation defines a maximal consistent set of Horn formulas, and vice versa. We
retain these two interdefinable notations, since each is useful in the subsequent development.
Similar comments apply to M od(œÜ) vs. |œÜ|; we also make use of the fact that there is a 1-1
correspondence between elements of |œÜ| and of M od(œÜ).
Last, since P is finite, a (Horn or propositional logic) belief set may be finitely represented, that is, for X a belief set, there is a formula œÜ such that Cn(œÜ) = X.

4. Horn Clause Belief Set Contraction
In this section, we examine the possible constructions for the operation of contraction of
Horn belief sets. We begin by operations based on remainde sets and proceed to introducing
the concept of a weak remainder set.
4.1 Horn Clause Contraction and Remainder Sets
The most straightforward way to define a Horn contraction function is by adapting a construction used in classical logic for contraction. To this end, Delgrande (2008) developed a
remainder-set approach to Horn contraction, which was subsequently generalised by Booth,
Meyer and Varzinczak (2009). It proves to be the case that these approaches are not sufficiently expressive for general Horn contraction; as well, contraction based on remainder
sets can be shown to have undesirable properties. We review the pertinent aspects of these
approaches here, and in particular consider why the results of (classical, AGM) contraction
do not readily extend to the Horn case.
The definition of remainder sets for Horn clause belief sets (called e-remainder sets in
Delgrande, 2008) is the same as that for a remainder set (Definition 1) but with respect
to Horn clauses and Horn derivability. For H a Horn belief set and œÜ ‚àà LHC , the set of
e-remainders with respect to H and œÜ is denoted by H ‚Üìe œÜ.
Definition 2 Let H ‚äÜ LHC and let œÜ ‚àà LHC .
H ‚Üìe œÜ is the set of sets of formulas such that H 0 ‚àà H ‚Üìe œÜ iff
1. H 0 ‚äÜ H
2. H 0 6` œÜ
483

Delgrande & Wassermann

3. For any H 00 such that H 0 ‚äÇ H 00 ‚äÜ H it holds that H 00 ` œÜ.
Each H 0 ‚àà H ‚Üìe œÜ is an œÜ-e-remainder with respect to H.
Usually such a H 0 will just be referred to simply as a remainder, since the Horn context
and underlying formula are clear.
Observation 1 If H ‚Üìe œÜ1 = H ‚Üìe œÜ2 , then for any H 0 ‚äÜ H, œÜ1 ‚àà Cnh (H 0 ) iff œÜ2 ‚àà
Cnh (H 0 ).
Observation 2 (Upper bound property) If X ‚äÜ H and œÜ 6‚àà Cnh (X), then there is some
X 0 such that X ‚äÜ X 0 ‚àà H ‚Üìe œÜ.
Horn remainders as given in Definition 2 can be regarded as comprising a set of candidate
contractions for H by a formula œÜ; a single such remainder then could be selected as the
maxichoice contraction of H by œÜ. Booth, Meyer, and Varzinczak (2009) subsequently argue
that maxichoice contraction is not sufficient for an account of Horn contraction functions.
In classical AGM contraction, the set of partial meet contraction functions is defined by
taking the intersection of some of the remainders. However, Booth, Meyer, and Varzinczak
also argue that the set of Horn partial meet contractions is not sufficient to capture the full
range of possible contraction functions. Instead they define infra remainder sets, as follows:
Definition 3 For belief sets H and X, X ‚àà H ‚áìe œÜ5 iff there is some X 0 ‚àà H ‚Üìe œÜ such that
\

H ‚Üìe œÜ ‚äÜ X ‚äÜ X 0 .
The elements of H ‚áìe œÜ are the infra e-remainder sets of H with respect to œÜ.
Thus an infra e-remainder set is any belief set that contains the intersection of Horn remainders, and is contained in some Horn remainder. All e-remainder sets are clearly infra
e-remainder sets, as is the intersection of any set of e-remainder sets. That is:
T
Observation 3 Let H ‚äÜ LHC , œÜ ‚àà LHC , and let X ‚äÜ H ‚Üìe œÜ. Then ( X) ‚àà H ‚áìe œÜ.
Example 1 For P = {a, b, c}, let H = Cnh (a ‚àß b).
Consider candidates for H ‚àíÃá(a ‚àß b).
It can be verified that there are three remainder sets:
Cnh (a ‚àß (c ‚Üí b)),
Cnh (b ‚àß (c ‚Üí a)),
Cnh ((a

and

‚Üí b) ‚àß (b ‚Üí a) ‚àß (c ‚Üí a) ‚àß (c ‚Üí b)).

As well, any remainder set and any infra remainder set must contain the closure of
(c ‚Üí a) ‚àß (c ‚Üí b).
5. Booth, Meyer, and Varzinczak (2009) write X ‚àà H ‚áìe Œ¶ where Œ¶ is a set of Horn clauses.

484

Horn Clause Contraction Functions

To see the last part of the example, note that both (c ‚Üí a) and (c ‚Üí b) are in all remainders,
and so in the intersection of the remainders. This however leads to a significant blemish. Call
p inessential in H if for any conjunction of atoms body not containing p, H ` p ‚àß body ‚Üí a
implies that either ` p ‚àß body ‚Üí a or H ` body ‚Üí a. For contraction defined in terms
of remainder sets, or intersections of remainder sets, or infra remainder sets, we have the
result:6
Theorem 2 Let ‚àíÃá be a Horn contraction function defined via a selection function as in
(2) and based on (infra) remainder sets.
For œÜ ‚àà H and p inessential in H, we obtain that (H ‚àíÃáœÜ) + p ` œÜ.
The following example (based on an example in Hansson, 1999) illustrates the problem:
1. You believe Cleopatra had a son and a daughter (s ‚àß d).
2. You learn that the source of information was unreliable, so you remove this belief; i.e.
you compute the contraction H ‚àíÃá(s ‚àß d).
3. You learn that it is raining outside (r).
4. You conclude that Cleopatra had a son and daughter (s ‚àß d)
This behaviour is clearly undesirable. However, consider what this example implies
about Horn contraction to this point: We have that H ‚àíÃá(s ‚àß d) + r entails s ‚àß d. Hence,
regardless of how ‚àíÃá is defined in terms of (infra) remainders, all models of H ‚àíÃá(s ‚àß d) in
which r is true must have that s and d is also true. What this in turn means is that sdr
cannot be a model of any s ‚àß d-remainder. This last point is curious, in that sdr is clearly
a counter-model of s ‚àß d, yet it does not take part in any remainder, and so does not take
part in any contraction.
In AGM contraction, we have that each œÜ-remainder of a belief set K can be characterized by the set of models of K together with a single countermodel of œÜ, and vice versa
(e.g., see GaÃàrdenfors, 1988, p. 86). What the above example shows is that this equivalence
between the proof-theoretic notion of remainders and the semantic notion of minimallyextended sets of models breaks down in the Horn case.
So, consider what is going on in the Horn case: Assume that H |= œÜ and we wish to find a
maximal belief set H 0 such that H 0 ‚äÇ H and H 0 6|= œÜ. That is, H 0 is to be a œÜ-remainder set
of H. As described, in classical AGM (maxichoice) contraction, from the semantic side one
adds a countermodel of œÜ to the models of H; this set of models characterises a candidate
theory for maxichoice contraction.
Consider the analogous process for Horn theories. Since a remainder set must be a
Horn theory, and the models of a Horn theory are closed under intersection, we would
need to make sure that this constraint holds here. So, intuitively, to carry out maxichoice
Horn contraction, we would add a countermodel of the formula for contraction, and close
the result under intersection. However, the theories resulting from this approach do not
correspond to those obtained via remainder sets. To see this, consider again Example 1,
and where the pertinent results are summarised in Figure 1.
6. This result would also be obtained in package contraction, discussed in Section 6, if package contraction
were defined in terms of infra remainder sets.

485

Delgrande & Wassermann

countermodel
ac
a
bc
b
c
‚àÖ

induced
models
a
b
‚àÖ

resulting KB

remainder
set?

a
a ‚àß (c ‚Üí b)
b
b ‚àß (c ‚Üí a)
(a ‚Üí b) ‚àß (b ‚Üí a)
(a ‚Üí b) ‚àß (b ‚Üí a) ‚àß (c ‚Üí a) ‚àß (c ‚Üí b)

‚àö
‚àö
‚àö

Figure 1: Example: Candidates for Horn contraction
We have that ac (viz. abc) is a countermodel of œÜ = ab; this is given in the first entry
of the first row of the table. Since H has a model ab, the intersection of these models,
ab ‚à© ac = a must also be included; this is the item in the second column. The resulting
belief set is characterised by the interpretations M od(H) ‚à™ {ac, a} = {abc, ab, ac, a}, which
is the set of models of formula a, given in the third column. The result isn‚Äôt a remainder
set, since Cnh (a ‚àß (c ‚Üí b)) is a logically stronger belief set that fails to imply a ‚àß b. This last
belief set, Cnh (a ‚àß (c ‚Üí b)) appears in the second row of the table. It can be observed that
the models of this belief set is made up of the models of H together with the countermodel
a, that is, the ‚Äúinduced model‚Äù in the first row.
As previously noted, there are three remainder sets, as indicated in the last column.
As discussed, this result is problematic for the approaches of both Delgrande (2008) and
Booth, Meyer, and Varzinczak (2009). For example, in none of the approaches in these
papers is it possible to obtain H ‚àíÃáe (a ‚àß b) ‚â° a, nor is it possible to obtain H ‚àíÃáe (a ‚àß b) ‚â°
((a ‚Üí b) ‚àß (b ‚Üí a)). But these possibilities would be desirable as potential contractions.
The diagnosis of the problem is now presumably clear. In the example, and for the
countermodel given by abc, it is not possible to have a set of interpretations M satisfying:
1. M is closed under intersections
2. M = M od(H) ‚à™ abc
The solution also seems clear: From a semantic point of view, one wants the characteristic
models of maxichoice candidates for H ‚àíÃáe œÜ to consist of the characteristic models of H
together with a single interpretation from M od(>) \ M od(œÜ). The resulting theories, called
weak remainder sets, would correspond to the theories given in the third column in Figure 1;
we explore this notion in the next subsection.
To conclude we note that it has been shown that (maxichoice) contraction based on
remainder sets alone suffers from a triviality result analogous to that in AGM contraction.
Theorem 3 (Makinson, 2009) Let a ‚àà P be an atom, and let H be a Horn belief set with
a ‚Üí ‚ä• ‚àà H. Let ‚àíÃá be a maxichoice Horn contraction function based on remainder sets.
Then for every atom b, at least one of b and b ‚Üí ‚ä• is in H ‚àíÃá(a ‚Üí ‚ä•) + a.
Hence if a is false according to H, then contracting by a ‚Üí ‚ä• and then expanding by a
yields a belief set in which every atom is believed to be true or believed to be false. This is
clearly far too unrealistic to be useful.
486

Horn Clause Contraction Functions

4.2 Horn Clause Contraction and Weak Remainder Sets
The previous section showed that basing Horn contractions solely on remainder sets (or infra
remainder sets) is problematic. We then suggested that an adequate version of contraction
should be based on weak remainder sets where for belief set H and formula œÜ ‚àà H, there is
a 1-1 correspondence between countermodels of œÜ and weak remainder sets. In this section
we develop Horn contraction based on weak remainder sets. We first give two constructions
for weak remainder sets, in terms of belief sets and in terms of sets of models, and show
that the constructions are equivalent. We then characterise maxichoice Horn contraction in
terms of weak remainder sets, showing via a representation result that the characterisations
are equivalent. Following this we similarly characterise partial meet contraction.
Definition 4 Let H be a Horn belief set, and let œÜ be a Horn formula.
H‚Üì‚Üìe œÜ is the set of sets of formulas such that
1. If œÜ ‚àà H then: H 0 ‚àà H‚Üì‚Üìe œÜ iff H 0 = H ‚à© m for some m ‚àà |>| \ |œÜ|.
2. Otherwise H‚Üì‚Üìe œÜ = {H}.
H 0 ‚àà H‚Üì‚Üìe œÜ is a weak remainder set of H and œÜ.
Observation 4 If H 0 ‚àà H‚Üì‚Üìe œÜ, then H 0 is a belief set, i.e., H 0 = Cnh (H 0 ).
In the above definition, m is a maximal consistent set of formulas, and so corresponds
to the set of formulas true in some interpretation. In this case the underlying interpretation
would belong to M od(>)\M od(œÜ), which is to say that the underlying interpretation would
be a countermodel of œÜ.
Example 2 For P = {a, b, c}, let H = Cnh (a ‚àß b) and œÜ = a ‚àß b.
For m1 = Cnh (a ‚àß ¬¨b ‚àß ¬¨c) ‚àà |>| \ |œÜ|, we have H ‚à© m1 = Cnh (a ‚àß (c ‚Üí b)).
For m2 = Cnh (a ‚àß ¬¨b ‚àß c) ‚àà |>| \ |œÜ|, we have H ‚à© m2 = Cnh (a).
Note that (H ‚à© m2 ) ‚äÇ (H ‚à© m1 ), and also that full propositional closure gives Cn(H ‚à©
m2 ) = Cn(a ‚àß (b ‚à® c)).
The previous definition specifies weak remainder sets in terms of maximal consistent
sets of formulas. The next definition is similar, but is expressed directly in terms of countermodels of a formula.
Definition 5 Let H be a Horn belief set, and let œÜ be a Horn formula. Define H ||e œÜ by:
1. If œÜ ‚àà H then: H ||e œÜ is the set of sets of formulas such that H 0 ‚àà H ||e œÜ iff there is
M 6‚àà M od(œÜ) such that M od(H 0 ) = Cl‚à© (M od(H) ‚à™ {M }).
2. Otherwise H ||e œÜ = {H}.
In our running example, H ||e œÜ is given by the closure of the formulas in column 3 in
Figure 1.
Perhaps not surprisingly, these two characterisations prove to be equivalent:
487

Delgrande & Wassermann

Theorem 4 For H a Horn belief set and œÜ a Horn formula:
H‚Üì‚Üìe œÜ = H ||e œÜ.
We are now in a position to define a Horn contraction operator. We start by defining a
selection function, basically as is done in the AGM approach. Given a selection function, it
is straightforward to define a maxichoice contraction operator, and following this, a partial
meet contraction operator.
Definition 6 Let H be a Horn belief set. Œ≥ is a selection function for H if, for every
œÜ ‚àà LHC ,
1. If H‚Üì‚Üìe œÜ 6= ‚àÖ then ‚àÖ =
6 Œ≥(H‚Üì‚Üìe œÜ) ‚äÜ H‚Üì‚Üìe œÜ.
2. If H‚Üì‚Üìe œÜ = ‚àÖ then Œ≥(H‚Üì‚Üìe œÜ) = {H}.
Definition 7 Let Œ≥ be a selection function on H such that Œ≥(H‚Üì‚Üìe œÜ) = {H 0 } for some
H 0 ‚àà H‚Üì‚Üìe œÜ.
The maxichoice Horn contraction based on weak remainders is given by:
H ‚àíÃáw œÜ = Œ≥(H‚Üì‚Üìe œÜ)
Hence the result of a maxichoice contraction is characterised by a single weak remainder
set.
We obtain the following representation result, relating the construction to a postulate
set characterising contraction:
Theorem 5 Let H be a Horn belief set. Then ‚àíÃáw is an operator of maxichoice Horn
contraction based on weak remainders iff ‚àíÃáw satisfies the following postulates.
(H ‚àíÃáw 1) H ‚àíÃáw œÜ is a Horn belief set.

(closure)

(H ‚àíÃáw 2) If not ` œÜ, then œÜ 6‚àà H ‚àíÃáw œÜ.

(success)

(H ‚àíÃáw 3) H ‚àíÃáw œÜ ‚äÜ H.

(inclusion)

(H ‚àíÃáw 4) If œÜ 6‚àà H, then H ‚àíÃáw œÜ = H.

(vacuity)

(H ‚àíÃáw 5) If ` œÜ then H ‚àíÃáw œÜ = H

(failure)

(H ‚àíÃáw 6) If œÜ ‚â° œà, then H ‚àíÃáw œÜ = H ‚àíÃáw œà.

(extensionality)

(H ‚àíÃáw 7) If H 6= H ‚àíÃáw œÜ then ‚àÉŒ≤ ‚àà LHC such that {œÜ, Œ≤} ` ‚ä•, H ‚àíÃáw œÜ ‚äÜ Cnh (Œ≤) and ‚àÄH 0
s.t H ‚àíÃáw œÜ ‚äÇ H 0 ‚äÜ H we have H 0 ‚äÜ
6 Cnh (Œ≤).
(maximality)
The first four postulates and (H ‚àíÃáw 6) have obvious counterparts in the AGM contraction
postulates. Notably, we do not obtain the recovery postulate. The following provides a
counterexample.
488

Horn Clause Contraction Functions

Example 3 Let H = Cn(p ‚Üí q) and œÜ = p ‚àß r ‚Üí q.
Then H ‚àíÃáw œÜ 6` p ‚Üí q, since p ‚Üí q ` p ‚àß r ‚Üí q.
Thus H ‚àíÃáw œÜ can be at most Cn({p ‚àß r ‚àß i ‚Üí q | i ‚àà P \ {p, r}}.)
But H ‚àíÃáw œÜ + œÜ ‚äÜ Cn({p ‚àß r ‚àß i ‚Üí q | i ‚àà P \ {p, r}) + œÜ 6` p ‚Üí q
and hence H ‚àíÃáw œÜ + œÜ 6` p ‚Üí q.
Postulate (H ‚àíÃáw 5) is derivable using the AGM postulates, but relies on the recovery postulate (K ‚àíÃá5) for its proof. Since we lack the recovery postulate, it is required here as a
postulate, covering a special case, in its own right.
Postulate (H ‚àíÃáw 7) is more complicated than the others, but it expresses the basic defining characteristic for maxichoice revision: If contraction is nontrivial (viz. H 6= H ‚àíÃáw œÜ),
then some countermodel of œÜ is a model of H ‚àíÃáw œÜ. This is expressed by Œ≤, in that Œ≤ and œÜ
are mutually inconsistent, H ‚àíÃáw œÜ is a subset of the closure of Œ≤, and H ‚àíÃáw œÜ is a maximal
set of formulas for which this holds. This in turn means that, even though the recovery
postulate does not hold, nonetheless the trivial contraction, in which the entire belief set
is discarded, is excluded as a legal contraction operator. It can be verified that in Example 1 (see also Figure 1) that both countermodels abc and abc fulfill the conditions on Œ≤ in
(H ‚àíÃáw 7), which is to say, this postulate captures the notion of weak remainder set.
We turn next to partial meet Horn contraction. The definition for partial meet Horn
contraction is analogous to that in AGM contraction, but based on weak remainder sets:
Definition 8 Let Œ≥ be a selection function on H such that Œ≥(H‚Üì‚Üìe œÜ) ‚äÜ (H‚Üì‚Üìe œÜ).
The partial meet Horn contraction based on weak remainders is given by:
H ‚àíÃápm œÜ =

\

Œ≥(H‚Üì‚Üìe œÜ)

A representation result involves a modification of the last postulate for maxichoice contraction:
Theorem 6 Let H be a Horn belief set. Then ‚àíÃápm is an operator of partial meet Horn
contraction based on weak remainders iff ‚àíÃápm satisfies the postulates (H ‚àíÃáw 1) ‚Äì (H ‚àíÃáw 6)
and:
(H ‚àíÃápm 7) If Œ≤ ‚àà H \(H ‚àíÃápm œÜ), then there is some H 0 such that H ‚àíÃápm œÜ ‚äÜ H 0 , œÜ 6‚àà Cnh (H 0 )
and œÜ ‚àà Cnh (H 0 ‚à™ {Œ≤})
(weak relevance)
Example 4 For our running example, the partial meet given by the first and last weak
remainder sets in Figure 1 is given by
Cnh ((b ‚Üí a) ‚àß (c ‚Üí a)).
In terms of models, it is characterised by the models of a ‚àß b, together with the two countermodels given by atoms ac and ‚àÖ, and closed under intersections.
489

Delgrande & Wassermann

5. Supplementary Postulates
In this section we investigate how the different proposals for Horn contraction operations
behave with respect to the supplementary postulates (K ‚àíÃá7) and (K ‚àíÃá8). Throughout this
section, we assume all selection functions to be transitively relational.
First we consider the operation of Horn partial meet e-contraction (Delgrande, 2008).
The following example shows that, considering ‚Üìe as defined by Delgrande (see also Definition 2), Horn partial meet e-contraction does not satisfy (K ‚àíÃá7):
Example 5 Let H = Cnh ({a ‚Üí b, b ‚Üí c, a ‚Üí d, d ‚Üí c}).
We then have
H ‚Üìe (a ‚Üí c) = {H1 , H2 , H3 , H4 }
H ‚Üìe (b ‚Üí c) = {H5 }
where:
H1
H2
H3
H4
H5

= Cnh ({a ‚Üí b, a ‚Üí d}),
= Cnh ({a ‚Üí b, a ‚àß c ‚Üí d, d ‚Üí c}),
= Cnh ({b ‚Üí c, a ‚àß c ‚Üí b, a ‚Üí d}),
= Cnh ({a ‚àß c ‚Üí b, b ‚Üí c, a ‚àß c ‚Üí d, d ‚Üí c, a ‚àß d ‚Üí b, a ‚àß b ‚Üí d}), and
= Cnh ({a ‚Üí b, a ‚Üí d, d ‚Üí c})

Note that the two first elements of H ‚Üìe (a ‚Üí c) are subsets of the single element of
H ‚Üìe (b ‚Üí c) and hence, cannot belong to H ‚Üìe (a ‚Üí c ‚àß b ‚Üí c).
H ‚Üìe (a ‚Üí c ‚àß b ‚Üí c) = {H3 , H4 , H5 }
If we take a selection function based on a transitive relation between remainder sets that
gives priority in the order in which they appear in this example, i.e., H5 ‚â∫ H4 ‚â∫ H3 ‚â∫
H2 ‚â∫ H1 , we have:
H ‚àí (a ‚Üí c) = H1
H ‚àí (b ‚Üí c) = H5
H ‚àí (a ‚Üí c ‚àß b ‚Üí c) = H3
And we see that
H ‚àí (a ‚Üí c) ‚à© H ‚àí (b ‚Üí c) = H1 6‚äÜ H3 = H ‚àí (a ‚Üí c ‚àß b ‚Üí c)
The same example shows that the operation does not satisfy (K ‚àíÃá8):
a ‚Üí c 6‚àà H ‚àí (a ‚Üí c ‚àß b ‚Üí c) but H ‚àí (a ‚Üí c ‚àß b ‚Üí c) 6‚äÜ H ‚àí (a ‚Üí c).
If there are no further restrictions on the selection function, the same example also
shows that contraction based on infra-remainders does not satisfy the supplementary postulates. Note that each remainder set in the example is also an infra-remainder and that
the selection function always selects a single element. It suffices to assign all the remaining
infra-remainders lower priority.
Now we can show that the operation of partial meet based on weak remainders (PMWR)
has a better behaviour with respect to the supplementary postulates:
490

Horn Clause Contraction Functions

Theorem 7 Partial meet based on weak remainders and a transitive relational selection
function satisfies (K ‚àíÃá7) and (K ‚àíÃá8).
More recently, Zhuang and Pagnucco (2010a) have addressed Horn contraction from the
point of view of epistemic entrenchment. They compare AGM contraction via epistemic
entrenchment in classical propositional logic with contraction in Horn logics. A postulate
set is provided and shown to characterise entrenchment-based Horn contraction. The fact
that AGM contraction allows disjunctions of formulas, which in general will not be Horn, is
handled by considering Horn strengthenings in their postulate set, which is to say, logically
weakest Horn formulas that subsume the disjunction. In contrast to earlier work, their
postulate set includes equivalents to the supplemental postulates, and so goes beyond the
set of basic postulates. In more detail, Zhuang and Pagnucco (2010a) have the following:
Definition 9 For a given clause œÜ, the set of its Horn strengthenings (œÜ)H is the set such
that œà ‚àà (œÜ)H if and only if œà is a Horn clause and there is no Horn clause œà 0 such that
œà ‚äÇ œà 0 ‚äÜ œÜ.
Of the ten postulates given by Zhuang and Pagnucco (2010a) to characterize epistemic
entrenchment Horn contraction (EEHC), postulates (H ‚àíÃá1), (H ‚àíÃá2), (H ‚àíÃá4), (H ‚àíÃá6), (H ‚àíÃá7)
and (H ‚àíÃá8) correspond exactly to the AGM postulates with the same numbers. (H ‚àíÃá1),
(H ‚àíÃá2), (H ‚àíÃá3), (H ‚àíÃá4) and (H ‚àíÃá6) correspond to postulates (H ‚àíÃáw 1)-(H ‚àíÃáw 6) characterizing partial meet contraction based on weak remainders just defined. The three new postulates are:
(H ‚àíÃá5) If œà ‚àà H ‚àíÃáœÜ ‚àß œà then œà ‚àà H ‚àíÃáœÜ ‚àß œà ‚àß Œ¥
(H ‚àíÃá9) If œà ‚àà H \ H ‚àíÃáœÜ then ‚àÄœá ‚àà (œÜ ‚à® œà)H , œá 6‚àà H ‚àíÃáœÜ
(H ‚àíÃá10) If ‚àÄœá ‚àà (œÜ ‚à® œà)H , œá 6‚àà H ‚àíÃáœÜ ‚àß œà then œà 6‚àà H \ H ‚àíÃáœÜ
Subsequently, Zhuang and Pagnucco (2010b) have shown that transitively relational
PMWR as defined above is more general than EEHC. This means that any operation
satisfying their set of 10 postulates (which include (K ‚àíÃá7) and (K ‚àíÃá8)) is a PMWR. We
have seen that PMWR satisfies (K ‚àíÃá7) and (K ‚àíÃá8), hence, in order to compare PMWR and
EEHC, we need to know whether PMWR satisfies (H ‚àíÃá5), (H ‚àíÃá9) and (H ‚àíÃá10).
Theorem 8 PMWR satisfies (H ‚àíÃá5).
Zhuang (2012) has shown that weak relevance implies (H ‚àíÃá9), hence, PMWR satisfies
(H ‚àíÃá9). PMWR in general does not satisfy (H ‚àíÃá10), as the following example shows:
Example 6 Let H = Cnh ({a, b}).
Then we have
H‚Üì‚Üìe a = {H1 , H3 } and
H‚Üì‚Üìe (a ‚àß b) = {H1 , H2 , H3 },
where
491

Delgrande & Wassermann

H1 = Cnh ({b ‚Üí a, a ‚Üí b}),
H2 = Cnh ({a}) and
H3 = Cnh ({b}).
Assuming a selection function based on a transitive relation such that H1 ‚â∫ H2 and
H1 ‚â∫ H3 (and H2  H3 and H3  H2 ), we have
H ‚àí a = H3 and H ‚àí (a ‚àß b) = H2 ‚à© H3
Since (a‚à®b)H = {a, b}, we have that for any œá ‚àà (a‚à®b)H , œá 6‚àà H ‚àí(a‚àßb), but b ‚àà H ‚àía.

6. Other Operators
In this section we consider two contraction-like operators. The first, package contraction, is
like contraction, but it is defined with respect to a set of formulas. The second operator,
forget, can be regarded as a removal of an atom or set of atoms from the language of
discourse.
6.1 Package Contraction
In AGM-style belief change in propositional logic, given a belief set K and a set of formulas
Œ¶, the package contraction K ‚àíÃáp Œ¶ is a form of contraction in which no (non-tautological)
member of Œ¶ is in K ‚àíÃáp Œ¶. In propositional logic the effect of package contraction may be
nearly, but not quite, obtained by contracting by the disjunction of elements in Œ¶. To see
the difference, consider where Œ¶ = {œÜ, œà}. Clearly, œÜ ‚à® œà 6‚àà K ‚àíÃá(œÜ ‚à® œà) whereas it seems
that a ‚Äúsimultaneous contraction‚Äù K ‚àíÃáp {œÜ, œà} should allow for the possibility of œÜ ‚à® œà being
true in the outcome.
As Booth, Meyer, and Varzinczak (2009) note, package contraction is of interest in Horn
clause theories, given the limited expressivity of such theories. That is, if œÜ, œà are Horn
formulas, H ‚àíÃá(œÜ ‚à® œà) will be undefined whenever œÜ ‚à® œà is non-Horn (which, of course, will
be most of the time). On the other hand, expressing a contraction of both œÜ and œà by
H ‚àíÃáp {œÜ, œà} seems to be perfectly fine.
Our development of Horn package contraction is analogous to that of maxichoice Horn
contraction based on weak remainders. Essentially, for a package contraction H ‚àíÃáp Œ¶, we
ensure that for each œÜ ‚àà Œ¶ a countermodel of œÜ is among the models of H ‚àíÃáp Œ¶.
Definition 10 Let H be a Horn belief set, and let Œ¶ = {œÜ1 , . . . , œÜn } be a finite7 set of Horn
formulas.
H‚Üì‚Üìp Œ¶ is the set of sets of formulas such that H 0 ‚àà H‚Üì‚Üìp Œ¶ iff
For every 1 ‚â§ i ‚â§ n, ‚àÉmi such that:
if 6` œÜi and œÜi ‚àà H then mi ‚àà |>| \ |œÜi |; otherwise mi = LHC ;
T
and H 0 = H ‚à© ni=1 mi .
In the next definition, the notion of a selection function on H (Definition 6) is extended in
the obvious fashion to apply to a set of Horn formulas.

7. Since we assume that the underlying language is finite, any set of formulas will be equivalent to a finite
set of formulas, under logical equivalence of formulas.

492

Horn Clause Contraction Functions

Definition 11 Let Œ≥ be a selection function on H such that Œ≥(H‚Üì‚Üìp Œ¶) = {H 0 } for some
H 0 ‚àà H‚Üì‚Üìp Œ¶.
The (maxichoice) package Horn contraction based on weak remainders is given by:
H ‚àíÃáp Œ¶ = Œ≥(H‚Üì‚Üìp Œ¶)
if ‚àÖ =
6 Œ¶ ‚à© H 6‚äÜ Cnh (>); and H otherwise.
The following result relates elements of H‚Üì‚Üìp Œ¶ to weak remainders.
Theorem 9 Let H be a Horn belief set and let Œ¶ = {œÜ1 , . . . , œÜn } be a set of Horn formulas
where for 1 ‚â§ i ‚â§ n we have 6` œÜi .
T
Then H 0 ‚àà H‚Üì‚Üìp Œ¶ iff for 1 ‚â§ i ‚â§ n there are Hi ‚àà H‚Üì‚Üìe œÜi and H 0 = ni=1 Hi .
It follows immediately from this that any maxichoice Horn contraction defines a package
contraction, and vice versa.
Corollary 1 Let ‚àíÃáp be an operator of maxichoice Horn package contraction. Then
H ‚àíÃáœÜ = H ‚àíÃáp Œ¶

for Œ¶ = {œÜ}

is an operator of maxichoice Horn contraction based on weak remainders.
Corollary 2 Let ‚àíÃá be an operator of maxichoice Horn contraction based on weak remainders. Then
\
H ‚àíÃáp Œ¶ =
H ‚àíÃáœÜ
œÜ‚ààŒ¶

is an operator of maxichoice Horn package contraction.
Example 7 Consider the Horn belief set H = Cnh ({a, b}) over P = {a, b, c}. We want to
determine elements of
H‚Üì‚Üìp Œ¶ = Cnh ({a, b})‚Üì‚Üìp {a, b}.
There are a total of 14 elements in H‚Üì‚Üìp Œ¶ and so 14 candidate package contractions. These
candidates can be described as follows:
1. There are 4 countermodels of a, given by:
A = {bc, b, c, ‚àÖ}.
Thus there are four weak remainders corresponding to these countermodels, and so
four candidates for maxichoice Horn contraction by a.
2. Similarly there are 4 countermodels of b:
B = {ac, a, c, ‚àÖ}.
493

Delgrande & Wassermann

3. Members of H‚Üì‚Üìp Œ¶ are given by
Cl‚à© (M od(H) ‚à™ {x} ‚à™ {y})
for x ‚àà A and y ‚àà B.
For example, for x = bc, y = ‚àÖ, we have that Cl‚à© (M od(H) ‚à™ {x} ‚à™ {y}) = {abc, ab, bc, b, ‚àÖ},
which is the set of models of (c ‚Üí b) ‚àß (a ‚Üí b).
For x = bc, y = ac, we have that Cl‚à© (M od(H) ‚à™ {x} ‚à™ {y}) = Cnh (>); this holds for
no other choice of x and y.
What this example indicates informally is that there is a great deal of choice with respect
to candidates for package contraction. To some extent, such a combinatorial explosion of
possibilities is to be expected, given the fact that a formula will in general have a large
number of countermodels, and that this is compounded by the fact that each formula in a
package contraction will be associated with its own countermodel. However, it can also be
noted that some candidate package contractions contain redundancies, in that a selected
countermodel of a may also be a countermodel of b, in which case there seems to be no
reason to allow the possible incorporation of a separate countermodel of b. Consequently,
we also consider versions of package contraction that in some sense yield a maximal belief
set. However, first we provide results regarding package contraction.
We have the following result:
Theorem 10 Let H be a Horn belief set. Then ‚àíÃáp is an operator of maxichoice Horn
package contraction based on weak remainders iff ‚àíÃáp satisfies the following postulates:
(H ‚àíÃáp 1) H ‚àíÃáp Œ¶ is a belief set.

(closure)

(H ‚àíÃáp 2) For œÜ ‚àà Œ¶, if not ` œÜ, then œÜ 6‚àà H ‚àíÃáp Œ¶

(success)

(H ‚àíÃáp 3) H ‚àíÃáp Œ¶ ‚äÜ H

(inclusion)

(H ‚àíÃáp 4) H ‚àíÃáp Œ¶ = H ‚àíÃáp (H ‚à© Œ¶)

(vacuity)

(H ‚àíÃáp 5) H ‚àíÃáp Œ¶ = H ‚àíÃáp (Œ¶ \ Cnh (>))

(failure)

(H ‚àíÃáp 5b) H ‚àíÃáp ‚àÖ = H

(triviality)

(H ‚àíÃáp 6) If œÜ ‚â° œà, then
H ‚àíÃáp (Œ¶ ‚à™ {œÜ}) = H ‚àíÃáp (Œ¶ ‚à™ {œà})

(extensionality)

(H ‚àíÃáp 7) If H 6= H ‚àíÃáp Œ¶ then for
Œ¶0 = (Œ¶ \ Cnh (>)) ‚à© H = {œÜ1 , . . . , œÜn }
there is ‚àÜ = {Œ≤1 , . . . , Œ≤n } where for 1 ‚â§ i ‚â§ n,
{œÜi , Œ≤i } ` ‚ä• and H ‚àíÃáp Œ¶ ‚äÜ Cnh (Œ≤i ) and
‚àÄH 0 s.t H ‚àíÃáp Œ¶ ‚äÇ H 0 ‚äÜ H, ‚àÉŒ≤ ‚àà ‚àÜ such that H 0 6‚äÜ Cnh (Œ≤)
494

(maximality)

Horn Clause Contraction Functions

With the exception of the last postulate, these postulates are clear and reasonable: As
usual, the result of package contraction is a belief set (H ‚àíÃáp 1). Moreover, each non-tautology
in a set Œ¶ is not believed following contraction (H ‚àíÃáp 2), and no formulas are added (H ‚àíÃáp 3).
Contracting a formula not originally in H has no effect on the contraction (H ‚àíÃáp 4), as does
attempting to contract a tautology (H ‚àíÃáp 5). An empty contraction unsurprisingly has no
effect (H ‚àíÃáp 5b). As in other knowledge-level accounts, contraction is independent of the
syntactic expression of formulas to be contracted (H ‚àíÃáp 6). The last postulate (H ‚àíÃáp 7)
corresponds to the maximality postulate for contraction based on weak remainders. If a
package contraction H ‚àíÃáp Œ¶ is nontrivial then each of the nontautologies in Œ¶ that appear
in H satisfy the same maximality condition as the formula for contraction does for regular
Horn contraction based on weak remainder sets. That is, package contraction essentially
extends contraction to a set of formulas. This result is to be expected, given Theorem 9
which related elements of H‚Üì‚Üìp Œ¶ to weak remainders.
As discussed, a characteristic of maxichoice package contraction is that there are a large
number of members of H‚Üì‚Üìp Œ¶, some of which may be logically quite weak. However it proves
to be the case that we can eliminate some candidates via pragmatic concerns. We have that
a package contraction H ‚àíÃáp Œ¶ is a belief set H 0 ‚àà H‚Üì‚Üìp Œ¶ such that, informally, models of H 0
contain a countermodel for each œÜi ‚àà Œ¶ along with models of H. In general, some interpretations will be countermodels of more than one member of Œ¶, T
and so pragmatically, one can
select minimal sets of countermodels. Hence
in
the
case
that
i (M od(>) \ M od(œÜi )) 6= ‚àÖ, a
T
single countermodel, that is some m ‚àà i (M od(>) \ M od(œÜi )), would be sufficient to yield
a package contraction.
T
Now, it may be that i (M od(>) \ M od(œÜi )) is empty. A simple example illustrates this
case:
Example 8 Let H = Cnh (a ‚Üí b, b ‚Üí a) where P = {a, b}. Then H ‚àíÃáp {a ‚Üí b, b ‚Üí a} =
Cnh (>). That is, the sole countermodel of a ‚Üí b is {a} while that of b ‚Üí a is {b}. The
intersection closure of these interpretations with those of H is {ab, a, b, ‚àÖ} = M od(>).
Informally one can get around this by simply selecting a minimal set of models such that
a countermodel of each member of Œ¶ is in the set. These considerations yield the following
definition:
Definition 12 Let H be a Horn belief set, and let Œ¶ = {œÜ1 , . . . , œÜn } be a set of Horn
formulas.
HS(Œ¶), the set of (minimal) hitting sets of interpretations with respect to Œ¶, is defined
by:
S ‚àà HS(Œ¶) iff
1. S ‚äÜ |>|
2. For every 1 ‚â§ i ‚â§ n where 6` œÜi and œÜi ‚àà H, S ‚à© (|>| \ |œÜi |) 6= ‚àÖ
3. For S 0 ‚äÇ S, S 0 ‚à© (|>| \ |œÜi |) = ‚àÖ for some 1 ‚â§ i ‚â§ n.
Thus we look for sets of sets of interpretations; elements of such a set S are interpretations represented as maximal consistent sets of formulas (Condition 1). As well, this set S
495

Delgrande & Wassermann

contains a countermodel for each member of Œ¶ (Condition 2) and moreover S is a subsetminimal set that satisfies these conditions (Condition 3). Thus S ‚àà HS(Œ¶) corresponds to
a minimal set of countermodels of members of Œ¶. As an aside, it can be noted that the
notion of a hitting set is not new in general (Garey & Johnson, 1979) nor in AI (Reiter,
1987).
Definition 13 H‚Üì‚Üìph Œ¶ is the set of sets of formulas such that
T
H 0 ‚àà H‚Üì‚Üìph Œ¶ iff H 0 = H ‚à© m‚ààS for some S ‚àà HS(Œ¶).
Definition 14 Let Œ≥ be a selection function on H such that Œ≥(H‚Üì‚Üìph Œ¶) = {H 0 } for some
H 0 ‚àà H‚Üì‚Üìph Œ¶.
Define:
H ‚àíÃáph Œ¶ = Œ≥(H‚Üì‚Üìph Œ¶)
if ‚àÖ =
6 Œ¶ ‚à© H 6‚äÜ Cnh (>); and H otherwise.
The following result follows straightforwardly.
Theorem 11 H ‚àíÃáph Œ¶ is an operator of maxichoice Horn package contraction.
Example 9 Consider the case where H = Cnh (a, b), P = {a, b, c}.
1. Let Œ¶ = {a, b}.
It can be verified that the hitting sets are given by:
{ {ac, bc}, {a, bc}, {ac, b}, {a, b}, {c}, {} }
The corresponding elements of H‚Üì‚Üìph Œ¶ are given by:
H‚Üì‚Üìph Œ¶ = { Cnh (>),
Cnh (c ‚Üí a),
Cnh (c ‚Üí b),
Cnh (c ‚Üí a, c ‚Üí b),
Cnh (a ‚Üí b, b ‚Üí a),
Cnh (a ‚Üí b, b ‚Üí a, c ‚Üí a, c ‚Üí b) }.
Compare this with Example 7, where we have 14 candidate package contractions.
2. Let Œ¶ = {a, a ‚àß b}. We obtain that
H‚Üì‚Üìph Œ¶ = { Cnh (b),
Cnh (b ‚àß (c ‚Üí a)),
Cnh (a ‚Üí b, b ‚Üí a),
Cnh (a ‚Üí b, b ‚Üí a, c ‚Üí a, c ‚Üí b) }.
496

Horn Clause Contraction Functions

Any set of formulas that satisfies Definition 13 clearly also satisfies Definition 11. One
can further restrict the set of candidate package contractions by replacing S 0 ‚äÇ S by |S 0 | <
|S| in the third part of Definition 12. In this case, the package contraction in Example 9,
Part 1 would yield just the two candidates Cnh (a ‚Üí b, b ‚Üí a) and Cnh (a ‚Üí b, b ‚Üí a, c ‚Üí
a, c ‚Üí b). As well, of course, one could continue in the obvious fashion to define a notion of
partial meet Horn package contraction. Given the limited use of such an operator, we omit
the details.
6.2 Forgetting in Horn Formulas
This section examines another means of removing beliefs from an agent‚Äôs belief set, that
of forgetting (Lin & Reiter, 1994; Lang & Marquis, 2002). Forgetting is an operation on
belief sets and atoms of the language; the result of forgetting an atom can be regarded as
decreasing the language by that atom.
In addressing forgetting, it will be easier to work with a set of Horn clauses, rather
than Horn formulas. Since there is no confusion, we will freely switch between sets of Horn
clauses and the corresponding Horn formula comprising the conjunction of clauses in the
set. Thus any time that a set appears as an element in a formula, it can be understood
as standing for the conjunction of members
of the V
set. Thus for sets of clauses S1 and
V
S2 , S1 ‚à® S2 will stand for the formula ( œÜ‚ààS1 œÜ) ‚à® ( œÜ‚ààS2 œÜ). Of course, all such sets are
guaranteed to be finitely representable, since our language is finite.
We introduce the following notation for this section, where S is a set of Horn clauses,
and > is now taken as a distinguished atom true in all interpretations.
‚Ä¢ For t ‚àà {‚ä•, >}, S[p/t] is the result of uniformly substituting t for atom p in every
œÜ ‚àà S.
‚Ä¢ S‚Üìp = {œÜ ‚àà S | p does not occur in œÜ}
Assume without loss of generality that for Horn clause œÜ ‚àà S, that head (œÜ) 6‚àà body(œÜ).
The following definition adapts the standard definition, attributed to George Boole, to
forgetting in Horn clauses.
Definition 15 For set of Horn clauses S and atom p, define f orget(S, p) to be S[p/‚ä•] ‚à®
S[p/>].
This is not immediately useful for us, since a disjunction is generally not Horn. However, the
next result shows that this definition nonetheless leads to a Horn-definable forget operator.
Recall that for clauses c1 and c2 , expressed as sets of literals where p ‚àà c1 and ¬¨p ‚àà c2 , that
the resolvent of c1 and c2 is the clause (c1 \ {p}) ‚à™ (c2 \ {¬¨p}). As well, recall that if c1 and
c2 are Horn, then so is their resolvent.
In the following, Res(S, p) is the set of Horn clauses obtained from S by carrying out
all possible resolutions with respect to p.
Definition 16 Let S be a set of Horn clauses and p an atom. Define
Res(S, p) = {œÜ | ‚àÉœÜ1 , œÜ2 ‚àà S such that
p ‚àà body(œÜ1 ) and p = head (œÜ2 ), and
œÜ = (body(œÜ1 ) \ {p} ‚à™ body(œÜ2 )) ‚Üí head (œÜ1 )}
497

Delgrande & Wassermann

Theorem 12 f orget(S, p) ‚â° S‚Üìp ‚à™ Res(S, p).
Corollary 3 Let S be a set of Horn clauses and p an atom. Then f orget(S, p) is equivalent
to a set of Horn clauses.
Corollary 4 Let S1 and S2 be sets of Horn clauses and p an atom. Then S1 ‚â° S2 implies
that f orget(S1 , p) ‚â° f orget(S2 , p).
There are several points of interest about these results. The theorem is expressed in
terms of arbitrary sets of Horn clauses, and not just deductively-closed Horn belief sets.
Hence the second corollary states a principle of irrelevance of syntax for the case for forgetting for belief bases. As well, the expression S‚Üìp ‚à™ Res(S, p) is readily computable, and so
the theorem in fact provides a means of computing f orget. Further, the approach clearly
iterates for more than one atom. We obtain the additional result:8
Corollary 5
f orget(f orget(S, p), q) ‚â° f orget(f orget(S, q), p).
Given this, we can define for a set of atoms A that f orget(S, ‚àÖ) = S and that
f orget(S, A) = f orget(f orget(S, a), A \ {a})
where a ‚àà A. On the other hand, forgetting an atom may result in a quadratic blowup of
the knowledge base.
Finally, it might seem that the approach allows for the definition of a revision operator
‚Äî and a procedure for computing a revision ‚Äî by using something akin to the Levi Identity.
Let A(œÜ) be the set of atoms appearing in (formula or set of formulas) œÜ. Then:
def

FRevise(S, œÜ) = f orget(S, A(œÜ)) + œÜ.
In fact, this does yield a revision operator, but an operator that in general is far too drastic
to be useful. To see this, consider a taxonomic knowledge base which asserts that whales
are fish, whale ‚Üí f ish. Of course, whales are mammals, but in using the above definition
to repair the knowledge base, one would first forget all knowledge involving whales, for
example, that whales have fins, breathe air, give live birth, and so on. Such an example
doesn‚Äôt prove that there are no reasonable revision operators definable via forget, but it does
show that a naƒ±Ãàve approach is problematic. Moreover, these problems are not particular to
Horn formulas, but rather any revision operator defined in terms of forgetting with respect
to any underlying logic would be similarly problematic.

7. Comparison among Constructions for Horn Contraction
This section provides a technical summary of the differences between the various contraction
operations defined on Horn belief sets:
‚Ä¢ Every e-remainder is a weak remainder, but the converse is not true.
8. In fact, this is an easy consequence of the definition of forget.

498

Horn Clause Contraction Functions

This is clearly seen in Figure 1. For a Horn theory H and formula œÜ, the e-remainders are the
maximal subsets of H that do not imply œÜ. The weak remainders are characterised by the
models of H together with a single countermodel of œÜ, and then closed under intersection.
In propositional logic these notions would coincide; here they do not. As well, this means
that weak remainders and partial meet are distinct notions, the latter corresponding to
intersections of weak remainders.
Similarly, we obtain the following:
‚Ä¢ Every e-remainder is an infra-remainder, but the converse is not true.
This is clear from Definition 3, and illustrated in Example 1.
We also have:
‚Ä¢ Not all infra-remainders are weak-remainders.
Looking again at Figure 1, we see that the set Cnh ({c ‚Üí a, c ‚Üí b, a ‚Üí b}) is an infraremainder but not a weak remainder. It can however be obtained as the intersection of two
remainders.
Consider Example 3.2 presented by Booth, Meyer and Varzinczak (2009), where H =
h
Cn ({p ‚Üí q, q ‚Üí r}) and one wants to contract by p ‚Üí r: In this case, the weak remainders
coincide with the remainders. The set {p ‚àß q ‚Üí r, p ‚àß r ‚Üí q} is an infra-remainder and
cannot be obtained as the intersection of weak-remainders. The authors claim that this set
is a desirable result of the contraction, but do not give any strong motivation.
Last, we have:
‚Ä¢ Not all weak remainders are infra-remainders.
Infra-remainders, by definition, must contain full-meet and be contained in some remainder.
Weak remainders are contained in some remainder (or are a remainder) but do not always
contain full meet, as can be seen in the table in Figure 1. Full-meet in that example would
contain {c ‚Üí a, c ‚Üí b} and there are two weak remainders (Cnh (a) and Cnh (b)) which do
not contain both formulas.
The last two items show that weak remainders and infra-remainders are independent
concepts and their relation should be studied in more detail. These various relations are
illustrated in Figure 2.

weak remainders

e‚àíremainders

Figure 2
499

infra remainders

Delgrande & Wassermann

The aforecited example of Booth, Meyer, and Varzinczak (2009) raises another point
that deserves attention: For H = Cnh ({p ‚Üí q, q ‚Üí r}), we have H ‚Üìe (p ‚Üí r) = H‚Üì‚Üìe (p ‚Üí
r) = {Cnh ({p ‚Üí q}), Cnh ({q ‚Üí r, p ‚àß r ‚Üí q})}. There is an asymmetry here ‚Äì while
it is possible to obtain Cnh ({p ‚Üí q}) as the result of contraction, e-remainders, weak
remainders or infra-remainders do not allow for Cnh ({q ‚Üí r}) as a possible outcome. This
has motivated the study of Horn belief base contraction (Delgrande & Wassermann, 2010),
where one may obtain Cnh ({q ‚Üí r}), and where we think we may find other interesting
alternatives.
Zhuang and Pagnucco have studied several forms of Horn Contraction, such as the
Epistemic Entrenchment Horn Contraction (EEHC) mentioned earlier (2010a), Transitively
Relational Partial-Meet Horn Contraction (TRPMHC) (2011) and Model-based Horn Contraction (MHC) (2012). These different operations are compared by Zhuang (2012). Partial
meet based on weak remainders is more general than EEHC and MHC. However, when the
selection function is required to be transitively relational, we obtain TRPMHC, which is
equivalent to MHC.

8. Conclusion
In this paper we have explored belief contraction, and operators related to belief contraction,
with respect to Horn theories. In the AGM approach there are two principal means of
constructing contraction functions, via remainders or maximal subsets of a belief set that fail
to imply a formula, and epistemic entrenchment, which incorporates a preference ordering
on formulas. Here we focus on Horn contraction functions that can be defined by remainderlike constructions.
It proves to be the case that basing contraction directly on remainder sets, yielding what
we call e-remainders, is problematic, in that the resulting approach is inexpressive and has
undesirable properties. We also show that an alternative that has been proposed, of infra
remainders suffers from the same problems. Based on an examination of model-theoretic
considerations we developed an account of maxichoice Horn contraction in terms of weak
remainder sets. The idea here is that the models of a contraction of a Horn belief set H by
a Horn formula œÜ are given by the models of H together with a countermodel of œÜ, closed
under intersection (so as to yield a Horn theory). We then provided representation results
for maxichoice Horn contraction as well as partial meet contraction, and compared them to
other proposals in the literature.
We also study two other kinds of operators for giving up beliefs in Horn theories: package
contraction and forgetting. The former involves contracting by a set of formulas, so that no
formula in the set is believed, Again, we give a construction and postulate set, along with
a corresponding representation result. The second operator, forgetting, can be thought of
as a shrinking of the language of discourse.
This work is interesting since Horn clauses have found widespread use in areas such
as logic programming, rule-based systems, deductive databases, and description logics. As
well, since Horn reasoning is weaker than classical reasoning, this work sheds light on the
foundations of belief change. A natural topic for future work is to consider Horn revision
operators and study their relation to Horn contraction. A second topic for future work is
to consider belief change in other logics which do not contain classical propositional logic.
500

Horn Clause Contraction Functions

Acknowledgments
The first author was partially supported by a Canadian NSERC Discovery Grant. The
second author was partially supported by the Brazilian National Research Council (CNPq),
through grants 304043/2010-9 and 471666/2010-6. We thank Tommie Meyer, Marcio
Ribeiro, David Makinson, and the anonymous reviewers for their helpful comments.

Appendix A. Proofs of the Main Results
Theorem 2: Let ‚àíÃá be a Horn contraction function defined via a selection function as in
(2) and based on (infra) remainder sets.
For œÜ ‚àà H and p inessential in H, we obtain that (H ‚àíÃáœÜ) + p ` œÜ.
Proof: Let œÜ = œÜ1 ‚àß ¬∑ ¬∑ ¬∑ ‚àß œÜn where each œÜi is a Horn clause. For Horn conjunct œÜi of œÜ,
we have H ‚àíÃáe œÜ |= p ‚Üí œÜi . (To see this, note first that œÜi is a Horn clause, and so is of the
form body ‚Üí a for conjunction of atoms body and atom a. Since body ‚Üí a ‚àà H and H is a
Horn belief set, so also p ‚àß body ‚Üí a ‚àà H. Since by assumption p is not in body, it follows
that p ‚àß body ‚Üí a is in any remainder set of H with respect to œÜ. Then, p ‚àß body ‚Üí a is
logically equivalent to p ‚Üí (body ‚Üí a), whence H ‚àíÃáe œÜ |= p ‚Üí œÜi .) Thus (H ‚àíÃáe œÜ) ‚à™ {p} |= œÜi
or (H ‚àíÃáe œÜ) + p |= œÜi for each conjunct of œÜ, and so (H ‚àíÃáe œÜ) + p |= œÜ. 
Theorem 3: Let a ‚àà P be an atom, and let H be a Horn belief set with a ‚Üí ‚ä• ‚àà H.
Let ‚àíÃá be a maxichoice Horn contraction function based on remainder sets. Then for every
atom b, at least one of b and b ‚Üí ‚ä• is in H ‚àíÃá(a ‚Üí ‚ä•) + a.
Proof: Suppose that for some atom b, neither of b and b ‚Üí ‚ä• is in H ‚àíÃá(a ‚Üí ‚ä•) + a,
where a ‚Üí ‚ä• ‚àà H. Since a is an atom, a ‚Üí ‚ä• is not a tautology, and as a ‚Üí ‚ä• ‚àà H,
by construction, H ‚àíÃá(a ‚Üí ‚ä•) is an element of H ‚Üìe (a ‚Üí ‚ä•). This, together with the
assumption b, b ‚Üí ‚ä• 6‚àà H ‚àíÃá(a ‚Üí ‚ä•), gives us (1) (H ‚àíÃá(a ‚Üí ‚ä•)) ‚à™ {b} ` a ‚Üí ‚ä• and (2)
(H ‚àíÃá(a ‚Üí ‚ä•)) ‚à™ {b ‚Üí ‚ä•} ` a ‚Üí ‚ä•. (Results (1) and (2) are a consequence of the fact
that since H ‚àíÃá(a ‚Üí ‚ä•) is a remainder set, it is a maximal set that fails to imply a ‚Üí ‚ä•.)
From (1) and (2) together, we have that (H ‚àíÃá(a ‚Üí ‚ä•)) ` a ‚Üí ‚ä•, contradicting the success
postulate. 
Lemma 1 Let T be a set of propositional formulas. Then
Cl‚à© (M od(T )) = M od(Horn(Cn(T ))).
Proof:
We have that Cl‚à© (M od(T )) is the least set of models such that M od(T ) ‚äÜ
Cl‚à© (M od(T )) and where Cl‚à© (M od(T )) = M od(H) for some Horn theory H. But this
theory is just the least upper Horn approximation T h of T (Selman & Kautz, 1996), given
by
T h = {Œ± | T ` Œ± where Œ± is a Horn prime implicate of T }.
We have that Cnh (T h ) = Horn(Cn(T )) from which the result follows. 
Theorem 4: For H a Horn belief set and œÜ a Horn formula:
H‚Üì‚Üìe œÜ = H ||e œÜ.
Proof:
501

Delgrande & Wassermann

1. H‚Üì‚Üìe œÜ ‚äÜ H ||e œÜ:
If œÜ 6‚àà H or ` œÜ then H‚Üì‚Üìe œÜ = H ||e œÜ = {H}.
So assume that œÜ ‚àà H and 6` œÜ.
Let H 0 ‚àà H‚Üì‚Üìe œÜ; we show that H 0 ‚àà H ||e œÜ.
Since H 0 ‚àà H‚Üì‚Üìe œÜ, by definition H 0 = H ‚à©m for some m ‚àà |>|\|œÜ|, and so M od(H 0 ) =
M od(H ‚à© m). H and m are Horn theories, thus H ‚à© m is a Horn theory.
Using the fact that for Horn belief set T , T = Horn(Cn(T )), we have that H ‚à© m =
Horn(Cn(H ‚à© m)) and so M od(H 0 ) = M od(Horn(Cn(H ‚à© m)).
Applying Lemma 1 to H‚à©m we obtain that M od(Horn(Cn(H‚à©m)) = Cl‚à© (M od(Cn(H‚à©
m))). Now, Cl‚à© (M od(Cn(H‚à©m))) = Cl‚à© (M od(H‚à©m)) = Cl‚à© ((M od(H)‚à™M od(m))).
By definition of m as a maximal consistent Horn theory, there is M ‚àà M od(>)
such that M od(m) = {M }. Putting the above together we get that M od(H 0 ) =
Cl‚à© ((M od(H) ‚à™ M )), that is, H 0 ‚àà H ||e œÜ.
2. H ||e œÜ ‚äÜ H‚Üì‚Üìe œÜ:
This part follows immediately by essentially taking the preceding part in reverse order.


Lemma 2 Maximality (H ‚àíÃáw 7) is equivalent to the following property, which we will call
(H ‚àíÃáw 70 ):
If H 6= H ‚àíÃáw œÜ then ‚àÉm ‚àà |>| \ |œÜ| s.t. H ‚àíÃáw œÜ ‚äÜ m and ‚àÄH 0 s.t. H ‚àíÃáw œÜ ‚äÇ H 0 ‚äÜ H we
have H 0 6‚äÜ m.
Proof: It is straightforward to show that the property implies (H ‚àíÃáw 7): Let Œ≤ be the
conjunction of literals appearing in m. Our language is finite, so Œ≤ is a well-defined formula.
So Cnh (Œ≤) = m, and thus (H ‚àíÃáw 7) holds.
For the other direction, assume that (H ‚àíÃáw 7) holds.
Claim: For given H and œÜ, if Œ≤ satisfies the conditions in (H ‚àíÃáw 7) then for any p ‚àà P,
either Œ≤ ‚àß p or Œ≤ ‚àß (p ‚Üí ‚ä•) also satisfies these conditions in (H ‚àíÃáw 7).
Proof of Claim: Clearly, if {œÜ, Œ≤} is inconsistent then so is {œÜ, Œ≤ ‚àß l} for l ‚àà
{p, p ‚Üí ‚ä•}; and if H ‚àí œÜ ‚äÜ Cnh (Œ≤) then H 0 ‚äÜ Cnh (Œ≤ ‚àß l) for l ‚àà {p, p ‚Üí ‚ä•}.
So we just need to show that for Horn theory H 0 where H ‚àí œÜ ‚äÇ H 0 ‚äÜ H, either
H 0 6‚äÜ Cnh (Œ≤ ‚àß p) or H 0 6‚äÜ Cnh (Œ≤ ‚àß (p ‚Üí ‚ä•)).
Towards a contradiction, assume otherwise. Then H 0 ‚äÜ Cnh (Œ≤ ‚àß p) and H 0 ‚äÜ
Cnh (Œ≤ ‚àß (p ‚Üí ‚ä•)) and so H 0 ‚äÜ Cnh (Œ≤ ‚àß p) ‚à© Cnh (Œ≤ ‚àß (p ‚Üí ‚ä•)). But Cnh (Œ≤) =
Cnh (Œ≤ ‚àß p) ‚à© Cnh (Œ≤ ‚àß p ‚Üí ‚ä•), and consequently H 0 ‚äÜ Cnh (Œ≤). This contradicts
that Œ≤ satisfies (H ‚àíÃáw 7) for H and œÜ.
Hence our assumption was incorrect, and so H 0 6‚äÜ Cnh (Œ≤ ‚àß p) or H 0 6‚äÜ Cnh (Œ≤ ‚àß
(p ‚Üí ‚ä•)).
502

Horn Clause Contraction Functions

We have just shown that if Œ≤ satisfies (H ‚àíÃáw 7) for given H and œÜ, then so does one of
Œ≤ ‚àß p or Œ≤ ‚àß (p ‚Üí ‚ä•). An induction over (the finite set) P then establishes that if Œ≤ satisfies
(H ‚àíÃáw 7) for given H and œÜ, then so does some Œ≤ 0 where Œ≤ 0 ` p or Œ≤ 0 ` (p ‚Üí ‚ä•) for every
p ‚àà P. Hence Œ≤ 0 is such that Cnh (Œ≤ 0 ) ‚àà |>| \ |œÜ|, and thus taking m = Cnh (Œ≤ 0 ) satisfies the
property. 
Theorem 5: Let H be a Horn belief set. Then ‚àíÃáw is an operator of maxichoice Horn
contraction based on weak remainders iff ‚àíÃáw satisfies the following postulates.
(H ‚àíÃáw 1) H ‚àíÃáw œÜ is a Horn belief set.

(closure)

(H ‚àíÃáw 2) If not ` œÜ, then œÜ 6‚àà H ‚àíÃáw œÜ.

(success)

(H ‚àíÃáw 3) H ‚àíÃáw œÜ ‚äÜ H.

(inclusion)

(H ‚àíÃáw 4) If œÜ 6‚àà H, then H ‚àíÃáw œÜ = H.

(vacuity)

(H ‚àíÃáw 5) If ` œÜ then H ‚àíÃáw œÜ = H

(failure)

(H ‚àíÃáw 6) If œÜ ‚â° œà, then H ‚àíÃáw œÜ = H ‚àíÃáw œà.

(extensionality)

(H ‚àíÃáw 7) If H 6= H ‚àíÃáw œÜ then ‚àÉŒ≤ ‚àà LHC such that {œÜ, Œ≤} ` ‚ä•, H ‚àíÃáw œÜ ‚äÜ Cnh (Œ≤) and ‚àÄH 0
s.t H ‚àíÃáw œÜ ‚äÇ H 0 ‚äÜ H we have H 0 ‚äÜ
6 Cnh (Œ≤).
(maximality)
Proof:
1. Construction to Postulates:
That the construction satisfies the first five postulates follows directly from the definitions of weak remainders and selection functions. To see that it satisfies (H ‚àíÃáw 6) we
only have to note that œÜ ‚â° œà implies that H‚Üì‚Üìe œÜ = H‚Üì‚Üìe œà and since Œ≥ is a function,
H ‚àíÃáw œÜ = H ‚àíÃáw œà.
To see that the construction satisfies (H ‚àíÃáw 7), suppose H 6= H ‚àíÃáw œÜ. This means that
H‚Üì‚Üìe œÜ 6= ‚àÖ and hence, there is m ‚àà |>| \ |œÜ| such that H ‚àíÃáw œÜ = H ‚à© m. Let Œ≤ be
the conjunction of all literals appearing in m. Then, since Cnh (Œ≤) = m, we have
that {œÜ, Œ≤} is inconsistent, H ‚àíÃáw œÜ ‚äÜ Cnh (Œ≤) and ‚àÄH 0 s.t H ‚àíÃáw œÜ ‚äÇ H 0 ‚äÜ H we have
H 0 6‚äÜ Cnh (Œ≤).
2. Postulates to Construction:
The proof uses (H ‚àíÃáw 70 ) rather than (H ‚àíÃáw 7), as they were shown to be equivalent in
Lemma 2.
Let ‚àíÃáw be an operator that satisfies Cn(H ‚àíÃáw 1) ‚Äì (H ‚àíÃáw 70 ).
Let Œ≥ be defined by Œ≥(H‚Üì‚Üìe œÜ) = {H ‚àíÃáw œÜ}.
To show that Œ≥ is a function:
503

Delgrande & Wassermann

Assume that H‚Üì‚Üìe œÜ = H‚Üì‚Üìe œà; we need to show that Œ≥(H‚Üì‚Üìe œÜ) = Œ≥(H‚Üì‚Üìe œà).
If œÜ 6‚àà H, then H‚Üì‚Üìe œÜ = {H} and since H‚Üì‚Üìe œÜ = H‚Üì‚Üìe œà, we have that
H‚Üì‚Üìe œà = H, and hence œà 6‚àà H or ` œà. Then, by (H ‚àíÃáw 4) or (H ‚àíÃáw 5),
H ‚àíÃáw œÜ = H ‚àíÃáw œà = H and by definition Œ≥(H‚Üì‚Üìe œÜ) = Œ≥(H‚Üì‚Üìe œà).
Now let us consider the case where œÜ, œà ‚àà H. Since H‚Üì‚Üìe œÜ = H‚Üì‚Üìe œà we have
that {H ‚à© m | m ‚àà |>| \ |œÜ|} = {H ‚à© m | m ‚àà |>| \ |œà|}.
It follows that |>| \ |œÜ| = |>| \ |œà|. To see this, suppose that {H ‚à© m | m ‚àà
|>| \ |œÜ|} = {H ‚à© m | m ‚àà |>| \ |œà|} and |>| \ |œÜ| =
6 |>| \ |œà|. Without loss
of generality, suppose there is m0 ‚àà |>| \ |œÜ| such that m0 6‚àà |>| \ |œà|. Then
m0 is a maximal consistent theory that contains œà. Since œà ‚àà H, we know
that œà ‚àà H ‚à© m0 . This means that H ‚à© m0 ‚àà {H ‚à© m | m ‚àà |>| \ |œÜ|}, but
H ‚à© m0 6‚àà {H ‚à© m | m ‚àà |>| \ |œà|}, as for any m ‚àà |>| \ |œà| by definition
œà 6‚àà m. This contradicts the initial hypothesis.
Since |>| \ |œÜ| = |>| \ |œà| we get that |œÜ| = |œà| and so œÜ ‚â° œà. From (H ‚àíÃáw 6)
we have H ‚àíÃáw œÜ = H ‚àíÃáw œà, and so Œ≥(H‚Üì‚Üìe œÜ) = Œ≥(H‚Üì‚Üìe œà).
If œÜ 6‚àà H, then from (H ‚àíÃáw 4) we have that H ‚àíÃáw œÜ = H. Similarly, if ` œÜ, then from
(H ‚àíÃáw 5) we again have that H ‚àíÃáw œÜ = H.
Consequently assume that œÜ ‚àà H and not ` œÜ. We need to show that H ‚àíÃáw œÜ ‚àà H‚Üì‚Üìe œÜ,
that is, H ‚àíÃáw œÜ = H ‚à© m for some m ‚àà |>| \ |œÜ|.
Since not ` œÜ, from (H ‚àíÃáw 2) we have œÜ 6‚àà H ‚àíÃáw œÜ; since œÜ ‚àà H we then have that
H 6= H ‚àíÃáw œÜ.
Since H 6= H ‚àíÃáw œÜ, from (H ‚àíÃáw 70 ) we get that there is m ‚àà |>| \ |œÜ| such that H ‚àíÃáw œÜ ‚äÜ
m.
As well, (H ‚àíÃáw 3) gives H ‚àíÃáw œÜ ‚äÜ H, and so this with H ‚àíÃáw œÜ ‚äÜ m implies that H ‚àíÃáw œÜ ‚äÜ
(m ‚à© H).
We need to show that H ‚àíÃáw œÜ = (m ‚à© H). Towards a contradiction assume that
H ‚àíÃáw œÜ 6= (m ‚à© H), that is to say, H ‚àíÃáw œÜ ‚äÇ (m ‚à© H).
Let œà ‚àà (m ‚à© H) \ (H ‚àíÃáw œÜ). Then
H ‚àíÃáw œÜ ‚äÇ Cnh (H ‚àíÃáw œÜ ‚à™ {œà}) ‚äÜ m ‚à© H ‚äÇ H.
But, substituting Cnh (H ‚àíÃáw œÜ ‚à™ {œà}) for H 0 in (H ‚àíÃáw 70 ) we get that Cnh (H ‚àíÃáw œÜ ‚à™
{œà}) 6‚äÜ m, contradiction.
Hence the assumption that H ‚àíÃáw œÜ 6= (m ‚à© H) is incorrect; hence H ‚àíÃáw œÜ = (m ‚à© H)
where (m ‚à© H) ‚àà H‚Üì‚Üìe œÜ, which was to be shown. 
Theorem 6: Let H be a Horn belief set. Then ‚àíÃápm is an operator of partial meet Horn
contraction based on weak remainders iff ‚àíÃápm satisfies the postulates (H ‚àíÃáw 1) ‚Äì (H ‚àíÃáw 6)
and:
(H ‚àíÃápm 7) If Œ≤ ‚àà H \(H ‚àíÃápm œÜ), then there is some H 0 such that H ‚àíÃápm œÜ ‚äÜ H 0 , œÜ 6‚àà Cnh (H 0 )
and œÜ ‚àà Cnh (H 0 ‚à™ {Œ≤})
(weak relevance)
504

Horn Clause Contraction Functions

Proof:
1. Construction to Postulates:
(H ‚àíÃáw 1) follows from the fact that the intersection of Horn theories is a Horn theory. Postulates (H ‚àíÃáw 2) ‚àí (H ‚àíÃáw 6) follow immediately from the definitions of weak
remainder, selection function and partial meet contraction.
To see that the construction satisfies weak relevance, note that if Œ≤ ‚àà H \ H ‚àí œÜ,
then there is some X ‚àà Œ≥(H‚Üì‚Üìe œÜ) such that Œ≤ 6‚àà X. Since Œ≤ ‚àà H, then there is some
m ‚àà |>| \ |œÜ| such that Œ≤ 6‚àà m and X = H ‚à© m. Take H 0 = m. Then H ‚àí œÜ ‚äÜ H 0 ,
œÜ 6‚àà Cnh (H 0 ) and œÜ ‚àà Cnh (H 0 ‚à™ {Œ≤}) = Cnh (‚ä•).
2. Postulates to Construction:
Let Œ≥(H‚Üì‚Üìe œÜ) = {X ‚àà H‚Üì‚Üìe œÜ | H ‚àíÃápm œÜ ‚äÜ X} if H‚Üì‚Üìe œÜ 6= ‚àÖ and Œ≥(H‚Üì‚Üìe œÜ) = {H}
otherwise.
T We have to show that: (1) Œ≥ is a function; (2) Œ≥ is a selection function;
and (3) Œ≥(H‚Üì‚Üìe œÜ) = H ‚àí œÜ.
T
If œÜ 6‚àà H, by (H ‚àíÃáw 4), H ‚àíÃápm œÜ = H = Œ≥(H‚Üì‚Üìe œÜ). Assume then that œÜ ‚àà H.
(1) Let H‚Üì‚Üìe œÜ1 = H‚Üì‚Üìe œÜ2 . We must show that Œ≥(H‚Üì‚Üìe œÜ1 ) = Œ≥(H‚Üì‚Üìe œÜ2 ). As in the
proof for maxichoice contraction, H‚Üì‚Üìe œÜ1 = H‚Üì‚Üìe œÜ2 implies that œÜ1 ‚â° œÜ2 and then, by
Postulate (H ‚àíÃáw 6), H‚àíœÜ1 = H‚àíœÜ2 . By the construction of Œ≥, Œ≥(H‚Üì‚Üìe œÜ1 ) = Œ≥(H‚Üì‚Üìe œÜ2 ).
(2) From the construction of Œ≥, we know that Œ≥(H‚Üì‚Üìe œÜ) ‚äÜ H‚Üì‚Üìe œÜ. So we have to show
that if H‚Üì‚Üìe œÜ 6= ‚àÖ, then Œ≥(H‚Üì‚Üìe œÜ) 6= ‚àÖ, and otherwise Œ≥(H‚Üì‚Üìe œÜ) = {H}.
(i) If H‚Üì‚Üìe œÜ 6= ‚àÖ, then H 6= ‚àÖ and |>| \ |œÜ| =
6 ‚àÖ. By (H ‚àíÃáw 1) and (H ‚àíÃáw 2),
œÜ 6‚àà Cn(H ‚àí œÜ). Then there is m ‚àà |>| \ |œÜ| such that H ‚àí œÜ ‚äÜ m. By (H ‚àíÃáw 3),
H ‚àí œÜ ‚äÜ H, hence, H ‚àí œÜ ‚äÜ H ‚à© m ‚àà Œ≥(H‚Üì‚ÜìœÜ).
(ii) If H‚Üì‚Üìe œÜ = ‚àÖ, then ` œÜ and by (H ‚àíÃáw 5), H ‚àí œÜ = H.
T
T
(3) We know thatTH ‚àí œÜ ‚äÜ Œ≥(H‚Üì‚Üìe œÜ). Suppose there is Œ≤ ‚àà Œ≥(H‚Üì‚Üìe œÜ) such that
Œ≤ 6‚àà H ‚àí œÜ. Since Œ≥(H‚Üì‚Üìe œÜ) ‚äÜ H, Œ≤ ‚àà H \ (H ‚àí Œ±) and by weak relevance we know
that there is some H 0 such that H ‚àí œÜ ‚äÜ H 0 , œÜ 6‚àà Cnh (H 0 ) and œÜ ‚àà Cnh (H 0 ‚à™ {Œ≤}).
Then there is m ‚àà |>| \ |œÜ| such that H 0 ‚äÜ m and Œ≤ 6‚àà m. Take X = H ‚à© m. Then
X ‚àà H‚Üì‚Üìe œÜ and from (H ‚àíÃáw 3) we have that H ‚àí œÜ ‚äÜ X and hence, X ‚àà Œ≥(H‚Üì‚Üìe œÜ).
But Œ≤ 6‚àà X, which leads to a contradiction. 
Theorem 7: Partial meet based on weak remainders and a transitive relational selection
function satisfies (K ‚àíÃá7) and (K ‚àíÃá8).
Proof:
Let Œ≥ be a selection function based on a transitive relation .
Since |>| \ |Œ± ‚àß Œ≤| = (|>| \ |Œ±|) ‚à™ (|>| \ |Œ≤|) and hence, H‚Üì‚Üìe Œ± ‚àß Œ≤ = H‚Üì‚Üìe Œ± ‚à™ H‚Üì‚Üìe Œ≤, in
order to show that PMWR satisfies postulate (K-7), it suffices to show that
(*) Œ≥(H‚Üì‚Üìe Œ± ‚àß Œ≤) ‚äÜ Œ≥(H‚Üì‚Üìe Œ±) ‚à™ Œ≥(H‚Üì‚Üìe Œ≤).9
9. This is called Choice-distributivity in the literature.

505

Delgrande & Wassermann

Take X ‚àà Œ≥(H‚Üì‚Üìe Œ± ‚àß Œ≤). We know that X ‚àà H‚Üì‚Üìe Œ± or X ‚àà H‚Üì‚Üìe Œ≤. Suppose that
X ‚àà H‚Üì‚Üìe Œ±, we have to show that X ‚àà Œ≥(H‚Üì‚Üìe Œ±). If X 6‚àà Œ≥(H‚Üì‚Üìe Œ±), then there is X 0 ‚àà H‚Üì‚Üìe Œ±
such that X ‚â∫ X 0 . But then X 0 ‚àà H‚Üì‚Üìe Œ± ‚àß Œ≤ and X 6‚àà Œ≥(H‚Üì‚Üìe Œ± ‚àß Œ≤). The case where
X ‚àà H‚Üì‚Üìe Œ≤ is analogous, thus X ‚àà Œ≥(H‚Üì‚Üìe Œ±) or X ‚àà Œ≥(H‚Üì‚Üìe Œ≤), which proves (*).
In order to show that PMWR satisfies postulate (K-8), let Œ± 6‚àà H ‚àí Œ± ‚àß Œ≤. We have to
show that
(**) Œ≥(H‚Üì‚Üìe Œ±) ‚äÜ Œ≥(H‚Üì‚Üìe Œ± ‚àß Œ≤)
From Œ± 6‚àà H ‚àí Œ± ‚àß Œ≤ we know that Œ≥(H‚Üì‚Üìe Œ± ‚àß Œ≤) contains at least one element of H‚Üì‚Üìe Œ±.
Since H‚Üì‚Üìe Œ± ‚äÜ H‚Üì‚Üìe Œ± ‚àß Œ≤ and Œ≥ is based on , we have that Œ≥(H‚Üì‚Üìe Œ±) ‚äÜ Œ≥(H‚Üì‚Üìe Œ± ‚àß Œ≤). 
Theorem 8: PMWR satisfies (H ‚àíÃá5).
Proof:
To see that PMWR satisfies (H ‚àíÃá5), first we have to note that H‚Üì‚Üìe œï‚àßœà ‚äÜ H‚Üì‚Üìe œï‚àßœà ‚àßŒ¥.
From œà ‚àà H ‚àí œï ‚àß œà, we know that œà ‚àà X for every X ‚àà Œ≥(H‚Üì‚Üìe œï ‚àß œà). We have to show
that œà ‚àà X for every X ‚àà Œ≥(H‚Üì‚Üìe œï ‚àß œà ‚àß Œ¥). Let X ‚àà Œ≥(H‚Üì‚Üìe œï ‚àß œà ‚àß Œ¥). If X 6‚àà H‚Üì‚Üìe œï ‚àß œà,
then X = H ‚à© m for m a maximal, consistent Horn theory that does not contain œï ‚àß œà ‚àß Œ¥
but contains œï ‚àß œà. Hence, œà ‚àà X. Otherwise, i.e., if X ‚àà H‚Üì‚Üìe œï ‚àß œà, we have to show that
X ‚àà Œ≥(H‚Üì‚Üìe œï ‚àß œà). Suppose that X 6‚àà Œ≥(H‚Üì‚Üìe œï ‚àß œà), then there is X 0 ‚àà H‚Üì‚Üìe œï ‚àß œà such that
X 0 < X. But then X 0 ‚àà H‚Üì‚Üìe œï ‚àß œà ‚àß Œ¥ and X cannot be an element of Œ≥(H‚Üì‚Üìe œï ‚àß œà ‚àß Œ¥).
Hence, for every X ‚àà Œ≥(H‚Üì‚Üìe œï‚àßœà ‚àßŒ¥), we know that œà ‚àà X and therefore, œà ‚àà H ‚àíœï‚àßœà ‚àßŒ¥.

Theorem 9: Let H be a Horn belief set and let Œ¶ = {œÜ1 , . . . , œÜn } be a set of Horn formulas
where for 1 ‚â§ i ‚â§ n we have 6` œÜi .
T
Then H 0 ‚àà H‚Üì‚Üìp Œ¶ iff for 1 ‚â§ i ‚â§ n there are Hi ‚àà H‚Üì‚Üìe œÜi and H 0 = ni=1 Hi .
Proof: Let H be a Horn belief set and Œ¶ = {œÜ1 , . . . , œÜn } ‚äÇ LHC .
=‚áí Let H 0 ‚àà H‚Üì‚Üìp Œ¶.
From Definition 10 we have that ‚àÉm1 , . . . , mn such that H 0 =

Tn

i=1 (H

‚à© mi ) where

1. if œÜi ‚àà H and 6` œÜi then mi ‚àà |>| \ |œÜi |;
2. otherwise mi = LHC .
For each i, 1 ‚â§ i ‚â§ n, as above,
1. if œÜi ‚àà H and 6` œÜi then by Definition 4, Hi = H ‚à© mi satisfies the conditions for
Hi ‚àà H‚Üì‚Üìe œÜi ;
2. otherwise we have mi = LHC and so Hi = H ‚à© mi = H ‚à© LHC = H satisfies the
conditions for Hi ‚àà H‚Üì‚Üìe œÜi , again by Definition 4.
‚áê= Consider some œÜi ‚àà Œ¶ and let Hi ‚àà H‚Üì‚Üìe œÜi .
From Definition 4 we have that
1. if œÜi ‚àà H and 6` œÜi then Hi = H ‚à© m for some m ‚àà |>| \ |œÜi |;
506

Horn Clause Contraction Functions

2. if œÜi 6‚àà H or ` œÜi then Hi = H or equivalently Hi = H ‚à© mi where mi = LHC .
T
Consequently for each i, 1 ‚â§ i ‚â§ n, as above, H 0 = ni=1 Hi satisfies the conditions
for H 0 ‚àà H‚Üì‚Üìp Œ¶ in Definition 10. 
Theorem 10: Let H be a Horn belief set. Then ‚àíÃáp is an operator of maxichoice Horn
package contraction based on weak remainders iff ‚àíÃáp satisfies the following postulates:
(H ‚àíÃáp 1) H ‚àíÃáp Œ¶ is a belief set.

(closure)

(H ‚àíÃáp 2) For œÜ ‚àà Œ¶, if not ` œÜ, then œÜ 6‚àà H ‚àíÃáp Œ¶

(success)

(H ‚àíÃáp 3) H ‚àíÃáp Œ¶ ‚äÜ H

(inclusion)

(H ‚àíÃáp 4) H ‚àíÃáp Œ¶ = H ‚àíÃáp (H ‚à© Œ¶)

(vacuity)

(H ‚àíÃáp 5) H ‚àíÃáp Œ¶ = H ‚àíÃáp (Œ¶ \ Cnh (>))

(failure)

(H ‚àíÃáp 5b) H ‚àíÃáp ‚àÖ = H

(triviality)

(H ‚àíÃáp 6) If œÜ ‚â° œà, then
H ‚àíÃáp (Œ¶ ‚à™ {œÜ}) = H ‚àíÃáp (Œ¶ ‚à™ {œà})

(extensionality)

(H ‚àíÃáp 7) If H 6= H ‚àíÃáp Œ¶ then for
Œ¶0 = (Œ¶ \ Cnh (>)) ‚à© H = {œÜ1 , . . . , œÜn }
there is ‚àÜ = {Œ≤1 , . . . , Œ≤n } where for 1 ‚â§ i ‚â§ n,
{œÜi , Œ≤i } ` ‚ä• and H ‚àíÃáp Œ¶ ‚äÜ Cnh (Œ≤i ) and
‚àÄH 0 s.t H ‚àíÃáp Œ¶ ‚äÇ H 0 ‚äÜ H, ‚àÉŒ≤ ‚àà ‚àÜ such that H 0 6‚äÜ Cnh (Œ≤)

(maximality)

Proof:
1. Construction to Postulates:
(H ‚àíÃáp 1) is obvious.
For (H ‚àíÃáp 2), if œÜ ‚àà H, then Definition 10 ensures that for any H 0 ‚àà H‚Üì‚Üìp Œ¶ that H 0 6` œÜ
and so œÜ 6‚àà H 0 .
For (H ‚àíÃáp 3) we have that H 0 ‚àà H‚Üì‚Üìp Œ¶ implies that H 0 is of the form H ‚à© X; consequently H 0 ‚äÜ H.
(H ‚àíÃáp 4) and (H ‚àíÃáp 5) are a direct consequence of the special cases in Definition 10 for
œÜ ‚àà Œ¶ where œÜ 6‚àà H or ` œÜ respectively.
(H ‚àíÃáp 5b) is vacuously satisfied by Definition 10, while for (H ‚àíÃáp 6), the form of any
H 0 ‚àà H‚Üì‚Üìp Œ¶ is easily seen to be independent of the syntactic form of members of Œ¶.
For (H ‚àíÃáp 7), let X ‚àà H‚Üì‚Üìp Œ¶ where Œ¶ = {œÜ1 , . . . , œÜn }. By appeal to (H ‚àíÃáp 4) and
(H ‚àíÃáp 5) we can assume without loss of generality that œÜ ‚àà Œ¶ implies that 6` œÜ and
œÜ ‚àà H. Let m1 , . . . , mn be as specified in Definition 10. Then m1 , . . . , mn satisfy
507

Delgrande & Wassermann

the conditions
T on Œ≤1 , . . . , Œ≤n in (H ‚àíÃáp 7): Since mi ‚àà |>| \ |œÜi |, so {œÜi , Œ≤i } ` ‚ä•. Since
X = H ‚à© ni=1 mi , so X ‚äÜ Cnh (mi ) = mi . Last, we need to show that for any belief
0
h
set H 0 where X ‚äÇ H 0 ‚äÜ H, that for some mi in our list,
Tn H 6‚äÜ Cn (mi ) = mi . But
this is a direct consequence of the fact that X = H ‚à© i=1 mi .
2. Postulates to Construction:
Let ‚àíÃáp satisfy Postulates (H ‚àíÃáp 1)‚Äì(H ‚àíÃáp 7), and let H be a Horn belief set and Œ¶ ‚äÜ
LHC . Let ‚àÜ be as specified in (H ‚àíÃáp 7) and for œÜ ‚àà Œ¶, define H ‚àí œÜ by:
(a) If ` œÜ or œÜ 6‚àà H then H ‚àí œÜ = H.
(b) Otherwise for the Œ≤ ‚àà ‚àÜ corresponding to œÜ, H ‚àí œÜ is the maximum set of
formulas such that H ‚àíÃáp Œ¶ ‚äÜ H ‚àí œÜ ‚äÇ H and H ‚àí œÜ ‚äÜ Cnh (Œ≤).
Using Theorem 5, it is easily shown that ‚àí is an operator of maxichoice Horn contraction.
This implies that there is a selection function Œ≥ such that H ‚àí œÜ = Œ≥(H‚Üì‚Üìe œÜ) for every
œÜ ‚àà Œ¶.
T
Therefore, by Theorem 9 we have that H ‚àíÃáp Œ¶ = œÜ‚ààŒ¶ H ‚àí œÜ = H 0 is such that
H 0 ‚àà H‚Üì‚Üìp Œ¶. 
Theorem 12: f orget(S, p) ‚â° S‚Üìp ‚à™ Res(S, p).
Proof: Let S be a finite set of nontautological Horn clauses. For p ‚àà P, define:
Sh = {c ‚àà S | p = head(c)}
Sb = {c ‚àà S | p ‚àà body(c)}
As well, we have already defined: S‚Üìp = {c ‚àà S | p does not occur in c}.
We obtain:
f orget(S, p) ‚â° S[p/‚ä•] ‚à® S[p/>]
‚â° (Sh [p/‚ä•] ‚à™ Sb [p/‚ä•] ‚à™ S‚Üìp [p/‚ä•]) ‚à®
(Sh [p/>] ‚à™ Sb [p/>] ‚à™ S‚Üìp [p/>])
‚â° (Sh [p/‚ä•] ‚à™ {>} ‚à™ S‚Üìp ) ‚à® ({>} ‚à™ Sb [p/>] ‚à™ S‚Üìp )
‚â° (Sh [p/‚ä•] ‚à™ S‚Üìp ) ‚à® (Sb [p/>] ‚à™ S‚Üìp )
‚â° S‚Üìp ‚à™ (Sh [p/‚ä•] ‚à® Sb [p/>])
‚â° S‚Üìp ‚à™ {c1 ‚à™ c2 | c1 ‚àà Sh [p/‚ä•] and c2 ‚àà Sb [p/>]}
‚â° S‚Üìp ‚à™ Res(S, p) 

References
Alchourron, C. E., & Makinson, D. (1985). On the logic of theory change: Safe contraction.
Studia Logica, 44 (4), 405‚Äì422.
508

Horn Clause Contraction Functions

AlchourroÃÅn, C., GaÃàrdenfors, P., & Makinson, D. (1985). On the logic of theory change:
Partial ¬ø meet contraction and revision functions. Journal of Symbolic Logic, 50 (2),
510‚Äì530.
Anderson, A., & Belnap Jr., N. (1975). Entailment: The Logic of Relevance and Necessity,
Vol. I. Princeton University Press.
Baader, F., Calvanese, D., McGuiness, D., Nardi, D., & Patel-Schneider, P. (Eds.). (2007).
The Description Logic Handbook (second edition). Cambridge University Press.
Booth, R., Meyer, T., Varzinczak, I., & Wassermann, R. (2011). On the Link between Partial
Meet, Kernel, and Infra Contraction and its Application to Horn Logic. Journal of
Artificial Intelligence Research, 42, 31‚Äì53.
Booth, R., Meyer, T., & Varzinczak, I. (2009). Next steps in propositional Horn contraction.
In Proceedings of the International Joint Conference on Artificial Intelligence, pp.
702‚Äì707, Pasadena, CA.
Creignou, N., Papini, O., Pichler, R., & Woltran, S. (2012). Belief revision within fragments
of propositional logic. In Brewka, G., Eiter, T., & McIlraith, S. A. (Eds.), Proceedings
of the Thirteenth International Conference on the Principles of Knowledge Representation and Reasoning. AAAI Press.
Delgrande, J., & Wassermann, R. (2010). Horn clause contraction functions: Belief set and
belief base approaches. In Lin, F., & Sattler, U. (Eds.), Proceedings of the Twelfth International Conference on the Principles of Knowledge Representation and Reasoning,
pp. 143‚Äì152, Toronto. AAAI Press.
Delgrande, J. (2008). Horn clause belief change: Contraction functions. In Brewka, G., &
Lang, J. (Eds.), Proceedings of the Eleventh International Conference on the Principles
of Knowledge Representation and Reasoning, pp. 156‚Äì165, Sydney, Australia. AAAI
Press.
Delgrande, J., & Peppas, P. (2011). Revising Horn Theories. In Twenty-Second International
Joint Conference on Artificial Intelligence, pp. 839‚Äì844.
Delgrande, J., & Wassermann, R. (2011). Topics in Horn contraction: Supplementary postulates, package contraction, and forgetting. In IJCAI-11 Workshop on Nonmonotonic
Reasoning, Action and Change (NRAC-11), pp. 87‚Äì94, Barcelona, Spain.
Eiter, T., & Gottlob, G. (1992). On the complexity of propositional knowledge base revision,
updates, and counterfactuals. Artificial Intelligence, 57 (2-3), 227‚Äì270.
Flouris, G., Plexousakis, D., & Antoniou, G. (2004). Generalizing the AGM postulates: Preliminary results and applications. In Proceedings of the 10th International Workshop
on Non-Monotonic Reasoning (NMR-04), pp. 171‚Äì179, Whistler BC, Canada.
GaÃàrdenfors, P. (1988). Knowledge in Flux: Modelling the Dynamics of Epistemic States.
The MIT Press, Cambridge, MA.
GaÃàrdenfors, P., & Makinson, D. (1988). Revisions of knowledge systems using epistemic
entrenchment. In Proc. Second Theoretical Aspects of Reasoning About Knowledge
Conference, pp. 83‚Äì95, Monterey, Ca.
509

Delgrande & Wassermann

Garey, M., & Johnson, D. (1979). Computers and Intractability: A Guide to the Theory of
NP-Completeness. W.H. Freeman and Co., New York.
Grove, A. (1988). Two Modellings for Theory Change. Journal of Philosophical Logic, 17,
157‚Äì170.
Hansson, S. O. (1999). A Textbook of Belief Dynamics. Applied Logic Series. Kluwer
Academic Publishers.
Khardon, R. (1995). Translating between Horn representations and their characteristic
models. Journal of Artificial Intelligence Research, 3, 349‚Äì372.
Lakemeyer, G., & Levesque, H. (2000). The Logic of Knowledge Bases. MIT Press, Cambridge, MA.
Lang, J., & Marquis, P. (2002). Resolving inconsistencies by variable forgetting. In Proceedings of the Eighth International Conference on the Principles of Knowledge Representation and Reasoning, pp. 239‚Äì250, San Francisco. Morgan Kaufmann.
Langlois, M., Sloan, R., SzoÃàreÃÅnyi, B., & TuraÃÅn, G. (2008). Horn complements: Towards
Horn-to-Horn belief revision. In Proceedings of the AAAI National Conference on
Artificial Intelligence, Chicago, Il.
Liberatore, P. (2000). Compilability and compact representations of revision of Horn knowledge bases. ACM Transactions on Computational Logic, 1 (1), 131‚Äì161.
Lin, F., & Reiter, R. (1994). Forget it!. In AAAI Fall Symposium on Relevance, New
Orleans.
Makinson, D. (2009) Personal communication.
Peppas, P. (2008). Belief revision. In van Harmelen, F., Lifschitz, V., & Porter, B. (Eds.),
Handbook of Knowledge Representation, pp. 317‚Äì359. Elsevier Science, San Diego,
USA.
Reiter, R. (1987). A theory of diagnosis from first principles. Artificial Intelligence, 32 (1),
57‚Äì96.
Rott, H. (1992). On the logic of theory change: More maps between different kinds of
contraction functions. In GaÃàrdenfors, P. (Ed.), Belief Revision, No. 29 in Cambridge
Tracts in Theoretical Computer Science, pp. 122‚Äì141. Cambridge University Press.
Selman, B., & Kautz, H. (1996). Knowledge compilation and theory approximation. Journal
of the ACM, 43 (2), 193‚Äì224.
Zhuang, Z., & Pagnucco, M. (2010a). Horn contraction via epistemic entrenchment. In
Janhunen, T., & NiemelaÃà, I. (Eds.), Logics in Artificial Intelligence - 12th European
Conference (JELIA 2010), Vol. 6341 of Lecture Notes in Artificial Intelligence, pp.
339‚Äì351. Springer Verlag.
Zhuang, Z., & Pagnucco, M. (2010b). Two methods for constructing Horn contractions.
In Li, J. (Ed.), AI 2010: Advances in Artificial Intelligence - 23rd Australasian Joint
Conference, Vol. 6464 of Lecture Notes in Artificial Intelligence, pp. 72‚Äì81. Springer
Verlag.
510

Horn Clause Contraction Functions

Zhuang, Z. (2012). Belief Change Under the Horn Fragment of Propositional Logic. Ph.D.
thesis, School of Computer Science and Engineering ‚Äì University of New South Wales.
Zhuang, Z., & Pagnucco, M. (2011). Transitively relational partial meet Horn contraction.
In Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence, pp. 1132‚Äì1138, Barcelona, Spain.
Zhuang, Z., & Pagnucco, M. (2012). Model based Horn contraction. In Proceedings of the
Thirteenth International Conference on the Principles of Knowledge Representation
and Reasoning, Rome, Italy.

511

Journal of Artificial Intelligence Research 48 (2013) 671-715

Submitted 04/13; published 11/13

Generating Natural Language Descriptions from OWL
Ontologies: the NaturalOWL System
Ion Androutsopoulos

ion@aueb.gr

Department of Informatics,
Athens University of Economics and Business, Greece
Digital Curation Unit ‚Äì Institute for the Management of Information Systems,
Research Centre ‚ÄúAthena‚Äù, Athens, Greece

Gerasimos Lampouras

lampouras06@aueb.gr

Department of Informatics,
Athens University of Economics and Business, Greece

Dimitrios Galanis

galanisd@aueb.gr

Department of Informatics,
Athens University of Economics and Business, Greece
Institute for Language and Speech Processing,
Research Centre ‚ÄúAthena‚Äù, Athens, Greece

Abstract
We present Naturalowl, a natural language generation system that produces texts
describing individuals or classes of owl ontologies. Unlike simpler owl verbalizers, which
typically express a single axiom at a time in controlled, often not entirely fluent natural
language primarily for the benefit of domain experts, we aim to generate fluent and coherent multi-sentence texts for end-users. With a system like Naturalowl, one can publish
information in owl on the Web, along with automatically produced corresponding texts
in multiple languages, making the information accessible not only to computer programs
and domain experts, but also end-users. We discuss the processing stages of Naturalowl,
the optional domain-dependent linguistic resources that the system can use at each stage,
and why they are useful. We also present trials showing that when the domain-dependent
linguistic resources are available, Naturalowl produces significantly better texts compared
to a simpler verbalizer, and that the resources can be created with relatively light effort.

1. Introduction
Ontologies play a central role in the Semantic Web (Berners-Lee, Hendler, & Lassila, 2001;
Shadbolt, Berners-Lee, & Hall, 2006). Each ontology provides a conceptualization of a
knowledge domain (e.g., consumer electronics) by defining the classes and subclasses of the
individuals (entities) in the domain, the types of possible relations between them etc. The
current standard to specify Semantic Web ontologies is owl (Horrocks, Patel-Schneider,
& van Harmelen, 2003), a formal language based on description logics (Baader, Calvanese,
McGuinness, Nardi, & Patel-Schneider, 2002), rdf, and rdf schema (Antoniou & van
Harmelen, 2008), with owl2 being the latest version of owl (Grau, Horrocks, Motik, Parc
2013
AI Access Foundation. All rights reserved.

Androutsopoulos, Lampouras, & Galanis

sia, Patel-Schneider, & Sattler, 2008). Given an owl ontology for a knowledge domain, one
can publish on the Web machine-readable data pertaining to that domain (e.g., catalogues of
products, their features etc.), with the data having formally defined semantics based on the
conceptualization of the ontology.1 Following common practice in Semantic Web research,
we actually use the term ontology to refer jointly to terminological knowledge (TBox) that
establishes a conceptualization of a knowledge domain, and assertional knowledge (ABox)
that describes particular individuals.
Several equivalent owl syntaxes have been developed, but people unfamiliar with formal
knowledge representation often have difficulties understanding them (Rector, Drummond,
Horridge, Rogers, Knublauch, Stevens, Wang, & Wroe, 2004). For example, the following
statement defines the class of St. Emilion wines, using the functional-style syntax of owl,
one of the easiest to understand, which we also adopt throughout this article.2
EquivalentClasses(:StEmilion
ObjectIntersectionOf(:Bordeaux
ObjectHasValue(:locatedIn :stEmilionRegion) ObjectHasValue(:hasColor :red)
ObjectHasValue(:hasFlavor :strong)
ObjectHasValue(:madeFrom :cabernetSauvignonGrape)
ObjectMaxCardinality(1 :madeFrom)))

To make ontologies easier to understand, several ontology verbalizers have been developed
(Schwitter, 2010a). Verbalizers usually translate the axioms (in our case, owl statements) of
the ontology one by one to controlled, often not entirely fluent English statements, typically
without considering the coherence of the resulting texts, and mostly for the benefit of domain
experts. By contrast, in this article we present a system that aims to produce fluent and
coherent multi-sentence texts describing classes or individuals of owl ontologies, with the
texts intended to be read by end-users (e.g., customers of on-line retail sites). For example,
our system can generate the following text from the owl statement above, if the ontology
has been annotated with domain-dependent linguistic resources discussed below.
St. Emilion is a kind of Bordeaux from the St. Emilion region. It has red color and strong flavor. It is
made from exactly one grape variety: Cabernet Sauvignon grapes.

Our system, called Naturalowl, is open-source and supports both English and Greek.
Hence, Greek texts can also be generated from the same owl statements, as in the following
product description, provided that appropriate Greek linguistic resources are also available.
By contrast, owl verbalizers typically produce only English (or English-like) sentences.
ClassAssertion(:Laptop :tecraA8)
ObjectPropertyAssertion(:manufacturedBy :tecraA8 :toshiba)
ObjectPropertyAssertion(:hasProcessor :tecraA8 :intelCore2)
DataPropertyAssertion(:hasMemoryInGB :tecraA8 "2"^^xsd:nonNegativeInteger)
DataPropertyAssertion(:hasHardDiskInGB :tecraA8 "110"^^xsd:nonNegativeInteger)
DataPropertyAssertion(:hasSpeedInGHz :tecraA8 "2"^^xsd:float)
DataPropertyAssertion(:hasPriceInEuro :tecraA8 "850"^^xsd:nonNegativeInteger)

[English description:] Tecra A8 is a laptop, manufactured by Toshiba. It has an Intel Core 2 processor,
2 gb ram and a 110 gb hard disk. Its speed is 2 ghz and it costs 850 Euro.
1. See http://owl.cs.manchester.ac.uk/repository/ for a repository of owl ontologies.
2. Consult http://www.w3.org/TR/owl2-primer/ for an introduction to the functional-style syntax of owl.

672

Generating Natural Language Descriptions from OWL Ontologies

[Greek description:] Œü Tecra A8 ŒµŒØŒΩŒ±Œπ Œ≠ŒΩŒ±œÇ œÜŒøœÅŒ∑œÑœåœÇ œÖœÄŒøŒªŒøŒ≥ŒπœÉœÑŒÆœÇ, Œ∫Œ±œÑŒ±œÉŒ∫ŒµœÖŒ±œÉŒºŒ≠ŒΩŒøœÇ Œ±œÄœå œÑŒ∑ŒΩ Toshiba.
ŒîŒπŒ±Œ∏Œ≠œÑŒµŒπ ŒµœÄŒµŒæŒµœÅŒ≥Œ±œÉœÑŒÆ Intel Core 2, 2 gb ram Œ∫Œ±Œπ œÉŒ∫ŒªŒ∑œÅœå Œ¥ŒØœÉŒ∫Œø 110 gb. Œó œÑŒ±œáœçœÑŒ∑œÑŒ¨ œÑŒøœÖ ŒµŒØŒΩŒ±Œπ 2 ghz Œ∫Œ±Œπ
Œ∫ŒøœÉœÑŒØŒ∂ŒµŒπ 850 ŒïœÖœÅœé.

The examples above illustrate how a system like Naturalowl can help publish information on the Web both as owl statements and as texts generated from the owl statements.
This way, information becomes easily accessible to both computers, which can process
the owl statements, and end-users speaking different languages; and changes in the owl
statements can be automatically reflected in the texts by regenerating them. To produce
fluent, coherent multi-sentence texts, Naturalowl relies on natural language generation
(nlg) methods (McKeown, 1985; Reiter & Dale, 2000) to a larger extent compared to existing owl verbalizers; for example, it includes mechanisms to avoid repeating information,
to order the facts to be expressed, aggregate smaller sentences into longer ones, generate
referring expressions etc. Although nlg is an established area, this is the first article to
discuss in detail an nlg system for owl ontologies, excluding simpler verbalizers. We do
not propose novel algorithms from a theoretical nlg perspective, but we show that there are
several particular issues that need to be considered when generating from owl ontologies.
For example, some owl statements lead to overly complicated sentences, unless they are
converted to simpler intermediate representations first; there are also several owl-specific
opportunities to aggregate sentences (e.g., when expressing axioms about the cardinalities
of properties); and referring expression generation can exploit the class hierarchy.
Naturalowl can be used with any owl ontology, but to obtain texts of high quality
domain-dependent generation resources are required; for example, the classes of the ontology
can be mapped to natural language names, the properties to sentence plans etc. Similar
linguistic resources are used in most nlg systems, though different systems adopt different
linguistic theories and algorithms, requiring different resources. There is little consensus on
exactly what information nlg resources should capture, apart from abstract specifications
(Mellish, 2010). The domain-dependent generation resources of Naturalowl are created
by a domain author, a person familiar with owl, when the system is configured for a new
ontology. The domain author uses the ProteÃÅgeÃÅ ontology editor and a ProteÃÅgeÃÅ plug-in that
allows editing the domain-dependent generation resources and invoking Naturalowl to view
the resulting texts.3 We do not discuss the plug-in in this article, since it is very similar to
the authoring tool of m-piro (Androutsopoulos, Oberlander, & Karkaletsis, 2007).
owl ontologies often use English words or concatenations of words (e.g., manufacturedBy)
as identifiers of classes, properties, and individuals. Hence, some of the domain-dependent
generation resources can often be extracted from the ontology by guessing, for example,
that a class identifier like Laptop in our earlier example is a noun that can be used to refer
to that class, or that a statement of the form ObjectPropertyAssertion(:manufacturedBy X
Y ) should be expressed in English as a sentence of the form ‚ÄúX was manufactured by Y ‚Äù.
Most owl verbalizers follow this strategy. Similarly, if domain-dependent generation resources are not provided, Naturalowl attempts to extract them from the ontology, or it uses
3. Consult http://protege.stanford.edu/ for information on ProteÃÅgeÃÅ. Naturalowl and its ProteÃÅgeÃÅ plugin are freely available from http://nlp.cs.aueb.gr/software.html. We describe Naturalowl version 2
in this article; version 1 (Galanis & Androutsopoulos, 2007) used a less principled representation of its
domain-dependent generation resources, without supporting owl2.

673

Androutsopoulos, Lampouras, & Galanis

generic resources. The resulting texts, however, are of lower quality; also, non-English texts
cannot be generated, if the identifiers of the ontology are English-like. There is a tradeoff
between reducing the effort to construct domain-dependent generation resources for owl
ontologies, and obtaining higher-quality texts in multiple languages, but this tradeoff has
not been investigated in previous work. We present trials we performed to measure the
effort required to construct the domain-dependent generation resources of Naturalowl and
the extent to which they improve the resulting texts, also comparing against a simpler
verbalizer that requires no domain-dependent generation resources. The trials show that
the domain-dependent generation resources help Naturalowl produce significantly better
texts, and that the resources can be constructed with relatively light effort, compared to
the effort typically needed to construct an ontology.
Overall, the main contributions of this article are: (i) it is the first detailed discussion of
a complete, general-purpose nlg system for owl ontologies and the particular issues that
arise when generating from owl ontologies; (ii) it shows that a system that relies on nlg
methods to a larger extent, compared to simpler owl verbalizers, can produce significantly
better natural language descriptions of classes and individuals, provided that appropriate
domain-dependent generation resources are available; (iii) it shows how the descriptions can
be generated in more than one languages, again provided that appropriate resources are
available; (iv) it shows that the domain-dependent generation resources can be constructed
with relatively light effort. As already noted, this article does not present novel algorithms
from a theoretical nlg perspective. In fact, some of the algorithms that Naturalowl uses
are of a narrower scope, compared to more fully-fledged nlg algorithms. Nevertheless, the
trials show that the system produces texts of reasonable quality, especially when domaindependent generation resources are provided. We hope that if Naturalowl contributes
towards a wider adoption of nlg methods on the Semantic Web, other researchers may
wish to contribute improved components, given that Naturalowl is open-source.
Naturalowl is based on ideas from ilex (O‚ÄôDonnell, Mellish, Oberlander, & Knott,
2001) and m-piro (Isard, Oberlander, Androutsopoulos, & Matheson, 2003). The ilex
project developed an nlg system that was demonstrated mostly with museum exhibits, but
did not support owl.4 The m-piro project produced a multilingual extension of the system
of ilex, which was tested in several domains (Androutsopoulos et al., 2007). Attempts to
use the generator of m-piro with owl, however, ran into problems (Androutsopoulos,
Kallonis, & Karkaletsis, 2005). By contrast, Naturalowl was especially developed for owl.
In the remainder of this article, we assume that the reader is familiar with rdf, rdf
schema, and owl. Readers unfamiliar with the Semantic Web may wish to consult an
introductory text first (Antoniou & van Harmelen, 2008).5 We also note that the recently
very popular Linked Data are published and interconnected using Semantic Web technologies.6 Most Linked Data currently use only rdf and rdf schema, but owl is in effect a
superset of rdf schema and, hence, the work of this paper also applies to Linked Data.
4. Dale et al. (1998) and Dannels (2008, 2012) also discuss nlg for museums.
5. A longer version of this article, with more background for readers who are unfamiliar with owl and the
Semantic Web, is available as a technical report (Androutsopoulos, Lampouras, & Galanis, 2012); see
http://nlp.cs.aueb.gr/publications.html.
6. Consult http://linkeddata.org/. See also the work of Duma and Klein (2013).

674

Generating Natural Language Descriptions from OWL Ontologies

Section 2 below briefly discusses some related work; we provide further pointers to
related work in the subsequent sections. Section 3 then explains how Naturalowl generates
texts, also discussing the domain-dependent generation resources of each processing stage.
Section 4 describes the trials we performed to measure the effort required to construct the
domain-dependent generation resources and their impact on the quality of the generated
texts. Section 5 concludes and proposes future work.

2. Related Work
We use the functional-style syntax of owl in this article, but several equivalent owl syntaxes exist. There has also been work to develop controlled natural languages (cnls), mostly
English-like, to be used as alternative owl syntaxes. Sydney owl Syntax (sos) (Cregan,
Schwitter, & Meyer, 2007) is an English-like cnl with a bidirectional mapping to and from
the functional-style syntax of owl; sos is based on peng (Schwitter & Tilbrook, 2004).
A similar bidirectional mapping has been defined for Attempto Controlled English (ace)
(Kaljurand, 2007). Rabbit (Denaux, Dimitrova, Cohn, Dolbear, & Hart, 2010) and clone
(Funk, Tablan, Bontcheva, Cunningham, Davis, & Handschuh, 2007) are other owl cnls,
mostly intended to be used by domain experts when authoring ontologies (Denaux, Dolbear,
Hart, Dimitrova, & Cohn, 2011). We also note that some owl cnls cannot express all the
kinds of owl statements (Schwitter, Kaljurand, Cregan, Dolbear, & Hart, 2008).
Much work on owl cnls focuses on ontology authoring and querying (Bernardi, Calvanese, & Thorne, 2007; Kaufmann & Bernstein, 2010; Schwitter, 2010b); the emphasis is
mostly on the direction from cnl to owl or query languages.7 More relevant to our work
are cnls like sos and ace, to which automatic mappings from normative owl syntaxes are
available. By feeding an owl ontology expressed, for example, in functional-style syntax
to a mapping that translates to an English-like cnl, all the axioms of the ontology can be
turned into English-like sentences. Systems of this kind are often called ontology verbalizers.
This term, however, also includes systems that translate from owl to English-like statements that do not belong in an explicitly defined cnl (Halaschek-Wiener, Golbeck, Parsia,
Kolovski, & Hendler, 2008; Schutte, 2009; Power & Third, 2010; Power, 2010; Stevens,
Malone, Williams, Power, & Third, 2011; Liang, Stevens, Scott, & Rector, 2011b).
Although verbalizers can be viewed as performing a kind of light nlg, they typically
translate axioms one by one, as already noted, without considering the coherence (or topical cohesion) of the resulting texts, usually without aggregating sentences nor generating
referring expressions, and often by producing sentences that are not entirely fluent or natural. For example, ace and sos occasionally use variables instead of referring expressions
(Schwitter et al., 2008). Also, verbalizers typically do not employ domain-dependent generation resources and typically do not support multiple languages. Expressing the exact
meaning of the axioms of the ontology in an unambiguous manner is considered more important in verbalizers than composing a fluent and coherent text in multiple languages,
partly because the verbalizers are typically intended to be used by domain experts.
7. Conceptual authoring or wysiwym (Power & Scott, 1998; Hallett, Scott, & Power, 2007), which has been
applied to owl (Power, 2009), and round-trip authoring (Davis, Iqbal, Funk, Tablan, Bontcheva, Cunningham, & Handschuh, 2008) are bidirectional, but focus mostly on ontology authoring and querying.

675

Androutsopoulos, Lampouras, & Galanis

Figure 1: The processing stages and sub-stages of Naturalowl.
Some verbalizers use ideas and methods from nlg. For example, some verbalizers include
sentence aggregation (Williams & Power, 2010) and text planning (Liang, Scott, Stevens, &
Rector, 2011a). Overall, however, nlg methods have been used only to a very limited extent
with owl ontologies. A notable exception is ontosum (Bontcheva, 2005), which generates
natural language descriptions of individuals, but apparently not classes, from rdf schema
and owl ontologies. It is an extension of miakt (Bontcheva & Wilks, 2004), which was
used to generate medical reports. Both were implemented in gate (Bontcheva, Tablan,
Maynard, & Cunningham, 2004) and they provide graphical user interfaces to manipulate
domain-dependent generation resources (Bontcheva & Cunningham, 2003). No detailed
description of ontosum appears to have been published, however, and the system does
not seem to be publicly available, unlike Naturalowl. Also, no trials of ontosum with
independently created ontologies seem to have been published. More information on how
ontosum compares to Naturalowl can be found elsewhere (Androutsopoulos et al., 2012).
Mellish and Sun (2006) focus on lexicalization and sentence aggregation, aiming to
produce a single aggregated sentence from an input collection of rdf triples; by contrast,
Naturalowl produces multi-sentence texts. In complementary work, Mellish et al. (2008)
consider content selection for texts describing owl classes. Unlike Naturalowl, their system
does not express only facts that are explicit in the ontology, but also facts deduced from
the ontology. Nguyen et al. (2012) discuss how the proof trees of facts deduced from owl
ontologies can be explained in natural language. It would be particularly interesting to
examine how deduction and explanation mechanisms could be added to Naturalowl.

3. The Processing Stages and Resources of NaturalOWL
Naturalowl adopts a pipeline architecture, which is common in nlg (Reiter & Dale, 2000),
though the number and purpose of its components often vary (Mellish, Scott, Cahill, Paiva,
Evans, & Reape, 2006). Our system generates texts in three stages, document planning,
micro-planning, and surface realization, discussed in the following sections; see Figure 1.
3.1 Document Planning
Document planning consists of content selection, where the system selects the information
to convey, and text planning, where it plans the structure of the text to be generated.
3.1.1 Content Selection
In content selection, the system first retrieves from the ontology all the owl statements
that are relevant to the class or individual to be described, it then converts the selected
676

Generating Natural Language Descriptions from OWL Ontologies

owl statements to message triples, which are easier to express as sentences, and it finally
selects among the message triples the ones to be expressed.
OWL statements for individual targets
Let us first consider content selection when Naturalowl is asked to describe an individual
(an entity), and let us call that individual the target. The system scans the owl statements
of the ontology, looking for statements of the forms listed in the left column of Table 1.8
In effect, it retrieves all the statements that describe the target directly, as opposed to
statements describing another individual or a (named) class the target is related to.
owl allows arbitrarily many nested ObjectUnionOf and ObjectIntersectionOf operators, which may lead to statements that are very difficult to express in natural language.
To simplify text generation and to ensure that the resulting texts are easy to comprehend,
we do not allow nested ObjectIntersectionOf and ObjectUnionOf operators in the ontologies the texts are generated from. In Table 1, this restriction is enforced by requiring class
identifiers to appear at some points where owl also allows expressions that construct unnamed classes using operators. If an ontology uses unnamed classes at points where Table 1
requires class identifiers (named classes), it can be easily modified to comply with Table 1
by defining new named classes for nested unnamed ones.9 In practice, nested ObjectUnionOf
and ObjectIntersectionOf operators are rare; see the work of Power et al. (Power, 2010;
Power & Third, 2010; Power, 2012) for information of the frequencies of different types of
owl statements.10
Statements of the form ClassAssertion(Class target ) may be quite complex, because
Class is not necessarily a class identifier. It may also be an expression constructing an
unnamed class, as in the following example. This is why there are multiple rows for
ClassAssertion in Table 1.
ClassAssertion(
ObjectIntersectionOf(:Wine
ObjectHasValue(:locatedIn :stEmilionRegion)
ObjectHasValue(:hasColor :red)
ObjectHasValue(:madeFrom :cabernetSauvignonGrape)
:chateauTeyssier2007)

ObjectHasValue(:hasFlavor :strong)
ObjectMaxCardinality(1 :madeFrom))

Naturalowl would express the owl statement above by generating a text like the following.
The 2007 Chateau Teyssier is a wine from the St. Emilion region. It has red color and strong flavor. It
is made from exactly one grape variety: Cabernet Sauvignon grapes.

Recall that the texts of Naturalowl are intended to be read by end-users. Hence, we
prefer to generate texts that may not emphasize enough some of the subtleties of the owl
8. Some owl statements shown in Table 1 with two arguments can actually have more arguments, but they
can be converted to the forms shown.
9. It is also easy to automatically detect nested unnamed classes and replace them, again automatically,
by new named classes (classes with owl identifiers). The domain author would have to be consulted,
though, to provide meaningful owl identifiers for the new classes (otherwise arbitrary identifiers would
have to be used) and natural language names for the new classes (see Section 3.2.1 below).
10. One could also refactor some nested operators; for example, t ‚àà ((A ‚à™ B) ‚à© (C ‚à™ D)) is equivalent to
t ‚àà (A ‚à™ B) and t ‚àà (C ‚à™ D). The conversion to message triples, to be discussed below, in effect
also performs some refactoring, but it cannot cope with all the possible nested union and intersection
operators, which is why we disallow them as a general rule.

677

Androutsopoulos, Lampouras, & Galanis
owl statements

Message triples

ClassAssertion(NamedClass target )
ClassAssertion(
ObjectComplementOf(NamedClass ) target )
ClassAssertion(
ObjectOneOf(indiv1 indiv2 ...) target )
ClassAssertion(
ObjectHasValue(objProp indiv ) target )
ClassAssertion(
ObjectHasValue(dataProp dataValue ) target )
ClassAssertion(ObjectHasSelf(objProp ) target )
ClassAssertion(
ObjectMaxCardinality(number prop [NamedClass ])
target )
ClassAssertion(
ObjectMinCardinality(number prop [NamedClass ])
target )
ClassAssertion(
ObjectExactCardinality(number prop [NamedClass ])
target )
ClassAssertion(
ObjectSomeValuesFrom(objProp NamedClass ) target )
ClassAssertion(
ObjectAllValuesFrom(objProp NamedClass ) target )
ClassAssertion(
ObjectIntersectionOf(C1 C2 ...) target )

<target, instanceOf, NamedClass >

ClassAssertion(
ObjectUnionOf(C1 C2 ...)

target )

ObjectPropertyAssertion(objProp target indiv )
DataPropertyAssertion(dataProp target dataValue )
NegativeObjectPropertyAssertion(
objProp target indiv )
NegativeDataPropertyAssertion(
dataProp target dataValue )
DifferentIndividuals(target indiv )
DifferentIndividuals(indiv target )
SameIndividual(target indiv )
SameIndividual(indiv target )

<target, not(instanceOf), NamedClass >
<target, oneOf,
or(indiv1, indiv2, ...)>
<target, objProp, indiv >
<target, dataProp, dataValue >
<target, objProp, target >
<target, maxCardinality(prop ),
number [:NamedClass ]>
<target, minCardinality(prop ),
number [:NamedClass ]>
<target, exactCardinality(prop ),
number [:NamedClass ]>
<target, someValuesFrom(objProp ),
NamedClass >
<target, allValuesFrom(objProp ),
NamedClass >
convert (ClassAssertion(C1 target ))
convert (ClassAssertion(C2 target )) ...
or(convert (ClassAssertion(C1 target )),
convert (ClassAssertion(C2 target )),
...)
<target, objProp, indiv >
<target, dataProp, dataValue >
<target, not(objProp ), indiv >
<target, not(dataProp ), dataValue >
<target,
<target,
<target,
<target,

differentIndividuals, indiv >
differentIndividuals, indiv >
sameIndividual, indiv >
sameIndividual, indiv >

Notation: Square brackets indicate optional arguments, and convert (Œæ) a recursive application of the
conversion to Œæ. NamedClass is a class identifier; objProp , dataProp , and prop are identifiers of object
properties, datatype properties, and properties; indiv , indiv1 , . . . are identifiers of individuals;
dataValue is a datatype value; and C , C1 , . . . are class identifiers, or expressions constructing classes
without ObjectIntersectionOf or ObjectUnionOf.

Table 1: owl statements for an individual target, and the corresponding message triples.
statements, in order to produce more readable texts. An owl expert might prefer, for
example, the following description of chateauTeyssier2007, which mirrors more closely the
corresponding owl statements.
The 2007 Chateau Teyssier is a member of the intersection of: (a) the class of wines, (b) the class of
individuals from (not necessarily exclusively) the St. Emilion region, (c) the class of individuals that have
(not necessarily exclusively) red color, (d) the class of individuals that have (not necessarily exclusively)
strong flavor, (e) the class of individuals that are made exclusively from Cabernet Sauvignon grapes.

678

Generating Natural Language Descriptions from OWL Ontologies

Stricter texts of this kind, however, seem inappropriate for end-users. In fact, it could be
argued that even mentioning that the wine is made from exactly one grape variety in the
text that Naturalowl produces is inappropriate for end-users. Our system can be instructed
to avoid mentioning this information via user modeling annotations, discussed below.
OWL statements for class targets
If the system is asked to describe a class, rather than an individual, it scans the ontology
for statements of the forms listed in the left column of Table 2. The class to be described
must be a named one, meaning that it must have an owl identifier, and Target denotes
its identifier. Again, to simplify the generation process and to avoid producing complicated
texts, Table 2 requires class identifiers to appear at some points where owl also allows
expressions that construct unnamed classes using operators. If an ontology uses unnamed
classes at points where Table 2 requires class identifiers, it can be easily modified.
In texts describing classes, it is difficult to express informally the difference between
EquivalentClasses and SubClassOf. EquivalentClasses(C1 C2 ) means that any individual
of C1 also belongs in C2 , and vice versa. By contrast, SubClassOf(C1 C2 ) means that any
member of C1 also belongs in C2 , but the reverse is not necessarily true. If we replace
EquivalentClasses by SubClassOf in the definition of StEmilion of page 672, any member
of StEmilion is still necessarily also a member of the intersection, but a wine with all the
characteristics of the intersection is not necessarily a member of StEmilion. Consequently,
one should perhaps add sentences like the ones shown in italics below, when expressing
EquivalentClasses and SubClassOf, respectively.
St. Emilion is a kind of Bordeaux from the St. Emilion region. It has red color and strong flavor. It is
made from exactly one grape variety: Cabernet Sauvignon grapes. Every St. Emilion has these properties,
and anything that has these properties is a St. Emilion.
St. Emilion is a kind of Bordeaux from the St. Emilion region. It has red color and strong flavor. It is
made from exactly one grape variety: Cabernet Sauvignon grapes. Every St. Emilion has these properties,
but something may have these properties without being a St. Emilion.

Naturalowl produces the same texts, without the sentences in italics, for both SubClassOf
and EquivalentClasses, to avoid generating texts that sound too formal. Also, it may
not mention some of the information of the ontology about a target class (e.g., that a St.
Emilion has strong flavor), when user modeling indicates that this information is already
known or that the text should not exceed a particular length. Hence, the generated texts
express necessary, not sufficient conditions for individuals to belong in the target class.
OWL statements for second-level targets
In some applications, expressing additional owl statements that are indirectly related
to the target may be desirable. Let us assume, for example, that the target is the individual
exhibit24, and that the following directly relevant statements have been retrieved from the
ontology. Naturalowl would express them by generating a text like the one below.
ClassAssertion(:Aryballos :exhibit24)
ObjectPropertyAssertion(:locationFound :exhibit24 :heraionOfDelos)
ObjectPropertyAssertion(:creationPeriod :exhibit24 :archaicPeriod)
ObjectPropertyAssertion(:paintingTechniqueUsed :exhibit24 :blackFigureTechnique)
ObjectPropertyAssertion(:currentMuseum :exhibit24 :delosMuseum)

679

Androutsopoulos, Lampouras, & Galanis
owl statements

Message triples

EquivalentClasses(Target C )
EquivalentClasses(C Target )
SubClassOf(Target NamedClass )
SubClassOf(Target ObjectComplementOf(NamedClass ))
SubClassOf(Target
ObjectOneOf(indiv1 indiv2 ...))
SubClassOf(Target ObjectHasValue(objProp indiv ))
SubClassOf(Target
ObjectHasValue(dataProp dataValue ))
SubClassOf(Target ObjectHasSelf(objProp ))
SubClassOf(Target
ObjectMaxCardinality(number prop [NamedClass ]))
SubClassOf(Target
ObjectMinCardinality(number prop [NamedClass ]))
SubClassOf(Target
ObjectExactCardinality(number prop [NamedClass ]))
SubClassOf(Target
ObjectSomeValuesFrom(objProp NamedClass ))
SubClassOf(Target
ObjectAllValuesFrom(objProp NamedClass ))
SubClassOf(Target
ObjectIntersectionOf(C1 C2 ...))

convert (SubClassOf(Target C ))
convert (SubClassOf(Target C ))
<Target, isA, NamedClass >
<Target, not(isA), NamedClass >
<Target, oneOf,
or(indiv1, indiv2, ...)>
<Target, objProp, indiv >

SubClassOf(Target
ObjectUnionOf(C1 C2 ...))
DisjointClasses(Target NamedClass )
DisjointClasses(NamedClass Target )

<Target, dataProp, dataValue >
<Target, objProp, Target >
<Target, maxCardinality(prop ),
number [:NamedClass ]>
<Target, minCardinality(prop ),
number [:NamedClass ]>
<Target, exactCardinality(objProp ),
number [:NamedClass ]>
<Target, someValuesFrom(objProp ),
NamedClass >
<Target, allValuesFrom(objProp ),
NamedClass >
convert (SubClassOf(C1 Target ))
convert (SubClassOf(C2 Target )) ...
or(convert (SubClassOf(C1 Target )),
convert (SubClassOf(C2 Target )),
...)
<Target, not(isA), NamedClass >
<Target, not(isA), NamedClass >

Notation: Square brackets indicate optional arguments, and convert (Œæ) a recursive application of the
conversion to Œæ. NamedClass is a class identifier; objProp , dataProp , and prop are identifiers of object
properties, datatype properties, and properties; indiv , indiv1 , . . . are identifiers of individuals;
dataValue is a datatype value; and C , C1 , . . . are class identifiers, or expressions constructing classes
without ObjectIntersectionOf or ObjectUnionOf.

Table 2: owl statements for a class target, and the corresponding message triples.
This is an aryballos, found at the Heraion of Delos. It was created during the archaic period and it was
decorated with the black-figure technique. It is currently in the Museum of Delos.

The names of classes and individuals can be shown as hyperlinks to indicate that they can
be used as subsequent targets. Clicking on a hyperlink would be a request to describe
the corresponding class or individual. Alternatively, we may retrieve in advance the owl
statements for the subsequent targets and add them to those of the current target.
More precisely, assuming that the target is an individual, the subsequent targets, called
second-level targets, are the target‚Äôs class, provided that it is a named one, and the individuals the target is directly linked to via object properties. Naturalowl considers second-level
targets only when the current target is an individual, because with class targets, second-level
targets often lead to complicated texts. To retrieve owl statements for both the current
and the second-level targets (when applicable), or only for the current target, we set the
maximum fact distance to 2 or 1, respectively. Returning to exhibit24, let us assume that
the maximum fact distance is 2 and that the following owl statements for second-level
targets have been retrieved.11
11. Consult http://www.w3.org/TR/owl-time/ for more principled representations of time in owl.

680

Generating Natural Language Descriptions from OWL Ontologies

SubClassOf(:Aryballos :Vase)
SubClassOf(:Aryballos
ObjectHasValue(:exhibitTypeCannedDescription
"An aryballos was a small spherical vase with a narrow neck, in which the athletes
kept the oil they spread their bodies with"^^xsd:string))
DatatypePropertyAssertion(:periodDuration :archaicPeriod "700 BC to 480 BC"^^xsd:string)
DatatypePropertyAssertion(:periodCannedDescription :archaicPeriod
"The archaic period was when the Greek ancient city-states developed"^^xsd:string)
DataPropertyAssertion(:techniqueCannedDescription :blackFigureTechnique
"In the black-figure technique, the silhouettes are rendered in black on the pale
surface of the clay, and details are engraved"^^xsd:string)

To express all the retrieved owl statements, including those for the second-level targets,
Naturalowl would now generate a text like the following, which may be preferable, if this
is the first time the user encounters an aryballos and archaic exhibits.
This is an aryballos, a kind of vase. An aryballos was a small spherical vase with a narrow neck, in
which the athletes kept the oil they spread their bodies with. This aryballos was found at the Heraion of
Delos and it was created during the archaic period. The archaic period was when the Greek ancient citystates developed and it spans from 700 bc to 480 bc. This aryballos was decorated with the black-figure
technique. In the black-figure technique, the silhouettes are rendered in black on the pale surface of the
clay, and details are engraved. This aryballos is currently in the Museum of Delos.

We note that in many ontologies it is impractical to represent all the information in
logical terms. In our example, it is much easier to store the information that ‚ÄúAn aryballos
was a small. . . bodies with‚Äù as a string, i.e., as a canned sentence, rather than defining
classes, properties, and individuals for spreading actions, bodies, etc. and generating the
sentence from a logical meaning representation. Canned sentences, however, have to be
entered in multiple versions, if several languages or user types need to be supported.
Converting OWL statements to message triples
Tables 1 and 2 also show how the retrieved owl statements can be rewritten as triples
of the form hS, P, Oi, where S is the target or a second-level target; O is an individual,
datatype value, class, or a set of individuals, datatype values, or classes that S is mapped
to; and P specifies the kind of mapping. We call S the semantic subject or owner of the
triple, and O the semantic object or filler ; the triple can also be viewed as a field named
P , owned by S, and filled by O. For example, the owl statements about exhibit24 shown
above, including those about the second-level targets, are converted to the following triples.
<:exhibit24, instanceOf, :Aryballos>
<:exhibit24, :locationFound, :heraionOfDelos>
<:exhibit24, :creationPeriod, :archaicPeriod>
<:exhibit24, :paintingTechniqueUsed, :blackFigureTechnique>
<:exhibit24, :currentMuseum, :delosMuseum>
<:Aryballos, isA, :Vase>
<:Aryballos, :exhibitTypeCannedDescription, "An aryballos was a... bodies with"^^xsd:string>
<:archaicPeriod, :periodDuration, "700 BC to 480 BC"^^xsd:string>
<:archaicPeriod, :periodCannedDescription, "The archaic period was..."^^xsd:string>
<:blackFigureTechnique, :techniqueCannedDescription, "In the black-figure..."^^xsd:string>

More precisely, P can be: (i) a property of the ontology; (ii) one of the keywords isA,
instanceOf, oneOf, differentIndividuals, sameIndividuals; or (iii) an expression of the
form modifier(œÅ), where modifier may be not, maxCardinality etc. (see Tables 1 and 2)
681

Androutsopoulos, Lampouras, & Galanis

Figure 2: Graph view of message triples.
and œÅ is a property of the ontology. We hereafter call properties all three types of P ,
though types (ii) and (iii) are strictly not properties in the terminology of owl. When
we need to distinguish between the three types, we use the terms property of the ontology,
domain-independent property, and modified property, respectively.
Every owl statement or collection of owl statements can be represented as a set of rdf
triples.12 The triples of Tables 1‚Äì2 are similar, but not the same as rdf triples. Most notably, expressions of the form modifier(œÅ) cannot be used as P in rdf triples. To avoid confusion, we call message triples the triples of Tables 1‚Äì2, to distinguish them from rdf triples.
As with rdf triples, message triples can be viewed as forming a graph. Figure 2 shows the
graph for the message triples of exhibit24; the triple linking blackFigureTechnique to a
canned sentence is not shown to save space. The second-level targets are the classes and
individuals at distance one from the target (exhibit24).13 By contrast, the graph for the
rdf triples representing the owl statements would be more complicated, and second-level
targets would not always be at distance one from the target.
Each message triple is intended to be easily expressible as a simple sentence, which is
not always the case with rdf triples representing owl statements. The message triples also
capture similarities of the sentences to be generated that may be less obvious when looking
at the original owl statements or the rdf triples representing them. For example, the
ClassAssertion and SubClassOf statements below are mapped to identical message triples,
apart from the identifiers of the individual and the class, and the similarity of the message
triples reflects the similarity of the resulting sentences, also shown below.
ClassAssertion(ObjectMaxCardinality(1 :madeFromGrape) :product145)
<:product145, maxCardinality(:madeFromGrape), 1>

Product 145 is made from at most one grape.

12. See http://www.w3.org/TR/owl2-mapping-to-rdf/.
13. Instead of retrieving the owl statements about the target and second-level targets and then converting
them to message triples, one could equivalently convert all the owl statements of the ontology to message
triples and select the message triples connecting the target to nodes up to distance two from the target.

682

Generating Natural Language Descriptions from OWL Ontologies

SubClassOf(:StEmilion ObjectMaxCardinality(1 :madeFromGrape))
<:StEmilion, maxCardinality(:madeFromGrape), 1>

St. Emilion is made from at most one grape.

By contrast, without the conversion to message triples, the owl statements and the rdf
triples representing them would lead to more difficult to follow sentences like the following:
Product 145 is a member of the class of individuals that are made from at most one grape.
St. Emilion is a subclass of the class of individuals that are made from at most one grape.

As a further example, Tables 1 and 2 discard ObjectIntersectionOf operators, producing
multiple message triples instead. For example, the EquivalentClasses statement defining
StEmilion on page 672 would be converted to the following message triples.
<:StEmilion,
<:StEmilion,
<:StEmilion,
<:StEmilion,
<:StEmilion,
<:StEmilion,

isA, :Bordeaux>
:locatedIn, :stEmilionRegion>
:hasColor, :red>
:hasFlavor, :strong>
:madeFromGrape, :cabernetSauvignonGrape>
maxCardinality(:madeFromGrape), 1>

The resulting message triples correspond to the sentences below, where subsequent references to StEmilion have been replaced by pronouns to improve readability; the sentences
could also be aggregated into longer ones, as discussed in later sections.
St. Emilion is a kind of Bordeaux. It is from the St. Emilion region. It has red color. It has strong flavor.
It is made from Cabernet Sauvignon grape. It is made from at most one grape variety.

By contrast the original owl statement of page 672 and the rdf triples representing it
would lead to the ‚Äòstricter‚Äô text of page 678, which is inappropriate for end-users, as already
noted. Notice, also, that Table 2 converts EquivalentClasses and SubClassOf statements to
identical triples, where P is isA, since Naturalowl produces the same texts for both kinds
of statements, as already discussed.
Tables 1 and 2 also replace ObjectUnionOf operators by disjunctions of message triples.
The following owl statement is mapped to the message triple shown below:
ClassAssertion(
UnionOf(ObjectHasValue(:hasFlavor :strong) ObjectHasValue(:hasFlavor :medium))
:houseWine)
or(<:houseWine, :hasFlavor, :strong>, <:houseWine, :hasFlavor, :medium>)

which leads to the first sentence below; the sentence can then be shortened during aggregation, leading to the second sentence below.
The house wine has strong flavor or it has medium flavor.
The house wine has strong or medium flavor.

683

Androutsopoulos, Lampouras, & Galanis

By contrast, the owl statement and the corresponding rdf triples in effect say that:
The house wine is a member of the union of: (i) the class of all wines that have strong flavor, and (ii) the
class of all wines that have medium flavor.

Interest scores and repetitions
Expressing all the message triples of all the retrieved owl statements is not always
appropriate. Let us assume, for example, that the maximum fact distance is 2 and that a
description of exhibit24 of Figure 2 has been requested by a museum visitor. It may be the
case that the visitor has already encountered other archaic exhibits, and that the duration
of the archaic period was mentioned in previous descriptions. Repeating the duration of
the period may, thus, be undesirable. We may also want to exclude message triples that
are uninteresting to particular types of users. For example, there may be message triples
providing bibliographic references, which children would probably find uninteresting.
Naturalowl provides mechanisms allowing the domain author to assign an importance
score to every possible message triple, and possibly different scores for different user types
(e.g., adults, children). The score is a non-negative integer indicating how interesting a user
of the corresponding type will presumably find the information of the message triple, if the
information has not already been conveyed to the user. In the museum projects Naturalowl
was originally developed for, the interest scores ranged from 0 (completely uninteresting) to
3 (very interesting), but a different range can also be used. The scores can be specified for
all the message triples that involve a particular property P (e.g., P = madeFrom), or for all
the message triples that involve semantic subjects S of a particular class (e.g., S ‚àà Statue
or S = Statue) and a particular property P , or for message triples that involve particular
semantic subjects (e.g., S =exhibit37) and a particular property P . For example, we may
wish to specify that the materials of the exhibits in a collection are generally of medium
interest (P = madeFrom, score 2), that the materials of statues are of lower interest (S ‚àà
statue, P = madeFrom, score 1), perhaps because all the statues of the collection are made
from stone, but that the material of the particular statue exhibit24 is very important (S =
exhibit10, P = madeFrom, score 3), perhaps because exhibit24 is a gold statue.
We do not discuss the mechanisms that can be used to assign interest scores to message
triples in this article, but a detailed description of these mechanisms can be found elsewhere
(Androutsopoulos et al., 2012). We also note that when human-authored texts describing
individuals and classes of the ontology are available along with the owl statements or, more
generally, the logical facts they express, statistical and machine learning methods can be
employed to learn to automatically select or assign interest scores to logical facts (Duboue &
McKeown, 2003; Barzilay & Lapata, 2005; Kelly, Copestake, & Karamanis, 2010). Another
possibility (Demir, Carberry, & McCoy, 2010) would be to compute the interest scores with
graph algorithms like PageRank (Brin & Page, 1998).
The domain author can also specify how many times each message triple has to be
repeated, before it can be assumed that users of different types have assimilated it. Once a
triple has been assimilated, it is never repeated in texts for the same user. For example, the
domain author can specify that children assimilate the duration of a historical period when
it has been mentioned twice; hence, the system may repeat, for example, the duration of
the archaic period in two texts. Naturalowl maintains a personal model for each end-user.
The model shows which message triples were conveyed to the particular user in previous
684

Generating Natural Language Descriptions from OWL Ontologies

texts, and how many times. Again, more information about the user modeling mechanisms
of Naturalowl can be found elsewhere (Androutsopoulos et al., 2012).
Selecting the message triples to convey
When asked to describe a target, Naturalowl first retrieves from the ontology the relevant owl statements, possibly also for second-level targets. It then converts the retrieved
statements to message triples, and consults their interest scores and the personal user models to rank the message triples by decreasing interest score, discarding triples that have
already been assimilated. If a message triple about the target has been assimilated, then all
the message triples about second-level targets that are connected to the assimilated triple
are also discarded; for example, if the creationPeriod triple (edge) of Figure 2 has been assimilated, then the triples about the archaic period (the edges leaving from archaicPeriod)
are also discarded. The system then selects up to maxMessagesPerPage triples from the most
interesting remaining ones; maxMessagesPerPage is a parameter whose value can be set to
smaller or larger values for types of users that prefer shorter or longer texts, respectively.
Limitations of content selection
owl allows one to define the broadest possible domain and range of a particular property,
using statements like the following.
ObjectPropertyDomain(:madeFrom :Wine)

ObjectPropertyRange(:madeFrom :Grape)

In practice, more specific range restrictions are then imposed for particular subclasses of
the property‚Äôs domain. For example, the following statements specify that when madeFrom
is used with individuals from the subclass GreekWine of Wine, the range (possible values) of
madeFrom should be restricted to individuals from the subclass GreekGrape of Grape.
SubClassOf(:GreekWine :Wine) SubClassOf(:GreekGrape :Grape)
SubClassOf(:GreekWine AllValuesFrom(:madeFrom :GreekGrape))

Naturalowl considers AllValuesFrom and similar restrictions (see Tables 1 and 2), but not
ObjectPropertyDomain and ObjectPropertyRange statements. The latter typically provide
too general and, hence, uninteresting information from the perspective of end-users.
More generally, Naturalowl does not consider owl statements that express axioms
about properties, meaning statements declaring that a property is symmetric, asymmetric,
reflexive, irreflexive, transitive, functional, that its inverse is functional, that a property is
the inverse of, or disjoint with another property, that it is subsumed by a chain of other
properties, or that it is a subproperty (more specific) of another property. Statements of
this kind are mostly useful in consistency checks, in deduction, or when generating texts
describing the properties themselves (e.g., what being a grandparent of somebody means).14
3.1.2 Text Planning
For each target, the previous mechanisms produce the message triples to be expressed,
with each triple intended to be easily expressible as a single sentence. The text planner of
Naturalowl then orders the message triples, in effect ordering the corresponding sentences.
14. Subproperties without sentence plans, discussed below, could inherit sentence plans from their superproperties, but in that case we automatically extract sentence plans from the ontology instead.

685

Androutsopoulos, Lampouras, & Galanis

Global and local coherence
When considering global coherence, text planners attempt to build a structure, usually
a tree, that shows how the clauses, sentences, or larger segments of the text are related to
each other, often in terms of rhetorical relations (Mann & Thompson, 1998). The allowed
or preferred orderings of the sentences (or segments) often follow, at least partially, from
the global coherence structure. In the texts, however, that Naturalowl is intended to
generate, the global coherence structures tend to be rather uninteresting, because most of
the sentences simply provide additional information about the target or the second-level
targets, which is why global coherence is not considered in Naturalowl.15
When considering local coherence, text planners usually aim to maximize measures that
examine whether or not adjacent sentences (or segments) continue to focus on the same entities or, if the focus changes, how smooth the transition is. Many local coherence measures
are based on Centering Theory (ct) (Grosz, Joshi, & Weinstein, 1995; Poesio, Stevenson,
& Di Eugenio, 2004). Consult the work of Karamanis et al. (2009) for an introduction to
ct and a ct-based analysis m-piro‚Äôs texts, which also applies to the texts of Naturalowl.
When the maximum fact distance of Naturalowl is 1, all the sentence-to-sentence transitions are of a type known in ct as continue, which is the preferred type. If the maximum
fact distance is 2, however, the transitions are not always continue. We repeat below the
long aryballos description of page 681 without sentence aggregation. For readers familiar
with ct, we show in italics the most salient noun phrase of each sentence un , which realizes
the discourse entity known as the preferred center cp (un ). The underlined noun phrases realize the backward looking center cb (un ), roughly speaking the most salient discourse entity
of the previous sentence that is also mentioned in the current sentence.
(1) This (exhibit) is an aryballos. (2) An aryballos is a kind of vase. (3) An aryballos was a small
spherical vase with a narrow neck, in which the athletes kept the oil they spread their bodies with. ‚Ä¢
(4) This aryballos was found at the Heraion of Delos. (5) It was created during the archaic period. (6)
The archaic period was when the Greek ancient city-states developed. (7) It spans from 700 bc to 480
bc. ‚Ä¢ (8) This aryballos was decorated with the black-figure technique. (9) In the black-figure technique,
the silhouettes are rendered in black on the pale surface of the clay, and details are engraved. ‚Ä¢ (10)
This aryballos is currently in the Museum of Delos.

In sentence 4, where cp (u4 ) is the target exhibit, cb (u4 ) is undefined and the transition from
sentence 3 to 4 is a nocb, a type of transition to be avoided; we mark nocb transitions with
bullets. In sentence 6, cp (u6 ) = cb (u6 ) 6= cb (u5 ), and we have a kind of transition known as
smooth-shift (Poesio et al., 2004), less preferred than continue, but better than nocb.
Another nocb occurs from sentence 7 to 8, followed by a smooth-shift from sentence 8
to 9, and another nocb from sentence 9 to 10. All the other transitions are continue.
The text planner of Naturalowl groups together sentences (message triples) that describe a particular second-level target (e.g., sentences 2‚Äì3, 6‚Äì7, and 9) and places each
group immediately after the sentence that introduces the corresponding second-level target
(immediately after sentences 1, 5, and 8). Thus the transition from a sentence that introduces a second-level target to the first sentence that describes the second-level target (e.g.,
15. Liang et al. (2011a) and Power (2011) seem to agree that very few rhetorical relations are relevant when
generating texts from owl ontologies.

686

Generating Natural Language Descriptions from OWL Ontologies

from sentence 1 to 2, from 5 to 6, from 8 to 9) is a smooth-shift (or a continue in the
special case from the initial sentence 1 to 2). A nocb occurs only at sentences that return
to providing information about the primary target, after a group of sentences that provide
information about a second-level target. All the other transitions are of type continue.
A simple strategy to avoid nocb transitions would be to end the generated text once
all the message triples that describe a second-level target have been reported, and record
in the user model that the other message triples that content selection provided were not
actually conveyed. In our example, this would generate sentences 1 to 3; then if the user
requested more information about the exhibit, sentences 4 to 7 would be generated etc.
Topical order
When ordering sentences, we also need to consider the topical similarity of adjacent
sentences. Compare, for example, the following two texts.
{locationSection The Stoa of Zeus Eleutherios is located in the western part of the Agora. It is located
next to the Temple of Apollo Patroos.} {buildSection It was built around 430 bc. It was built in the Doric
style. It was built out of porous stone and marble.} {useSection It was used during the Classical period,
the Hellenistic period, and the Roman period. It was used as a religious place and a meeting point.}
{conditionSection It was destroyed in the late Roman period. It was excavated in 1891 and 1931. Today it
is in good condition.}
The Stoa of Zeus Eleutherios was built in the Doric style. It was excavated in 1891 and 1931. It was
built out of porous stone and marble. It is located in the western part of the Agora. It was destroyed in
the late Roman period. It was used as a religious place and a meeting point. It is located next to the
Temple of Apollo Patroos. It was built around 430 bc. Today it is in good condition. It was used during
the Classical period, the Hellenistic period, and the Roman period.

Even though both texts contain the same sentences, the second text is more difficult to
follow, if at all acceptable. The first one is better, because it groups together topically
related sentences. We mark the sentence groups in the first text by curly brackets, but the
brackets would not be shown to end-users. In longer texts, sentence groups may optionally
be shown as separate paragraphs or sections, which is why we call them sections.
To allow the message triples (and the corresponding sentences) to be grouped by topic,
the domain author may define sections (e.g., locationSection, buildSection) and assign
each property to a single section (e.g., assign the properties isInArea and isNextTo to
locationSection). Each message triple is then placed in the section of its property. An
ordering of the sections and of the properties inside each section can also be specified, causing the message triples to be ordered accordingly (e.g., we may specify that locationSection
should precede buildSection, and that inside locationSection, the isInArea property should
be expressed before isNextTo). The sections, the assignments of the properties to sections,
and the order of the sections and the properties are defined in the domain-dependent generation resources (Androutsopoulos et al., 2012).
The overall text planning algorithm
Naturalowl‚Äôs text planning algorithm is summarized in Figure 3. If the message triples
to be ordered include triples that describe second-level targets, i.e., triples hS, P, Oi whose
owner S is a second-level target, then the triples of the primary and each second-level target
687

Androutsopoulos, Lampouras, & Galanis

procedure orderMessageTriples
inputs:
t[0]: primary target
t[1], ..., t[n]: second-level targets
L[0]: unordered list of triples describing t[0]
...
L[n]: unordered list of triples describing t[n]
SMap: mapping from properties to sections
SOrder: partial order of sections
POrder: partial order of properties within sections
output:
ordered list of message triples
steps:
for i := 0 to n { orderMessageTriplesAux(L[i], SMap, SOrder, POrder) }
for i := 1 to n { insertAfterFirst(<t[0], _, t[i]>, L[0], L[i]) }
return L[0]
procedure orderMessageTriplesAux
inputs:
L: unordered list of triples about a single target
SMap: mapping from properties to sections
SOrder: partial order of sections
POrder: partial order of properties within sections
local variables:
S[1], ..., S[k]: lists, each with triples of one section
output:
ordered list of message triples about a single target
steps:
<S[1], ..., S[k]> := splitInSections(L, SMap)
for i := 1 to k { S[i] := orderTriplesInSection(S[i], POrder) }
<S[1], ..., S[k]> := reorderSections(S[1], ..., S[k], SOrder)
return concatenate(S[1], ..., S[k])

Figure 3: The overall text planning algorithm of Naturalowl.

are ordered separately, using the ordering of properties and sections. The ordered triples of
each second-level target are then inserted into the ordered list of the primary target triples,
immediately after the first triple that introduces the second-level target, i.e., immediately
after the first triple whose O is the second-level target.
Further related work on text planning
The ordering of properties and sections is similar to text schemata (McKeown, 1985),
roughly speaking domain-dependent patterns that specify the possible arrangements of different types of sentences (or segments). Sentence ordering has been studied extensively in
text summarization (Barzilay, Elhadad, & McKeown, 2002). Duboue and McKeown (2001)
discuss methods that could be used to learn the order of sentences or other segments in
nlg from semantically tagged training corpora. Consult also the work of Barzilay and Lee
(2004), Elsner et al. (2007), Barzilay and Lapata (2008), and Chen et al. (2009).
688

Generating Natural Language Descriptions from OWL Ontologies

Figure 4: A lexicon entry for the verb ‚Äúto find‚Äù.
3.2 Micro-planning
The processing stages we have discussed so far select and order the message triples to
be expressed. The next stage, micro-planning, consists of three sub-stages: lexicalization,
sentence aggregation, and generation of referring expressions; see also Figure 1 on page 676.
3.2.1 Lexicalization
During lexicalization, nlg systems usually turn the output of content selection (in our case,
the message triples) to abstract sentence specifications. In Naturalowl, for every property
of the ontology and every supported natural language, the domain author may specify one or
more template-like sentence plans to indicate how message triples involving that property
can be expressed. We discuss below how sentence plans are specified, but first a slight
deviation is necessary, to briefly discuss the lexicon entries of Naturalowl.
Lexicon entries
For each verb, noun, or adjective that the domain author wishes to use in the sentence
plans, a lexicon entry has to be provided, to specify the inflectional forms of that word.16
All the lexicon entries are multilingual (currently bilingual); this allows sentence plans to be
reused across similar languages when no better option is available, as discussed elsewhere
(Androutsopoulos et al., 2007). Figure 4 shows the lexicon entry for the verb whose English
base form is ‚Äúfind‚Äù, as viewed by the domain author when using the ProteÃÅgeÃÅ plug-in of
Naturalowl. The identifier of the lexicon entry is toFindLex. The English part of the entry
shows that the base form is ‚Äúfind‚Äù, the simple past is ‚Äúfound‚Äù etc. Similarly, the Greek
part of the lexicon entry would show the base form of the corresponding verb (‚ÄúŒ≤œÅŒØœÉŒ∫œâ‚Äù)
and its inflectional forms in the various tenses, persons etc. The lexicon entries for nouns
and adjectives are very similar.
Most of the English inflectional forms could be automatically produced from the base
forms by using simple morphology rules. We hope to exloit an existing English morphology
component, such as that of simplenlg (Gatt & Reiter, 2009), in future work. Similar
morphology rules for Greek were used in the authoring tool of m-piro (Androutsopoulos et
al., 2007), and we hope to include them in a future version of Naturalowl. Rules of this kind
would reduce the time a domain author spends creating lexicon entries. In the ontologies
we have considered, however, a few dozens of lexicon entries for verbs, nouns, and adjectives
16. No lexicon entries need to be provided for closed-class words, like determiners and prepositions.

689

Androutsopoulos, Lampouras, & Galanis

suffice. Hence, even without facilities to automatically produce inflectional forms, creating
the lexicon entries is rather trivial. Another possibility would be to exploit a general-purpose
lexicon or lexical database, like WordNet (Fellbaum, 1998) or celex, though resources of
this kind often do not cover the highly technical concepts of ontologies.17
The lexicon entries and, more generally, all the domain-dependent generation resources
of Naturalowl are stored as instances of an owl ontology (other than the ontology the texts
are generated from) that describes the linguistic resources of the system (Androutsopoulos
et al., 2012). The domain author, however, interacts with the plug-in and does not need to
be aware of the owl representation of the resources. By representing the domain-dependent
generation resources in owl, it becomes easier to publish them on the Web, check them for
inconsistencies etc., as with other owl ontologies.
Sentence plans
In Naturalowl, a sentence plan is a sequence of slots, along with instructions specifying how to fill them in. Figure 5 shows an English sentence plan for the property
usedDuringPeriod, as viewed by the domain author when using the ProteÃÅgeÃÅ plug-in of Naturalowl. The sentence plan expresses message triples of the form hS, usedDuringPeriod, Oi
by producing sentences like the following.
[slot1 This stoa] [slot2 was used] [slot3 during] [slot4 the Classical period].
[slot1 The Stoa of Zeus Eleutherios] [slot2 was used] [slot3 during] [slot4 the Classical period, the Hellenistic
period, and the Roman period].

The first slot of the sentence plan of Figure 5 is to be filled in with an automatically
generated referring expression for the owner (S) of the triple. For example, if the triple to
express is <:stoaZeusEleutherios, :usedDuringPeriod, :classicalPeriod>, an appropriate
referring expression for S may be a demonstrative noun phrase like ‚Äúthis stoa‚Äù, a pronoun
(‚Äúit‚Äù), or the monument‚Äôs natural language name (‚Äúthe Stoa of Zeus Eleutherios‚Äù). We
discuss the generation of referring expressions below, along with mechanisms to specify
natural language names. The sentence plan also specifies that the referring expression must
be in nominative case (e.g., ‚Äúit‚Äù or ‚Äúthis stoa‚Äù, as opposed to the genitive case expressions
‚Äúits‚Äù or ‚Äúthis stoa‚Äôs‚Äù, as in ‚ÄúThis stoa‚Äôs height is 5 meters‚Äù).
The second slot is to be filled in with a form of the verb whose lexicon identifier is
toUseVerb. The verb form must be in the simple past and passive voice, in positive polarity
(as opposed to ‚Äúwas not used‚Äù). Its number must agree with the number of the expression
in the first slot; for example, we want to generate ‚ÄúThe Stoa of Zheus Eleutherios was
used‚Äù, but ‚ÄúStoas were used‚Äù. The third slot is filled in with the preposition ‚Äúduring‚Äù.
The fourth slot is filled in with an expression for the filler (O) of the message triple, in
accusative case.18 With <:stoaZeusEleutherios, :usedDuringPeriod, :classicalPeriod>,
the slot would be filled in with the natural language name of classicalPeriod.19 The
sentence plan also allows the resulting sentence to be aggregated with other sentences.
17. See http://www.ldc.upenn.edu/Catalog/catalogEntry.jsp?catalogId=LDC96L14 for celex.
18. English prepositions usually require noun phrase complements in accusative (e.g., ‚Äúon him‚Äù). In Greek
and other languages, cases have more noticeable effects.
19. Future versions of Naturalowl may allow a referring expression for O other than its natural language
name to be produced (e.g., a pronoun), as with S.

690

Generating Natural Language Descriptions from OWL Ontologies

Figure 5: A sentence plan for the property usedDuringPeriod.
More generally, the instructions of a sentence plan may indicate that a slot should be
filled in with one of the following (i‚Äìvii):
(i) A referring expression for the S (owner) of the message triple. A sentence plan may
specify a particular type of referring expression to use (e.g., always use the natural language
name of S) or, as in the example of Figure 5, it may allow the system to automatically
produce the most appropriate type of referring expression depending on the context.
(ii) A verb for which there is a lexicon entry, in a particular form, possibly a form that
agrees with another slot. The polarity of the verb can also be manually specified or, if the
filler (O) of the message triple is a Boolean value, the polarity can be automatically set to
match that value (e.g., to produce ‚ÄúIt does not have a built-in flash‚Äù when O is false).
(iii) A noun or adjective from the lexicon, in a particular form (e.g., case, number), or
in a form that agrees with another slot.
(iv) A preposition or (v) a fixed string.
(vi) An expression for the O (filler) of the triple. If O is an individual or class, then the
expression is the natural language name of O; if O is a datatype value (e.g., an integer),
then the value itself is inserted in the slot; and similarly if O is a disjunction or conjunction
of datatype values, individuals, or classes.
(vii) A concatenation of property values of O, provided that O is an individual. For
example, we may need to express a message triple like the first one below, whose (anonymous
in the rdf sense) object :n is linked to both a numeric value (via hasAmount) and an
individual standing for the currency (via hasCurrency).
<:tecra8, :hasPrice, _:n>

<_:n, :hasAmount, "850"^^xsd:float>

<_:n, :hasCurrency, :euroCurrency>

We would want the sentence plan to include a slot filled in with the concatenation of the
hasAmount value of :n and the natural language name of the hasCurrency value of :n (e.g.,
‚Äú850 Euro‚Äù in English, ‚Äú850 ŒïœÖœÅœé‚Äù in Greek).
Default sentence plan
If no sentence plan has been provided for a particular property of the ontology, Naturalowl uses a default sentence plan, consisting of three slots. The first slot is filled in
with an automatically generated referring expression for the owner (S) of the triple, in
nominative case. The second slot is filled in with a tokenized form of the owl identifier of
the property. The third slot is filled in with an appropriate expression for the filler (O) of
691

Androutsopoulos, Lampouras, & Galanis

the triple, as discussed above, in accusative case (if applicable). For the following message
triple, the default sentence plan would produce the sentence shown below:
<:stoaZeusEleutherios, :usedDuringPeriod, and(:classicalPeriod, :hellenisticPeriod, :romanPeriod)>

Stoa zeus eleutherios used during period classical period, hellenistic period, and roman period.

Notice that we use a single message triple with an and(...) filler, instead of a different
triple for each period. This kind of triple merging is in effect a form of aggregation, discussed
below, but it takes place during content selection. Also, we assumed in the sentence above
that the natural language names of the individuals have not been provided either; in this
case, Naturalowl uses tokenized forms of the owl identifiers of the individuals instead.
The tokenizer of Naturalowl can handle both CamelCase (e.g., :usedDuringPeriod) and
underscore style (e.g., :used during period). When other styles are used in the identifiers
of properties, classes, and individuals, the output of the tokenizer may be worse than the
example suggests, but the resulting sentences can be improved by providing sentence plans
and by associating classes and individuals with natural language names, discussed below.
Using rdfs:label strings
owl properties (and other elements of owl ontologies) can be labeled with strings in
multiple natural languages using the rdfs:label annotation property, defined in the rdf and
owl standards. For example, the usedDuringPeriod property could be labeled with ‚Äúwas
used during‚Äù as shown below; there could be similar labels for Greek and other languages.
AnnotationAssertion(rdfs:label :usedDuringPeriod "was used during"@en)

If an rdfs:label string has been specified for the property of a message triple, Naturalowl
uses that string in the second slot of the default sentence plan. The quality of the resulting
sentences can, thus, be improved, if the rdfs:label strings are more natural phrases than
the tokenized property identifiers. With the rdfs:label shown above, the default sentence
plan would produce the following sentence.
Stoa zeus eleutherios was used during classical period, hellenistic period, and roman period.

Even with rdfs:label strings, the default sentence plan may produce sentences with disfluencies. Also, the rdfs:label strings do not indicate the grammatical categories of their
words, and this does not allow the system to apply many of the sentence aggregation rules
discussed below. A further limitation of the default sentence plan is that it does not allow
the slots for S and O to be preceded or followed, respectively, by any other phrase.
Sentence plans for domain-independent and modified properties
The domain author does not need to provide sentence plans for domain-independent
properties (e.g., instanceOf, isA, see Tables 1‚Äì2). These properties have fixed, domainindependent semantics; hence, built-in sentence plans are used. The English built-in sentence plans, which also serve as further examples of sentence plans, are summarized in
Table 3; the Greek built-in sentence plans are similar. To save space we show the sentence
plans as templates in Table 3, and we do not show the sentence plans for negated domainindependent properties (e.g., not(isA)), which are similar. Additional slot restrictions not
692

Generating Natural Language Descriptions from OWL Ontologies

Forms of message triples and the
Example message triples and
corresponding built-in sentence plans
possible resulting sentences
<S, instanceOf, O >
<:eos450d, instanceOf, :PhotographicCamera>
ref(S) toBeVerb name(indef, O)
The eos 450d is a photographic camera.
<S, instanceOf, O >
<:eos450d, instanceOf, :Cheap>
ref(S) toBeVerb name(adj, O)
The eos 450d is cheap.
<S, oneOf, O >
<:WineColor, oneOf, or(:white, :rose, :red)>
ref(S) toBeVerb name(O)
A wine color is white, rose, or red.
<S, differentIndividuals, O >
<:n97, differentIndividuals, :n97mini>
ref(S) toBeVerb not identical to name(O)
The n97 is not identical to the n97 mini.
<S, sameIndividual, O >
<:eos450d, sameIndividual, :rebelXSi>
ref(S) toBeVerb identical to name(O)
It is identical to the Rebel xsi.
<S, isA, O >
<:StEmilion, isa, :Bordeaux>
ref(S) toBeVerb a kind of name(noarticle, O)
St. Emilion is a kind of Bordeaux.
<S, isA, O >
<:StEmilion, isa, :Red>
ref(S) toBeVerb name(adj, O)
St. Emilion is red.
Notation: ref(Œæ) stands for a referring expression for Œæ; name(Œæ) is the natural language name of Œæ;
name(indef, Œæ) and name(noarticle, Œæ) mean that the name should be a noun phrase with an indefinite
or no article. Sentence plans involving name(adj, Œæ) are used when the natural language name of Œæ
is a sequence of one or more adjectives; otherwise the sentence plan of the previous row is used.

Table 3: Built-in English sentence plans for domain-independent properties.
shown in Figure 3 require, for example, subject-verb number agreement and the verb forms
(‚Äúis‚Äù or ‚Äúwas‚Äù) to be in present tense. Information provided when specifying the natural
language names of individuals and classes, discussed below, shows if definite or indefinite
articles or no articles at all should be used (e.g., ‚Äúthe n97 mini‚Äù, ‚Äúexhibit 24‚Äù, ‚Äúa St. Emilion‚Äù or ‚Äúthe St. Emilion‚Äù or simply ‚ÄúSt. Emilion‚Äù), and what the default number of each
name is (e.g., ‚ÄúA wine color is‚Äù or ‚ÄúWine colors are‚Äù). It is also possible to modify the
built-in sentence plans; for example, in a museum context we may wish to generate ‚ÄúAn
aryballos was a kind of vase‚Äù instead of ‚ÄúAn aryballos is a kind of vase‚Äù.
The sentence plans for modified properties (e.g., minCardinality(manufacturedBy), see
Tables 1‚Äì2) are also automatically produced, from the sentence plans of the unmodified
properties (e.g., manufacturedBy).
Specifying the appropriateness of sentence plans
Multiple sentence plans may be provided for the same property of the ontology and the
same language. Different appropriateness scores (similar to the interest scores of properties)
can then be assigned to alternative sentence plans per user type. This allows specifying, for
example, that a sentence plan that generates sentences like ‚ÄúThis amphora depicts Miltiades‚Äù is less appropriate when interacting with children, compared to an alternative sentence
plan with a more common verb (e.g., ‚Äúshows‚Äù). Automatically constructed sentence plans
inherit the appropriateness scores of the sentence plans they are constructed from.
Related work on sentence plans
The sentence plans of Naturalowl are similar to expressions of sentence planning languages like spl (Kasper & Whitney, 1989) that are used in generic surface realizers, such as
fuf/surge (Elhadad & Robin, 1996), kpml (Bateman, 1997), realpro (Lavoie & Ram693

Androutsopoulos, Lampouras, & Galanis

bow, 1997), nitrogen/halogen (Langkilde, 2000), and openccg (White, 2006). The
sentence plans of Naturalowl, however, leave fewer decisions to subsequent stages. This
has the disadvantage that our sentence plans often include information that could be obtained from large-scale grammars or corpora (Wan, Dras, Dale, & Paris, 2010). On the
other hand, the input to generic surface realizers often refers to non-elementary linguistic concepts (e.g., features of a particular syntax theory) and concepts of an upper model
(Bateman, 1990); the latter is a high-level domain-independent ontology that may use a very
different conceptualization than the ontology the texts are to be generated from. Hence,
linguistic expertise, for example in Systemic Grammars (Halliday, 1994) in the case of kpml
(Bateman, 1997), and effort to understand the upper model are required. By contrast, the
sentence plans of Naturalowl require the domain author to be familiar with only elementary linguistic concepts (e.g., tense, number), and they do not require familiarity with an
upper model. Our sentence plans are simpler than, for example, the templates of Busemann and Horacek (1999) or McRoy et al. (2003), in that they do not allow, for instance,
conditionals or recursive invokation of other templates. See also the work of Reiter (1995)
and van Deemter et al. (2005) for a discussion of template-based vs. more principled nlg.
When corpora of texts annotated with the message triples they express are available,
templates can also be automatically extracted (Ratnaparkhi, 2000; Angeli, Liang, & Klein,
2010; Duma & Klein, 2013). Statistical methods that jointly perform content selection,
lexicalization, and surface realization have also been proposed (Liang, Jordan, & Klein,
2009; Konstas & Lapata, 2012a, 2012b), but they are currently limited to generating single
sentences from flat records.
Specifying natural language names
The domain author can assign natural language (nl) names to the individuals and
named classes of the ontology; recall that by named classes we mean classes that have owl
identifiers. If an individual or named class is not assigned an nl name, then its rdfs:label
or a tokenized form of its identifier is used instead. The nl names that the domain author
provides are specified much as sentence plans, i.e., as sequences of slots. For example, we
may specify that the English nl name of the class ItalianWinePiemonte is the concatenation
of the following slots; we explain the slots below.
[indef an] [adj Italian] [headnoun wine] [prep from] [def the] [noun Piemonte] [noun region]

This would allow Naturalowl to generate the sentence shown below from the following
message triple; a tokenized form of the identifier of wine32 is used.
<:wine32, instanceOf, :ItalianWinePiemonte>

Wine 32 is an Italian wine from the Piemonte region.

Similarly, we may assign the following nl names to the individuals classicalPeriod, stoa
ZeusEleutherios, gl2011, and the classes ComputerScreen and Red. Naturalowl makes no
distinction between common and proper nouns; both are entered as nouns in the lexicon,
and may be multi-word (e.g., ‚ÄúZeus Eleutherios‚Äù). Naturalowl can also be instructed to
capitalize the words of particular slots (e.g., ‚ÄúClassical‚Äù).
694

Generating Natural Language Descriptions from OWL Ontologies

[def the] [adj Classical] [headnoun period] , [def the] [headnoun stoa] [prep of] [noun Zeus Eleutherios],
[headnoun GL-2011] , [indef a] [noun computer] [headnoun screen] , [headadj red]

These nl names could be used to express the message triples shown below:
<:stoaZeusEleutherios, :usedDuringPeriod,

:classicalPeriod>

The Stoa of Zeus Eleutherios was used during the Classical period.
<:gl2011, instanceOf, :ComputerScreen>

<:gl2011, instanceOf, :Red>

GL-2011 is a computer screen. GL-2011 is red.

More precisely, each nl name is a sequence of slots, with accompanying instructions
specifying how the slots are to be filled in. Each slot can be filled in with:
(i) An article, definite or indefinite. The article in the first slot (if present) is treated as
the article of the overall nl name.
(ii) A noun or adjective flagged as the head (main word) of the nl name. Exactly one
head must be specified per nl name and it must have a lexicon entry. The number and case
of the head, which is also taken to be the number and case of the overall nl name, can be
automatically adjusted per context. For example, different sentence plans may require the
same nl name to be in nominative case when used as a subject, but in accusative when used
as the object of a verb; and some aggregation rules, discussed below, may require a singular
nl name to be turned into plural. Using the lexicon entries, which list the inflectional forms
of nouns and adjectives, Naturalowl can adjust the nl names accordingly. The gender of
head adjectives can also be automatically adjusted, whereas the gender of head nouns is
fixed and specified by their lexicon entries.
(iii) Any other noun or adjective, among those listed in the lexicon. The nl name may
require a particular inflectional form to be used, or it may require an inflectional form that
agrees with another slot of the nl name.
(iv) A preposition, or (v) any fixed string.
As with sentence plans, the domain author specifies nl names by using the ProteÃÅgeÃÅ
plug-in of Naturalowl. Multiple nl names can be specified for the same individual or class,
and they can be assigned different appropriateness scores per user type; hence, different
terminology (e.g., common names of diseases) can be used when generating texts for nonexperts, as opposed to texts for experts (e.g., doctors). The domain author can also specify,
again using the plug-in, if the nl names of particular individuals or classes should involve
definite, indefinite, or no articles, and if the nl names should be in singular or plural by
default. For example, we may prefer the texts to mention the class of aryballoi as a single
particular generic object, or by using an indefinite singular or plural form, as shown below.
The aryballos is a kind of vase. An aryballos is a kind of vase. Aryballoi are a kind of vase.

695

Androutsopoulos, Lampouras, & Galanis

3.2.2 Sentence Aggregation
The sentence plans of the previous section lead to a separate sentence for each message triple.
nlg systems often aggregate sentences into longer ones to improve readability. In Naturalowl, the maximum number of sentences that can be aggregated to form a single longer
sentence is specified per user type via a parameter called maxMessagesPerSentence. In the
museum contexts our system was originally developed for, setting maxMessagesPerSentence
to 3 or 4 led to reasonable texts for adult visitors, whereas a value of 2 was used for children. The sentence aggregation of Naturalowl is performed by a set of manually crafted
rules, intended to be domain-independent. We do not claim that this set of rules, which
was initially based on the aggregation rules of m-piro (Melengoglou, 2002), is complete,
and we hope it will be extended in future work; see, for example, the work of Dalianis
(1999) for a rich set of aggregation rules.20 Nevertheless, the current rules of Naturalowl
already illustrate several aggregation opportunities that arise when generating texts from
owl ontologies.
To save space, we discuss only English sentence aggregation; Greek aggregation is similar. We show mostly example sentences before and after aggregation, but the rules actually
operate on sentence plans and they also consider the message triples being expressed. The
rules are intended to aggregate short single-clause sentences. Sentence plans that produce
more complicated sentences may be flagged (using the tickbox at the bottom of Figure
5) to signal that aggregation should not affect their sentences. The aggregation rules apply almost exclusively to sentences that are adjacent in the ordering produced by the text
planner; the only exception are aggregation rules that involve sentences about cardinality
restrictions. Hence, depending on the ordering of the text planner there may be more or
fewer aggregation opportunities; see the work of Cheng and Mellish (2000) for related discussion. Also, the aggregation rules of Naturalowl operate on sentences of the same topical
section, because aggregating topically unrelated sentences often sounds unnatural.
The aggregation of Naturalowl is greedy. For each of the rules discussed below, starting
from those discussed first, the system scans the original (ordered) sentences from first to
last, applying the rule wherever possible, provided that the rule‚Äôs application does not lead
to a sentence expressing more than maxMessagesPerSentence original sentences. If a rule can
be applied in multiple ways, for example to aggregate two or three sentences, the application
that aggregates the most sentences without violating maxMessagesPerSentence is preferred.
Avoid repeating a noun with multiple adjectives: Message triples of the form hS, P, O1 i, . . . ,
hS, P, On i will have been aggregated into a single message triple hS, P, and(O1 , . . . , On )i.
If the nl names of O1 , . . . , On are, apart from possible initial determiners, sequences of
adjectives followed by the same head noun, then the head noun does not need to be repeated.
Let us consider the following message triple. Assuming that the nl names of the three
periods are as in the first sentence below, the original sentence will repeat ‚Äúperiod‚Äù three
times. The aggregation rule omits all but the last occurrence of the head noun.
<:stoaZeusEleutherios, :usedDuringPeriod, and(:classicalPeriod, :hellenisticPeriod, :romanPeriod)>

It was used during the Classical period, the Hellenistic period, and the Roman period.

‚áí It was used

during the Classical, the Hellenistic, and the Roman period.
20. When appropriate corpora are available, it may also be possible to train aggregation modules (Walker,
Rambow, & Rogati, 2001; Barzilay & Lapata, 2006).

696

Generating Natural Language Descriptions from OWL Ontologies

Cardinality restrictions and values: This is a set of rules that aggregate all the sentences (not
necessarily adjacent) that express message triples of the form hS, M (P ), Oi and hS, P, Oi, for
the same S and P , with M being any of minCardinality, maxCardinality, exactCardinality.
When these rules are applied, MaxMessagesPerSentence is ignored. For example, these rules
perform aggregations like the following.
Model 35 is sold in at most three countries. Model 35 is sold in at least three countries. Model 35 is sold
in Spain, Italy, and Greece.

‚áí Model 35 is sold in exactly three countries: Spain, Italy, and Greece.

Class and passive sentence: This rule aggregates (i) a sentence expressing a message triple
hS, instanceOf, Ci or hS, isA, Ci and (ii) a passive immediately subsequent sentence expressing a single triple of the form hS, P, Oi, for the same S, where P is an (unmodified) property
of the ontology. The subject and auxiliary verb of the second sentence are omitted.
Bancroft Chardonnay is a kind of Chardonnay. It is made in Bancroft.

‚áí Bancroft Chardonnay is a

kind of Chardonnay made in Bancroft.

Class and prepositional phrase: The second sentence now involves the verb ‚Äúto be‚Äù in the
active simple present, immediately followed by a preposition; the other conditions are as in
the previous rule. The subject and verb of the second sentence are omitted.
Bancroft Chardonnay is a kind of Chardonnay. It is from Bancroft.

‚áí Bancroft Chardonnay is a kind

of Chardonnay from Bancroft.

Class and multiple adjectives: This rule aggregates (i) a sentence of the same form as in
the previous two rules, and (ii) one or more immediately preceding or subsequent sentences,
each expressing a single message triple hS, Pi , Oi i, for the same S, where Pi are (unmodified)
properties of the ontology. Each of the preceding or subsequent sentences must involve the
verb ‚Äúto be‚Äù in the active simple present, immediately followed by only an adjective. The
adjectives are absorbed into sentence (i) maintaining their order.
This is a motorbike. It is red. It is expensive.

‚áí This is a red, expensive motorbike.

Same verb conjunction/disjunction: In a sequence of sentences involving the same verb
form, each expressing a single message triple hS, Pi , Oi i, where S is the same in all the
triples and Pi are (unmodified) properties of the ontology, a conjunction can be formed by
mentioning the subject and verb once. The ‚Äúand‚Äù is omitted when a preposition follows.
‚áí It has medium body and moderate flavor.
He was born in Athens. He was born in 1918. ‚áí He was born in Athens in 1918.
It has medium body. It has moderate flavor.

A similar rule applies to sentences produced from disjunctions of message triples, as illustrated below. A variant of the first aggregation rule is then also applied.
The house wine has strong flavor or it has medium flavor.
flavor.

‚áí The house wine has strong or medium flavor.
697

‚áí The house wine has strong flavor or medium

Androutsopoulos, Lampouras, & Galanis

Different verbs conjunction: When there is a sequence of sentences, not involving the same
verb form, each expressing a message triple hS, Pi , Oi i, where S is the same in all the triples
and Pi are (unmodified) properties of the ontology, a conjunction can be formed:
Bancroft Chardonnay is dry. It has moderate flavor. It comes from Napa.

‚áí Bancroft Chardonnay is

dry, it has moderate flavor, and it comes from Napa.

3.2.3 Generating Referring Expressions
A sentence plan may require a referring expression to be generated for the S of a message
triple hS, P, Oi. Depending on the context, it may be better, for example, to use the nl
name of S (e.g., ‚Äúthe Stoa of Zeus Eleutherios‚Äù), a pronoun (e.g., ‚Äúit‚Äù), a demonstrative
noun phrase (e.g., ‚Äúthis stoa‚Äù) etc. Similar alternatives could be made available for O,
but Naturalowl currently uses O itself, if it is a datatype value; or the nl name of O, its
tokenized identifier, or its rdfs:label, if O is an entity or class; and similarly for conjunctions
and disjunctions in O. Hence, below we focus only on referring expressions for S.
Naturalowl currently uses a limited range of referring expressions, which includes only
nl names (or tokenized identifiers or rdfs:label strings), pronouns, and noun phrases
involving only a demonstrative and the nl name of a class (e.g., ‚Äúthis vase‚Äù). For example,
referring expressions that mention properties of S (e.g., ‚Äúthe vase from Rome‚Äù) are not
generated. Although the current referring expression generation mechanisms of Naturalowl
work reasonably well, they are best viewed as placeholders for more elaborate algorithms
(Krahmer & van Deemter, 2012), especially algorithms based on description logics (Areces,
Koller, & Striegnitz, 2008; Ren, van Deemter, & Pan, 2010).
Let us consider the following generated text, which expresses the triples hSi , Pi , Oi i
shown below. We do not aggregate sentences in this section, to illustrate more cases where
referring expressions are needed; aggregation would reduce, however, the number of pronouns, making the text less repetitive. For readers familiar with ct (Section 3.1.2), we
show again in italics the noun phrase realizing cp (un ), we show underlined the noun phrase
realizing cb (un ), and we mark nocb transitions with bullets.
(1) Exhibit 7 is a statue. (2) It was sculpted by Nikolaou. (3) Nikolaou was born in Athens. (4) He was
born in 1918. (5) He died in 1998. ‚Ä¢ (6) Exhibit 7 is now in the National Gallery. (7) It is in excellent
condition.
<:exhibit7,
<:nikolaou,
<:nikolaou,
<:exhibit7,

instanceOf, :Statue>
<:exhibit7, :hasSculptor, :nikolaou>
:cityBorn, :athens>
<:nikolaou, :yearBorn, "1918"^^xsd:integer>
:yearDied, "1998"^^xsd:integer>
<:exhibit7, :currentLocation, :nationalGallery>
:currentCondition, :excellentCondition>

Naturalowl pronominalizes Sn (for n > 1) only if Sn = Sn‚àí1 , as in sentences 2, 4, 5, and
7. Since typically cp (ui ) = Si , we obtain cp (un ) = cp (un‚àí1 ), whenever Sn is pronominalized, if the pronoun is resolved by the reader as intended. People tend to prefer readings
where cp (un ) = cp (un‚àí1 ), if no other restriction is violated (e.g., gender, number, world
knowledge). This helps the pronouns that Naturalowl generates to be correctly resolved
by readers, even when they would appear to be potentially ambiguous. For example, the
pronoun of sentence 7 is most naturally understood as referring to the exhibit, as it is intended to, not the gallery, even though both are neuter and can be in excellent condition.
698

Generating Natural Language Descriptions from OWL Ontologies

Note that with both referents, the transition from sentence 6 to 7 is a continue; hence,
transition type preferences play no role. The gender of each generated pronoun is the gender
of the (most appropriate) nl name of the S that the pronoun realizes.21 If S does not have
an nl name, Naturalowl uses the gender of the (most appropriate) nl name of the most
specific class that includes S and has an nl name (or one of these classes, if they are many).
nl names can also be associated with sets of genders, which give rise to pseudo-pronouns
like ‚Äúhe/she‚Äù; this may be desirable in the nl name of a class like Person.
With some individuals or classes, we may not wish to use nl names, nor tokenized
identifiers or rdfs:label strings. This is common, for example, in museum ontologies, where
some exhibits are known by particular names, but many other exhibits are anonymous and
their owl identifiers are not particularly meaningful. Naturalowl allows the domain author
to mark individuals and classes as anonymous, to indicate that their nl names, tokenized
identifiers, and rdfs:label strings should be avoided. When the primary target is marked as
anonymous, Naturalowl uses a demonstrative noun phrase (e.g., ‚Äúthis statue‚Äù) to refer to
it. The demonstrative phrase involves the nl name of the most specific class that subsumes
the primary target, has an nl name, and has not been marked as anonymous. Especially
in sentences that express isA or instanceOf message triples about the primary target, the
demonstrative phrase is simply ‚Äúthis‚Äù, to avoid generating sentences like ‚ÄúThis statue is
a statue‚Äù. The marking of anonymous individuals and classes currently affects only the
referring expressions of the primary target.
3.3 Surface Realization
In many nlg systems, the sentences at the end of micro-planning are underspecified; for
example, the order of their constituents or the exact forms of their words may be unspecified.
Large-scale grammars or statistical models can then be used to fill in the missing information
during surface realization, as already discussed (Section 3.2.1). By contrast, in Naturalowl
(and most template-based nlg systems) the (ordered and aggregated) sentence plans at the
end of micro-planning already completely specify the surface (final) form of each sentence.
Hence, the surface realization of Naturalowl is mostly a process of converting internal,
but fully specified and ordered sentence specifications to the final text. Punctuation and
capitalization are also added. Application-specific markup (e.g., html tags, hyperlinks) or
images can also be added by modifying the surface realization code of Naturalowl.

4. Trials
In our previous work, Naturalowl was used mostly to describe cultural heritage objects.
In the xenios project, it was tested with an owl version of an ontology that was created
during m-piro to document approximately 50 archaeological exhibits (Androutsopoulos et
al., 2007).22 The owl version comprised 76 classes, 343 individuals (including cities, persons
etc.), and 41 properties. In xenios, Naturalowl was also embedded in a robotic avatar
that presented the exhibits of m-piro in a virtual museum (Oberlander, Karakatsiotis,
21. In languages like Greek that use grammatical instead of natural genders, the pronouns‚Äô genders cannot
be determined by consulting the ontology (e.g., to check if the referent is animate or inanimate).
22. xenios was co-funded by the European Union and the Greek General Secretariat of Research and Technology; see http://www.ics.forth.gr/xenios/.

699

Androutsopoulos, Lampouras, & Galanis

Isard, & Androutsopoulos, 2008). More recently, in the indigo project, Naturalowl was
embedded in mobile robots acting as tour guides in an exhibition about the ancient Agora
of Athens.23 An owl ontology documenting 43 monuments was used; there were 49 classes,
494 individuals, and 56 properties in total.
In xenios and indigo, the texts of Naturalowl were eventually indistinguishable from
human-authored texts. We participated, however, in the development of the ontologies, and
we may have biased them towards choices (e.g., classes, properties) that made it easier for
Naturalowl to generate high-quality texts. Hence, in the trials discussed below, we wanted
to experiment with independently developed ontologies. We also wanted to experiment with
different domains, as opposed to cultural heritage.
A further goal was to compare the texts of Naturalowl against those of a simpler verbalizer. We used the owl verbalizer of the swat project (Stevens et al., 2011; Williams,
Third, & Power, 2011), which we found to be particularly robust and useful.24 The verbalizer produces an alphabetical glossary with an entry for each named class, property, and
individual, without requiring domain-dependent generation resources. Each glossary entry
is a sequence of English-like sentences expressing the corresponding owl statements of the
ontology. The swat verbalizer uses a predetermined partial order of statements in each
glossary entry; for example, when describing a class, statements about equivalent classes
or super-classes are mentioned first, and individuals belonging in the target class are mentioned last.25 The verbalizer actually translates the owl ontology to Prolog, it extracts
lexicon entries from owl identifiers and rdfs:label strings, and it uses predetermined sentence plans specified as a dcg grammar. It also aggregates, in effect, message triples of the
same property that share one argument (S or O) (Williams & Power, 2010).
Our hypothesis was that the domain-dependent generation resources would help Naturalowl produce texts that end-users would consider more fluent and coherent, compared
to those produced by the swat verbalizer, but also those produced by Naturalowl without
domain-dependent generation resources. We also wanted to demonstrate that high-quality
texts could be produced in both English and Greek, and to measure the effort required
to create the domain-dependent generation resources of Naturalowl for existing ontologies. This effort had not been measured in our previous work, because the development
of the domain-dependent generation resources was combined with the development of the
ontologies. Since the time needed to create the domain-dependent generation resources
depends on one‚Äôs familiarity with Naturalowl and its ProteÃÅgeÃÅ plug-in, exact times are not
particularly informative. Instead, we report figures such as the number of sentence plans,
lexicon entries etc. that were required, along with approximate times. We do not evaluate
23. indigo was an fp6 ist project of the European Union; consult http://www.ics.forth.gr/indigo/.
Videos of the robots of xenios and indigo are available at http://nlp.cs.aueb.gr/projects.html.
Two aueb students, G. Karakatsiotis and V. Pterneas, won the Interoperability Challenge of the 2011
Microsoft Imagine Cup with a similar mobile phone application, called Touring Machine, which uses
Naturalowl; see http://www.youtube.com/watch?v=PaNAmNC7dZw.
24. The swat verbalizer can be used on-line at http://swat.open.ac.uk/tools/. We used the generalpurpose version that was on-line in July and August 2011; a similar verbalizer from owl to ace (Section
2) is available at http://attempto.ifi.uzh.ch/site/docs/owl to ace.html. A domain-specific version
of swat for the snomed biomedical ontology has also been developed (Liang et al., 2011a, 2011b).
25. The verbalizer also organizes the English-like sentences of each glossary entry under sub-headings like
‚ÄòDefinition‚Äô, ‚ÄòTaxonomy‚Äô, ‚ÄòDescription‚Äô, ‚ÄòDistinctions‚Äô (Williams et al., 2011). We discarded these subheadings, whose meanings were not entirely clear to us, but we retained the order of the sentences.

700

Generating Natural Language Descriptions from OWL Ontologies

the usability of the ProteÃÅgeÃÅ plug-in of Naturalowl, since it is very similar to the authoring
tool of m-piro. Previous experiments (Androutsopoulos et al., 2007) showed that computer
science graduates with no expertise in nlg could learn to use effectively the authoring tool
of m-piro to create the necessary domain-dependent generation resources for existing or
new ontologies, after receiving the equivalent of a full-day introduction course.
4.1 Trials with the Wine Ontology
In the first trial, we experimented with the Wine Ontology, which is often used in Semantic
Web tutorials.26 It comprises 63 wine classes, 52 wine individuals, a total of 238 classes and
individuals (including wineries, regions, etc.), and 14 properties.
We submitted the Wine Ontology to the swat verbalizer to obtain its glossary of Englishlike descriptions of classes, properties, and individuals. We retained only the descriptions
of the 63 wine classes and the 52 wine individuals. Subsequently, we also discarded 20 of
the 63 wine class descriptions, as they were for trivial classes (e.g., RedWine) and they were
stating the obvious (e.g., ‚ÄúA red wine is defined as a wine that has as color Red‚Äù).27 In
the descriptions of the remaining 43 wine classes and 52 wine individuals, we discarded
sentences expressing axioms that Naturalowl does not consider, for example sentences
providing examples of individuals that belong in a class being described. The remaining
sentences express the same owl statements that Naturalowl expresses when its maximum
fact distance is set to 1. Two examples of texts produced by the swat verbalizer follow.
Chenin Blanc (class): A chenin blanc is defined as something that is a wine, is made from grape the
Chenin Blanc Grape, and is made from grape at most one thing. A chenin blanc both has as flavor
Moderate, and has as color White. A chenin blanc both has as sugar only Off Dry and Dry, and has as
body only Full and Medium.
The Foxen Chenin Blanc (individual): The Foxen Chenin Blanc is a chenin blanc. The Foxen Chenin
Blanc has as body Full. The Foxen Chenin Blanc has as flavor Moderate. The Foxen Chenin Blanc has
as maker Foxen. The Foxen Chenin Blanc has as sugar Dry. The Foxen Chenin Blanc is located in the
Santa Barbara Region.

Subsequently, we generated texts for the 43 classes and 52 individuals using Naturalowl
without domain-dependent generation resources, hereafter called Naturalowl(‚àí), setting
the maximum fact distance to 1; the resulting texts were very similar to swat‚Äôs.
We then constructed the domain-dependent generation resources of Naturalowl for the
Wine Ontology. The resources are summarized in Table 4. They were constructed by the
second author, who devoted three days to their construction, testing, and refinement.28
Our experience is that it takes weeks (if not longer) to develop an owl ontology the size
of the Wine Ontology (acquire domain knowledge, formulate the axioms in owl, check for
inconsistencies, populate the ontology with individuals etc.); hence, a period of a few days is
26. See http://www.w3.org/TR/owl-guide/wine.rdf.
27. Third (2012) discusses how owl axioms leading to undesirable sentences of this kind might be detected.
28. Some of the resources were constructed by editing directly their owl representations, rather than using
the ProteÃÅgeÃÅ plug-in, which was not fully functional at that time. By using the now fully functional
plug-in, the time to create the domain-dependent generation resources would have been shorter.

701

Androutsopoulos, Lampouras, & Galanis
Resources
Sections
Property assignments to sections
Interest score assignments
Sentence plans
Lexicon entries
Natural language names

English

Greek
2
7
8

5
67
41

‚àí
‚àí
‚àí

Table 4: Domain-dependent generation resources created for the Wine Ontology.
relatively light effort, compared to the time needed to develop an owl ontology of this size.
Only English texts were generated in this trial; hence, no Greek resources were constructed.
We defined only one user type, and we used interest scores only to block sentences stating
the obvious, by assigning zero interest scores to the corresponding message triples; we also
set maxMessagesPerSentence to 3. Only 7 of the 14 properties of the Wine Ontology are used
in the owl statements that describe the 43 classes and 52 individuals. We defined only 5
sentence plans, as some of the 7 properties could be expressed by the same sentence plans.
We did not define multiple sentence plans per property. We also assigned the 7 properties
to 2 sections, and ordered the sections and properties. We created nl names only when
the automatically extracted ones were causing disfluencies. The extracted nl names were
obtained from the owl identifiers of classes and individuals; no rdfs:label strings were
available. To reduce the number of manually constructed nl names further, we declared
the 52 individual wines to be anonymous (and provided no nl names for them). Most of
the 67 lexicon entries were used in the remaining 41 nl names of classes and individuals;
nl names were very simple, having 2 slots on average. We used Naturalowl with the
domain-dependent resources, hereafter called Naturalowl(+), to re-generate the 95 texts,
again setting the maximum fact distance to 1; example texts follow.
Chenin Blanc (class): A Chenin Blanc is a moderate, white wine. It has only a full or medium body. It
is only off-dry or dry. It is made from exactly one wine grape variety: Chenin Blanc grapes.

The Foxen Chenin Blanc (individual): This wine is a moderate, dry Chenin Blanc. It has a full body. It
is made by Foxen in the Santa Barbara County.

The resulting 285 texts (95 √ó 3) of the three systems (swat verbalizer, Naturalowl(‚àí),
Naturalowl(+)) were shown to 10 computer science students (both undergraduates and
graduate students), who were not involved in the development of Naturalowl; they were all
fluent in English, though not native English speakers, and they did not consider themselves
wine experts. The students were told that a glossary of wines was being developed for people
who were interested in wines and knew basic wine terms (e.g., wine colors, wine flavors),
but who were otherwise not wine experts. Each one of the 285 texts was given to exactly
one student. Each student was given approximately 30 texts, approximately 10 randomly
selected texts from each system. The owl statements that the texts were generated from
were not shown, and the students did not know which system had generated each text.
Each student was shown all of his/her texts in random order, regardless of the system that
had generated them. The students were asked to score each text by stating how strongly
they agreed or disagreed with statements S1 ‚ÄìS5 below. A scale from 1 to 3 was used (1:
disagreement, 2: ambivalent, 3: agreement).
702

Generating Natural Language Descriptions from OWL Ontologies
Criteria
Sentence fluency
Referring expressions
Text structure
Clarity
Interest

swat
2.00 ¬± 0.15
1.40 ¬± 0.13
2.15 ¬± 0.16
2.66 ¬± 0.13
2.30 ¬± 0.15

Naturalowl(‚àí)
1.76 ¬± 0.15
1.15 ¬± 0.09
2.20 ¬± 0.16
2.55 ¬± 0.13
2.14 ¬± 0.16

Naturalowl(+)
2.80 ¬± 0.10
2.72 ¬± 0.13
2.94 ¬± 0.05
2.74 ¬± 0.11
2.68 ¬± 0.12

Table 5: Results for texts generated from the Wine Ontology by the swat verbalizer and
Naturalowl with (+) and without (‚àí) domain-dependent generation resources.
(S1 ) Sentence fluency: The sentences of the text are fluent, i.e., each sentence on its own is grammatical
and sounds natural. When two or more smaller sentences are combined to form a single, longer sentence,
the resulting longer sentence is also grammatical and sounds natural.
(S2 ) Referring expressions: The use of pronouns and other referring expressions (e.g., ‚Äúthis wine‚Äù) is
appropriate. The choices of referring expressions (e.g., when to use a pronoun or other expression instead
of the name of an object) sound natural, and it is easy to understand what these expressions refer to.
(S3 ) Text structure: The order of the sentences is appropriate. The text presents information by moving
reasonably from one topic to another.
(S4 ) Clarity: The text is easy to understand, provided that the reader is familiar with basic wine terms.
(S5 ) Interest: People interested in wines, but who are not wine experts, would find the information
interesting. Furthermore, there are no redundant sentences in the text (e.g., sentences stating the obvious).29

S5 assesses content selection, the first processing sub-stage; we expected the differences
across the three systems to be very small, as they all reported the same information, with the
exception of redundant sentences blocked by using zero interest assignments in Naturalowl.
S3 assesses text planning, the second sub-stage; again we expected small differences, as many
of the wine properties can be mentioned in any order, though there are some properties (e.g.,
maker, location) that are most naturally reported separately from others (e.g., color, flavor),
which is why we used two sections (Table 4). S1 assesses lexicalization and aggregation; we
decided not to use separate statements for these two stages, since it might have been difficult
for the students to understand exactly when aggregation takes place. S2 assesses referring
expression generation. S4 measures the overall perceived clarity of the texts. There was no
statement for surface realization, as this stage had a rather trivial effect.
Table 5 shows the average scores of the three systems, with averages computed on the
95 texts of each system, along with 95% confidence intervals (of sample means). For each
criterion, the best score is shown in bold; the confidence interval of the best score is also
shown in bold if it does not overlap with the other confidence intervals.30
As expected, the domain-dependent generation resources clearly help Naturalowl produce more fluent sentences and much better referring expressions. The text structure scores
show that the assignment of the ontology‚Äôs properties to sections and the ordering of the
sections and properties had a greater impact on the perceived structure of the texts than
we expected. The highest score of the swat verbalizer was obtained in the clarity criterion, which agrees with our experience that one can usually understand what the texts of
the swat verbalizer mean, even if their sentences are often not entirely fluent, not particularly well ordered, and keep repeating proper names. Naturalowl(+)had the highest clarity
29. The students were told not to consider whether or not additional information should have been included.
30. When two intervals do not overlap, the difference is statistically significant. When they overlap, the
difference may still be statistically significant; we performed paired two-tailed t-tests (Œ± = 0.05) in these
cases. In a pilot study, we also measured the inter-annotator agreement of two of the students on a sample
of 30 texts (10 from each system). Agreement was very high (sample Pearson correlation r ‚â• 0.91) in all
five criteria. A similar pilot study was performed in the next trial, also indicating very high agreement.

703

Androutsopoulos, Lampouras, & Galanis

score, but the difference from the swat verbalizer, which had the second highest score, is not
statistically significant. Naturalowl(+)also obtained higher interest scores than the other
two systems, with statistically significant differences from both; these differences, which are
larger than we expected, can only be attributed to the zero interest score assignments of
the domain-dependent generation resources, which blocked sentences stating the obvious,
because otherwise all three systems report the same information.
The swat verbalizer obtained higher scores than Naturalowl(‚àí), with the text structure score being the only exception. Only the difference in the referring expression scores
of the two systems, though, is statistically significant. Both systems, however, received
particularly low scores for their referring expressions, which is not surprising, given that
they both always refer to individuals and classes by extracted names; the slightly higher
score of the swat verbalizer is probably due to its better tokenization of owl identifiers.
4.2 Trials with the Consumer Electronics Ontology
In the second trial, we experimented with the Consumer Electronics Ontology, an owl ontology for consumer electronics products and services.31 The ontology comprises 54 classes
and 441 individuals (e.g., printer types, paper sizes, manufacturers), but no information
about particular products. We added 60 individuals describing 20 digital cameras, 20 camcorders, and 20 printers. The 60 individuals were randomly selected from a publicly available
dataset of 286 digital cameras, 613 camcorders, and 58 printers, whose instances comply
with the Consumer Electronics Ontology.32
We submitted the Consumer Electronics Ontology with the additional 60 individuals
to the swat verbalizer, and retained only the descriptions of the 60 individuals. Again,
we removed sentences expressing axioms Naturalowl does not consider. We also renamed
the string values of some datatype properties to make the texts easier to understand (e.g.,
‚Äúcmt‚Äù became ‚Äúcm‚Äù). An example description follows.
The Sony Cyber-shot DSC-T90 is a digital camera.
The Sony Cyber-shot DSC-T90 has as manufacturer Sony.
The Sony Cyber-shot DSC-T90 has as data interface type Usb2 0.
The Sony Cyber-shot DSC-T90 has as depth Depth. Depth has as unit of measurement cm. Depth has as value
float 9.4.
The Sony Cyber-shot DSC-T90 has as digital zoom factor the Digital Zoom Factor. The Digital Zoom Factor has
as value float 12.1. [. . . ]
The Sony Cyber-shot DSC-T90 has as feature Video Recording, Microphone and the Automatic Picture Stabilizer.
The Sony Cyber-shot DSC-T90 has as self timer true. [. . . ]

In this ontology, many properties have composite values, expressed by using auxiliary individuals. In the example above, a property (hasDepth) connects the digital camera to an
auxiliary individual Depth (similar to the anonymous node :n of the property concatenation
price example of page 691), which is then connected via two other properties (hasValueFloat
31. Consult http://www.ebusiness-unibw.org/ontologies/consumerelectronics/v1.
32. See http://rdf4ecommerce.esolda.com/ for the dataset that we used. A list of similar datasets is
available at http://wiki.goodrelations-vocabulary.org/Datasets.

704

Generating Natural Language Descriptions from OWL Ontologies

and hasUnitOfMeasurement) to the float value 9.4 and the unit of measurement (centimeters), respectively. We obtained the descriptions of the auxiliary individuals (e.g., Depth),
which are different entries in the glossary of the swat verbalizer, and we copied them immediately after the corresponding sentences that introduce the auxiliary individuals. We
also formatted each text as a list of sentences, as above, to improve readability.
We then generated texts for the 60 products using Naturalowl(‚àí), setting the maximum
fact distance to 1. Descriptions of auxiliary individuals were also generated and copied
immediately after the sentences introducing them. The texts were very similar to those of
the swat verbalizer, and they were formatted in the same manner.
In this trial, we also wanted to consider a scenario where the set of individuals to be
described changes frequently (e.g., the products sold by a reseller change, new products arrive etc.) along with changes in other connected individuals (e.g., new manufacturers may
be added), but nothing else in the ontology changes, i.e., only the assertional knowledge
changes. In this case, it may be impractical to update the domain-dependent generation
resources whenever the population of individuals changes. Our hypothesis was that by considering a sample of individuals of the types to be described (printers, cameras, camcorders,
in our case), it would be possible to construct domain-dependent generation resources (e.g.,
sections, the ordering of sections and properties, sentence plans, the nl names of classes)
that would help Naturalowl generate reasonably good descriptions of new (unseen) individuals (products), without updating the domain-dependent generation resources, using the
tokenized owl identifiers or rdfs:label strings of the new individuals as their nl names.
To simulate this scenario, we randomly split the 60 products in two non-overlapping sets,
the development set and the test set, each consisting of 10 digital cameras, 10 camcorders,
and 10 printers. Again, the second author constructed and refined the domain-dependent
generation resources of Naturalowl, this time by considering a version of the ontology that
included the 30 development products, but not the 30 test products, and by viewing the
generated texts of the 30 development products only. This took approximately six days (for
two languages).33 Hence, relatively light effort was again needed, compared to the time it
typically takes to develop an ontology of this size, with terminology in two languages. Texts
for the 30 products of the test set were then also generated by using Naturalowl and the
domain-dependent generation resources of the development set.
As in the previous trial, we defined only one user type, and we used interest scores only
to block sentences stating the obvious. The maximum messages per sentence was again 3.
We constructed domain-dependent generation resources for both English and Greek; the
resources are summarized in Table 6. We created sentence plans only for the 42 properties
of the ontology that were used in the development set (one sentence plan per property); the
test set uses two additional properties, for which the default sentence plans of Naturalowl
(for English and Greek) were used. We also assigned the 42 properties to 6 sections, and
ordered the sections and properties. We created nl names only when the automatically
extracted ones were causing disfluencies in the development texts. Unlike the previous
trial, the products to be described were not declared to be anonymous individuals, but the
number of nl names that had to be provided was roughly the same as in the previous trial,
33. Again, some of the domain-dependent generation resources were constructed by editing their owl representations. As a test, the second author later reconstructed the domain-dependent generation resources
from scratch using the fully functional ProteÃÅgeÃÅ plug-ing, this time in four days.

705

Androutsopoulos, Lampouras, & Galanis
Resources
Sections
Property assignments to sections
Interest score assignments
Sentence plans
Lexicon entries
Natural language names

English

Greek

6
42
12
42
19
36

42
19
36

Table 6: Domain-dependent generation resources for the Consmer Electronics Ontology.
since fewer automatically extracted names were causing disfluencies; in particular, all the
products had reasonably good rdfs:label strings providing their English names.
An example description from the development set produced by Naturalowl(+)follows.
We formatted the sentences of each section as a separate paragraph, headed by the name of
the section (e.g., ‚ÄúOther features:‚Äù); this was easy, because Naturalowl can automatically
mark up the sections in the texts. The maximum fact distance was again 1, but the sentence
plans caused Naturalowl to automatically retrieve additional message triples describing
the auxiliary individuals at distance 1; hence, we did not have to retrieve this information
manually, unlike the texts of the swat verbalizer and Naturalowl(‚àí).
Type: Sony Cyber-shot DSC-T90 is a digital camera.
Main features: It has a focal length range of 35.0 to 140.0 mm, a shutter lag of 2.0 to 0.0010 sec and
an optical zoom factor of 4.0. It has a digital zoom factor of 12.1 and its display has a diagonal of 3.0 in.
Other features: It features an automatic picture stabilizer, a microphone, video recording and it has a
self-timer.
Energy and environment: It uses batteries.
Connectivity, compatibility, memory: It supports USB 2.0 connections for data exchange and it has
an internal memory of 11.0 GB.
Dimensions and weight: It is 5.7 cm high, 1.5 cm wide and 9.4 cm deep. It weighs 128.0 grm.

The 180 English texts that were generated by the three systems for the 30 development
and 30 test products were shown to the same 10 students of the first trial. The students
were now told that the texts would be used in on-line descriptions of products in the Web
site of a retailer. Again, the owl statements that the texts were generated from were not
shown to the students, and the students did not know which system had generated each
text. Each student was shown 18 randomly selected texts, 9 for products of the development
set (3 texts per system) and 9 for products of the test set (again 3 texts per system). Each
student was shown all of his/her texts in random order, regardless of the system that had
generated them. The students were asked to score the texts as in the previous trial.
Table 7 shows the results for the English texts of the development set.34 As in the previous trial, the domain-dependent generation resources clearly help Naturalowl produce
much more fluent sentences, and much better referring expressions and sentence orderings.
The text structure scores of the swat verbalizer and Naturalowl(‚àí)are now much lower
than in the previous trial, because there are now more message triples to express per individual and more topics, and the texts of these systems jump from one topic to another
making the texts look very incoherent; for example, a sentence about the width of a camera
may be separated from a sentence about its height by a sentence about shutter lag. This
34. When a confidence interval is 0.00, this means that all the students gave the same score to all texts.

706

Generating Natural Language Descriptions from OWL Ontologies
Criteria
Sentence fluency
Referring expressions
Text structure
Clarity
Interest

swat
1.97 ¬± 0.15
1.10 ¬± 0.06
1.67 ¬± 0.15
1.97 ¬± 0.15
1.77 ¬± 0.14

Naturalowl(‚àí)
1.93 ¬± 0.27
1.10 ¬± 0.11
1.33 ¬± 0.19
2.07 ¬± 0.26
1.73 ¬± 0.29

Naturalowl(+)
2.90 ¬± 0.08
2.87 ¬± 0.08
2.97 ¬± 0.04
3.00 ¬± 0.00
3.00 ¬± 0.00

Table 7: English development results for the Consumer Electronics Ontology.
Criteria
Sentence fluency
Referring expressions
Text structure
Clarity
Interest

swat
2.03 ¬± 0.15
1.10 ¬± 0.06
1.57 ¬± 0.13
2.07 ¬± 0.15
1.83 ¬± 0.17

Naturalowl(‚àí)
1.87 ¬± 0.15
1.10 ¬± 0.06
1.37 ¬± 0.12
1.93 ¬± 0.15
1.60 ¬± 0.14

Naturalowl(+)
2.87 ¬± 0.08
2.87 ¬± 0.08
2.93 ¬± 0.05
2.97 ¬± 0.04
2.97 ¬± 0.04

Table 8: English test results for the Consumer Electronics Ontology.
incoherence may have also contributed to the much lower clarity scores of these two systems, compared to the previous trial. The interest scores of these two systems are also much
lower than in the previous trial; this may be due to the verbosity of their texts, caused by
their frequent references to auxiliary individuals in the second trial, combined with the lack
(or very little use) of sentence aggregation and pronoun generation. By contrast, the clarity and interest of Naturalowl(+)were judged to be perfect; the poor clarity and interest
of the other two systems may have contributed to these perfect scores though. Again, the
swat verbalizer obtained slightly better scores than Naturalowl without domain-dependent
generation resources, except for clarity, but the differences are not statistically significant.
Table 8 shows the results for the English texts of the test set. The results of the swat
verbalizer and Naturalowl(‚àí)are very similar to those of Table 7, as one would expect.
Also, there was only a very marginal decrease in the scores of Naturalowl(+), compared to
the scores of the same system for the development set in Table 7. There is no statistically
significant difference, however, between the corresponding cells of the two tables, for any
of the three systems. These results support our hypothesis that by considering a sample
of individuals of the types to be described one can construct domain-dependent generation
resources that can be used to produce high-quality texts for new individuals of the same
types, when the rest of the ontology remains unchanged. The fact that all the products (but
not the other individuals) had rdfs:label strings providing their English names probably
contributed to the high results of Naturalowl(+)in the test set, but rdfs:label strings of
this kind are common in owl ontologies.
We then showed the 60 Greek texts that were generated by Naturalowl(+)to the same
10 students, who were native Greek speakers; the swat verbalizer and Naturalowl(‚àí)cannot

Criteria
Sentence fluency
Referring expressions
Text structure
Clarity
Interest

Naturalowl(+),
development data
2.87 ¬± 0.12
2.77 ¬± 0.20
3.00 ¬± 0.00
3.00 ¬± 0.00
2.97 ¬± 0.06

Naturalowl(+),
test data
2.83 ¬± 0.09
2.80 ¬± 0.11
3.00 ¬± 0.00
2.93 ¬± 0.05
3.00 ¬± 0.00

Table 9: Greek results for the Consumer Electronics Ontology.
707

Androutsopoulos, Lampouras, & Galanis
No.
1
2
3
4
5
6
7

System Configuration
Naturalowl(+)
‚àí interest scores
‚àí ref. expr. gen.
‚àí nl names
‚àí aggregation
‚àí sentence plans
‚àí sections, ordering

Sentence Fluency
4.80 ¬± 0.12
4.53 ¬± 0.16
3.93 ¬± 0.28
3.71 ¬± 0.29
3.64 ¬± 0.33
2 .07 ¬± 0 .37
1.89 ¬± 0.36

Ref. Expressions
5.00 ¬± 0.00
4.95 ¬± 0.06
1 .53 ¬± 0 .22
1.48 ¬± 0.21
1.33 ¬± 0.19
1.33 ¬± 0.19
1.33 ¬± 0.19

Text Structure
4.82 ¬± 0.15
4.78 ¬± 0.12
4.80 ¬± 0.12
4.71 ¬± 0.15
4.67 ¬± 0.16
4.60 ¬± 0.18
1 .53 ¬± 0 .24

Clarity
4.78 ¬± 0.12
4.62 ¬± 0.17
4.51 ¬± 0.24
4.24 ¬± 0.25
4.24 ¬± 0.25
2 .49 ¬± 0 .36
2.33 ¬± 0.33

Interest
4.89 ¬± 0.09
4.20 ¬± 0.19
4.07 ¬± 0.22
3.98 ¬± 0.26
3.93 ¬± 0.26
2 .38 ¬± 0.35
1.89 ¬± 0.28

Table 10: Ablation English test results for the Consumer Electronics Ontology. Each
configuration removes one component or resource from the previous configuration.
generate Greek texts from the Consumer Electronics ontology. Table 9 shows the results
we obtained for the Greek texts of the development and test sets. There is no statistically
significant difference from the corresponding results for English (cf. the last columns of Tables 7 and 8). There is also no statistically significant difference in the results for the Greek
texts of the development and test sets (Table 9). We note, however, that it is common to
use English names of electronics products in Greek texts, which made using the English
rdfs:label names of the products in the Greek texts acceptable. In other domains, for
example cultural heritage, it might be unacceptable to use English names of individuals;
hence, one would have to provide Greek nl names for new individuals.
4.3 Ablation Trials with the Consumer Electronics Ontology
In the last trial, we studied how the quality of the generated texts is affected when various components and domain-dependent generation resources of Naturalowl are gradually
removed. We used the Consumer Electronics Ontology, with the domain-dependent generation resources that we had constructed for the 30 development products of the previous
trial. We also used 45 new test products (15 digital cameras, 15 camcorders, and 15 printers, from the same publicly available dataset), other than the 30 development and the 30
test products of the previous trial.
We generated English texts for the 45 new test products, using the 7 configurations of
Naturalowl of Table 10. The resulting 45√ó7 = 315 texts were shown to 7 students, who had
the same background as in the previous trials. Each student was shown the 7 texts of 6 or 7
test products (42 or 49 texts per student). For each product, the 7 texts were shown side by
side in random order, and the students were instructed to take into account the differences
of the 7 texts. The students did not know which system had generated which text. The
same criteria (statements S1 ‚ÄìS5 of Section 4.1) were used again, but a scale from 1 to 5
was used this time (1: strong disagreement, 2: disagreement, 3: ambivalent, 4: agreement,
5: strong agreement), to make it easier to distinguish between the 7 configurations.
The first configuration (Naturalowl(+)) is Naturalowl with all of its components enabled, using all the available domain-dependent generation resources. As in the previous
trial (see Table 8), the texts of this configuration were judged to be near-perfect by all the
criteria. The second configuration was the same, but without the interest score assignments.
The results of the second configuration were very close to the results of the first one, since
interest score assignments were used only to avoid generating sentences stating the obvious
(e.g., ‚ÄúSony Cyber-shot DSC-T90 is manufactured by Sony‚Äù). The biggest decrease was in
the interest criterion, as one would expect, but the scores for sentence fluency and clarity
were also affected, presumably because the sentences that state the obvious sound unnatural
708

Generating Natural Language Descriptions from OWL Ontologies

and seem to introduce noise. There were very small differences in the scores for referring
expressions and text structure, which seem to suggest that when the overall quality of the
texts decreases, the judges are biased towards assigning lower scores in all of the criteria.35
The third configuration was the same as the second one, but the component that generates pronouns and demonstrative noun phrases was disabled, causing Naturalowl to always
use the nl names of the individuals and classes, or names extracted from the ontology. There
was a big decrease in the score for referring expresions, showing that despite their simplicity, the referring expression generation methods of Naturalowl have a noticeable effect;
we mark big decreases in italics in Table 10. The scores for sentence fluency, interest, and
clarity were also affected, presumably because repeating the names of the individuals and
classes made the sentences look less natural, boring, and more difficult to follow. There was
almost no difference (a very small positive one) in the text structure score.
In the fourth configuration, the nl names of the individuals and classes were also removed, forcing Naturalowl to always use automatically extracted names. There was a
further decrease in the score for referring expressions, but the decrease was small, because
the referring expressions were already poor in the third configuration. Note, also, that
the nl names are necessary for Naturalowl to produce pronouns and demonstrative noun
phrases; hence, the higher referring expression score of the third configuration would not
have been possible without the nl names. The sentence fluency and clarity scores were also
affected in the fourth configuration, presumably because the automatically extracted names
made the texts more difficult to read and understand. There were also small decreases in the
scores for interest and even text structure, suggesting again that when the overall quality
of the texts decreases, the judges are biased towards lower scores in all of the criteria.
In the fifth configuration, aggregation was turned off, causing Naturalowl to produce
a separate sentence for each message triple. With sentences sharing the same subject no
longer being aggregated, more referring expressions for subjects had to be generated. Since
the component that generates pronouns and demonstrative noun phrases had been switched
off and the nl names had been removed, more repetitions of automatically extracted names
had to be used, which is why the score for referring expressions decreased further. Sentence
fluency was also affected, since some obvious aggregations were no longer being made, which
made the sentences look less natural. There was also a small decrease in the score for the
perceived text structure and interest, but no difference in the score for clarity. Overall, the
contribution of aggregation to the perceived quality of the texts seems to be rather small.
In the sixth configuration, all the sentence plans were removed, forcing Naturalowl to
use the default sentence plan and tokenized property identifiers. There was a sharp decrease
in sentence fluency and clarity, as one would expect, but also in the perceived interest of
the texts. There was also a small decrease in the perceived text structure, and no difference
in the score for referring expressions. Overall, these results indicate that sentence plans are
a very important part of the domain-dependent generation resources.
In the seventh configuration, the sections, assignments of properties to sections, and the
ordering of sections and properties were removed, causing Naturalowl to produce random
35. In all of the criteria, all the differences from one configuration to the next one are statistically significant, with the only exceptions being the differences in clarity between configurations 4 and 5, and the
differences in the scores for referring expressions between configurations 5‚Äì6 and 6‚Äì7. Again, when the
95% confidence intervals overlapped, we performed paired two-tailed t-tests (Œ± = 0.05).

709

Androutsopoulos, Lampouras, & Galanis

orderings of the message triples. There was a very sharp decrease in the score for text
structure. The scores for the perceived interest, clarity, but also sentence fluency were also
affected, again suggesting that when the overall quality of the texts decreases, the judges
are biased towards lower scores in all of the criteria.
We conclude that the sections and ordering information of the domain-dependent generation resources are, along with the sentece plans, particularly important. We note, however,
that the best scores were obtained by enabling all the components and using all the available
domain-dependent generation resources.

5. Conclusions and Future Work
We provided a detailed description of Naturalowl, an open-source nlg system that produces English and Greek texts describing individuals or classes of owl ontologies. Unlike
simpler verbalizers, which typically express a single axiom at a time in controlled, often
not entirely fluent English primarily for the benefit of domain experts, Naturalowl aims to
generate fluent and coherent multi-sentence texts for end-users in more than one languages.
We discussed the processing stages of Naturalowl, the optional domain-dependent generation resources of each stage, as well as particular nlg issues that arise when generating
from owl ontologies. We also presented trials we performed to measure the effort required
to construct the domain-dependent generation resources and the extent to which they improve the resulting texts, also comparing against a simpler owl verbalizer that requires no
domain-dependent generation resources and employs nlg methods to a lesser extent. The
trials showed that the domain-dependent generation resources help Naturalowl produce
significantly better texts, and that the resources can be constructed with relatively light
effort, compared to the effort that is typically needed to develop an owl ontology.
Future work could compare the effort needed to construct the domain-dependent generation resources against the effort needed to manually edit the lower quality texts produced
without domain-dependent generation resources. Our experience is that manually editing
texts generated by a verbalizer (or Naturalowl(‚àí)) is very tedious when there is a large
number of individuals (e.g., products) of a few types to be described, because the editor has
to repeat the same (or very similar) fixes. There may be, however, particular applications
where post-editing the texts of a simpler verbalizer may be preferable.
We also aim to replace in future work the pipeline architecture of Naturalowl by a global
optimization architecture that will consider all the nlg processing stages in parallel, to avoid
greedy stage-specific decisions (Marciniak & Strube, 2005; Lampouras & Androutsopoulos,
2013a, 2013b). Finally, we hope to test Naturalowl with biomedical ontologies, such as the
Gene Ontology and snomed.36

References
Androutsopoulos, I., Kallonis, S., & Karkaletsis, V. (2005). Exploiting OWL ontologies in the
multilingual generation of object descriptions. In 10th European Workshop on NLG, pp. 150‚Äì
155, Aberdeen, UK.
36. See http://www.geneontology.org/ and http://www.ihtsdo.org/snomed-ct/.

710

Generating Natural Language Descriptions from OWL Ontologies

Androutsopoulos, I., Lampouras, G., & Galanis, D. (2012). Generating natural language descriptions
from OWL ontologies: A detailed presentation of the NaturalOWL system. Tech. rep., NLP
Group, Department of Informatics, Athens University of Economics and Business, Greece.
Androutsopoulos, I., Oberlander, J., & Karkaletsis, V. (2007). Source authoring for multilingual
generation of personalised object descriptions. Nat. Language Engineering, 13 (3), 191‚Äì233.
Angeli, G., Liang, P., & Klein, D. (2010). A simple domain-independent probabilistic approach to
generation. In Conf. on Empirical Methods in NLP, pp. 502‚Äì512, Cambridge, MA.
Antoniou, G., & van Harmelen, F. (2008). A Semantic Web Primer. MIT Press.
Areces, C., Koller, A., & Striegnitz, K. (2008). Referring expressions as formulas of description logic.
In 5th Int. Nat. Lang. Generation Conf., pp. 42‚Äì49, Salt Fork, OH.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. (Eds.). (2002). The
Description Logic Handbook. Cambridge Univ. Press.
Barzilay, R., Elhadad, N., & McKeown, K. (2002). Inferring strategies for sentence ordering in
multidocument news summarization. Journal of AI Research, 17, 35‚Äì55.
Barzilay, R., & Lapata, M. (2005). Collective content selection for concept-to-text generation. In
Human Lang. Technology Conf. and Conf. on Empirical Methods in Nat. Language Processing,
pp. 331‚Äì338, Vancouver, British Columbia, Canada.
Barzilay, R., & Lapata, M. (2006). Aggregation via set partitioning for natural language generation.
In Human Lang. Technology Conf. of NAACL, pp. 359‚Äì366, New York, NY.
Barzilay, R., & Lapata, M. (2008). Modeling local coherence: An entity-based approach. Comput.
Linguistics, 34 (1), 1‚Äì34.
Barzilay, R., & Lee, L. (2004). Catching the drift: Probabilistic content models, with applications to
generation & summarization. In 43rd Annual Meeting of ACL, pp. 113‚Äì120, Ann Arbor, MI.
Bateman, J. (1990). Upper modelling: A general organisation of knowledge for nat. lang. processing.
In 5th Int. Workshop on NLG, pp. 54‚Äì61, Dawson, PA.
Bateman, J. (1997). Enabling technology for multilingual nat. lang. generation: the KPML development environment. Nat. Lang. Engineering, 3 (1), 15‚Äì56.
Bernardi, R., Calvanese, D., & Thorne, C. (2007). Lite natural language. In 7th Int. Workshop on
Comput. Semantics, Tilburg, The Netherlands.
Berners-Lee, T., Hendler, J., & Lassila, O. (2001). The Semantic Web. Sc. American, May, 34‚Äì43.
Bontcheva, K. (2005). Generating tailored textual summaries from ontologies. In 2nd European
Semantic Web Conf., Heraklion, Greece.
Bontcheva, K., & Cunningham, H. (2003). The Semantic Web: a new opportunity and challenge
for human language technology. In Workshop on Human Lang. Tech. for the SW and Web
Services, 2nd Int. Semantic Web Conf., Sanibel Island, FL.
Bontcheva, K., Tablan, V., Maynard, D., & Cunningham, H. (2004). Evolving GATE to meet new
challenges in language engineering. Nat. Lang. Eng., 10 (3/4), 349‚Äì373.
Bontcheva, K., & Wilks, Y. (2004). Automatic report generation from ontologies: the MIAKT
approach. In 9th Int. Conf. on Applications of Nat. Language to Information Systems, pp.
324‚Äì335, Manchester, UK.
Brin, S., & Page, L. (1998). The anatomy of a large-scale hypertextual Web search engine. Computer
Networks and ISDN Systems, 30 (1-7), 107‚Äì117.
Busemann, S., & Horacek, H. (1999). A flexible shallow approach to text generation. In 9th Int.
Workshop on Nat. Lang. Generation, pp. 238‚Äì247, New Brunswick, NJ.
711

Androutsopoulos, Lampouras, & Galanis

Chen, H., Branavan, S., Barzilay, R., & Karger, D. (2009). Content modeling using latent permutations. Journal of Artificial Intelligence Research, 36, 129‚Äì163.
Cheng, H., & Mellish, C. (2000). Capturing the interaction between aggregation and text planning
in two generation systems. In 1st Int. Conf. on Nat. Lang. Generation, pp. 186‚Äì193, Mitzpe
Ramon, Israel.
Cregan, A., Schwitter, R., & Meyer, T. (2007). Sydney OWL syntax ‚Äì towards a controlled natural
language syntax for OWL. In OWL Experiences and Directions Workshop, Innsbruck, Austria.
Dale, R., Green, S., Milosavljevic, M., Paris, C., Verspoor, C., & Williams, S. (1998). Dynamic
document delivery: generating natural language texts on demand. In 9th Int. Conf. and
Workshop on Database and Expert Systems Applications, pp. 131‚Äì136, Vienna, Austria.
Dalianis, H. (1999). Aggregation in nat. lang. generation. Comput. Intell., 15 (4), 384‚Äì414.
Dannells, D. (2012). On generating coherent multilingual descriptions of museum objects from
Semantic Web ontologies. In 7th International NLG Conf., pp. 76‚Äì84, Utica, IL.
Dannels, D. (2008). Generating tailored texts for museum exhibits. In Workshop on Language
Technology for Cultural Heritage Data of the Language Resources and Evaluation Conf., Marrakech, Morocco.
Davis, B., Iqbal, A., Funk, A., Tablan, V., Bontcheva, K., Cunningham, H., & Handschuh, S. (2008).
Roundtrip ontology authoring. In 7th Int. Conf. on the Semantic Web, pp. 50‚Äì65, Karlsruhe,
Germany.
Demir, S., Carberry, S., & McCoy, K. (2010). A discourse-aware graph-based content-selection
framework. In 6th Int. NLG Conf., pp. 17‚Äì25, Trim, Co. Meath, Ireland.
Denaux, R., Dimitrova, V., Cohn, A., Dolbear, C., & Hart, G. (2010). Rabbit to OWL: Ontology
authoring with a CNL-based tool. In Fuchs, N. (Ed.), Controlled Nat. Language, Vol. 5972 of
Lecture Notes in Computer Science, pp. 246‚Äì264. Springer.
Denaux, R., Dolbear, C., Hart, G., Dimitrova, V., & Cohn, A. (2011). Supporting domain experts
to construct conceptual ontologies. Web Semantics, 9 (2), 113‚Äì127.
Duboue, P., & McKeown, K. (2001). Empirically estimating order constraints for content planning
in generation. In 39th Meeting of ACL, pp. 172‚Äì179, Toulouse, France.
Duboue, P., & McKeown, K. (2003). Statistical acquisition of content selection rules for natural
language generation. In Conf. on Empirical Methods in Nat. Language Processing, pp. 121‚Äì
128, Sapporo, Japan.
Duma, D., & Klein, E. (2013). Generating nat. lang. from Linked Data: Unsupervised template
extraction. In 10th Int. Conf. on Computational Semantics, pp. 83‚Äì94, Potsdam, Germany.
Elhadad, M., & Robin, J. (1996). SURGE: A reusable comprehensive syntactic realization component. In 8th Int. NLG Workshop, Herstmonceux Castle, Sussex, UK.
Elsner, M., Austerweil, J., & Charniak, E. (2007). A unified local and global model for discourse
coherence. In Human Lang. Technologies Conf. of the North American Chapter of ACL, pp.
436‚Äì443, Rochester, New York.
Fellbaum, C. (Ed.). (1998). WordNet: an Electronic Lexical Database. MIT Press.
Funk, A., Tablan, V., Bontcheva, K., Cunningham, H., Davis, B., & Handschuh, S. (2007). CLOnE:
Controlled language for ontology editing. In 6th Int. Semantic Web and 2nd Asian Semantic
Web Conf., pp. 142‚Äì155, Busan, Korea.
Galanis, D., & Androutsopoulos, I. (2007). Generating multi-lingual descriptions from linguistically
annotated OWL ontologies: the NaturalOWL system. In 11th European Workshop on Nat.
Lang. Generation, Schloss Dagstuhl, Germany.
712

Generating Natural Language Descriptions from OWL Ontologies

Gatt, A., & Reiter, E. (2009). SimpleNLG: A realisation engine for practical applications. In 12th
European Workshop on NLG, pp. 90‚Äì93, Athens, Greece.
Grau, B., Horrocks, I., Motik, B., Parsia, B., Patel-Schneider, P., & Sattler, U. (2008). OWL 2: The
next step for OWL. Web Semantics, 6, 309‚Äì322.
Grosz, B., Joshi, A., & Weinstein, S. (1995). Centering: a framework for modelling the local coherence
of discourse. Comput. Linguistics, 21 (2), 203‚Äì225.
Halaschek-Wiener, C., Golbeck, J., Parsia, B., Kolovski, V., & Hendler, J. (2008). Image browsing
and natural language paraphrases of semantic web annotations. In 1st Workshop on Semantic
Interop. in the European Digital Library, 5th European Semantic Web Conf., Tenerife, Spain.
Hallett, C., Scott, D., & Power, R. (2007). Composing questions through conceptual authoring.
Comput. Linguistics, 33, 105‚Äì133.
Halliday, M. (1994). Introduction to Functional Grammar (2nd edition). Edward Arnold.
Horrocks, I., Patel-Schneider, P., & van Harmelen, F. (2003). From SHIQ and RDF to OWL: the
making of a Web Ontology Language. Web Semantics, 1 (1), 7‚Äì26.
Isard, A., Oberlander, J., Androutsopoulos, I., & Matheson, C. (2003). Speaking the users‚Äô languages.
IEEE Intelligent Systems, 18 (1), 40‚Äì45.
Kaljurand, K. (2007). Attempto Controlled English as a Semantic Web Language. Ph.D. thesis,
Faculty of Mathematics and Computer Science, University of Tartu, Estonia.
Karamanis, N., Mellish, C., Poesio, M., & Oberlander, J. (2009). Evaluating centering for information
ordering using corpora. Comput. Linguistics, 35 (1), 29‚Äì46.
Kasper, R., & Whitney, R. (1989). SPL: A sentence plan language for text generation. Tech. rep.,
Information Sciences Institute, University of Southern California.
Kaufmann, E., & Bernstein, A. (2010). Evaluating the usability of nat. lang. query languages and
interfaces to Semantic Web knowledge bases. Web Semantics, 8, 377‚Äì393.
Kelly, C., Copestake, A., & Karamanis, N. (2010). Investigating content selection for language
generation using machine learning. In 12th European Workshop on Nat. Lang. Generation,
pp. 130‚Äì137, Athens, Greece.
Konstas, I., & Lapata, M. (2012a). Concept-to-text generation via discriminative reranking. In 50th
Annual Meeting of the ACL, pp. 369‚Äì378, Jeju Island, Korea.
Konstas, I., & Lapata, M. (2012b). Unsupervised concept-to-text generation with hypergraphs. In
Human Lang. Technology Conf. of NAACL, pp. 752‚Äì761, MontreÃÅal, Canada.
Krahmer, E., & van Deemter, K. (2012). Computational generation of referring expressions: A
survey. Comput. Linguistics, 38 (1), 173‚Äì218.
Lampouras, G., & Androutsopoulos, I. (2013a). Using integer linear programming for content selection, lexicalization, and aggregation to produce compact texts from OWL ontologies. In
14th European Workshop on Nat. Lang. Generation, 51st Annual Meeting of ACL, pp. 51‚Äì60,
Sofia, Bulgaria.
Lampouras, G., & Androutsopoulos, I. (2013b). Using integer linear programming in concept-to-text
generation to produce more compact texts. In 51st Annual Meeting of ACL (short papers),
pp. 561‚Äì566, Sofia, Bulgaria.
Langkilde, I. (2000). Forest based statistical sentence generation. In 1st Conf. of the North American
Chapter of ACL, pp. 170‚Äì177, Seattle, WA.
Lavoie, B., & Rambow, O. (1997). A fast and portable realizer for text generation systems. In 5th
Conf. on Applied Nat. Language Processing, pp. 265‚Äì268, Washington DC.
713

Androutsopoulos, Lampouras, & Galanis

Liang, P., Jordan, M., & Klein, D. (2009). Learning semantic correspondences with less supervision.
In 47th Meeting of ACL and 4th AFNLP, pp. 91‚Äì99, Suntec, Singapore.
Liang, S., Scott, D., Stevens, R., & Rector, A. (2011a). Unlocking medical ontologies for non-ontology
experts. In 10th Workshop on Biomedical NLP, Portland, OR.
Liang, S., Stevens, R., Scott, D., & Rector, A. (2011b). Automatic verbalisation of SNOMED classes
using OntoVerbal. In 13th Conf. AI in Medicine, pp. 338‚Äì342, Bled, Slovenia.
Mann, W., & Thompson, S. (1998). Rhetorical structure theory: A theory of text organization. Text,
8 (3), 243‚Äì281.
Marciniak, T., & Strube, M. (2005). Beyond the pipeline: Discrete optimization in NLP. In 9th
Conf. on Comput. Nat. Language Learning, pp. 136‚Äì143, Ann Arbor, MI.
McKeown, K. (1985). Text Generation. Cambridge Univ. Press.
McRoy, S., Channarukul, S., & Ali, S. (2003). An augmented template-based approach to text
realization. Nat. Language Engineering, 9 (4), 381‚Äì420.
Melengoglou, A. (2002). Multilingual aggregation in the M-PIRO system. Master‚Äôs thesis, School
of Informatics, University of Edinburgh, UK.
Mellish, C. (2010). Using Semantic Web technology to support NLG ‚Äì case study: OWL finds RAGS.
In 6th Int. NLG Conf., pp. 85‚Äì93, Trim, Co. Meath, Ireland.
Mellish, C., & Pan, J. (2008). Nat. lang. directed inference from ontologies. Artificial Intelligence,
172, 1285‚Äì1315.
Mellish, C., Scott, D., Cahill, L., Paiva, D., Evans, R., & Reape, M. (2006). A reference architecture
for nat. lang. generation systems. Nat. Language Engineering, 12, 1‚Äì34.
Mellish, C., & Sun, X. (2006). The Semantic Web as a linguistic resource: opportunities for nat.
lang. generation. Knowledge Based Systems, 19, 298‚Äì303.
Nguyen, T., Power, R., Piwek, P., & Williams, S. (2012). Planning accessible explanations for
entailments in OWL ontologies. In 7th International NLG Conf., pp. 110‚Äì114, Utica, IL.
Oberlander, J., Karakatsiotis, G., Isard, A., & Androutsopoulos, I. (2008). Building an adaptive
museum gallery in Second Life. In Museums and the Web, Montreal, Canada.
O‚ÄôDonnell, M., Mellish, C., Oberlander, J., & Knott, A. (2001). ILEX: an architecture for a dynamic
hypertext generation system. Nat. Language Engineering, 7 (3), 225‚Äì250.
Poesio, M., Stevenson, R., & Di Eugenio, B. (2004). Centering: A parameter theory and its instantiations. Comput. Linguistics, 30 (3), 309‚Äì363.
Power, R. (2009). Towards a generation-based semantic web authoring tool. In 12th European
Workshop on Nat. Lang. Generation, pp. 9‚Äì15, Athens, Greece.
Power, R. (2010). Complexity assumptions in ontology verbalisation. In 48th Annual Meeting of
ACL (short papers), pp. 132‚Äì136, Uppsala, Sweden.
Power, R. (2011). Deriving rhetorical relationships from semantic content. In 13th European Workshop on Nat. Lang. Generation, Nancy, France.
Power, R. (2012). OWL simplified english: a finite-state language for ontology editing. In 3rd
International Workshop on Controlled Natural Language, pp. 44‚Äì60, Zurich, Switzerland.
Power, R., & Scott, D. (1998). Multilingual authoring using feedback texts. In 17th Int. Conf. on
Comp. Ling. and 36th Meeting of ACL, pp. 1053‚Äì1059, Montreal, Canada.
Power, R., & Third, A. (2010). Expressing OWL axioms by English sentences: Dubious in theory,
feasible in practice. In 23rd Int. Conf. on Comput. Linguistics, pp. 1006‚Äì1013, Beijing, China.
714

Generating Natural Language Descriptions from OWL Ontologies

Ratnaparkhi, A. (2000). Trainable methods for surface natural language generation. In 1st Conf. of
the North American Chapter of ACL, pp. 194‚Äì201, Seattle, WA.
Rector, A., Drummond, N., Horridge, M., Rogers, J., Knublauch, H., Stevens, R., Wang, H., &
Wroe, C. (2004). OWL pizzas: Practical experience of teaching OWL-DL: Common errors and
common patterns. In 14th Int. Conf. on Knowledge Engineering and Knowledge Management,
pp. 63‚Äì81, Northamptonshire, UK.
Reiter, E. (1995). NLG vs. templates. In 5th European Workshop on Nat. Lang. Generation, Leiden,
The Netherlands.
Reiter, E., & Dale, R. (2000). Building Natural Lang. Generation Systems. Cambridge Univ. Press.
Ren, Y., van Deemter, K., & Pan, J. (2010). Charting the potential of description logic for the
generation of referring expressions. In 6th Int. Nat. Lang. Generation Conf., pp. 115‚Äì123,
Trim, Co. Meath, Ireland.
Schutte, N. (2009). Generating nat. language descriptions of ontology concepts. In 12th European
Workshop on Nat. Lang. Generation, pp. 106‚Äì109, Athens, Greece.
Schwitter, R. (2010a). Controlled nat. languages for knowledge representation. In 23rd Int. Conf.
on Comput. Linguistics (posters), pp. 1113‚Äì1121, Beijing, China.
Schwitter, R. (2010b). Creating and querying formal ontologies via controlled nat. language. Applied
Artificial Intelligence, 24, 149‚Äì174.
Schwitter, R., Kaljurand, K., Cregan, A., Dolbear, C., & Hart, G. (2008). A comparison of three
controlled nat. languages for OWL 1.1. In 4th OWL Experiences and Directions Workshop,
Washington DC.
Schwitter, R., & Tilbrook, M. (2004). Controlled natural language meets the Semantic Web. In
Australasian Language Technology Workshop, pp. 55‚Äì62, Sydney, Australia.
Shadbolt, N., Berners-Lee, T., & Hall, W. (2006). The Semantic Web revisited. IEEE Intell. Systems,
21, 96‚Äì101.
Stevens, R., Malone, J., Williams, S., Power, R., & Third, A. (2011). Automatic generation of
textual class definitions from OWL to English. Biomedical Semantics, 2 (S 2:S5).
Third, A. (2012). ‚ÄúHidden semantics‚Äù: What can we learn from the names in an ontology?. In 7th
International NLG Conf., pp. 67‚Äì75, Utica, IL.
van Deemter, K., Krahmer, E., & Theune, M. (2005). Real versus template-based natural language
generation: a false opposition?. Comput. Linguistics, 31 (1), 15‚Äì24.
Walker, M., Rambow, O., & Rogati, M. (2001). Spot: A trainable sentence planner. In 2nd Annual
Meeting of the North American Chapter of ACL, pp. 17‚Äì24, Pittsburgh, PA.
Wan, S., Dras, M., Dale, R., & Paris, C. (2010). Spanning tree approaches for statistical sentence
generation. In Krahmer, E., & Theune, M. (Eds.), Empirical Methods in Nat. Lang. Generation, pp. 13‚Äì44. Springer.
White, M. (2006). CCG chart realization from disjunctive inputs. In 4th Int. Nat. Lang. Generation
Conf., pp. 12‚Äì19, Sydney, Australia.
Williams, S., & Power, R. (2010). Grouping axioms for more coherent ontology descriptions. In 6th
Int. Nat. Lang. Generation Conf., pp. 197‚Äì201, Trim, Co. Meath, Ireland.
Williams, S., Third, A., & Power, R. (2011). Levels of organization in ontology verbalization. In
13th European Workshop on Nat. Lang. Generation, pp. 158‚Äì163, Nancy, France.

715

Journal of Artificial Intelligence Research 48 (2013) 415‚Äì473

Submitted 05/13; published 11/13

Defeasible Inheritance-Based Description Logics
Giovanni Casini

GCasini@csir.co.za

Centre for Artificial Intelligence Research (CAIR)
CSIR Meraka Institute and UKZN, South Africa

Umberto Straccia

umberto.straccia@isti.cnr.it

Istituto di Scienze e Tecnologie dell‚ÄôInformazione (ISTI)
CNR, Italy

Abstract
Defeasible inheritance networks are a non-monotonic framework that deals with hierarchical knowledge. On the other hand, rational closure is acknowledged as a landmark of the
preferential approach to non-monotonic reasoning. We will combine these two approaches
and deÔ¨Åne a new non-monotonic closure operation for propositional knowledge bases that
combines the advantages of both. Then we redeÔ¨Åne such a procedure for Description Logics
(DLs), a family of logics well-suited to model structured information. In both cases we will
provide a simple reasoning method that is built on top of the classical entailment relation
and, thus, is amenable of an implementation based on existing reasoners. Eventually, we
evaluate our approach on well-known landmark test examples.

1. Introduction
The notion of rational closure (Lehmann & Magidor, 1992) is acknowledged as a landmark
for non-monotonic reasoning due to its Ô¨Årm logical properties, but it has limited inference
capabilities: e.g. an exceptional class will not inherit any of the typical properties from its
superclass. Consider penguins: they are atypical birds, since they do not Ô¨Çy, but they still
share a lot of typical properties of birds, e.g. they have wings. However, under rational
closure we may not infer that penguins have wings. On the other hand, Defeasible Inheritance Networks (INs) (Horty, 1994) are a non-monotonic framework appropriate for the
formalisation of hierarchical knowledge that does not have such a limitation, but exhibit
questionable logical properties (see Section 3.1).
We combine these two approaches and deÔ¨Åne a new non-monotonic closure operation
for propositional knowledge bases that combines the advantages of both, and then we apply
the method to Description Logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & PatelSchneider, 2003), a family of logics that are known to be well-suited to model structured
information.
1.1 Contributions and Roadmap
Section 2.1 is just a brief recap of a classical approach to inheritance nets, Horty‚Äôs (1994)
skeptical extension, while Section 2.2 describes the classical rational closure for propositional
logic, generalising a method presented by Freund (1998). The remaining material addresses
our contributions that can be summarised as follows.
c
2013
AI Access Foundation. All rights reserved.

Casini & Straccia

1. In Section 3 we propose a new method to reason about INs that relies on the procedure for rational closure, and we present a Boolean extension of INs, called Boolean
defeasible Inheritance Networks (BINs).
2. Using BINs, we develop in Section 4 a defeasible inheritance-based propositional closure
that combines the advantages of both inheritance nets and rational closure.
3. Eventually, in Section 5 we apply the latter procedure to the case of defeasible inheritancebased description logics.
A major feature of the procedures we propose is that for propositional logic and DLs
we still maintain all desired logical properties of rational closure, but with more inferential
power with respect to exceptional classes. Moreover our method requires only the existence
of a decision procedure for classical entailment and, thus, can be implemented on top of
existing propositional SAT solvers and DL reasoners.
Please note that the present paper is a substantially revised and extended version of a
previous work (Casini & Straccia, 2011). SpeciÔ¨Åcally,
1. we provide an in-depth description of our reasoning model;
2. we extensively validate our approach w.r.t. to a series of landmark (test) examples
illustrated by Horty (1994) and Sandewall (2010) (see Appendix A);
3. we provide computational complexity results related to our reasoning procedures; and
4. we include the proofs supporting out major claims (see Appendix B); due to the
complexity of the notation, we add also a table summarising the meaning of the
symbols we use more frequently (Appendix C).
1.2 Related Work
We refer to two main approaches to non-monotonic reasoning: inheritance networks on one
hand and the preferential approach on the other.
Inheritance networks have been developed as a formalism for reasoning about taxonomic
information. From the original ideas of Touretzky (1986), the approach has richly developed
(Sandewall, 1986; Touretzky, Horty, & Thomason, 1987; Horty, Thomason, & Touretzky,
1987; Touretzky, Thomason, & Horty, 1991; Makinson, 1991; Simonet, 1996). See the works
by Horty (1994) and Thomason (1992) for an overview, while Gabbay and Schlecta (2009)
and Sandewall (2010) have more recently contributed to the Ô¨Åeld. In particular, in order
to evaluate our proposal, we shall refer to the skeptical approach described by Horty (1987,
1994) as the landmark of the classical approach to inheritance networks.
On the other hand, Lehmann and Magidor‚Äôs rational closure falls into the preferential
approach to non-monotonic reasoning; such an approach, since the Ô¨Årst formulation by
Shoham (1988), has become a main representative of non-monotonic reasoning (Kraus,
Lehmann, & Magidor, 1990; Lehmann & Magidor, 1992; Makinson, 1994, 2005; Freund,
1998; Bochman, 2001; Rott, 2001; Schlechta, 2004), particularly appreciated for the solid
logical characterization of the consequence relation.
Eventually, our proposal shall be applied in the Ô¨Åeld of description logics (Baader et al.,
2003). Several non-monotonic DLs exist (Baader & Hollunder, 1993; Bonatti, Faella, &
416

Defeasible Inheritance-Based Description Logics

Sauro, 2011c, 2011b; Brewka & Augustin, 1987; Britz, Heidema, & Meyer, 2008; Donini,
Nardi, & Rosati, 2002; Giordano, Olivetti, Gliozzi, & Pozzato, 2009; Giordano, Gliozzi,
Olivetti, & Pozzato, 2012b; Grimm & Hitzler, 2009; Knorr, Alferes, & Hitzler, 2011; Quantz
& Royer, 1992; Straccia, 1993), which integrate several kinds of non-monotonic reasoning
mechanism into DLs. Somewhat related to our proposal are the works by Britz et al. (2008)
and Giordano et al. (2009, 2012b), as they address the application of the preferential methods into the DL framework, but they do not refer to rational closure. In a previous publication (Casini & Straccia, 2010) we present a procedure to apply rational closure to DLs, and
such a procedure is at the basis of our actual proposal, but here we modify the approach in
order to amplify its inferential power.

2. Preliminaries
For completeness, we start with the basic notions about INs and propositional rational
closure we shall rely on.
2.1 Defeasible Inheritance Networks
In INs (Horty, 1994; Sandewall, 2010) there are classes (nodes), a strict subsumption relation
and a defeasible subsumption relation among such classes (links). We shall indicate nodes
by letters p, q . . ., and we shall describe an IN by a pair N = hS, U i, where S is a set of
strict links, while U is a set of defeasible links. Every link in N is a direct link, and it can
be strict or defeasible, positive or negative. SpeciÔ¨Åcally,
1. p ‚áí q: class p is subsumed by class q [positive strict link];
2. p 6‚áî q: class p and class q are disjoint [negative strict link];
3. p ‚Üí q: an element of the class p is usually an element of the class q [positive defeasible
link];
4. p 6‚Üí q: an element of the class p is usually not an element of the class q [negative
defeasible link].
Example 2.1. The typical ‚Äòpenguin example‚Äô could be represented as N = h{p ‚áí b}, {p 6‚Üí
f, b ‚Üí f, b ‚Üí w}i, reading b as ‚ÄòBird‚Äô, p as ‚ÄòPenguin‚Äô, f as ‚ÄòFlying‚Äô and w as ‚Äôhas Wings‚Äô.
In the presence of strict links only, the subsumption relation between the classes would
correspond simply to a transitive closure of the links: if p is subsumed by q and q is
subsumed by r, then p is subsumed by r. Instead, the presence of defeasible links implies
the possibility of potential inconsistencies in the hierarchy of classes, as in the penguin
example: a transitive closure of the subsumption relation would force us to conclude at
the same time that penguins are Ô¨Çying and non-Ô¨Çying creatures. Hence reasoning with
inheritance networks consists mainly in deciding which conclusions have to be considered
valid when faced with potential contradictions. In most of the classical approaches such
decisions are based on the notions of potential path and preemption (a procedure that,
given two conÔ¨Çicting paths, allows to choose the one resting on more speciÔ¨Åc information,
invalidating the other). Among the various proposals, we shall brieÔ¨Çy present Horty‚Äôs (1994)
417

Casini & Straccia

classical approach, to which we shall refer as a landmark. First, we recall the notion of path
that is shared by all the classical approaches to INs. We refer to the paths by means of
Greek letters (œÄ, œÅ, œÉ, œÜ, œà . . .), or with tuples indicating the sequence of the nodes involved.
For example, the triple œÄ = hp, œÉ, qi indicates a path œÄ that starts from the node p, passes
through the path œÉ, and ends into the node q.
Definition 2.1 (Potential Paths, Horty, 1994, p. 117). Given a net N = hS, U i, we can
define iteratively its paths (where 99K‚àà {‚Üí, ‚áí} and 699K‚àà {6‚Üí, 6‚áî})1 :
‚Ä¢ Every direct link in N is a simple path:
‚Äì If p 99K q ‚àà S, hp, qi is a positive path.
‚Äì If p 699K q ‚àà S, hp, qi is a negative path.
‚Ä¢ Assume a path œÄ = ht, œÉ, pi.
‚Äì If œÄ is positive,
‚àó If p 99K q ‚àà S, hœÄ, qi is a positive path.
‚àó If p 699K q ‚àà S, hœÄ, qi is a negative path.
‚Äì If œÄ is negative,
‚àó If q ‚áí p ‚àà S, hœÄ, qi is a negative path.
If a path is composed only by strict links, it is a strict path, otherwise it is a defeasible
one.
A potential path represents a potential argumentation, and we have to decide if it is
valid or not. If the path is strict, it is automatically considered as valid, otherwise, in case
of potential conÔ¨Çicts between the conclusions of distinct defeasible paths, we have to choose
which ones of them have to be considered as valid.
Using the notions of path and preemption, Horty deÔ¨Ånes an iterative construction of
an extension of a net, that is, of the set of the paths considered valid in the net. Due to
the complexity of the formal deÔ¨Ånition, we describe just roughly the procedure, referring to
Horty‚Äôs work (1994, sect. 3), for a better insight.
The inductive construction of the paths is based on a notion of degree of paths. Once
we have identiÔ¨Åed the potential paths, we can deÔ¨Åne also a notion of generalised path. That
is, a generalisation of defeasible paths that, given ‚ãÜ ‚àà {‚áí, 6‚áî, ‚áê, ‚Üí, 6‚Üí}, is deÔ¨Åned as:
1. every direct link is a generalised path;
2. if œÄ = hœÉ, pi is a generalised path, and p ‚ãÜ q ‚àà N , then hœÄ, qi is a generalised path.
We associate to every defeasible path hp, œÉ, qi a number that corresponds to the number
of links in the longest generalised path between p and q, denoted as degN (hp, œÉ, qi).
In inheritance nets, the notion of contradiction corresponds to the notion of conflict:
we say that a path is conÔ¨Çicted if there is another path with the same starting and end
points, but opposite polarity (i.e., we have two potential paths moving from a node p to a
1. We assume the link 6‚áî to be symmetric, that is, if p 6‚áî q ‚àà S, then q 6‚áî p ‚àà S too.

418

Defeasible Inheritance-Based Description Logics

node q, but one is positive while the other is negative). If we are dealing with strict paths,
the presence of a conÔ¨Çict points out an actual contradiction, while, dealing with defeasible
paths, the contradiction is just potential and could be resolved by the notion of preemption
(Horty, 1994, Def. 3.2.2) that allows to prefer the path relying on more speciÔ¨Åc information.
In the procedure deÔ¨Åned by Horty we start with a net N , and, working iteratively on the
degree of the paths, we deÔ¨Åne a sequence of pairs hN , Pi i, where Pi is the set of the paths
considered valid at the i-th step. In brief, given a net N = hS, U i, Horty‚Äôs procedure results
into the construction of a sequence of sets of valid paths P0 , P1 , P2 , . . . where:
1. P0 = N ; and
2. Pn+1 is Pn united with all the paths of degree n + 1 and that are the extension of a
valid path of degree n and that preempt all the eventual conÔ¨Çicting paths.
S
The skeptical extension of a net N is deÔ¨Åned by ‚àû
n=1 Pn (Horty, 1994, sect. 2.2.2 and
3.3.2). To indicate that a (positive or negative, strict or defeasible) connection between two
nodes p and q is considered valid in Horty‚Äôs skeptical extension we write N
p ‚ãÜ q, with
‚ãÜ ‚àà {‚áí, 6‚áî, ‚Üí, 6‚Üí}.
Example 2.2. Consider example 2.1; following Horty‚Äôs procedure we obtain a skeptical
extension of the net composed of the valid paths p ‚áí b, p 6‚Üí f, b ‚Üí f, b ‚Üí w, p ‚áí b ‚Üí w.
Consistency. A net is considered inconsistent iÔ¨Ä we can validate two conÔ¨Çicting paths,
that is, there is a pair of nodes p and q such that we can derive both a positive connection
(N
p ‚Üí q or N
p ‚áí q) and a negative one (N
p 6‚Üí q or N
p 6‚áî q) between
them.
2.2 Propositional Rational Closure
Non-monotonic systems can be analysed from the point of view of the properties of the consequence relations they deÔ¨Åne (Makinson, 1994). From such a perspective INs do not satisfy
some desirable logical properties, presented below, such as (CM) and (CT) (Makinson, 1994,
pp. 56-57).
Even if the satisfaction of the structural properties we are going to present is not unanimously considered as a necessary condition for a formalization of defeasible reasoning,
since most of the interesting nonmonotonic logics do not satisfy some of them, we still consider their satisfaction as a desiderata: such properties are intuitive and give back a strong
logical characterization of the consequence relation, they have a solid semantic characterization based on preferential interpretation (Kraus et al., 1990; Lehmann & Magidor, 1992),
and have strong connections to the classic AGM approach to belief revision (AlchourroÃÅn,
GaÃàrdenfors, & Makinson, 1985). Moreover the decision problem can be often reduced to
a procedure based on the classical decision problem (as in the proposal we are going to
present) allowing to implement the procedure on top of existing reasoners, and the systems
based on the preferential approach rarely give back counter-intuitive results. The main
problems are that the inferential power of such approaches is often too weak (we can often
point out conclusions that we would like to obtain, but that the system is not able to derive), and that the preferential approach has been developed for propositional logics, and
the attempts to extend it to Ô¨Årst-order languages have turned out to be quite problematic.
419

Casini & Straccia

The proposal we are going to present tries to overcome such inferential weaknesses, characteristic of the classical preferential approaches. After presenting it for the propositional
languages, we readapt the procedure to the expressivity of DLs since, even if the preferential approach cannot be easily reformulated for Ô¨Årst-order logics, it turns out to be still
appropriate for fragments of Ô¨Årst-order logic as DLs.
In what follows, we shall present a procedure for building the rational closure of a
knowledge base using the default-assumption approach (Poole, 1988; Makinson, 2005); such
an approach reduces the construction of the rational closure into a series of checks based on
the classical consequence relations. The procedure we are presenting heavily relies on the
one by Freund (1998).
SpeciÔ¨Åcally, consider a classical propositional language built on a Ô¨Ånite set of propositional letters P = {p1 , . . . , pn }, using the classical connectives ¬¨, ‚àß, ‚à®, ‚äÉ, ‚â°; sentences will
be denoted by capital letters C, D, E . . ., while sets of sentences by capital Greek letters
Œì, ‚àÜ, . . ., and ‚ä§ and ‚ä• will have the usual meaning of ‚Äútrue‚Äù and ‚Äúfalse‚Äù; in the knowledge
bases, we shall indicate consequential information by means of C ‚ä¢ D and C|‚àºD, respectively strict and defeasible conditionals, that have to be read respectively as ‚ÄòIf C, then
always D‚Äô and ‚ÄòIf C, then typically D‚Äô.  denotes the classical entailment relation, and,
given a set of formulae Œ¶ or a set of strict conditionals T , we indicate by Œ¶ and T the
monotonic entailment relations obtained adding to , respectively, the set of propositional
formulae Œ¶ or the set of conditionals {C |= D | C ‚ä¢ D ‚àà T } as extra information; we shall
use |‚àº also to indicate a generic non-monotonic consequence relation.
The knowledge base (KB) of an agent can be represented by means of conditionals or
by means of formulae; we call conditional knowledge base a pair hT , Di, where T is a Ô¨Ånite
set of strict conditionals and D is a Ô¨Ånite set of defeasible conditionals.
Example 2.3. The penguin example can be encoded as: K = hT , Di with T = {p ‚ä¢ b} and
D = {p|‚àº¬¨f, b|‚àºf, b|‚àºw}.
Another way to formalize defeasible information may be based simply on formulae, using
the default-assumption approach: a default-assumption knowledge base is a pair hŒ¶, ‚àÜi,
where Œ¶ and ‚àÜ are sets of formulae representing respectively what the agent considers as
necessarily true and as typically true.
Example 2.4. The penguin example could be encoded as: K = hŒ¶, ‚àÜi with Œ¶ = {p ‚äÉ b}
and ‚àÜ = {b ‚äÉ f, p ‚äÉ ¬¨f, b ‚äÉ w}.
We shall use the Greek letter Œ¥ to distinguish default-assumption formulae (i.e., the
members of ‚àÜ). We next show how to map a conditional knowledge base into a defaultassumption knowledge base (we will transform KBs of the kind of the one in Example 2.3
into KBs of the kind in Example 2.4), and then we show a simple procedure to reason within
the latter, by relying only on a decision procedure for |=.
We proceed as follows: (i) we deÔ¨Åne the notions of rational consequence relation and
rational closure, (ii) then, we describe a procedure to build a rational closure using a
default-assumption knowledge base.
420

Defeasible Inheritance-Based Description Logics

A consequence relation |‚àº is rational iÔ¨Ä it satisÔ¨Åes the following properties (Lehmann &
Magidor, 1992):
(REF)
(CT)

(CM)

(LLE)

(RW)

C|‚àºC for every C
C|‚àºD

ReÔ¨Çexivity

C ‚àß D|‚àºF
C|‚àºF

C|‚àºD
C|‚àºF
C ‚àß D|‚àºF
C|‚àºF

C|‚àºD

Cautious Monotony

|= C ‚â° D
D|‚àºF

D |= F
C|‚àºF

Cut (Cumulative Transitivity)

Left Logical Equivalence

Right Weakening

(OR)

C|‚àºF
D|‚àºF
C ‚à® D|‚àºF

Left Disjunction

(RM)

C|‚àºF
C6|‚àº¬¨D
C ‚àß D|‚àºF

Rational Monotony

The Ô¨Årst six properties, (REF)‚Äì(OR), characterise the class of the preferential consequence relations: that is, given a conditional base
D = {C1 |‚àºE1 , . . . , Cn |‚àºEn } ,
we say that a conditional C|‚àºD is in the preferential closure P(D) iÔ¨Ä it is derivable from
D using the rules (REF)‚Äì(OR) (Kraus et al., 1990). However, the preferential closure is
generally considered inferentially too weak to be satisfactory, and so it is natural to look
for stronger forms of closure.
The closure under the rule (RM) is considered, between the interesting rules, the
strongest one. However, given the form of such a rule (we have a negated conditional
between the premises), the rational extension of a conditional base D is not unique. Indeed,
we have multiple possibilities to close D under such a condition: for example, if we have
D = {C|‚àºF }, then neither C ‚àß D|‚àºF nor C|‚àº¬¨D are in D and we can choose to add to
D either of them in order to satisfy (RM); moreover, as this simple example shows, it is
possible that the consequence relation obtained from the intersection of diÔ¨Äerent rational
extensions of a knowledge base does not satisfy (RM) anymore (in this particular case, the
intersection would not contain neither C ‚àß D|‚àºF nor C|‚àº¬¨D). Hence, to deÔ¨Åne a rational
closure for a conditional base D, we have to choose one between the possible rational extensions of D. Lehmann and Magidor have deÔ¨Åned a rational closure operation R that satisÔ¨Åes
a set of desiderata (Lehmann & Magidor, 1992, sect. 5.1-5.3).
1. P(D) ‚äÜ R(D). That is, the conditional base D and every conditional preferentially
derivable from it should be in the rational closure of D.
2. For every conditional of form C|‚àº‚ä•, C|‚àº‚ä• ‚àà R(D) iÔ¨Ä C|‚àº‚ä• ‚àà P(D). Analogously, for
every conditional of form ‚ä§|‚àºC, ‚ä§|‚àºC ‚àà R(D) iÔ¨Ä ‚ä§|‚àºC ‚àà P(D). The conditionals of
421

Casini & Straccia

form C|‚àº‚ä• deÔ¨Åne what situations are simply considered impossible, while the conditionals of form ‚ä§|‚àºC indicate what is considered typical in general. Both such kinds
of information are properly managed by the preferential closure.
3. If we have that C|‚àºF ‚àà P(D), C|‚àº¬¨D, C ‚àßD|‚àºF ‚àà
/ P(D), we prefer a closure operation
adding C ‚àß D|‚àºF instead of C|‚àº¬¨D: the sense of a rule as (RM) is to employ a constrained form of monotonicity (given C|‚àºF , we add C ‚àß D|‚àºF ), not to arbitrarily add
new defaults (the addition of C|‚àº¬¨D); hence, whenever possible, given a conditional
C|‚àºF we want to consider its strengthening C ‚àß D|‚àºF instead of the unmotivated
addition of a conditional C|‚àº¬¨D.
We shall not describe Lehmann and Magidor‚Äôs rational closure by referring to the original
formulation (Lehmann & Magidor, 1992). Instead, we shall directly refer to a correspondent
construction, heavily relying on the procedure deÔ¨Åned by Freund (1998), and based on the
translation of a conditional KB into a default-assumption KB, which we illustrate next.
We start with a conditional KB K = hT , Di. The Ô¨Årst steps (Steps 1-3) are to deÔ¨Åne
an exceptionality ranking for all the conditionals in the KB, following the analogous procedure by Lehmann and Magidor (1992): such a ranking will permit to distinguish correctly
the strict and the defeasible knowledge contained in the KB (Step 4), since part of the
strict knowledge could be implicitly contained in D. This will allow us to construct the
correspondent default-assumption KB (Steps 5-6). SpeciÔ¨Åcally:
Step 1. We translate the strict knowledge into defeasible conditionals, that is, we move
from a KB hT , Di to h‚àÖ, D ‚àó i, where
D ‚àó = D ‚à™ {C ‚àß ¬¨D|‚àº‚ä• | C ‚ä¢ D ‚àà T } .
Intuitively, in the preferential setting, saying that C ‚ä¢ D is valid is equivalent to
saying that its negation is an absurdity (¬¨(C ‚äÉ D)|‚àº‚ä•) (Bochman, 2001, sect. 6.5).
Step 2. We deÔ¨Åne D ‚àó as the set of the materialisations of the conditionals in D ‚àó , i.e., the
material implications corresponding to such conditionals:
D ‚àó = {C ‚äÉ D | C|‚àºD ‚àà D ‚àó } .
Also, we indicate by AD‚àó the set of the antecedents of the conditionals in D ‚àó :
AD‚àó = {C | C|‚àºD ‚àà D ‚àó } .
Step 3. We deÔ¨Åne an exceptionality ranking of the conditionals in D ‚àó (Lehmann & Magidor, 1992, sect. 2.6). We build such a ranking on the following notion of exceptionality.
Given a set of conditionals D, a formula C is exceptional for D iÔ¨Ä D preferentially
entails ‚ä§|‚àº¬¨C (i.e., ‚ä§|‚àº¬¨C ‚àà P(D)); recall that a conditional ‚ä§|‚àºC ‚àà R(D) iÔ¨Ä ‚ä§|‚àºC ‚àà
P(D).
A conditional C|‚àºD is said to be exceptional for D iÔ¨Ä its antecedent C is exceptional for D. The exceptionality of a proposition can be decided based on |= only
(Lehmann & Magidor, 1992, Corol. 5.22), as C is exceptional for a set of conditionals
422

Defeasible Inheritance-Based Description Logics

D (i.e., ‚ä§|‚àº¬¨C ‚àà P(D)) iÔ¨Ä D |= ¬¨C, where D is the set of the materialisations of the
conditionals in D.
Let E(AD ) indicate the set of the antecedents that result exceptional w.r.t. D, that is
E(AD ) = {C ‚àà AD | D |= ¬¨C} ,
and with E(D) the exceptional conditionals in D, i.e.,
E(D) = {C|‚àºD ‚àà D | C ‚àà E(AD )} .
Obviously, for every D, E(D) ‚äÜ D.
Step 3.1. Taking under consideration the knowledge base h‚àÖ, D ‚àó i, we can construct
iteratively a sequence E0 , E1 . . . of subsets of the conditional base D ‚àó in the following way:
E0 = D ‚àó
Ei+1 = E(Ei ) .
Since D ‚àó is a Ô¨Ånite set, the construction will terminate with an (empty or nonempty) Ô¨Åxed point of E, i.e., a set composed only of exceptional conditionals,
which materialisations negate all their own antecedents.
Step 3.2. Using such a sequence, we deÔ¨Åne a ranking function r that associates to
every conditional in D ‚àó a number, representing its own level of exceptionality:
r(C|‚àºD) =



i
if C|‚àºD ‚àà Ei and C|‚àºD ‚àà
/ Ei+1
‚àû if C|‚àºD ‚àà Ei for every i .

Step 4. In Step 3 we have deÔ¨Åned the materialisation of D ‚àó and the rank of every conditional in it. Now,
Step 4.1. we can determine if D ‚àó is inconsistent. A conditional base D is inconsistent if from it we can derive the conditional ‚ä§|‚àº‚ä•. We know from above that a
conditional of the form ‚ä§|‚àºC is in the rational closure of D iÔ¨Ä it is in its preferential closure, that is, given the result recalled in Step 3.1, we can check the
consistency of D ‚àó using D ‚àó : ‚ä§|‚àº‚ä• ‚àà P(D ‚àó ) iÔ¨Ä D ‚àó |= ‚ä•;
Step 4.2. if D ‚àó is consistent, we deÔ¨Åne the background theory Te of the agent as2
Te = {‚ä§ ‚ä¢ ¬¨C | C|‚àºD ‚àà D ‚àó and r(C|‚àºD) = ‚àû} .

Moreover, one may verify that for every conditional in T there is a logically
equivalent conditional in Te ;

2. One may easily verify the correctness of this definition referring to results in the work of Bochman
(2001, sect. 7.5.3, Definition 7.5.1, the definition of clash on p.178, Corollary 7.5.7, Definition 7.5.2, and
Lemma 7.5.5). It suffices to show that the set of the conditionals with ‚àû as ranking value represents
the greatest clash of D (the proof is quite immediate by the definition of the exceptionality ranking).

423

Casini & Straccia

e i.e., the
Step 4.3. once we have Te , we can also identify the set of conditionals D,
‚àó
defeasible part of the information contained in D : i.e.,
e = {C|‚àºD ‚àà D ‚àó | r(C|‚àºD) < ‚àû} (obviously, D
e ‚äÜ D) .
D

Essentially, so far we have moved into T the non-defeasible knowledge ‚Äòhidden‚Äô in D,
e Moreover, we have the ranking values of all
obtaining a new conditional base hTe , Di.
e
the conditionals in D.

Step 5. Now we build the default-assumption characterization of the rational closure of
e To do so, we translate Te into a set of correspondent formulae Œ¶,
e i.e.,
hTe , Di.
e = {C | ‚ä§ ‚ä¢ C ‚àà Te } ,
Œ¶

e into a sequence of default-assumptions (i.e., formulae) ‚àÜ.
e SpeciÔ¨Åcally, given
and D
e
the rank value of the conditionals in D, we construct a sequence of default assumptions
e = hŒ¥0 , . . . , Œ¥n i ,
‚àÜ

e and
where n is the highest rank-value in D,
^
e and r(C|‚àºD) ‚â• i} .
Œ¥i = {C ‚äÉ D | C|‚àºD ‚àà D

(1)

DeÔ¨Åning the default-assumptions in this way, as presented by Freund (1998), we obtain
a set of default formulae, each one associated with a rank value, s.t. every default
formula is classically derivable from the preceding ones, that is,
Œ¥i |= Œ¥i+1 , for 0 ‚â§ i < n .
e and the default-assumption set ‚àÜ,
e according
Step 6. Given now the background theory Œ¶
e
e
to the steps deÔ¨Åned so far, we associate to the agent the pair hŒ¶, ‚àÜi. Combining such
steps with the main theorem in Freund‚Äôs work (1998, Thm. 24), it can be shown that
e ‚àÜi
e is
the default-assumption characterisation of the agent by means of the pair hŒ¶,
equivalent to the rational closure of the pair hT , Di deÔ¨Åned by Lehmann and Magidor
(1992). That is,
Proposition 2.1. Given a knowledge base K = hT , Di,
C|‚àºD ‚àà R(K) ,
where R is the rational closure operation defined by Lehmann and Magidor (1992), iff
e ‚à™ {Œ¥i } |= D,
{C} ‚à™ Œ¶

e (we indicate it by
where Œ¥i is the first formula in hŒ¥0 , . . . , Œ¥n i consistent with {C} ‚à™ Œ¶
C|‚àºhŒ¶,
e ‚àÜi
e D).
424

Defeasible Inheritance-Based Description Logics

As a consequence, using the following knowledge base transformations
hT , Di

e
hTe , Di

h‚àÖ, D ‚àó i

e ‚àÜi
e ,
hŒ¶,

(‚àó‚àó)

e ‚àÜi
e by means of Proposition 2.1,
we can characterise the rational closure of hT , Di via hŒ¶,
i.e.,
C|‚àºD ‚àà R(hT , Di) iÔ¨Ä C|‚àºhŒ¶,
e ‚àÜi
e D .
So, we have a method to decide defeasible consequence under rational closure. SpeciÔ¨Åcally, given a defeasible knowledge base hT , Di and the propositions C and D,
1. once for all, apply to hT , Di the transformations (‚àó‚àó) to obtain the defeasible knowle ‚àÜi;
e
edge base hŒ¶,

e
e =
2. given C, determine Œ¥i as the Ô¨Årst ({C} ‚à™ Œ¶)-consistent
formula of the sequence ‚àÜ
hŒ¥0 , . . . , Œ¥n i.
3. then decide if D follows under rational closure from C w.r.t. hT , Di by determining
e ‚à™ {Œ¥i }  D.
whether {C} ‚à™ Œ¶

Example 2.5. Consider again the case of the penguin, with the knowledge base of Example 2.3. First (Step1), we move the strict knowledge in T into the defeasible part, obtaining
D ‚àó = {p ‚àß ¬¨b|‚àº‚ä•, p|‚àº¬¨f, b|‚àºf, b|‚àºw} .
Then (Step2) we define the set of the materialisations
D ‚àó = {p ‚àß ¬¨b ‚äÉ ‚ä•, p ‚äÉ ¬¨f, b ‚äÉ f, b ‚äÉ w} ,
and the correspondent set of antecedents
AD‚àó = {p ‚àß ¬¨b, b, p} .

We use the set of materialisations D ‚àó to determine the ranking value of the formulae in
AD‚àó and the conditionals in D ‚àó (Step3), obtaining
0 = r(b) = r(b|‚àºf ) = r(b|‚àºw)
1 = r(p) = r(p|‚àº¬¨f )
‚àû = r(p ‚àß ¬¨b) = r(p ‚àß ¬¨b|‚àº‚ä•) .
So (Step4), we define a conditional base

with

e = hTe , Di
e ,
K
Te = {‚ä§ ‚ä¢ ¬¨p ‚à® b}
e = {p|‚àº¬¨f, b|‚àºf, b|‚àºw}
D

(since in this case the strict and the defeasible part of the conditional base were correctly
e is the same as K).
separated already in the initial base K, we obtain that K
425

Casini & Straccia

Such a conditional base is translated into a knowledge base

(Step5), with

where

e ‚àÜi
e
hŒ¶,
e = {¬¨p ‚à® b}
Œ¶
e = {Œ¥0 , Œ¥1 } ,
‚àÜ
Œ¥0 = (p ‚äÉ ¬¨f ) ‚àß (b ‚äÉ f ) ‚àß (b ‚äÉ w)
Œ¥1 = p ‚äÉ ¬¨f .

Using such default information, we conclude (Step6) that penguins do not fly, birds fly
and birds have wings.
Remark 1. Considering Example 2.5, it would be intuitive also to conclude that penguins
have wings (p|‚àºw), but in the rational closure a category that is recognized as atypical, as the
category of penguins in the present case (they are birds, but they don‚Äôt fly, and consequently
r(p) = 1), cannot inherit any of the typical characteristics of their super classes. Hence we
are not allowed to conclude that, presumably, penguins have wings. Such a weak inferential
power is generally considered the main limit of the rational closure. On the other hand, as
we are going to see in the next section, INs manage successfully this kind of problems.
This procedure to determine the rational closure maintains the same computational
complexity as the classical decision procedure, since it is easily veriÔ¨Åed that all the transformations in (‚àó‚àó) require at most O(|K|) entailment tests and, given also proposition 2.1
and the fact that the strict part can encode any (monotone) propositional theory, we have
that
Proposition 2.2. Deciding propositional defeasible consequence under rational closure (|‚àºŒ¶,‚àÜ )
is coNP-complete.
Lehmann and Magidor (1992) specify also a semantic characterization of the propositional rational closure, and an alternative correspondent construction has been recently
presented by Giordano et al. (2012a). If we move from propositional logic to DLs, a version
of rational closure for the language ALC has previously been proposed (Casini & Straccia,
2010), and such a procedure can be semantically characterized by means of preferential DL
interpretations (Britz, Casini, Meyer, Moodley, & Varzinczak, 2013).
As seen above, rational closure deÔ¨Ånes a non-monotonic consequence relation with an intuitive behaviour and strong logical properties; however, as by Remark 1, it is also somewhat
weak, as often there are conclusions about exceptional situations that, despite intuitive, we
cannot derive. Such a behaviour is due to the fact that the procedure associates to a set of
premises only those conditionals that are at least as exceptional.
Next, we are going to reÔ¨Åne rational closure in order to avoid such a loss of inferential
power w.r.t. exceptional premises. Our proposal is based on a modiÔ¨Åcation of the initial
knowledge base: we add new conditionals that give information about exceptional cases that
426

Defeasible Inheritance-Based Description Logics

would be lost in the rational closure procedure. Such a reÔ¨Ånement is obtained using again
the ranking procedure, but applying it ‚Äòlocally‚Äô, that is, in order to decide if a conditional
C|‚àºD has to be added to our KB we apply the same procedure as in rational closure, but
we consider only the information that is relevant to the inferential connection between C
and D. For example, assume a knowledge base composed only of the set of conditionals
D = {p|‚àºq, q|‚àºr, q|‚àºt, p|‚àº¬¨t}; now, following the procedure for rational closure we obtain
that p is an exceptional proposition, the only one, and so we cannot derive neither p|‚àºr nor
p|‚àºt. But, while we do not want to derive p|‚àºt, as we already have p|‚àº¬¨t, intuitively we
do not have any reason to avoid the conclusion p|‚àºr. In fact, such a conclusion would be
desirable, since p is a q, and p being an r does not generate any conÔ¨Çict with the rest of the
information in the knowledge base.
So, our aim is to specify a way to decide which information in the KB is relevant
w.r.t. a particular connection (in the above case, p|‚àºr). In order to determine such a ‚Äòlocal‚Äô
relatedness we are going to consider INs: we use their ‚Äògraphical‚Äô characterisation in order
to identify the relevant information w.r.t. the connection we want to investigate, and then
we apply the ranking procedure to the pieces of information recognised as relevant.

3. Boolean Defeasible Inheritance Networks
Here we present a new decision procedures for INs, based on classical propositional decisions,
that, in addition to being a main step in the nonmonotonic construction we are going to
present later on, turns out to be an interesting IN decision procedure per se.
In the following, we proceed as follows. At Ô¨Årst, we deÔ¨Åne a procedure for INs, and then
we map it into propositional logic, obtaining the desired reÔ¨Ånement of rational closure.
3.1 Exceptionality Levels in Inheritance Nets
Our Ô¨Årst aim is to apply to INs a modiÔ¨Åed version of the decision procedure for rational
closure; we do this in order to deÔ¨Åne a method for deciding validity in INs that rely on
propositional calculus so to allow easily (i) to extend such a method in order to include into
the language also the propositional connectives ¬¨, ‚àß, ‚à®, and (ii) to integrate it with rational
closure, in order to extend the inferential power of rational closure without compromising
its logical properties. A non-negligible side product is that it is a propositional SAT-based
reasoning procedure.
We shall brieÔ¨Çy review the case of purely strict nets showing that this case is easily
manageable using propositional calculus, and then we shall focus on mixed nets.
3.1.1 Strict Nets
For the strict part of the nets we want to obtain the same valid connections as in all classical
proposals. If a net is composed only of strict links, i.e., N = hS, ‚àÖi, its valid connections and
its consistency can be easily checked using propositional calculus. Indeed, deÔ¨Åne a classical
propositional language ‚Ñì using the nodes in N as propositional letters (call PN such a set
of propositional letters), and ‚äÉ and ¬¨ as connectives, and translate the set of links S into
the set of the corresponding propositional implications
Œ¶ = {p ‚äÉ q | p ‚áí q ‚àà S} ‚à™ {p ‚äÉ ¬¨q | p 6‚áî q ‚àà S} .
427

Casini & Straccia

We indicate by l a literal in ‚Ñì (being a literal a propositional letter or its negation), and
we deÔ¨Åne AŒ¶ as the set of the antecedents of the implications in Œ¶, that is
AŒ¶ = {p | p ‚äÉ l ‚àà Œ¶} .
Then we can derive the valid paths using Œ¶ and classical consequence relation  3 .
Proposition 3.1. Consider a net N = hS, ‚àÖi and translate it into a set of propositional
implications Œ¶. The following properties hold:
1. If N is a consistent net, there is a valid strict positive (resp., negative) path hp, œÉ, qi
from p to q, that is N
p ‚áí q (resp., N
p 6‚áî q), iff Œ¶  p ‚äÉ q (resp., Œ¶  p ‚äÉ ¬¨q).
2. N is inconsistent iff Œ¶  ¬¨p for some p ‚àà AŒ¶ .
3. Deciding strict consequence can be done in polynomial time.
So we can treat the decision problem in strict nets by means of classical propositional
calculus, obtaining exactly the same valid strict paths as in the classical approaches to nets.
Note that there is a diÔ¨Äerence in the notion of inconsistency between INs and propositional logic. As seen in Section 2.1, a net is considered inconsistent if there is a node p
that, simultaneously, is positively and negatively connected to another node q: p is and
is not, simultaneously, a subclass of q. In the inheritance nets, such a situation is interpreted as a contradiction, while in the propositional logic the correspondent situation
(Œ¶ |= (p ‚äÉ q) ‚àß (p ‚äÉ ¬¨q)) would just force the negation of the propositional letter (i.e.,
node) p (Œ¶  ¬¨p), that would correspond to saying that no individual can fall under the
class p.
3.1.2 Mixed Nets
Now we consider nets with both strict and defeasible links. In what follows we will assume
that the strict part of a net N = hS, U i is inferentially closed, that is, if N
p ‚áí q (resp.,
if N
p 6‚áî q) then p ‚áí q ‚àà S (resp. p 6‚áî q ‚àà S).
Our procedure diÔ¨Äers from the classical approaches to INs mainly because it is not based
on the notion of potential path; instead, we translate the net‚Äôs links into propositional
formulae, and then we build an exceptionality ranking using a procedure that is similar to
the one deÔ¨Åned for rational closure. The main diÔ¨Äerence with the procedure deÔ¨Åned for
rational closure lays on the ‚Äòlocal‚Äô characterization of the exceptionality rankings: to check
if there is a valid connection between a pair of nodes p and q we proceed in deÔ¨Åning an
exceptionality ranking of the nodes; however, we do not consider all the nodes in the net,
but only those ‚Äòrelated‚Äô to p and q. Such a relation is determined by means of the notion
of course, that is a generalisation of the potential path.
Roughly, courses are simply routes on the net following the direction of the arrows,
without considering if each of them is a positive or a negative arrow.
Definition 3.1 (Course). Courses are defined as follows (where ‚ãÜ ‚àà {‚áí, 6‚áî, ‚Üí, 6‚Üí}):
3. Note that strict links can be encoded as 2-CNF formulae, also called Krom formulae, and that the
propositional 2-SAT problem is in P .

428

Defeasible Inheritance-Based Description Logics

1. every link p ‚ãÜ q in N is a course œÄ = hp, qi in N ; and
2. if œÄ = hœÉ, qi is a course and q ‚ãÜ r is a link in N that does not already appear in œÄ,
then œÄ ‚Ä≤ = hœÄ, ri is a course in N .
The omission of repetitions in courses is needed to guarantee the Ô¨Åniteness of courses
even if the net contains cycles. So, given a net N deÔ¨Åned by a Ô¨Ånite number of links, there
is only a Ô¨Ånite set C N of courses, that, in turn, are Ô¨Ånite sequences of nodes. We denote
N the set of all the courses in N going from node p to the node q, i.e.,
with Cp,q
N
Cp,q
= {œÉ ‚àà C N | œÉ = hp, œÉ ‚Ä≤ , qi for some œÉ ‚Ä≤ } .

We next provide a procedure that deÔ¨Ånes the validity of a defeasible connection between
two nodes p and q, via a mapping into propositional logic. Given a net N = hS, U i, we
deÔ¨Åne a correspondent knowledge base
KN = hŒ¶N , ‚àÜN i ,
where
Œ¶N = {p ‚äÉ q | p ‚áí q ‚àà S} ‚à™ {p ‚äÉ ¬¨q | p 6‚áî q ‚àà S}
and
‚àÜN = {p ‚äÉ q | p ‚Üí q ‚àà U } ‚à™ {p ‚äÉ ¬¨q | p 6‚Üí q ‚àà U } .
In the following, we may omit N if it is clear from the context.
We deÔ¨Åne an ‚Äòexceptionality ranking‚Äô of the nodes, that depends on the decision problem
with respect to p and q only.4
So, let
‚àÜp,q = {r ‚äÉ t | r ‚Üí t ‚àà œÉ, œÉ ‚àà Cp,q } ‚à™
{r ‚äÉ ¬¨t | r 6‚Üí t ‚àà œÉ, œÉ ‚àà Cp,q } ,
and consider the set of relative antecedents (l being a literal)
Ap,q = {a | a ‚äÉ l ‚àà Œ¶N ‚à™ ‚àÜp,q } .
In the following, Œ¶N will denote the supra classical entailment relation obtained adding
to  the set of propositional formulae Œ¶N as extra axioms. For the strict part of the net, if
p Œ¶N q (resp., p Œ¶N ¬¨q), then we say that q (resp., ¬¨q) follows strictly from p in N , and
we indicate it by p ‚ä¢N q (resp., p ‚ä¢N ¬¨q).
On the other hand, |‚àºN will indicate the inference relation for the defeasible part, that
is, p|‚àºN q has to be read as ‚Äòa member of the class p is typically also a member of the class
q‚Äô in N . Analogously for p|‚àºN ¬¨q in the negative case.
4. This is the main difference w.r.t. the procedure for propositional rational closure: while there we rank
all the information in the KB at once, here we rank only the information related to the connection we
are interested in, between p and q.

429

Casini & Straccia

Now, we use Œ¶N and ‚àÜp,q to determine the exceptionality level. If we are investigating the connection between p and q, a node in Ap,q is exceptional if it is negated by the
information contained in Œ¶ and ‚àÜp,q (compare with Step 3.2 in Section 2.2):
E(Ap,q ) = {a ‚àà Ap,q | ‚àÜp,q Œ¶N ¬¨a}
E(‚àÜp,q ) = {a ‚äÉ b ‚àà ‚àÜp,q | a ‚àà E(Ap,q )} .
Therefore, like Step 3.3 of Section 2.2, we build a sequence
Œ±0 = Ap,q
Œ±i = E(Œ±i‚àí1 ) ,
and the corresponding sequence
E0 = ‚àÜp,q
Ei = E(Ei‚àí1 ) .
Since Ap,q and ‚àÜp,q are Ô¨Ånite, and for every i Œ±i ‚äÜ Œ±i+1 and Ei+1 ‚äÜ Ei , the sequences
terminate with an (empty or non-empty) Ô¨Åxed point of the function E, as in Section 2.2.
DeÔ¨Åne now a ranking function (like Step 3.4) r that associates to every implication in
‚àÜp,q a number, representing its level of exceptionality:
rp,q (a) = i if a ‚àà Œ±i and a ‚àà
/ Œ±i+1
rp,q (a) = ‚àû if a ‚àà Œ±i for all i
rp,q (a ‚äÉ b) = i if (a ‚äÉ b) ‚àà Ei and (a ‚äÉ b) ‚àà
/ Ei+1
rp,q (a ‚äÉ b) = ‚àû if (a ‚äÉ b) ‚àà Ei for all i .
Clearly, r(a ‚äÉ b) = r(a) for every a ‚äÉ b ‚àà ‚àÜp,q . In the following, we assume that we
do not obtain any node with a ranking value of ‚àû (that is, the function E terminates with
an empty set). We will see later on (Proposition 3.6) that in this latter case the net is
inconsistent.
b p,q of the implications a ‚äÉ b ‚àà ‚àÜp,q that are at least as
We now consider the set ‚àÜ
exceptional as p,
b p,q = {a ‚äÉ b ‚àà ‚àÜp,q | r(a ‚äÉ b) ‚â• r(p)} ,
‚àÜ

and eventually deÔ¨Åne

b p,q Œ¶ p ‚äÉ q
p|‚àºN q iÔ¨Ä ‚àÜ
N
b
p|‚àºN ¬¨q iÔ¨Ä ‚àÜp,q Œ¶N p ‚äÉ ¬¨q .

In the language of the nets, we indicate the inference relation generated by such a
procedure by the symbol ‚Ä≤ . That is,
N

‚Ä≤

p ‚áí q iÔ¨Ä

p ‚ä¢N q

N

‚Ä≤

p 6‚áî q iÔ¨Ä

p ‚ä¢N ¬¨q

N
N

‚Ä≤

p ‚Üí q iÔ¨Ä
p 6‚Üí q iÔ¨Ä

p|‚àºN q
p|‚àºN ¬¨q .

‚Ä≤

So, given N = hS, U i and a pair of nodes hp, qi, our inference procedure for INs can be
summarised as follows:
430

Defeasible Inheritance-Based Description Logics

1. Close S under strict validity.
2. Check if there is a direct (and hence valid) link in N connecting p to q. If there is,
the connection is valid. Otherwise, proceed.
3. Determine the set Cp,q of the courses in N connecting p to q, map the links in S and
Cp,q into the sets of implications Œ¶ and ‚àÜp,q , deÔ¨Åne the set Ap,q of the antecedents of
the implications in Œ¶ ‚à™ ‚àÜp,q .
4. Determine the ranking value of every proposition in Ap,q and every implication in
‚àÜp,q .
b p,q of the implications that are at least as exceptional as p.
5. DeÔ¨Åne the set ‚àÜ

6. Then decide N
b p,q Œ¶ p ‚äÉ ¬¨q).
(‚àÜ

‚Ä≤

p ‚Üí q (N

‚Ä≤

b p,q Œ¶ p ‚äÉ q
p 6‚Üí q) by determining whether ‚àÜ

Please note again that we rely on a decision procedure for  only. The examples below
illustrate the behaviour of our method.
Example 3.1. Consider Example 2.1 with additional links t ‚áí b and t ‚áí p (read t as
‚Äòtweety‚Äô).
w
b
f

t

p

Figure 1: Example 3.1
We translate the net into the following knowledge base
K = hŒ¶, ‚àÜi ,
where
Œ¶ = {t ‚äÉ b, t ‚äÉ p, p ‚äÉ b}
and
‚àÜ = {p ‚äÉ ¬¨f, b ‚äÉ f, b ‚äÉ w} .
Suppose now, we want to decide if t is connected to f (i.e., Tweety flies).
Since the link b ‚Üí w does not appear in any course from t to f , we have
‚àÜt,f

= {p ‚äÉ ¬¨f, b ‚äÉ f }

At,f

= {t, b, p} ,
431

Casini & Straccia

and so we obtain
‚àÜt,f Œ¶ ¬¨p and ‚àÜt,f Œ¶ ¬¨t .
Thus,
0 = r(b) = r(b ‚äÉ f )
1 = r(t) = r(p) = r(p ‚äÉ ¬¨f )
So,
b t,f Œ¶ t ‚äÉ ¬¨f , we have
and, as ‚àÜ

b t,f = {p ‚äÉ ¬¨f }
‚àÜ
t|‚àºN ¬¨f ,

as expected.
As next, we ask if t is connected to w (i.e., Tweety has wings). Now, we have
‚àÜt,w = {b ‚äÉ w}
At,w = {t, b, p} .
As ‚àÜt,w does not imply the negation of any of the members of At,w , we have
0 = r(t) = r(p) = r(b) = r(b ‚äÉ w)
and

b t,w = ‚àÜt,w .
‚àÜ

b t,w Œ¶ t ‚äÉ w, we have
As ‚àÜ

t|‚àºN w ,

as expected.
Example 3.2. Consider the Nixon Diamond (see Figure 2), where n is ‚ÄòNixon‚Äô, r is ‚Äòrepublican‚Äô, q is ‚Äòquaker‚Äô, and p is ‚Äòpacifist‚Äô; it is another classical problem in nonmonotonic
reasoning, that is similar to the previous one but we are not informed if a path is more
specific of the other (while above the link p ‚áí b tells us that the information about the
penguins is more specific than the information about the birds). So, we do not want neither
n ‚Üí p nor n 6‚Üí p validated.
q
p

n

r

Figure 2: Nixon diamond.
432

Defeasible Inheritance-Based Description Logics

The knowledge base K corresponding to the net is composed of
Œ¶ = {n ‚äÉ r, n ‚äÉ q}
‚àÜ = {r ‚äÉ ¬¨p, q ‚äÉ p} .
We want to check if n is connected to p. So, ‚àÜn,p = ‚àÜ, and the only negated antecedent is n
ÀÜ n,p = ‚àÖ. Since ‚àÜ
ÀÜ n,p 6Œ¶ n ‚äÉ p
(‚àÜn,p Œ¶ ¬¨n): r(q ‚äÉ p) = r(r ‚äÉ ¬¨p) = 0 while r(n) = 1, i.e., ‚àÜ
ÀÜ n,p 6Œ¶ n ‚äÉ ¬¨p, we conclude that
and ‚àÜ
n 6 |‚àºN
n 6 |‚àºN

p
¬¨p .

The two following examples illustrate that our procedure and Horty‚Äôs skeptical closure,
notwithstanding they often manifest similar results, do not always give back the same
results, nor one is included in the other.
Example 3.3. Consider the net in Figure 3.
f

g

x

p

a

m

n

y

Figure 3: Example 3.3
We want to investigate if there is a valid connection between a and p. According to
Horty‚Äôs skeptical closure, we cannot conclude anything about a and p (N 6 a ‚Üí p). Instead,
‚Ä≤ a ‚Üí p), since we have r(a) = r(f ) = r(g) =
with our approach we obtain a|‚àºK p (N
r(x) = 1.
Example 3.4. Consider the net in Figure 4.
p
c

t

e

f

b

Figure 4: Example 3.4
We want to investigate if there is a valid connection between p and b. According to
Horty (1994) we conclude N
p 6‚Üí b, while with our approach we cannot conclude anything.
433

Casini & Straccia

So, even if in many situations the results of the two approaches are the same, we can
obtain diÔ¨Äerent results with them. Such diÔ¨Äerent outcomes are mainly due to a diÔ¨Äerence in
how conÔ¨Çicts are interpreted. Consider Example 3.4, where we have an unresolved conÔ¨Çict
between two paths from p to f , that is, no one of the two paths preempts the other, and so
none of them can be considered as valid, both in Horty‚Äôs and in our approach. In Horty‚Äôs
interpretation, such a conÔ¨Çict prevents also the construction of paths starting at p and
passing through f : in order to be constructible a path has to be built augmenting a valid
shorter path, and thus we cannot construct any path starting from p and passing through
f (Horty, 1994, Def. 2.1.1). So, an unresolved conÔ¨Çict totally eliminates the possibility to
consider such paths in more ample argumentations, where they could play some role. On
the other hand, in our approach we are not so radical about conÔ¨Çicts: the fact that we
cannot conclude neither p ‚Üí f nor p 6‚Üí f does not eliminate the possibility that in the
actual world one of such connections is true; simply we do not have enough information to
decide. The possibility of p ‚Üí f to be eÔ¨Äectively valid invites us to take under consideration
such a potential argumentation in moving from p to b. So, looking for a connection between
p and b in Example 3.4, while Horty cannot consider the path hp, c, t, f, bi, avoiding the
rise of a conÔ¨Çict with the path hp, e, bi, in our approach we still consider the possibility
for hp, c, t, f i to be eÔ¨Äectively true, allowing the path hp, c, t, f, bi to play a role in deciding
whether there is a valid connection between p and b. In such a way we have a potential
conÔ¨Çict with hp, e, bi that prevents the validity of the latter. For other signiÔ¨Åcant examples
of our approach see Appendix A.
Notice that, even if it is built on the notion of courses, our procedure ‚Äòrespects‚Äô the
classical notion of potential path, that is, every valid connection corresponds to a potential
path on the net (DeÔ¨Ånition 2.1).
Proposition 3.2. Consider a net N . For every connection p|‚àºN q (resp., p|‚àºN ¬¨q) validated
by our procedure, there is a corresponding positive (resp., negative) potential path from p to
q in the net N .
3.1.3 Inference Relation
Talking about nets, the structural properties characterizing rational consequence relations,
REF , CT , CM , and RM , take the following form5 :
(REF)
(CT)
(CM)
(RM)

N
N
N
N

p ‚ãÜ q for every p ‚ãÜ q ‚àà N
p‚ãÜq
N,p ‚ãÜ q
r‚àós
N
r‚àós
p‚ãÜq
N
r‚àós
N,p ‚ãÜ q
r‚àós
r‚àós
N 6 p‚ãÜq
N , p6 ‚ãÜq
r‚àós

The meaning of the properties is still the same as the propositional case, simply readapted
to the expressivity of the INs: the net represents the information at our disposal, the
premises of the derivation, and the links are the informational atoms of our language.
5. with ‚ãÜ, ‚àó ‚àà {‚Üí, 6‚Üí}; ‚ÄòN , a ‚ãÜ b‚Äô in the premises indicates the addition of the direct link a ‚ãÜ b to the net N ;
6 ‚ãÜ indicates the opposite arrow of ‚ãÜ (e.g. 6 ‚ãÜ is ‚Üí iff ‚ãÜ is 6‚Üí)

434

Defeasible Inheritance-Based Description Logics

Hence, the sense of the rules is the same as before. (REF) indicates that whatever piece
of information (link) is in the premises, it appears also in the conclusions. (CT) is a cut
condition, that states that if the validity of a link can be derived from the links in the rest of
the net, such a link can be eliminated without aÔ¨Äecting the set of the conclusions derivable
from the net. (CM) is a form of constrained monotony, opposite to (CT), that states that
whatever conclusion can be derived from the net, it can be added to the premises without
aÔ¨Äecting the other conclusions. (CT) and (CM) have an intuitive appeal, and from the
logical point of view characterize
as a closure operation. The translation of (RM) is less
intuitive, since we do not have in INs a classical notion of negation, but we have only a
notion of conÔ¨Çict; hence the sense of the rule is that, if p ‚Üí q is not a consequence of N ,
then the addition of information conÔ¨Çicting with p ‚Üí q, i.e., p 6‚Üí q, should not aÔ¨Äect the
defeasible consequences of the net N . The fact that INs do not share with classical logic
the notions of contradiction and negation makes this formulation of (RM) less intuitive and
interesting.
The proprieties (REF), (CT) and (CM) are often considered proprieties that a nonmonotonic consequence relation should satisfy (Kraus et al., 1990; Makinson, 1994), and so
it is interesting to check if they are satisÔ¨Åed in the IN formalism. We know that the classical
approaches to inheritance nets do not satisfy (CT) and (CM) (Makinson, 1994, pp. 56-57),
while our approach is logically more appealing.
Proposition 3.3.

‚Ä≤

satisfies (REF), (CT) and (CM).

While (RM) is not satisÔ¨Åed.
Proposition 3.4.

‚Ä≤

does not satisfy (RM).

The following example proves the proposition
Example 3.5. Consider the net in Figure 5. The net is composed of the links p ‚Üí f ,
f ‚Üí b, and p ‚Üí t. We have N
p ‚Üí b and N 6 t ‚Üí b, but N , t 6‚Üí b 6 p ‚Üí b.
b
f

t

p

Figure 5: Counterexample to RM.
This example actually shows that, dealing with the notion of negation and consistency
that characterize INs, (RM) does not look as a desirable property anymore, since the addition of t 6‚Üí b to the net creates a Nixon Diamond from which we do not want to derive
p ‚Üí b (see Example 3.2).
435

Casini & Straccia

Other properties of logical consequence relations, left equivalence and right weakening,
have an analogous in the following properties:
(LE)
(RW)

N

p‚ãÜq N
p‚áír N
N
r‚ãÜq
p‚Üíq
N
q‚áír
N
p‚Üír

N

r‚áíp

We also introduce a property that corresponds to the logical property of supra classicality (if C  D, then C|‚àºD), a rule satisÔ¨Åed by most non-monotonic consequence relations:
(Sup)

N
N

Proposition 3.5.

p‚áíq
p‚Üíq
‚Ä≤

N
N

p 6‚áî q
p 6‚Üí q

satisfies (LE), (RW ), and (Sup).

3.1.4 Consistency
As indicated at the end of Section 2.1, a net is considered inconsistent if we are forced
to conclude for some pair of nodes p, q that p and q are both positively and negatively
connected. Since, as seen above, ‚Ä≤ satisÔ¨Åes (Sup), we can say that a mixed net is consistent
iÔ¨Ä we cannot conclude both N ‚Ä≤ p ‚Üí q and N ‚Ä≤ p 6‚Üí q for any pair of nodes p, q.
Now we are going to see that in order to check the consistency of a mixed net we can use
the ranking procedure: it is suÔ¨Écient to apply it to the whole net. As for the propositional
case (see Section 2.2), the ranking procedures deÔ¨Åned on the nodes of a net terminates,
after a Ô¨Ånite number of steps, into either an empty set Œ±n or a Ô¨Åxed point of the function
E, i.e., the set of the nodes that result always exceptional. In such a case, we say that such
nodes have an inÔ¨Ånite ranking value (r(p) = ‚àû). If we want to check whether a net N is
consistent, it is suÔ¨Écient to apply the ranking procedure to the entire net, and see if there
are nodes with inÔ¨Ånite ranking.
Proposition 3.6. A net N is consistent iff we do not have a node p with r(p) = ‚àû, that
is, we do not conclude both N ‚Ä≤ p ‚Üí q and N ‚Ä≤ p 6‚Üí q for any pair p, q.
Example 3.6. The net in Figure 6 is an example of an inconsistent net, from which we
‚Ä≤ t ‚Üí f and N
‚Ä≤ t 6‚Üí f . Such a net is translated into the
would conclude both N
b
f

t

p

Figure 6: An example of inconsistent net.
436

Defeasible Inheritance-Based Description Logics

knowledge base
Œ¶ = {t ‚äÉ b, t ‚äÉ p, p ‚äÉ b, b ‚äÉ p}
‚àÜ = {p ‚äÉ ¬¨f, b ‚äÉ f } .
We proceed the ranking of the entire net, and we obtain that ‚àÜ Œ¶ ¬¨p, ‚àÜ Œ¶ ¬¨b and
‚àÜ Œ¶ ¬¨t, that is, E1 = ‚àÜ. Hence, ‚àÜ is a fixed-point of the exceptionality ranking function,
and p, b, t have ‚àû as ranking value.
3.1.5 Properties
In the Ô¨Åeld of inheritance networks, a taxonomy of the diÔ¨Äerent approaches has been developed on the basis of some relevant properties (Horty, 1994). We brieÔ¨Çy check which of
them are satisÔ¨Åed by our approach.
‚Ä¢ Purely defeasible / mixed nets. Cyclic / acyclic nets. Our procedure deals easily with
two properties that often create problems in the traditional approaches: the presence
of both strict and defeasible links (mixed nets), and the presence of cycles (cyclic
nets).
‚Ä¢ Credulous / skeptical / directly skeptical approaches. Our approach corresponds to a
directly skeptical approach: given a net, we obtain a unique set of valid connections in
it (vs. the credulous approach, that allows for diÔ¨Äerent sets of valid paths, possibly in
conÔ¨Çict with each other), and such a unique set is not obtained from the intersection
of diÔ¨Äerent possible extensions (as in some skeptical approaches), but it is obtained
from a single closure operation.
‚Ä¢ Upward / downward chaining. For the deÔ¨Ånition of valid paths, we do not use any
form of induction on their length, neither starting from the initial node toward the
terminal node (upward chaining), nor in the reverse direction (downward chaining);
hence, no form of chaining is used in our procedure.
‚Ä¢ On-path / off-path preemption. OÔ¨Ä-path preemption is the classical form of preemption, used also by Horty (1994, Def. 3.2.2), while on-path preemption is more
binding, requiring the preempting node to lie on the initial segment of the path it preempts (Horty, 1994, sect. 4.2.4). We do not exactly formalise a form of preemption,
since we do not confront directly the diÔ¨Äerent paths between two nodes. However,
our procedure has a behaviour that is analogous to the use of oÔ¨Ä-path preemption.
3.1.6 Computational Complexity
To deÔ¨Åne the overall complexity of our decision procedure over the nets, we have to consider
the complexity of the course-identiÔ¨Åcation procedure, that is, given a net N = hS, U i and
two nodes s, t in N , which is the computational cost to identify ‚àÜs,t (note that Œ¶ can easily
be computed in polynomial time), whose size is bounded polynomially by the size of N .
Given that the construction of courses is independent from the nature of the links (either
they are positive or negative, defeasible or strict), we can analyse the problem using simple
directed graphs. Given a net N = hS, U i, it is suÔ¨Écient to deÔ¨Åne the correspondent directed
graph G = hV, Ei in the following way:
437

Casini & Straccia

‚Ä¢ V is the set of nodes in N .
‚Ä¢ E is a set of directed links ha, bi, with a, b ‚àà V , s.t. ha, bi ‚àà E iÔ¨Ä one of the following
holds:
a ‚áí b ‚àà S , a 6‚áî b ‚àà S , a ‚Üí b ‚àà U , a 6‚Üí b ‚àà U .
Recall that we have stated the presence of a 6‚áî b in S implies that b 6‚áî a is in S too. So,
for a 6‚áî b ‚àà S we have both ha, bi and hb, ai in E.
Once we have deÔ¨Åned G, let us recall a well-known result in graph theory saying that
in a directed graph, given two nodes p and q, determining if there is a path from p to q
can be determined in time O(|V | + |E|), e.g. using BFS (Breadth First Search) (Cormen,
Stein, Rivest, & Leiserson, 2001). Now, the following argument shows that indeed ‚àÜs,t can
be determined in polynomial time 6 . At Ô¨Årst, we check if there is a path between s and t.
If not, then ‚àÜs,t = ‚àÖ. Otherwise, we call the procedure Delta(s) below:
Delta(s): for each outgoing edge hs, xi of s, such that both hs, xi and x are not marked,
do: if there is a path between x and t then mark both hs, xi and x, and recursively,
call Delta(x).
Once Ô¨Ånished, ‚àÜs,t can immediately be build from the marked edges. Note that each edge
is marked once and each node is marked (i.e., explored) once and, thus, the algorithm is
bounded polynomially by the size of the graph.
Once we have found the set ‚àÜs,t and Œ¶, we have to apply the decision procedure based
on the propositional rational closure to decide if there is a valid connection between p and
q (as for Section 2.2, the number of entailment tests is polynomially bounded by the size
of the net). As all formulae are 2-CNF, like Proposition 3.1, we obtain that the decision
procedure w.r.t. the net respects the complexity costs of the related propositional calculus.
Proposition 3.7. Deciding defeasible consequence under inheritance networks (
done in polynomial time.

‚Ä≤)

can be

Eventually, if we want to determine all the valid links in the net N we have to consider
all the pairs of nodes in the net N . So, obtained the graph G = hV, Ei we have to repeat the
procedure for all the elements of the set of the pairs of nodes in the graph, whose cardinality
is |V |(|V | ‚àí 1). Hence, again
Proposition 3.8. Computing all the valid connections in a net can be done in polynomial
time.
3.2 Boolean Inheritance Nets
We next extend INs by introducing in them the classical propositional connectives ¬¨, ‚àß, ‚à®.
Despite such an extension has been felt as desirable, we are aware of just an attempt in this
direction (Horty & Thomason, 1990).
6. We are not interested here in figuring out a tight bound.

438

Defeasible Inheritance-Based Description Logics

c

c

c‚äïd

c‚äód

d

d

Figure 7: Disjunction

Figure 8: Conjunction

3.2.1 Negation
So far, we have used the link 6‚áî to indicate that two classes are disjoint: p 6‚áî q has p ‚äÉ ¬¨q
as logical meaning. We change the notation and substitute 6‚áî with ‚áî¬¨ , indicating with
p ‚áî¬¨ q that ‚Äòclass p and class q are complementary‚Äô (i.e., p ‚â° ¬¨q), and in general we
will indicate the complementary class of a class p with pÃÑ. Hence, we can substitute every
link p 6‚áî q in a net with four links: p ‚áî¬¨ p, q ‚áî¬¨ q, p ‚áí q, and q ‚áí p. Moreover, we
can eliminate the negative defeasible links, since p 6‚Üí q can be expressed as p ‚Üí qÃÑ ‚áî¬¨ q.
So, we can transform an IN into a net using only the arrows ‚Üí, ‚áí, and ‚áî¬¨ . We shall
continue to use 6‚áî as a macro indicating the valid negative strict connections obtained from
the composition of ‚áî¬¨ and ‚áí, that is, we indicate with p 6‚áî q the presence of a path
¬¨
. . d ‚áê} q ,
p‚áí
| a ‚áí{z. . . ‚áí b} ‚áî |c ‚áê .{z
n arrows

with n, m ‚â• 0.

m arrows

3.2.2 Conjunction and Disjunction
Next, we extend inheritance nets to support conjunction and disjunction as well, by allowing
links a, b ‚áî‚àß c (conjunction of a and b is equivalent to c) and c ‚áî‚à® a, b (disjunction of a
and b is equivalent to c). We will assume that inheritance nets containing such kind of
links are closed according to the following rule: if there is a, b ‚áî‚àß c (resp., a, b ‚áî‚à® c) in
a net, then there are also c ‚áí a and c ‚áí b (resp., a ‚áí c and b ‚áí c) in the net. We call
these nets Boolean Defeasible Inheritance Networks (BINs). We shall use a ‚äó b and a ‚äï b
to indicate, respectively, that a node represents the conjunction or the disjunction of a and
b. Graphically, we indicate disjunctive and conjunctive links as in Figure 7 and Figure 8,
respectively.
We extend now our reasoning method to BINs. To do so, we need to amplify the notion
of course, introducing the notion of duct: we consider not only ‚Äòlinear‚Äô routes from one point
to another, but also ‚Äòparallel‚Äô routes, in order to model the introduction of the conjunction
in the consequent and the introduction of the disjunction in the antecedent. Roughly,
œÄ = hs,

œÉ
, ti
œÉ‚Ä≤

will indicate a duct œÄ that starts at node s and develops through the ducts œÉ and œÉ ‚Ä≤ , both
reaching the node t.
439

Casini & Straccia

Definition 3.2 (Duct). Ducts are defined as follows (where ‚ãÜ ‚àà {‚áí, 6‚áî, ‚Üí, 6‚Üí}):
1. every link p ‚ãÜ q in N is a duct œÄ = hp, qi in N ;
2. if œÄ = hœÉ, qi is a duct and q ‚ãÜ r is a link in N that does not already appear in œÄ, then
œÄ ‚Ä≤ = hœÄ, ri is a duct in N ;
3. if œÄ = hq, œÉi is a duct and r ‚ãÜ q is a link in N that does not already appear in œÄ, then
œÄ ‚Ä≤ = hr, œÄi is a duct in N ;
t,œÉ
4. if ht, œÉ, pi and hr, œÉ ‚Ä≤ , pi are ducts, then for s ‚áî‚à® t, r ‚àà S, hs, r,œÉ
‚Ä≤ , pi is a duct; and

5. if hp, œÉ, ti and hp, œÉ ‚Ä≤ , ri are ducts, then for t, r ‚áî‚àß s ‚àà S, hp, œÉœÉ,t
‚Ä≤ ,r , si is a duct.
Now our reasoning method for BINs is as follows. Given a net N = hS, U i, we can deÔ¨Åne
a correspondent knowledge base K = hŒ¶, ‚àÜi, where
Œ¶ = {p ‚äÉ q | p ‚áí q ‚àà S}
‚à™ {p ‚â° ¬¨q | p ‚áî¬¨ q ‚àà S}
‚à™ {p ‚â° q ‚àß r | q, r ‚áî‚àß p ‚àà S}
‚à™ {p ‚â° q ‚à® r | p ‚áî‚à® q, r ‚àà S}
‚à™ {p ‚äÉ ¬¨q | p 6‚áî q ‚àà S}
‚àÜ = {p ‚äÉ q | p ‚Üí q ‚àà U } .
Now, we may proceed to the deÔ¨Ånition of |‚àºN as in Section 3.1, simply considering C N as
N (or simply C ) as the set of the ducts from p to q.
the set of the ducts in N , and Cp,q
p,q
Example 3.7. Consider the net N illustrated in Figure 9. The net N is mapped into the
e

d
g

a

¬¨

b
c
f

Figure 9: Example 3.7
KB K = hŒ¶, ‚àÜi, where

7

Œ¶ = {c ‚àß d ‚â° g, f ‚â° ¬¨g}
‚àÜ = {a ‚äÉ b, b ‚äÉ c, b ‚äÉ d, b ‚äÉ e, a ‚äÉ f } .
7. To ease the reading, we have omitted the redundant implications such as g ‚äÉ c, obtained from c, d ‚áî‚àß
g, g ‚áí c ‚àà N .

440

Defeasible Inheritance-Based Description Logics

Now, we ask whether a is connected to c. It can be verified that
‚àÜa,c = {a ‚äÉ b, b ‚äÉ c, b ‚äÉ d, a ‚äÉ f } .
Note that b ‚äÉ d ‚àà ‚àÜa,c , as there is a duct from a to c that passes through c and d in order
to reach g, and then back towards c. Now, the only negated antecedent is a (‚àÜa,c Œ¶ ¬¨a)
and, thus,
b a,c = {a ‚äÉ b, a ‚äÉ f } .
‚àÜ
b a,c 6Œ¶ a ‚äÉ c and ‚àÜ
b a,c 6Œ¶ a ‚äÉ ¬¨c, we have
Since ‚àÜ

a6|‚àºN c and a6|‚àºN ¬¨c .

In a similar way, we may show that a6|‚àºN d and a6|‚àºN ¬¨d. This is the desirable result: since
a ‚Üí f is a direct link, we have that a|‚àºN f (i.e., a|‚àºN ¬¨(c ‚àß d)), and hence we know that
we cannot conclude both a|‚àºN c and a|‚àºN d. But, since we have no evidence whether one of
such conclusions has to be preferred to the other, we do not conclude either of them. The
result of our ‚Äòskeptical‚Äô approach is that a6|‚àºN c, a6|‚àºN ¬¨c, a6|‚àºN d, and a6|‚àºN ¬¨d. On the other
hand, since the only duct connecting a to e is ha, b, ei (that is, the nodes c, d, g, and f do
not play any role in any possible argumentation connecting a to e), we can conclude a|‚àºN e.
3.2.3 Properties
We call BIN the inference relation deÔ¨Åned by the just deÔ¨Åned closure operation over BINs
and we have:
N

BIN

p ‚áí q iÔ¨Ä p Œ¶ q

N

BIN

p 6‚áî q iÔ¨Ä p Œ¶ ¬¨q

N

BIN

p ‚Üí q iÔ¨Ä p|‚àºN q

N

BIN

p 6‚Üí q iÔ¨Ä p|‚àºN ¬¨q .

BINs inherit the same structural properties of our INs, that is, (REF ), (CM ), and
(CT ). Analogously, (LE), (RW ), and (Sup) are still valid.
Proposition 3.9.
Proposition 3.10.

BIN

satisfies (REF ), (CM ), and (CT ).

BIN

satisfies (LE), (RW ), and (Sup).

Since the procedure deÔ¨Åned in Section 3.1 is simply a special case of the procedure for
BINs, (RM) is falsiÔ¨Åed also for BINs by the same counter-example of proposition 3.4. Moreover, introduced conjunction and disjunction, we can express the analogous of the rules of
disjunction in the premises (OR) and conjunction in the consequent (AND):
(OR)

(AND)

N

BIN

p‚ãÜq N
N

N

BIN

s‚ãÜq N
BIN t ‚ãÜ q

BIN

p‚Üíq N
N

p‚Üís N
BIN p ‚Üí t

BIN

441

BIN

t ‚áî‚à® p, s

BIN

q, s ‚áî‚àß t

Casini & Straccia

The sense is the same as in the propositional case, and it remains intuitive also in
the BIN environment: (OR) represents the validity of reasoning by cases, while (AND)
represents that the conjunction of distinct conclusions is still a valid conclusion from the
net.
Proposition 3.11.

BIN

satisfies (OR) and (AND).

3.2.4 Consistency
Also w.r.t. consistency, we obtain the same result as for INs, i.e., the net is consistent if the
ranking procedure terminates into an empty set.
Proposition 3.12. A BIN N is consistent iff we do not have any node p with r(p) = ‚àû,
that is, we cannot conclude both p ‚Üí q and p 6‚Üí q for any pair p, q.
Remark 2. As seen in Section 3.1.4 the notion of consistency in inheritance nets is different from the notion of consistency for propositional logic. Using our procedure a net is
inconsistent if, applying the ranking function to the entire net, we obtain a node with ‚àû as
ranking value (see Proposition 3.6). Up to this point, if we find that a net is inconsistent,
we simply stop our decision procedure.
In what follows we are going to work with BINs in the framework of propositional logic.
So, in order to assimilate the notion of consistency with the one of propositional logic, from
now on we shall consider a modified version of our procedure for BINs. Suppose we have
to decide the validity of the connection between two nodes p, q in a net N . If N results
consistent, then we proceed as above, otherwise, if our net results inconsistent (some node
has infinite ranking value) we do not simply stop, but, in case r(p) < ‚àû, we still apply our
procedure. Otherwise, if p itself has infinite ranking value (r(p) = ‚àû), we do not proceed
further.
3.2.5 Computational Complexity
As for INs, we have to determine ‚àÜs,t (computing Œ¶ is again immediate) from the ducts
in a BIN. Now, it is not diÔ¨Écult to see that a recursive BFS graph travelling procedure
as the one devised for INs can be worked out for BINs as well. By illustration, refer to
Figure 9 and assume we are processing node b. Since from b, both d and c are reachable
and d, c ‚áî‚à® g ‚àà S, and, recursively, there is a path from g to c, we can mark hb, ci and hb, di,
and mark the ‚Äúconjunction‚Äù d, c ‚áî‚à® g ‚àà S as visited. Again, all nodes and ‚Äúaggregated
nodes‚Äù are visited at most ones, guaranteeing polynomial cost for computing ‚àÜs,t .
Now, while ‚àÜs,t and Œ¶ can be determined in polynomial time, and as for Section 2.2,
the number of entailment tests is polynomially bounded by the size of the net, the strict
part may encode any propositional formula and, thus, unlike the case of INs, we have:
Proposition 3.13. Deciding defeasible consequence for BINs (
problem.

BIN )

is a coNP-complete

4. Defeasible Inheritance in Propositional Logic
Now, we depart from BINs and apply a similar reasoning procedure in the framework of
propositional logic, and show how to obtain a kind of closure of a knowledge base that
442

Defeasible Inheritance-Based Description Logics

results to be a rational consequence relation, but that is more informative than the classical
rational closure (Lehmann & Magidor, 1992).
We consider a propositional language with only ¬¨, ‚à®, ‚àß as connectives. So, we start with
a conditional KB K = hT , Di (see Section 2.2), with T = {C1 ‚ä¢ D1 , . . . , Cn ‚ä¢ Dn } and
D = {E1 |‚àºF1 , . . . , Em |‚àºFm }.
Step 1. Given a conditional base K = hT , Di, check if K is preferentially consistent (that
is, check if its materialisation is consistent; Section 2.2, Step 4.1). If it is consistent,
we deÔ¨Åne a BIN from K, i.e., a net NK = hSK , UK i, modelling the information in K
in the following way:
(i) we consider every formula C that appears as antecedent or as succedent in the
conditionals in K, and we create a node C representing each of them, modulo
logical equivalence (that is, a node C represents the class of the formulae logically
equivalent to C).
(ii) for each node we add also, if not already present, the complementary node (the
node representing its negation), and we link them by ‚áî¬¨ ;
(iii) we add the strict links: if C ‚ä¢ D ‚àà T we add the strict link C ‚áí D to the net;
we also add to SK all the strict links that correspond to the logical dependencies
between the formulae represented by the nodes w.r.t. the consequence relation
T . If ‚ä§ appears in a conditional, we add to the net a correspondent node ‚ä§,
and, for every other node n in the net, we add a strict node n ‚áí ‚ä§. Analogously,
for ‚ä• we add ‚ä• ‚áí n for every node n in the net.
(iv) eventually, for C|‚àºD ‚àà D, we add a defeasible link ‚Üí from node C to node D.
Step 2. We apply the reasoning procedure for BINs to NK (Section 3.2) to identify all valid
defeasible connections C|‚àºN D and we add them as C|‚àºD to the conditional base K
to obtain a new conditional base K‚Ä≤ = hT , D ‚Ä≤ i 8 .
Step 3. Finally, we apply to K‚Ä≤ its rational closure (Section 2.2) and we deÔ¨Åne a nonmonotonic consequence relation |‚àºK by
C|‚àºK D iÔ¨Ä C|‚àºD ‚àà R(K‚Ä≤ ) .
Now, we can show that
Proposition 4.1. |‚àºK is a rational consequence relation containing K.
Example 4.1. Consider again the penguin example. We modify it slightly in order to
consider also the use of the connectives. While birds (b) typically fly, live on trees, and have
wings (f , t, w), penguins do not fly and do not live on trees (¬¨f ‚àß ¬¨t). So, our knowledge
base K = hT , Di will be:
T

= {p ‚ä¢ b}

D = {b|‚àºf, b|‚àºt, b|‚àºw, p|‚àº¬¨f ‚àß ¬¨t} .
8. We do not modify T , since all the strict connections valid in the net are classically derivable from T .

443

Casini & Straccia

Notwithstanding penguins‚Äô atypicality as birds, penguins have wings, and we would like
to be able to derive it from the information at our disposal, that is, we would like to conclude
p|‚àºw. Please note that this is not possible using classical preferential approaches, but we
can obtain such a conclusion passing trough the first step of our closure operation, that is,
defining the corresponding net.
Specifically, from the knowledge base K we define the net in Figure 10 (the dashed arrows
are the strict arrows that are not explicit in the conditional base, but that are logically valid
and that are added to SK in the construction of the net NK ).
¬¨f ‚àß ¬¨t

¬¨

¬¨f
¬¨

t‚à®f

¬¨

p

¬¨t

¬¨

f

t

¬¨p

b

¬¨w

w

¬¨

¬¨

¬¨b

Figure 10: Example 4.1
Using the procedure defined for BINs, from such a net we obtain a new knowledge base
K‚Ä≤ = hT , D ‚Ä≤ i ,
with
D ‚Ä≤ = {b|‚àºf, b|‚àºt, b|‚àºw, p|‚àº¬¨f ‚àß ¬¨t, p|‚àºw, p|‚àº¬¨f, p|‚àº¬¨t, b|‚àºf ‚à® t} .
Note that, while the new conditionals
p|‚àº¬¨f,

p|‚àº¬¨t,

b|‚àºf ‚à® t

would be present also in the simple rational closure of K (we obtain them by Right Weakening), we have obtained also the conditional
p|‚àºw ,
444

Defeasible Inheritance-Based Description Logics

that would not be present in the rational closure of K (see Remark 1).
Now, following the procedure defined in Section 2.2, we compute the rational closure
of the new knowledge base K‚Ä≤ , obtaining a rational consequence relation that contains the
original K.
Please note that, if we were using only BINs, we could have not derived anything else,
since our vocabulary would be limited to the propositions expressed by the nodes; however,
by relying on the rational closure of propositional knowledge bases, we can reason using the
full expressivity of a propositional language, deriving new conditionals as, for example,
b ‚àß green|‚àºf ,
which can not be derived using BINs as green does not appear in the net.
The next example shows another characteristic of this approach. In the preferential
approach typicality is an ‚Äòabsolute‚Äô property of a proposition w.r.t. the agent‚Äôs knowledge
base, that is, if a class results atypical w.r.t. some other class (as penguins w.r.t. birds),
it results atypical w.r.t. the entire knowledge base. In our approach instead, typicality is
a comparative notion: we can consider a class as exceptional with respect to a superclass,
but absolutely typical with respect to another.
Example 4.2. Consider a red fish (r). It is both a fish (f ) and a pet (p). Typically, a fish
has gills (g) and scales (s), while pets are docile (d) and play with kids (k). Red fishes are
not typical pets, since they do not play with kids. So, the K = hT , Di is
T

= {r ‚ä¢ f, r ‚ä¢ p}

D = {r|‚àº¬¨k, p|‚àºk, p|‚àºd, f |‚àºg, f |‚àºs} .
In the rational closure red fishes, since they are atypical pets (they do not play with kids),
result atypical in general, and they cannot inherit any of the typical properties of all their
super classes.
Instead, we want red fishes to inherit, besides the properties of pets that are compatible
with them (d), also all the typical properties of fishes (g and s), since we consider them
typical fishes.
To do so, we translate our knowledge base into the net in Figure 11. From such a net
we obtain a new knowledge base K‚Ä≤ = hT , D ‚Ä≤ i, with
D ‚Ä≤ = {r|‚àº¬¨k, p|‚àºk, p|‚àºd, f |‚àºg, f |‚àºs, r|‚àºd, r|‚àºg, r|‚àºs}
and so we have derived exactly the desired conditionals.
Next, we compute the rational closure of K‚Ä≤ , following the procedure defined in Section
2.2, and we obtain a rational consequence relation containing K and more information about
red fishes, information that, as intuitive as it is, we would not be able to derive from the
simple rational closure of K.
Therefore, we have deÔ¨Åned a new rational consequence relation for K that extends K,
as K ‚äÇ R(K‚Ä≤ ), and that contains intuitive conditionals not in the rational closure of K.
445

Casini & Straccia

¬¨g

g
f
¬¨f

s

¬¨

¬¨

¬¨s

¬¨

¬¨

¬¨p
d

r

¬¨

¬¨r

¬¨d

¬¨

p

¬¨k

¬¨

k

Figure 11: Example 4.2
Consistency. DeÔ¨Åned some inference procedure, a conditional base K is consistent iÔ¨Ä we
cannot derive ‚ä§|‚àº‚ä•. We have seen (Section 2.2) that for rational closure a conditional base
is consistent iÔ¨Ä its preferential closure is consistent (‚ä§|‚àº‚ä• ‚àà R(K) iÔ¨Ä ‚ä§|‚àº‚ä• ‚àà P(K)). Here,
given a base K, we obtain that our procedure preserves the preferential consistency of K:
as seen in Section 2.2, K is preferentially consistent iÔ¨Ä its rational closure is consistent (i.e.,
‚ä§ 6 |‚àºrc
K ‚ä•), and we can prove the following.
Proposition 4.2. Given a conditional base K, ‚ä§|‚àºK ‚ä• iff ‚ä§|‚àº‚ä• ‚àà R(K).
By the results in Section 2.2, this corresponds to saying that ‚ä§|‚àºK ‚ä• iÔ¨Ä K  ‚ä• (assuming
K = hT , Di, K = T ‚à™ D).
Computational Complexity. Considering the procedures deÔ¨Åned for the BINs, we can
conclude that the deÔ¨Åned procedure has the same complexity of the rational closure, as it
is the composition of the procedure deÔ¨Åned for BINs (Proposition 3.13) and a Ô¨Ånal rational
closure operation (Proposition 2.2).
Proposition 4.3. For a propositional conditional base K, deciding C|‚àºK D is a coNPcomplete problem.

5. Defeasible Inheritance in DLs
Next, we apply our method to a signiÔ¨Åcant DL representative, namely ALC (Baader et al.,
2003, ch. 2). ALC corresponds to a fragment of Ô¨Årst order logic, using monadic predicates,
called concepts, and dyadic ones, called roles.
In order to stress the parallel between the procedure presented in Section 2.2 and the
proposal in ALC, we are going to use the same notation for the components playing an
analogous role in the two construction: we use p, q, r, . . . for concept names, and C, D, E, . . .
to indicate concepts in general, instead, respectively, of atomic propositions and propositions, and |= and |‚àº to indicate, respectively, the classical consequence relation of ALC and
446

Defeasible Inheritance-Based Description Logics

a non-monotonic consequence relation in ALC. Œ¥ will indicate a default concept, that is, a
concept that we assume as applying to every individual, if not informed of the contrary.
We have a Ô¨Ånite set of concept names C = {p, q, r, . . .}, a Ô¨Ånite set of role names R =
{R, S, T, . . .} and the set L of ALC-concepts is deÔ¨Åned inductively as follows: (i) C ‚äÇ L;
(ii) ‚ä§, ‚ä• ‚àà L; (iii) C, D ‚àà L ‚áí C ‚äì D, C ‚äî D, ¬¨C ‚àà L; and (iv) C ‚àà L, R ‚àà R ‚áí
‚àÉR.C, ‚àÄR.C ‚àà L. Concept C ‚äÉ D is used as a shortcut of ¬¨C ‚äî D. The symbols ‚äì and ‚äî
correspond, respectively, to the conjunction ‚àß and the disjunction ‚à® of classical logic.
Given a set of individuals O, indicated by bold letters a, b, c, . . ., an assertion is of
the form a:C (C ‚àà L) or of the form (a, b):R (R ‚àà R), respectively indicating that the
individual a is an instance of concept C, and that the individuals a and b are connected
by the role R.
A general inclusion axiom (GCI) is of the form C ‚äë D (C, D ‚àà L) and indicates that
any instance of C is also an instance of D. We use C = D as a shortcut of the pair of
C ‚äë D and D ‚äë C.
From a FOL point of view, assertions and inclusion axioms can easily be mapped in
FOL by the following transformation:
œÑ (a:C) = œÑ (a, C),
œÑ (C ‚äë D) = ‚àÄx.(œÑ (x, C) ‚Üí œÑ (x, D)),
œÑ (x, A) = A(x),
œÑ (x, C ‚äì D) = œÑ (x, C) ‚àß œÑ (x, D),
œÑ (x, ‚àÉR.C) = ‚àÉy.(R(x, y) ‚àß œÑ (y, C))
œÑ (x, ‚àÄR.C) = ‚àÄy.(R(x, y) ‚Üí œÑ (y, C))

œÑ ((a, b):R) = R(a, b),
œÑ (x, ‚ä§) = ‚ä§(x), œÑ (x, ‚ä•) = ‚ä•(x),
œÑ (x, ¬¨C) = ¬¨œÑ (x, C),
œÑ (x, C ‚äî D) = œÑ (x, C) ‚à® œÑ (x, D),
where y is a new variable,
where y is a new variable .

Now, a classical knowledge base is deÔ¨Åned by a pair K = hA, T i, where T is a Ô¨Ånite
set of GCIs (the TBox ) and A is a Ô¨Ånite set of assertions (the ABox ), whereas a defeasible
knowledge base is represented by a triple K = hA, T , Di, where additionally D is a Ô¨Ånite
‚äè D (‚Äòan instance of a concept C is typically an instance of a concept
set of conditionals C ‚àº
9
D‚Äô), with C, D ‚àà L .
Example 5.1. Consider again the penguin example. Just add a role P rey in the vocabulary,
where a role instantiation (a, b):P rey is read as ‚Äòa preys on b‚Äô, and add also two more
concepts, i (insect) and f i (fish). An example of defeasible KB is
K = hA, T , Di
with
A = {a:p, b:b, (a, c):P rey, (b, c):P rey}
T = {p ‚äë b, i ‚äë ¬¨f i}
‚äè ¬¨f, b ‚äè f, p ‚äè ‚àÄP rey.f i, b ‚äè ‚àÄP rey.i} .
D = {p ‚àº
‚àº
‚àº
‚àº
The particular structure of a defeasible KB allows for the ‚Äòisolation‚Äô of the pair hT , Di,
that we could call the conceptual system of the agent, from the information about the
individuals (formalized in A).
9. Since for the monotonic part we substitute the meta-linguistic conditionals C ‚ä¢ D with formulae C ‚äë D,
we substitute also for the defeasible part of the knowledge base the conditionals C|‚àºD with conditional
‚äè D, that we could call defeasible inclusion axioms.
formulae C ‚àº

447

Casini & Straccia

In what follows we are going to work with the information about concepts hT , Di Ô¨Årst,
exploiting the immediate analogy with the homonymous pair in the propositional setting,
and then we will address the case involving individuals as well. We show that by using
our method we overcome to the limits of classical rational closure, already presented for
ALC (Casini & Straccia, 2010), in a similar way as for the propositional case. Please note
that the procedure presented here is based on a slightly modiÔ¨Åed version of the procedure
for rational closure previously presented by Casini and Straccia (2010), i.e., on the one
presented by Britz et al. (2013). The latter is accompanied by a semantic characterization,
based on DL interpretations with a preferential relation deÔ¨Åned over the individuals. Such a
semantic characterization of rational closure for ALC characterises all the steps of our procedure (the ‚Äòlocal‚Äô applications of rational closure and the Ô¨Ånal one). However, we still lack
a semantic characterization of the overall procedure, accounting also for the modularization
of the knowledge base done using the INs.
Step 1. Given a conceptual system K = hT , Di, check its preferential consistency, that is,
deÔ¨Åne
T

= {C ‚äÉ D | C ‚äë D ‚àà T }

‚äè D ‚àà D}
D = {C ‚äÉ D | C ‚àº

and construct a BIN NK from K. The process is the same as the one in Section 4,
just treat the concepts as propositions: nodes in NK represent the concepts appearing
as antecedents or consequents of the inclusion axioms in T and D (modulo logical
equivalence); for every node we add its complementary node, if not already present,
and we connect them by ‚áî¬¨ ; every GCI C ‚äë D ‚àà T becomes a strict link C ‚áí D;
‚äè D ‚àà D becomes a defeasible link C ‚Üí D.
and every defeasible inclusion axiom C ‚àº
Moreover, consider the consequence relation T as the monotonic consequence relation
obtained adding the GCIs in T to , and add to the net the strict links representing
all the logical dependencies between nodes with respect to T 10 .
Step 2. Apply the reasoning procedure for BINs to NK (Section 3.2) to identify all the
‚äè D to the conditional base
valid defeasible connections C ‚Üí D, and add them as C ‚àº
‚Ä≤
‚Ä≤
K to obtain a new conditional base K = hT , D i.
Now, once we have augmented our knowledge base with new defeasible conditionals, we
proceed as follows.
‚äè ‚ä• | C ‚äë D ‚àà T }.
Step 3. DeÔ¨Åne D ‚àó = D ‚Ä≤ ‚à™ {C ‚äì ¬¨D ‚àº
‚äè D ‚àà D ‚Ä≤ } and let A ‚àó = {C | C ‚äè D ‚àà D ‚àó }.
Step 4. DeÔ¨Åne D ‚àó = {C ‚äÉ D | C ‚àº
D
‚àº

Step 5. Determine the exceptionality ranking of the conditionals in D ‚àó using the set of
the antecedents AD‚àó and the materialisations
in D ‚àó , where a concept C is exceptional
d
w.r.t. a set of conditionals D iÔ¨Ä |= D ‚äë ¬¨C. The steps are the same of the propositional case (Step
3 in Section 2.2) by replacing the expression D |= ¬¨C with the
d
expression |= D ‚äë ¬¨C. In this way deÔ¨Åne a ranking function r.
10. In order to create the strict part of the net it is possible to use the techniques introduced for the procedure
of classification of DL knowledge bases (Baader et al., 2003, ch. 9).

448

Defeasible Inheritance-Based Description Logics

Step 6. As Step 4.1, Section 2, verify if the KB is consistent, by checking the consistency
of D ‚àó . Then (as in Steps 4.2 - 4.3 in Section 2.2), deÔ¨Åne the sets
‚äè D ‚àà D ‚Ä≤ and r(C ‚äè D) = ‚àû}
Te = {‚ä§ ‚äë ¬¨C | C ‚àº
‚àº
‚Ä≤
‚äè
‚äè
‚äè
e
D = {C ‚àº D | C ‚àº D ‚àà D and r(C ‚àº D) < ‚àû} .

e and ‚àÜ,
e with
Step 7. DeÔ¨Åne (similarly to Step 5 in Section 2.2) the sets of concepts Œ¶

where
Œ¥i =

l

e = {C | ‚ä§ ‚äë C ‚àà T }
Œ¶
e = {Œ¥0 , . . . , Œ¥n } ,
‚àÜ

‚äèD ‚ààD
e and r(C
{C ‚äÉ D | C ‚àº

‚äè
‚àº

D) ‚â• i} .

As for Section 2, for every Œ¥i , 0 ‚â§ i < n, |= Œ¥i ‚äë Œ¥i+1 .
Step 8. Now, we can deÔ¨Åne the inference relation |‚àºK as
C|‚àºK D iÔ¨Ä |= C ‚äì

l

e ‚äì Œ¥i ‚äë D,
Œ¶

e
where Œ¥i is the Ô¨Årst {C} ‚à™ Œ¶-consistent
formula11 of the sequence hŒ¥0 , . . . , Œ¥n i. This is
the DL analogue as Step 6, Section 2.2.
Again, all steps require a decision procedure for the classical entailment relation |= of
DLs. We can redeÔ¨Åne the properties characterizing a rational consequence relation into the
framework of DLs.
We can show that
Proposition 5.1. |‚àºK is a rational consequence relation containing K.
That is, the analogous properties of the propositional rational consequence relation are
satisÔ¨Åed, namely:
(REF) C|‚àºK C
(LLE)

(CT)

C |‚àºK E

|=T C = D

D |‚àºK E

C ‚äì D |‚àºK E

(OR)
11. That is, 6|= C ‚äì

(RW)

C |‚àºK D

(CM)

C |‚àºK E
C |‚àºK E

D |‚àºK E

(RM)

C ‚äî D |‚àºK E
de
Œ¶ ‚äë ¬¨Œ¥i .

449

C |‚àºK D

|=T D ‚äë E

C |‚àºK E
C |‚àºK E

C |‚àºK D

C ‚äì D |‚àºK E
C |‚àºK D

C 6 |‚àºK ¬¨E

C ‚äì E |‚àºK D

Casini & Straccia

Example 5.2. Consider example 5.1, where additionally we also add a role Born (‚ÄòBorn(x, y)‚Äô
is read as ‚Äòx is born from y‚Äô), and a concept e (Egg). Consider
K = hT , Di ,
where
T

= {p ‚äë b, i ‚äë ¬¨f i}

‚äè ‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§, b ‚äè ‚àÄP rey.i ‚äì ‚àÉP rey.‚ä§, b ‚äè ‚àÉBorn.e} .
D = {p ‚àº
‚àº
‚àº

p

b
¬¨

¬¨

‚àÉBorn.e

p

¬¨

‚àÄBorn.¬¨e

b

‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§

‚àÄP rey.i ‚äì ‚àÉP rey.‚ä§
¬¨

¬¨
‚àÉP rey.¬¨f i ‚äî ‚àÄP rey.‚ä•

‚àÉP rey.¬¨i ‚äî ‚àÄP rey.‚ä•

Figure 12: Example 5.2
Now (Step 1), we build the correspondent net NK (figure 12), and we obtain (Step 2)
that
‚äè ‚àÉBorn.e} .
D ‚Ä≤ = D ‚à™ {p ‚àº
Then we move to the rational closure. The pair hT , D ‚Ä≤ i is changed into (Step 3)
‚äè ‚ä•, i ‚äì f i ‚äè ‚ä•,
D ‚àó = { p ‚äì ¬¨b ‚àº
‚àº
‚äè ‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§, b ‚äè ‚àÄP rey.i ‚äì ‚àÉP rey.‚ä§,
p‚àº
‚àº
‚äè ‚àÉBorn.e, p ‚äè ‚àÉBorn.e} .
b‚àº
‚àº

The set of the materialisations of D ‚àó is (Step 4)
D ‚àó = {p ‚àß ¬¨b ‚äÉ ‚ä•, i ‚äì f i ‚äÉ ‚ä•, p ‚äÉ ‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§,
b ‚äÉ ‚àÄP rey.i ‚äì ‚àÉP rey.‚ä§, b ‚äÉ ‚àÉBorn.e, p ‚äÉ ‚àÉBorn.e}
AD‚àó = {p ‚äì ¬¨b, i ‚äì f i, p, b} .
We obtain now (Step 5) the exceptionality ranking of the conditionals:
‚äè ‚ä•, i ‚äì f i ‚äè ‚ä•, p ‚äè ‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§,
E0 = {p ‚äì ¬¨b ‚àº
‚àº
‚àº
‚äè ‚àÄP rey.i ‚äì ‚àÉP rey.‚ä§, b ‚äè ‚àÉBorn.e, p ‚äè ‚àÉBorn.e}
b‚àº
‚àº
‚àº
‚äè ‚ä•, i ‚äì f i ‚äè ‚ä•, p ‚äè ‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§, p ‚äè ‚àÉBorn.e}
E1 = {p ‚äì ¬¨b ‚àº
‚àº
‚àº
‚àº
‚äè ‚ä•, i ‚äì f i ‚äè ‚ä•}
E2 = {p ‚äì ¬¨b ‚àº
‚àº
‚äè ‚ä•, i ‚äì f i ‚äè ‚ä•} = E .
E3 = {p ‚äì ¬¨b ‚àº
2
‚àº

450

Defeasible Inheritance-Based Description Logics

From this we get the ranking values of every conditional in D ‚àó : namely,
‚äè ‚àÄP rey.i ‚äì ‚àÉP rey.‚ä§) = r(b ‚äè ‚àÉBorn.e)
0 = r(b ‚àº
‚àº
‚äè ‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§) = r(p ‚äè ‚àÉBorn.e)
1 = r(p ‚àº
‚àº
‚äè ‚ä•) = r(i ‚äì f i ‚äè ‚ä•) .
‚àû = r(p ‚äì ¬¨b ‚àº
‚àº

From this ranking, we obtain (Steps 6-7) a background theory
Te = {‚ä§ ‚äë ¬¨(p ‚äì ¬¨b), ‚ä§ ‚äë ¬¨(i ‚äì f i)} ,

e = {Œ¥0 , Œ¥1 }, with
and a default-assumption set ‚àÜ

Œ¥0 = (b ‚äÉ ‚àÄP rey.i ‚äì ‚àÉP rey.‚ä§) ‚äì (b ‚äÉ ‚àÉBorn.e) ‚äì

Œ¥1

(p ‚äÉ ‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§) ‚äì (p ‚äÉ ‚àÉBorn.e)
= (p ‚äÉ ‚àÄP rey.f i ‚äì ‚àÉP rey.‚ä§) ‚äì (p ‚äÉ ‚àÉBorn.e)

to be used for the definition of the consequence relation |‚àºK (Step 8).
For example, we derive that typical penguins‚Äô preys are fishes, i.e.,
p|‚àºK ‚àÄP rey.f i ,
and not insects, i.e.,
p|‚àºK ‚àÄP rey.¬¨i ,
and that also penguins are born from eggs, i.e.,
p|‚àºK ‚àÉBorn.e ,
that would not be derivable from the rational closure, as presented by Casini and Straccia (2010).
Computational Complexity. From a computational complexity point of view, as deciding entailment in ALC is ExpTime-complete (Donini & Massacci, 2000) and, as for
Section 2.2, the number of entailment tests is polynomially bounded by the size of the
knowledge base, following exactly the same procedures deÔ¨Åned for the propositional case,
we conclude that
Proposition 5.2. Deciding C|‚àºK D in ALC is an ExpTime-complete problem.
5.1 Closure Operation over Individuals
So far we left out the ABox, but we are going to consider it here. The procedure for the
ABox is built over the above procedure for the TBox, that is, we consider a knowledge base
hA, T , Di such that all the strict knowledge has already been moved into T , i.e., in D we
do not have axioms with ‚àû as ranking value (that is, they correspond to the sets Te and
e obtained using the procedure in the previous section). The basic idea of the following
D
procedure is to consider each individual named in the ABox as much typical as possible,
that is, to associate to it all the possible defeasible information that is consistent with the
rest of the knowledge base. In order to apply the defeasible information locally to each
451

Casini & Straccia

individual, we encode such information using the materialisations of the inclusion axioms,
e in the section
i.e., the set ‚àÜ = hŒ¥1 , . . . , Œ¥n i, s.t. |= Œ¥i ‚äë Œ¥i+1 for 1 ‚â§ i < n (the set ‚àÜ
12
above ). We want to be able to associate to each individual a ‚àà O (with O being the set
of the individuals named in the ABox) the strongest formula Œ¥i that is consistent with the
e = hAD , T i, that we call
knowledge base. In such a way we deÔ¨Åne a new knowledge base K
a ABox extension of the knowledge base hA, T , Di.
Definition 5.1 (ABox extension). Given a knowledge base K = hA, T , Di, a knowledge
base hAD , T i is an ABox extension of K = hA, T , Di iff
‚Ä¢ hAD , T i is classically consistent and A ‚äÜ AD .
‚Ä¢ AD \ A is composed of all the assertions a:C such that a ‚àà O and C = Œ¥i for some i,
and for every Œ¥h s.t. h < i,
hT , AD ‚à™ {a:Œ¥h }i |= ‚ä•
The above deÔ¨Ånition identiÔ¨Åes the extensions of the original ABox A s.t. to every
individual is associated all the defeasible information that is consistent with the rest of the
knowledge base. Still, the main problem is that, since the individuals can be related to
each other through roles, the possibility of associating a default concept to an individual
can be inÔ¨Çuenced by the default information associated to other individuals, as shown in
the following example.
‚äè A‚äì‚àÄR.¬¨A}
Example 5.3. Consider K = hA, Di, with A = {(a, b):R} and D = D0 = {‚ä§ ‚àº
(hence we have ‚àÜ = hŒ¥0 i = hA ‚äì ‚àÄR.¬¨Ai). If we associate Œ¥0 to a, we obtain b:¬¨A and we
cannot associate Œ¥0 to b; on the other hand, if we apply Œ¥0 to b, we derive b:A and we are
not anymore able to associate Œ¥0 to a. Hence, we define two possible rational extensions of
K.


This implies that, given a knowledge base hA, T , Di, even if the closure of hT , Di is
always unique there is the possibility that we have more than one ABox extensions. A
simple procedure to obtain all the possible extensions of a knowledge base hA, T , Di, with
O the set of the individuals in named in A, is the following:
Definition 5.2 (Procedure for ABox extensions).
‚Ä¢ Consider the set S of all the linear orders of the individuals in O;
‚Ä¢ For each s = ha1 , . . . , am i in S do:
‚Äì Set j := 1
‚Äì Set AsD := A
‚Äì Repeat until j = m + 1:
‚àó Find the first default Œ¥i ‚àà ‚àÜ such that hAsD ‚à™ {aj :Œ¥i }, T }i 6|= ‚ä§ ‚äë ‚ä•.
‚àó AsD := AsD ‚à™ {aj :Œ¥i }.
e and ‚àÜ
e must be done
12. Note that, given a conditional knowledge base, the procedure to determine Te , D
once for all.

452

Defeasible Inheritance-Based Description Logics

‚àó j =j+1
‚Äì return hAsD , T i
where we indicate by AsD the ABox extension of A obtained using the sequence s.
Now, it can be shown that
Proposition 5.3. Given a linear order of the individuals in K, the above procedure determines an ABox extension of K. Vice-versa, every ABox extension of K corresponds to the
knowledge base generated by some linear order of the individuals in O.
e1 = hA‚à™{a:A ‚äì ‚àÄR.¬¨A}, ‚àÖi
For instance, related to Example 5.3, we obtain the extension K
e
from the order ha, bi, while K2 = hA ‚à™ {b:A ‚äì ‚àÄR.¬¨A}, ‚àÖi is obtained from the order hb, ai.
Example 5.4. Refer to Example 5.1, and let K = {A, T , D}, where
A = {a:p, b:b, (a, c):P rey, (b, c):P rey}
T = {p ‚äë b, i ‚äë ¬¨f i}
‚äè f, b ‚äè ‚àÄP rey.i, p ‚äè ¬¨f, p ‚äè ‚àÄP rey.f i}
D = {b ‚àº
‚àº
‚àº
‚àº

From such a knowledge base we define a set ‚àÜ = {Œ¥0 , Œ¥1 } with

Œ¥0 = (b ‚äÉ f ) ‚äì (b ‚äÉ ‚àÄP rey.i) ‚äì (p ‚äÉ ¬¨f ) ‚äì (p ‚äÉ ‚àÄP rey.f i)
Œ¥1 = (p ‚äÉ ¬¨f ) ‚äì (p ‚äÉ ‚àÄP rey.f i) .
If we consider an order where a comes before b, then we associate Œ¥1 to a, and consequently c is presumed to be a fish and we are prevented in the association of Œ¥0 to b. If we
consider b before a, c is not a fish and we cannot apply Œ¥1 to a.
Now, if we Ô¨Åx a priori a linear order s on the individuals, we can say that a:C is a
e |= a:C, where K
e is
defeasible consequence of K w.r.t. the order s, written ‚ÄòK s a:C‚Äô, iÔ¨Ä K
the ABox extension generated from K based on the order s.

For instance, related to Example 5.3 and order s1 = ha, bi, we may infer that K s1 a:A,
while with order s2 = hb, ai, we may infer that K s2 b:A.
The interesting point of such a consequence relation is that it still satisÔ¨Åes the properties
of a rational consequence relation in the following way.
453

Casini & Straccia

(REFDL )

hA, T , Di s a:C for every a:C ‚àà A

(LLEDL )

hA ‚à™ {b:D}, T , Di s a:C
D=E
hA ‚à™ {b:E}, T , Di s a:C

(RWDL )

hA, T , Di s a:C
C‚äëD
hA, T , Di s a:D

(CTDL )
(CMDL )

hA ‚à™ {b:D}, T , Di s a:C
hA, T , Di s b:D
hA, T , Di s a:C
hA, T , Di s a:C
hA, T , Di s b:D
hA ‚à™ {b:D}, T , Di s a:C

(ORDL )

hA ‚à™ {b:D}, T , Di s a:C
hA ‚à™ {b:E}, T , Di s a:C
hA ‚à™ {b:D ‚äî E}, T , Di s a:C

(RMDL )

hA, T , Di s a:C
hA, T , Di 6s b:¬¨D
hA ‚à™ {b:D}, T , Di s a:C

We can show that
Proposition 5.4. Given K and a linear order s of the individuals in K, the consequence
relation s satisfies the properties (REFDL ) ‚àí (RMDL ).
Note that from a computational complexity point of view, as entailment w.r.t. a ALC TBox
is ExpTime-complete (Donini & Massacci, 2000) and the number of individuals in K is linearly bounded by |K|, we get immediately
Proposition 5.5. Deciding K s a:C in ALC is a ExpTime-complete problem.
In the presence of multiple ABox extensions, we can also deÔ¨Åne the inference relation
, a more conservative inference relation independent from any order on the individuals,
that corresponds to the intersection of all the inference relations s modelling a rational
extension.
=

\

{s | s is a linear order on the elements of O}

However, there is the possibility that we lose the property of rational monotonicity, as
shown in the following example.
Example 5.5. Consider the knowledge base hA, Di s.t. A = {(a, b):R} and D = D0 ‚à™ D1 ,
‚äè A ‚äì ‚àÄR.¬¨A, ‚ä§ ‚äè B} and D = {¬¨A ‚äè ¬¨B, ¬¨‚àÄR.¬¨A ‚äè B} (where D and D
with D0 = {‚ä§ ‚àº
1
0
1
‚àº
‚àº
‚àº
are the sets of the conditionals of rank 0 and of the conditionals of rank 1, respectively).
We can define two sequences on the individuals, s = ha, bi and s‚Ä≤ = hb, ai, each of them
‚Ä≤
‚Ä≤
defining a different rational extension (s and s ), and let =s ‚à© s . We have that
‚äèB
hA, Di  a:B, since in both the extensions a:B holds (in s because of the axiom ‚ä§ ‚àº
‚Ä≤
‚Ä≤
s
s
‚äè
a:A.
6
and in  for the axiom ¬¨‚àÄr.¬¨A ‚àº B) while we have hA, Di 6 a:A, since hA, Di 
However, hA ‚à™ {a:¬¨A}, Di 6 a:B, since hA ‚à™ {a:¬¨A}, Di 6s a:B.
454

Defeasible Inheritance-Based Description Logics

We have no increase in the computational complexity of the decision procedure: assuming that the number of individuals named in the ABox is n, we have to perform a s -test
for each possible sequences s deÔ¨Åned on the n individuals. That is, in the worst case we
k
need to do n! s tests, each of which can be done in time O(2|K| ) for some k. Now, it can
2
be shown that13 n! < 2n and, thus, the decision problem for  remains in ExpTime.
Proposition 5.6. Deciding K  a:C in ALC is a ExpTime-complete problem.
Notwithstanding, we conjecture that in many (probably most) of the real-world cases, a
knowledge base would have a single rational ABox extension, and in such cases (RMDL ) is
still valid. To check whether a knowledge base hA, T , Di has a single rational ABox extension, it is suÔ¨Écient to associate to each individual in O the strongest Œ¥i modulo consistency
w.r.t hA, T , Di, exactly as in the procedure in DeÔ¨Ånition 5.2, but doing the consistency
check of aj :Œ¥i w.r.t. the original A instead that w.r.t. AsD . In the end, check whether
hAsD , T i is consistent; in such a case we have obtained the only rational ABox extension of
hA, T , Di.
The following is a knowledge base with a unique ABox extension.
Example 5.6. Consider the KB in Example 5.4, where (b, c):P rey is replaced with (b, d):P rey.
Then, whatever is the order on the individuals, we obtain the following association between
the default formulae and the individuals: a:Œ¥1 , b:Œ¥0 , c:Œ¥0 , and d:Œ¥0 . Using the information
in these defaults, we obtain an unique default-assumption extension.

A semantic characterization of  and s , making use of preferential DL models, is
presented by Casini et al. (2013).
Now let‚Äôs brieÔ¨Çy consider some heuristics that are useful in case we want to present to
the system speciÔ¨Åc ABox queries. Assume we want to know if a particular individual a
presumably falls under a concept C, and we want to draw the safest possible conclusion.
In the presence of multiple acceptable extensions, the classical solution is to use a skeptical
approach, i.e., to use the inference relation , corresponding to the intersection of all the
inference relations associated to each possible ordering s of the individuals appearing in A.
As we have seen above, in case of multiple rational extensions the computational complexity of the  decision problem does not rise w.r.t the classical ALC decision problem.
Moreover, in case of multiple extensions, the amount of defeasible information associable to
an individual a can be inÔ¨Çuenced only by the individuals related to it by means of a role: it
is immediate to see that if there is no role-connection in the ABox between two individuals
a and b, then the information that is associated to a does not inÔ¨Çuence at all the amount
of defeasible information that we can associate to b, and the other way around. Hence,
we can ease the decisions w.r.t. the ABox introducing the notion of cluster, i.e., a set of
individuals named in the ABox that are linked by means of a sequence of role connections.
To do so, given an ABox A, we indicate with Q the symmetric and transitive
S closure of all
the roles in our vocabulary, i.e., the symmetric and transitive closure of R.
Definition
5.3 (Cluster). Define Q as the reflexive, symmetric and transitive closure of
S
R. Given an individual a ‚àà O, we call the cluster of a the set [a] of the individuals

13. This can be shown by induction on n, or see e.g.http://lifecs.likai.org/2012/06/better-upper-bound-forfactorial.html.

455

Casini & Straccia

connected to a through Q:
[a] = {b ‚àà O | Q(a, b)} .
Hence, in order to know what we can presumably conclude about a, it is suÔ¨Écient to
determine s w.r.t. each sequence s of individuals in [a]. Let A[a] be the ABox obtained restricting A to the statements containing individuals in [a]; the query a:C is clearly decidable
using only A[a] .
Proposition 5.7. hA, T , Di  a:C iff hA[a] , T , Di s a:C for every ordering s of the
individuals in A[a] .
If we have a query about an individual a s.t. a is not named in the ABox (a ‚àà
/ O), we
do not have any constraints deÔ¨Åned in the ABox about a, i.e., we only know a:‚ä§; hence, for
each individual not appearing in the ABox, we can associate with it the strongest default
concept consistent with T , that is Œ¥0 : for any a s.t. a ‚àà
/ O, we can derive that presumably
a:C holds iÔ¨Ä hAa , T i |= a:C, where Aa = A ‚à™ {a:Œ¥0 }.

6. Comparison with Related Work
Between non-monotonic logics, the so-called preferential approach can be distinguished
from the other various proposals (as Reiter‚Äôs defaults, modal approaches, defeasible inheritance. . . ) mainly due its logical properties, since the former approach is committed to the
satisfaction of some desirable structural properties of the consequence relation (see Section
2.2). On the other hand, considering them from the point of view of the inferential capacity
the preferential approach often results weaker than other proposals, since often there are
desirable, intuitive conclusions that we cannot derive (see Remark 1).
In our proposal we have tried to combine the classical rational closure with inheritance
networks in order to overcome the inferential limits without prejudicing the logical properties
of the consequence relation.
In Section 3 we also present an alternative way to reason about defeasible inheritance.
Despite our proposal has been presented mainly to integrate it with propositional language
and rational closure, it results an interesting approach per se, and in Appendix A we
compare it with Horty‚Äôs classical skeptical extension (Horty, 1994, sect. 2-3) and Sandewall‚Äôs
landmark examples (Sandewall, 2010).
As indicated in the introduction, there have been many papers aimed at the implementation of non-monotonic reasoning into the DL formalisms. For most of such proposals the
comparison with our approach has to be done considering the diÔ¨Äerent non-monotonic formalisms, independently from the DL-environment. So we refer to Makinson‚Äôs work (1994)
for a comparison between the various non-monotonic approaches.
In the last years the main proposals for the implementation of nonmonotonic reasoning
in DLs have been connected to two approaches: the preferential one and circumscription.
In the preferential approach, the work by Britz and al. (Britz et al., 2008; Britz, Meyer,
& Varzinczak, 2011) on preferential DL semantics is strongly connected to our approach,
and one of the results has been the semantic characterization of rational closure cited above
(Britz et al., 2013).
Still very close to our approach is the work by Giordano et al. (2012b), that is based too
on a preferential approach. The conclusions that we can derive using the logic ALC+Tmin
456

Defeasible Inheritance-Based Description Logics

are intuitive, but the complexity of the decision problem for the ABox is co-NExpNP (Giordano et al., 2012b, Thm. 13), and the procedure cannot be reduced to classical entailment.
Among the proposals based on circumscription, the work by Bonatti et al. (2009) is
particularly representative. From the point of view of the quality of the inferences, in such
a proposal it results more diÔ¨Écult w.r.t. the preferential approach to draw the expected
conclusions. For example, assume that our knowledge base contains the information that
mammals typically live on land, but that whales are abnormal mammals that do not live
on the land, and the ABox contains the information a:M ammal ‚äì ¬¨W hale. Not knowing
anything else about the individual a, we would like our reasoning system to reason on the
assumption that we are dealing with a typical mammal (since, moreover, it is speciÔ¨Åed that
a is not a whale) and hence being able to derive that a lives on the land. However, using
circumscription, the conclusions we can draw changes w.r.t. which concepts the user decides
to keep fixed or varying (a non-trivial choice), and the results can be that we are not able
to derive a:‚àÉHabitat.Land, that we are able to derive it, or we can even derive that whales
do not exist (Bonatti et al., 2009, sect. 2.1). In our proposal instead, we can formalize the
problem with a knowledge base hA, T , Di with A = {a:M ammal} (we do not need to specify
that it is not a whale), T = {W hale ‚äë M ammal, W hale ‚äë ¬¨‚àÉHabitat.Land} and D =
‚äè ‚àÉHabitat.Land}; without needing any kind of choice from the user, the system
{M ammal ‚àº
can derive automatically a:‚àÉHabitat.Land. Moreover, we have seen that the computational
cost of our procedure involving an ABox is exponential, while in the circumscription case, for
languages analogous to ALC, the complexity of the instance problem is co-NExpNP (Bonatti
et al., 2009, sect. 4.1.1). Some of the issues just discussed have been addressed and solved
by Bonatti et al. (2010, 2011a), but only for circumscriptive systems that are speciÔ¨Åcally
built for low-complexity DLs such as EL.
On the other hand, procedures based on circumscription are able to derive defeasible
information about individuals that are implicit in the ABox, that is, they can, for exam‚äè D that presumably a:‚àÉR.D. Our procedure involving
ple, conclude from a:‚àÉR.C and C ‚àº
ABoxes is not able to make such a kind of derivation, since we can add defeasible information
only to the individuals named in the ABox. We are working on a further reÔ¨Ånement of the
procedure in order to deal also with the implicit individuals; a Ô¨Årst attempt to take under
consideration also such individuals has been proposed in a previous publications (Casini &
Straccia, 2010, pp. 9-10), adding a completion procedure for the ABox in order to explicitly
name in the ABox the implicit individuals, but such a procedure needs to be reÔ¨Åned.
Among the proposals regarding the introduction of probabilistic reasoning in DLs,
Lukasiewicz (2008) presents a combination of nonmonotonic and probabilistic reasoning.
The nonmonotonic part is based on the preferential approach, and he too presents a construction that augments the inferential power of rational closure. Let us consider his proposal by eliminating the probabilistic part, i.e., considering only conditionals associated to
probability 1 (conditionals (œà|œÜ)[1, 1] in his notation), since they convey the same meaning
as our defeasible conditionals. His procedure seems to give back the same results as ours in
most of the cases, but the two proposals diÔ¨Äer in the general approach: he proceeds with a
reÔ¨Ånement of the ranking structure, while we use a reÔ¨Ånement of the content of the knowledge base. In fact, the behaviour of the two can diÔ¨Äer. Consider for example a knowledge
‚äè b, a ‚äè d, b ‚äè c, c ‚äè e, d ‚äè ¬¨e} (in Lukasiewicz‚Äôs notation it would
base h‚àÖ, Di, with D = {a ‚àº
‚àº
‚àº
‚àº
‚àº
correspond to a knowledge base with an empty TBox and a set P containing the conditionals
457

Casini & Straccia

(b|a)[1, 1], . . . ).14 In our construction we can derive a|‚àºc, since there is simply a duct ha, b, ci
from a to c, while in Lukasiewicz‚Äôs approach we cannot, since we have to consider what follows from all the three preferred subset of the knowledge base that are consistent with
‚äè b, a ‚äè d, b ‚äè c, c ‚äè e}, {a ‚äè b, a ‚äè d, b ‚äè c, d ‚äè ¬¨e}, {a ‚äè b, a ‚äè d, c ‚äè e, d ‚äè ¬¨e}),
a (that are {a ‚àº
‚àº
‚àº
‚àº
‚àº
‚àº
‚àº
‚àº
‚àº
‚àº
‚àº
‚àº
and a|‚àºc does not follow from the latter.

7. Conclusions
By combining the classical rational closure with ideas from defeasible inheritance networks,
we have proposed a new rational consequence relation that overcomes some limits of both the
formalisms. By doing so, we have extended the defeasible inference capabilities by allowing
an atypical class still to inherit some properties from its superclass while maintaining the
desired logical properties of rational closure. The table below summarizes the structural
properties satisÔ¨Åed by the systems taken under consideration:15

REF
CT
CM
LE
RW
OR
RM

Horty
‚Ä¢

‚Ä¢
‚Ä¢

IN
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

BIN
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

PL
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

DL
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

As we can see, our proposals for defeasible inheritance-based propositional logic and
Description Logics still satisfy all axioms of classical rational closure. Another feature is
that our method does uniquely require the existence of a decision procedure of classical
entailment and, thus, can be implemented on top of exiting propositional SAT solvers and
DL reasoners. Since we have introduced a procedure that is interesting also from the point
of view of inheritance nets, we have presented the more comprehensive procedure for logical
knowledge bases making use of the nets‚Äô formalism; notwithstanding, we are conÔ¨Ådent that
the procedure can be reformulated avoiding the shift from one formalism to another.
The procedure presented for ALC can be straightly extended to languages more expressive than ALC; on the other hand, at present the procedure needs a language that is
closed under propositional connectives, and hence we need to augment the expressivity of
the language in order to apply it to less expressive DL languages as EL, forcing in this way
an increase in the computational costs w.r.t. the classical decision problem.
Hence, looking for an adaptation of the procedure appropriate for dealing with tractable,
less expressive DLs is one of the main open problems of the present proposal, together with
a more proper semantic characterization of the procedure and the ability of reasoning in a
defeasible way about implicit individuals, as discussed in the previous section.
14. The example corresponds to the structure of Example.A.4 in Appendix A, just eliminating the link at
the center of the figure.
15. IN, BIN, PL, DL stand for our proposals for INs, Boolean INs, propositional logic and DLs, respectively.

458

Defeasible Inheritance-Based Description Logics

Appendix A. Examples
We are going to validate our decision procedures for inheritance nets against some signiÔ¨Åcant
examples proposed by Horty (1994) and Sandewall (2010). We shall use BINs, but, in order
to simplify the graphical representation, we shall also use 6‚áî as a macro, as explained in
Section 3.2. As a side eÔ¨Äect, we obtain an analogue behaviour for the propositional and DL
cases too.
Example A.1 (Horty, 1994, ex. Œì12 ). Consider the net in Figure 13. Horty claims that the
desirable conclusion should be a|‚àºp, since ‚ÄúIn the environment of mixed nets [. . . ] certain
kinds of compound defeasible paths can legitimately be thought to carry immediate information - namely, those paths consisting of a single defeasible link followed by a strict end
segment, of any length‚Äù (Horty, 1994, p. 143). That corresponds to the condition of (RW ),
that, as we have seen in Section 3.1.2, our procedure satisfies.
r
s

p

a

t

Figure 13: Example A.1
Indeed, we translate the net into the KB K = hŒ¶, ‚àÜi, with Œ¶ = {a ‚äÉ s, s ‚äÉ t, r ‚äÉ p}
and ‚àÜ = {s ‚äÉ r, t ‚äÉ ¬¨p}. We have ‚àÜa,p = ‚àÜ, ‚àÜa,p |=Œ¶ ¬¨s, and ‚àÜa,p |=Œ¶ ¬¨a. So the only
implication in ‚àÜa,p with ranking grater than 0 is s ‚äÉ r, and, since s ‚äÉ r Œ¶ a ‚äÉ p, we have
a|‚àºK p.
Example A.2 (Horty, 1994, ex. Œì18 ). Consider the net in Figure 14. In this example Horty
claims that we should not prefer the negative path ha, p, si over the positive path ha, r, si,
since the negative link a 6‚Üí q nullifies the path from p to r. Our procedure satisfies such a
claim.
p
a

q

s

r

Figure 14: Example A.2
Indeed, we translate the net into the KB K = hŒ¶, ‚àÜi, with Œ¶ = ‚àÖ and ‚àÜ = {a ‚äÉ p, a ‚äÉ
r, p ‚äÉ q, q ‚äÉ r, r ‚äÉ s, a ‚äÉ ¬¨q, p ‚äÉ ¬¨s}. We have ‚àÜa,s = ‚àÜ, ‚àÜa,s  ¬¨p, and ‚àÜa,p  ¬¨a.
459

Casini & Straccia

Therefore, we have E1 = {a ‚äÉ p, a ‚äÉ r, a ‚äÉ ¬¨q, p ‚äÉ q, p ‚äÉ ¬¨s}. Now, E1  ¬¨a, and a is the
only node of rank 2, with E2 = {a ‚äÉ p, a ‚äÉ r, a ‚äÉ ¬¨q}. So we conclude neither a|‚àºs nor
a|‚àº¬¨s.
Example A.3 (Sandewall, 2010, ex. B.1, Double Diamond). Consider the net N = {S, U }
defined as (see Figure 15)
S = {s ‚áî¬¨ s, r ‚áî¬¨ r}
U

= {a ‚Üí t, a ‚Üí p, t ‚Üí s, p ‚Üí s, s ‚Üí r, p ‚Üí q, q ‚Üí r}
s
r

t
¬¨

¬¨
s

r

q

a
p

Figure 15: Double diamond.
The net N is translated in the knowledge base K = {Œ¶, ‚àÜ} with Œ¶ = {‚àÖ} and ‚àÜ = {a ‚äÉ
t, a ‚äÉ p, t ‚äÉ s, p ‚äÉ ¬¨s, s ‚äÉ r, p ‚äÉ q, q ‚äÉ ¬¨r}.
Using our method, from this net we derive neither a|‚àºr, nor a|‚àº¬¨r, as it should be.
However, we can derive a|‚àºq, which is a desirable result that is not derivable with Sandewall‚Äôs
approach.
Example A.4 (Sandewall, 2010, ex. B.2, Simonet‚Äôs Scenario). Consider the net N = {S, U }
defined as (Figure 16)
S = {e ‚áî¬¨ e}
U = {a ‚Üí b, a ‚Üí d, b ‚Üí c, c ‚Üí e, d ‚Üí c, d ‚Üí e} .
c
e

b
¬¨

a

e
d

Figure 16: Simonet‚Äôs scenario.
460

Defeasible Inheritance-Based Description Logics

The net N is translated in the knowledge base K = {Œ¶, ‚àÜ} with Œ¶ = {‚àÖ} and ‚àÜ = {a ‚äÉ
b, a ‚äÉ d, b ‚äÉ c, c ‚äÉ e, d ‚äÉ c, d ‚äÉ ¬¨e}.
Using our method, from this net we derive a|‚àº¬¨e, as it should be, while Sandewall cannot
derive it. Moreover, he derives neither a|‚àºc nor b|‚àºe.
Example A.5 (Sandewall, 2010, ex. B.3, On-Path vs. OÔ¨Ä-Path Preemption). Consider the
net N = {S, U } defined as (see Figure 17)
S = {wa 6‚áî ga}
U

= {c ‚Üí re, c ‚Üí ce, re ‚Üí e, ce ‚Üí e, e ‚Üí ga, re ‚Üí wa} .
e
ce

c

ga

wa
re

Figure 17: On-Path vs OÔ¨Ä-Path.
The net N is translated in the knowledge base K = {Œ¶, ‚àÜ} with Œ¶ = {wa ‚äÉ ¬¨ga} and
‚àÜ = {c ‚äÉ re, c ‚äÉ ce, re ‚äÉ e, ce ‚äÉ e, e ‚äÉ ga, re ‚äÉ wa}.
The connection c ‚Üí wa is valid only if we use a form of off-path preemption, while with
on-path preemptions it is not derivable. In our setting, we derive c|‚àºwa: even if we cannot
consider our method a form of preemption (at least explicitly), as said in Section 3.1.5 our
method gives back results that are analogous to those of off-path preemption.
The following examples use also conjunctions, so we are going to use BINs.
Example A.6 (Sandewall, 2010, ex. B.4, Juvenile OÔ¨Äender). The original ‚ÄúJuvenile offender‚Äù example is represented by the following net (see Figure 18) N = {S, U }, with
S = {b ‚áí g, b ‚áí m, p ‚áî¬¨ p, m, g ‚áî‚àß m ‚äó g}
U

= {g ‚Üí p, m ‚Üí p} ,

where p is read as ‚Äòto be punished‚Äô, g as ‚Äòguilty‚Äô, m as ‚Äòis minor‚Äô, b is ‚ÄòBilly‚Äô. We want
to express that m has the priority on g, and so that b ‚ÜíN w. Since in our nets it is
possible to express conjunctions, we can solve the problem adding the link m ‚äó g ‚Üí p and
m, g ‚áî‚àß m ‚äó g.
The net is translated in the knowledge base K = {Œ¶, ‚àÜ} with Œ¶ = {b ‚äÉ g, b ‚äÉ m} and
‚àÜ = {g ‚äÉ p, m ‚äÉ ¬¨p, m ‚àß g ‚äÉ ¬¨p}. From this knowledge base we derive b|‚àº¬¨p, as expected.
Example A.7 (Sandewall, 2010, ex. B.5, Campus Residence Scenario). As in example A.6,
in the ‚ÄúCampus residence‚Äù example there is the necessity to include priorities. We can solve
461

Casini & Straccia

m
m‚äóg

b

¬¨

p

g

p

Figure 18: Juvenile oÔ¨Äender.
the problem by inserting conjunctions. Indeed, the net N = {S, U } is composed by (see
Figure 19)
S = {t ‚áí ma, t ‚áí e, t ‚áí m, w 6‚áî n, ma, e ‚áî‚àß ma ‚äó e}
U = {ma ‚äó e ‚Üí w, m ‚Üí n} ,
where ma is read as ‚Äòis married‚Äô, e as ‚Äòemployed‚Äô, w as ‚Äòlives in west apartments‚Äô, m as
‚Äòmale‚Äô, n as ‚Äòlives in northern apartments‚Äô, t is ‚ÄòTom‚Äô. We want to express that ma ‚äó e has
the priority on m, and so that t ‚Üí w results valid. to do so, we add the links m‚äóma‚äóe ‚Üí w,
and m, ma ‚äó e ‚áî‚àß m ‚äó ma ‚äó e.
ma
ma ‚äó e
w

t

e

ma ‚äó e ‚äó m

n
m

Figure 19: Campus residence scenario.
The net is translated in the knowledge base K = {Œ¶, ‚àÜ} with Œ¶ = {t ‚äÉ ma, t ‚äÉ e, t ‚äÉ
m, w ‚äÉ ¬¨n} and ‚àÜ = {ma ‚àß e ‚äÉ w, m ‚äÉ n, m ‚àß ma ‚àß e ‚äÉ w}. From this knowledge base we
derive t|‚àºw, as expected.
We treat the last example as a propositional problem. Just to have a simpler net from
the graphical point of view we do not put the negation nodes that are useless for the
resolution, and we use a three-place conjunction link, just as a macro for the construction
of the conjunction of three nodes.
462

Defeasible Inheritance-Based Description Logics

Example A.8 (Sandewall, 2010, ex. B.6, Good Math Student Scenario). The knowledge
base K = {T , D} is composed by (see Figure 20)
T

= {t ‚ä¢ gs, t ‚ä¢ f m, t ‚ä¢ mb, aa ‚ä¢ ¬¨ag}

D = {mb|‚àºag, f m ‚àß ag|‚àºmm, mm ‚àß mb ‚àß gs|‚àºaa, f m|‚àºpm} ,

gs

mb
mm ‚äó mb ‚äó gs

t

ag
aa

f m ‚äó ag
mm
fm
pm

Figure 20: Good math student.
Sandewall identifies the following candidates for valid conclusions:
t|‚àºag t|‚àºaa t|‚àºf m ‚àß ag
t|‚àºmm t|‚àºmm ‚àß mb t|‚àºmm ‚àß mb ‚àß gs

t|‚àºpm .

We cannot conclude any of the conditionals above. The point is that the net is highly
interconnected, especially by strict links, so that all the nodes have ranking 0, except for t
and mm ‚äó mb ‚äó gs that have ranking 1. Therefore, any of the conclusions above, with t as
premise, cannot be obtained.

Appendix B. Proofs
Proposition 3.1. Consider a net N = hS, ‚àÖi and translate it into a set of propositional
implications Œ¶. The following properties hold:
1. If N is a consistent net, there is a valid strict positive (resp., negative) path hp, œÉ, qi
from p to q, that is N
p ‚áí q (resp., N
p 6‚áî q), iff Œ¶  p ‚äÉ q (resp., Œ¶  p ‚äÉ ¬¨q).
2. N is inconsistent iff Œ¶  ¬¨p for some p ‚àà AŒ¶ .
463

Casini & Straccia

3. Deciding strict consequence can be done in polynomial time.
Proof. First, it is easy to prove by induction on the length of the paths that, if there is a
positive (resp., negative) path in S from p to q, then Œ¶  p ‚äÉ q (resp., Œ¶  p ‚äÉ ¬¨q). Hence
we have:
1a) If N is a consistent net and there is a valid strict positive (negative) path œÄ(p, œÉ, q)
from p to q, then Œ¶  p ‚äÉ q (Œ¶  p ‚äÉ ¬¨q).
Moreover, if N is inconsistent, then we can conclude, for some p, q in it, p ‚áí q and
p 6‚áî q, and so we have Œ¶  p ‚äÉ q and Œ¶  p ‚äÉ ¬¨q, that is, Œ¶  ¬¨p. So we have one half of
the second statement.
2a) If Œ¶ 6 ¬¨p for every p ‚àà A‚Ñì , then N is consistent.
Now we move to show the other halves of the statements.
1b) If N is a consistent net and Œ¶  p ‚äÉ q (resp., Œ¶  p ‚äÉ ¬¨q), then there is a valid strict
positive (resp., negative) path œÄ(p, œÉ, q) from p to q.
In order to model the classical consequence relation , we use the propositional resolution method. We use the symbol ‚ä¢R to indicate the inferences in the resolution
method.
Every element of Œ¶ has the forms p ‚äÉ q or p ‚äÉ ¬¨q. Such implications correspond, in
the clause form, respectively to the clauses (i.e., sets of literals) {¬¨p, q} and {¬¨p, ¬¨q}.
Call Œ¶ the set of the clauses corresponding to Œ¶. For example, if we assume that
Œ¶ ‚ä¢R {¬¨p, q} (that is, Œ¶  p ‚äÉ q), we have that the set of clauses Œ¶, {p}, {¬¨q} resolves
into the empty set (that is, Œ¶, ¬¨(p ‚äÉ q)  ‚ä•).
1. Positive case (N
p ‚áí q): Assume Œ¶  p ‚äÉ q for some p, q ‚àà PN . In order to
apply the refutational approach, p ‚äÉ q has to be negated, and, since ¬¨(p ‚äÉ q)
is equivalent to p ‚àß ¬¨q, we introduce the clauses {p}, {¬¨q}. So, in the resolution
approach Œ¶  p ‚äÉ q is translated into Œ¶, {p}, {¬¨q} ‚ä¢R ‚àÖ. We have also assumed
that Œ¶ is consistent, and hence we have that Œ¶ 6‚ä¢R ‚àÖ. Since the set Œ¶ is composed
only of pairs of literals (of form {¬¨p, q} or {¬¨p, ¬¨q}), every reduction step between
them gives back again a pair of literals (for example, from {¬¨p, q} and {¬¨q, ¬¨r},
we obtain {¬¨p, ¬¨r}). Therefore, in order to obtain the empty set we need to use
both {p} and {¬¨q} in the refutation procedure. So, the clause {¬¨q} must be
eliminated using a clause containing q. Such a clause must necessarily have the
form {¬¨ri , q} for some ri , and we obtain a new clause {¬¨ri }. Again, {¬¨ri } can
be eliminated only by a clause of form {¬¨rj , ri }, obtaining a clause {¬¨rj }. Since
the set Œ¶ is Ô¨Ånite, such a procedure has to terminate, and it can only be done if
we obtain a clause {¬¨p}, that can be resolved by {p}. That is, there has to be in
Œ¶ a clause {¬¨p, rl }, for some rl , s.t. {¬¨rl } appears in the reduction procedure.
Now, the clauses of Œ¶ used in the reduction process correspond to a chain of
links in the net S: p ‚áí rl , . . . , ri ‚áí q, that deÔ¨Åne a valid path (p, œÉ, q) in S.
2. Negative case (N
p 6‚áî q): assume Œ¶  p ‚äÉ ¬¨q for some p, q ‚àà PS . p ‚äÉ ¬¨q has
to be negated and it is translated into the clauses {p}, {q}. {q} can be combined
464

Defeasible Inheritance-Based Description Logics

with a clause of form {¬¨q, ¬¨ri } (that represents q ‚äÉ ¬¨ri , that, in turn, represents
a link q 6‚áî ri ) (case 1), or with a clause of form {¬¨q, ri } (i.e., q ‚äÉ ri , that, in
turn, is q ‚áí ri ) (case 2).
Case 1. We obtain the clause {¬¨ri }, and the procedure is the same of the positive
case. The clauses used in the reduction process correspond to a strict negative path of form: p ‚áí rl , . . . , rj ‚áí ri , ri 6‚áî q.
Case 2. We obtain the clause {ri }, and we would have combine it with a clause of
form {¬¨ri , ¬¨rj }, or of form {¬¨ri , rj }. In the former case we move to case
1, ending with a strict negative path p ‚áí rh , . . . , rl ‚áí rj , rj 6‚áî ri , ri ‚áê q.
In the latter case we have a new clause {¬¨rj }, and we are again in case
2; however, such a procedure has to terminate, and, in order to terminate,
such a reduction procedure has at some point to move into the case 1. The
clauses used in the reduction procedure correspond to a path of form p ‚áí
ri , . . . , rj ‚áí rk , rk 6‚áî rl , rl ‚áê rm , . . . , rn ‚áê q, where the link 6‚áî corresponds
to the shift to the case 1.
2b) Automatically, we have also that if N is consistent, then Œ¶ 6 ¬¨p for every p ‚àà A‚Ñì .
Otherwise, we would have Œ¶  p ‚äÉ q and Œ¶  p ‚äÉ ¬¨q for some nodes p and q, that
would imply, by the procedure above, the inconsistency of N .
3) About the third point, consider that strict links can be encoded as 2-CNF formulae,
also called Krom formulae, and the propositional 2-SAT problem is in P .

Proposition 3.2. Consider a net N . For every connection p|‚àºN q (resp., p|‚àºN ¬¨q) validated
by our procedure, there is a corresponding positive (resp., negative) potential path from p to
q in the net N .
b p,q . Our procedure states that p|‚àº q iÔ¨Ä ‚àÜ
b p,q ‚à™ Œ¶  p ‚äÉ q (and
Proof. DeÔ¨Åne the set ‚àÜ
N
b p,q ‚à™ Œ¶  p ‚äÉ ¬¨q). Following a procedure analogous to the one of the proof of
p|‚àºN ¬¨q iÔ¨Ä ‚àÜ
proposition 3.1, we can show that the derivation of such implications is connected to the
presence of positive (negative) potential paths in the net.
Proposition 3.3.

‚Ä≤

satisfies (REF ), (CT ) and (CM ).

To prove this proposition we need Ô¨Årst to prove the following lemma.
‚Ä≤ p ‚ãÜ q (‚ãÜ ‚àà {‚Üí, 6‚Üí}). Call Œ¶ the set
Lemma B.1. Consider a net N = hS, U i s.t. N
of material implications corresponding to the links in S, and Œ¶ the consequence relation
obtained adding to  the formulae in Œ¶ as extra-axioms. Consider the net N ‚Ä≤ obtained
ÀÜN
adding the link p ‚ãÜ q in N . Then, for every pair of nodes r, s in N , we have that ‚àÜ
r,s and
‚Ä≤
N
ÀÜ
‚àÜ
r,s are equivalent w.r.t. Œ¶ .

Proof. The two nets contain the same nodes. Given two nodes r and s, we have two possible
N ‚Ä≤ , we have C N ‚Ä≤ = C N ‚Ä≤ , and consequently
N ‚Ä≤ or p ‚ãÜ q ‚àà C N ‚Ä≤ . If p ‚ãÜ q ‚àà
/ Cr,s
cases: p ‚ãÜ q ‚àà
/ Cr,s
r,s
r,s
r,s
ÀÜ N ‚Ä≤ . If p ‚ãÜ q ‚àà C N ‚Ä≤ , we have that C N ‚Ä≤ ‚äÜ C N ‚Ä≤ , and consequently C N ‚äÜ C N , and the
ÀÜN = ‚àÜ
‚àÜ
r,s
p,q
r,s
r,s
r,s
r,s
r,s
465

Casini & Straccia

‚Ä≤

‚Ä≤

N and C N on one hand and C N and C N
correspondent sets of courses in the two nets (Cp,q
p,q
r,s
r,s
on the other) contain exactly the same nodes and the same links, apart, possibly, from p ‚ãÜ q.
N‚Ä≤
N
N‚Ä≤
That corresponds to saying that ‚àÜN
p,q and ‚àÜp,q on one hand, and ‚àÜr,s and ‚àÜr,s on the other
contain exactly the same implications, apart, possibly, from p ‚äÉ lq (where lq ‚àà {q, ¬¨q}),
and exactly the same set of antecedents.
‚Ä≤ p ‚ãÜ q, we have ‚àÜ
N
N
ÀÜN
Since N
p,q Œ¶ p ‚äÉ lq , and consequently ‚àÜp,q Œ¶ p ‚äÉ lq . So, ‚àÜp,q
‚Ä≤
‚Ä≤
N
N
N
and ‚àÜN
p,q are Œ¶ -equivalent, and then also ‚àÜr,s and ‚àÜr,s are Œ¶ -equivalent. So, since ‚àÜr,s
‚Ä≤
N
and ‚àÜr,s are Œ¶ -equivalent and contain the same set of antecedents, they generate the same
ÀÜ N ‚Ä≤ are equivalent w.r.t. Œ¶ .
ÀÜ N and ‚àÜ
ranking, that is, ‚àÜ
r,s
r,s

Now we can prove Proposition 3.3.
Proof. The satisfaction of (REF ) is trivial, since every direct link is trivially valid.
(CT ): assume N ‚Ä≤ p ‚ãÜ q and N , p ‚ãÜ q ‚Ä≤ r ‚àó s. We call N ‚Ä≤ the net obtained adding p ‚ãÜ q
‚Ä≤
ÀÜN
in N . N ‚Ä≤ ‚Ä≤ r ‚àó s means that ‚àÜ
r,s Œ¶ r ‚äÉ ls (ls ‚àà {s, ¬¨s}). By the lemma B.1 we have that
ÀÜ N Œ¶ r ‚äÉ ls , that is, N ‚Ä≤ r ‚àó s.
ÀÜ N ‚Ä≤ are equivalent w.r.t. Œ¶ , so we have also ‚àÜ
ÀÜ N and ‚àÜ
‚àÜ
r,s
r,s
r,s
‚Ä≤
‚Ä≤
(CM ): assume N
p ‚ãÜ q and N
r ‚àó s. We call N ‚Ä≤ the net obtained adding p ‚ãÜ q in
ÀÜ N Œ¶ r ‚äÉ ls . By the lemma B.1 we have that ‚àÜ
ÀÜ N and ‚àÜ
ÀÜ N‚Ä≤
N . N ‚Ä≤ r ‚àó s means that ‚àÜ
r,s
r,s
r,s
‚Ä≤
‚Ä≤ r ‚àó s.
ÀÜN
are equivalent w.r.t. Œ¶ , so we have also ‚àÜ

r
‚äÉ
l
,
that
is,
N
,
p
‚ãÜ
q
s
r,s Œ¶
Proposition 3.5.

‚Ä≤

satisfies (LE), (RW ), and (Sup).

Proof. The proofs are immediate, considering our procedure and the fact that the implications corresponding to strict links are always present in each decision procedure.
Proposition 3.6 A net N is consistent iff we do not have a node p with r(p) = ‚àû, that is,
we do not conclude both N ‚Ä≤ p ‚Üí q and N ‚Ä≤ p 6‚Üí q for any pair p, q.
It is proved combining the following two lemmas.
Lemma B.2. Given a net N , and two nodes p and q in it, we can conclude both p|‚àºN q
and p|‚àºN ¬¨q iff r(p) = ‚àû.
Proof. From left to right. It is immediate from the deÔ¨Ånition of the ranking procedure: if
r(p) 6= ‚àû, then the set of implications with at least the same ranking as p do not imply ¬¨p,
and so they cannot imply both p ‚äÉ q and p ‚äÉ ¬¨q for any q.
From right to left. If r(p) = ‚àû, we have a set E‚àû 16 of implications (with p between
their antecedents) such that E‚àû Œ¶ ¬¨p. That implies E‚àû Œ¶ p ‚äÉ q and E‚àû Œ¶ p ‚äÉ ¬¨q for
whichever q, that is, p|‚àºN q and p 6 |‚àºN q.
Lemma B.3. Every node with ranking ‚àû in a set of courses C has the same ranking value
in every set of courses extending C.
Proof. It is immediate from the monotony of the consequence relations Œ¶N .
16. E‚àû is the set of ‚àû-ranked defaults.

466

Defeasible Inheritance-Based Description Logics

From these lemmas we conclude that if a node p has inÔ¨Ånite ranking in a net, then the net is
inconsistent (p|‚àºN q and p|‚àºN ¬¨q for some p and q), and, conversely, if a net is inconsistent,
then there is a node p with inÔ¨Ånite ranking.
Proposition 3.9

BIN

satisfies (REF ), (CM ), and (CT ).

Proof. The proof retraces the one for proposition 3.3.
Proposition 3.10

BIN

satisfies (LE), (RW ), and (Sup).

Proof. The proof retraces the one for proposition 3.5.
Proposition 3.11

BIN

satisfies (OR) and (AN D).

Proof. (OR): we have N BIN p ‚ãÜ t and N BIN q ‚ãÜ t, and we have p, q ‚áî‚à® s ‚àà S. Assume
‚ãÜ =‚Üí. The case with ‚ãÜ =6‚Üí is analogous.
ÀÜ p,t Œ¶ p ‚äÉ t and ‚àÜ
ÀÜ q,t Œ¶ q ‚äÉ t.
We have N BIN p ‚Üí t and N BIN q ‚Üí t, that is, ‚àÜ
Since N BIN p ‚Üí t and N BIN q ‚Üí t, by proposition 3.2 we have at least a duct between
p and t and one between q and t. So, since p, q ‚áî‚à® s, there is a duct from s to t. Moreover,
since there is at least a duct between s and t and p ‚áí s and q ‚áí s, every duct connecting
s to t allows for a duct connecting p to t and q to t. Hence, ‚àÜs,t ‚äÜ ‚àÜp,t and ‚àÜs,t ‚äÜ ‚àÜq,t
holds.
On the other hand, we have that, since p, q ‚áî‚à® s, s is connected to t by all the connections moving from p and from q. So, we have that ‚àÜp,t ‚äÜ ‚àÜs,t and ‚àÜq,t ‚äÜ ‚àÜs,t . Hence,
‚àÜp,t = ‚àÜq,t = ‚àÜs,t holds and the ranking functions rs,t , rp,t , and rq,t are the same as they
work with the same sets of material implications.
At the propositional level, we have that Œ¶ s ‚â° (p ‚à® q) and either rs,t (p) ‚â§ rs,t (q) or
rs,t (q) ‚â§ rs,t (p). Assume the former (the same reasoning applies in the other case). If
ÀÜ q,t ‚äÜ ‚àÜ
ÀÜ p,t . Moreover, the least set in the exceptionality order
rs,t (p) ‚â§ rs,t (q) we have that ‚àÜ
negating p does negate also q, and so is the least set in the exceptionality order negating
ÀÜ p,t = ‚àÜ
ÀÜ s,t . So, ‚àÜ
ÀÜ s,t Œ¶ p ‚äÉ t, and, since ‚àÜ
ÀÜ q,t ‚äÜ ‚àÜ
ÀÜ p,t ,
t, that is, rs,t (t) = rs,t (p), and ‚àÜ
ÀÜ
ÀÜ
we have also ‚àÜs,t Œ¶ q ‚äÉ t; hence by classical reasoning we obtain ‚àÜs,t Œ¶ (p ‚à® q) ‚äÉ t,
ÀÜ s,t Œ¶ s ‚äÉ t. Eventually, N BIN s ‚Üí t.
i.e., ‚àÜ
(AN D): we have N BIN p ‚Üí q and N BIN p ‚Üí s, and we have s, q ‚áî‚àß t ‚àà S. Every
duct connecting p to q and p to s are part of a duct connecting p to t by the addiction
of s, q ‚áî‚àß t, while every duct connecting p to t is part of a duct connecting p to q (resp.,
p to s) by the addiction of t ‚áí q (resp., t ‚áí s). So, ‚àÜp,q = ‚àÜp,s = ‚àÜp,t , and we obtain
N BIN p ‚Üí t.
Proposition 3.12 A BIN N is consistent iff we do not have any node p with r(p) = ‚àû,
that is, we cannot conclude both p ‚Üí q and p 6‚Üí q for any pair p, q.
Proof. The proof is similar to the one for proposition 3.6.
Proposition 4.1. |‚àºK is a rational consequence relation containing K.
Proof. |‚àºK has been obtained as the rational closure of K‚Ä≤ , so it is a rational consequence
relation. Moreover, R(K‚Ä≤ ) contains K‚Ä≤ , and, since K ‚äÜ K‚Ä≤ , it contains K too.
467

Casini & Straccia

Proposition 4.2. Given a conditional base K, ‚ä§|‚àºK ‚ä• iff ‚ä§|‚àº‚ä• ‚àà R(K).
Proof. It is suÔ¨Écient to prove that, given a conditional base K = hT , U i, and obtained its
extension K‚Ä≤ = hT , U ‚Ä≤ i (Steps 1-3), K is preferentially consistent iÔ¨Ä the conditional base K‚Ä≤
is preferentially consistent too.
From right to left the proof is immediate, since K ‚äÜ K‚Ä≤ . From left to right, if K is
6 ‚ä•. Given that every conditional added in K‚Ä≤ corresponds
consistent that means that T ‚à™D 
to an implication that is classically derivable from a subset of T ‚à™ D, we have that T ‚à™
D ‚Ä≤ ‚äÜ C(T ‚à™ D) (where C is the classical closure operation associated to ). So we have
C(T ‚à™ D ‚Ä≤ ) = C(T ‚à™ D). Then, ‚ä• ‚àà
/ C(ŒìK‚Ä≤ ), and K‚Ä≤ is a consistent knowledge base too.
Proposition 5.1 |‚àºK is a rational consequence relation containing K.
Proof. It is suÔ¨Écient to show (1) that every inclusion axiom in T and in D is valid in |‚àºK ,
and (2) that |‚àºK satisÔ¨Åes the properties characterizing a rational consequence relation.
(1) By construction, if C ‚äë D ‚àà T , then ‚ä§ ‚äë C ‚äÉ D ‚àà Te (that is, modulo logical
equivalence, T ‚äÜ Te ). Assume C|‚àºD ‚àà D. Then we have either r(C) = r(C|‚àºD) = ‚àû,
or r(C) = r(C|‚àºD)= i, for some i < ‚àû. In the Ô¨Årst case we have ‚ä§ ‚äë ¬¨C ‚àà Te ,
e ‚äë D, which implies C|‚àº D. In the second case, we have that
and so  {C} ‚à™ Œ¶
K
 Œ¥i ‚äë C ‚äÉ D, with Œ¥i being the default-assumption associated to the premise C.
e ‚à™ {Œ¥i } ‚äë D, that is, C|‚àº D.
Hence we have  {C} ‚à™ Œ¶
K

(2) The consequence relation |‚àºK satisÔ¨Åes the properties of a rational consequence relation.
(REF ) is obviously satisÔ¨Åed, as (LLE) is. For (RW ), assume we have C|‚àºK D. That
e ‚à™ {Œ¥i } ‚äë D, that, given
means that for the Ô¨Årst C-consistent Œ¥i in ‚àÜ,  {C} ‚à™ Œ¶
e
Œ¶e D ‚äë E, implies  {C} ‚à™ Œ¶ ‚à™ {Œ¥i } ‚äë E, i.e., C|‚àºK E.

e ‚à™ Œ¥i ‚äë E, where Œ¥i is the Ô¨Årst C ‚äì
(CT ) C ‚äì D|‚àºK E corresponds to  {C ‚äì D} ‚à™ Œ¶
D-consistent formula in ‚àÜ. Analogously, C|‚àºK D means that for the Ô¨Årst Ce ‚à™ {Œ¥j } ‚äë D. Since  C ‚äì D ‚äë C, we have that
consistent Œ¥j in ‚àÜ,  {C} ‚à™ Œ¶
j ‚â§ i, that is,  Œ¥j ‚äë Œ¥i . Hence, we have that  {C ‚äì D} ‚à™ T ‚à™ {Œ¥j } ‚äë E and
e ‚à™ {Œ¥j } ‚äë D, and, since  satisÔ¨Åes (CT ),  {C} ‚à™ Œ¶
e ‚à™ {Œ¥j } ‚äë E, that
 {C} ‚à™ Œ¶
is, C|‚àºK E.
e ‚à™ {Œ¥i } ‚äë E.
(CM ) C|‚àºK E means that for the Ô¨Årst C-consistent Œ¥i in ‚àÜ,  {C} ‚à™ Œ¶
e ‚à™ {Œ¥i } ‚äë D for the same Œ¥i . Hence, Œ¥i
Analogously, C|‚àºK D means that  {C} ‚à™ Œ¶
e
is consistent with C‚äìD, and, by the monotony of , we have  {C‚äìD}‚à™Œ¶‚à™{Œ¥
i} ‚äë
E, that is, C ‚äì D|‚àºK E.
e ‚à™ {Œ¥i } ‚äë E.
(OR) C|‚àºK E means that for the Ô¨Årst C-consistent Œ¥i in ‚àÜ,  {C} ‚à™ Œ¶
e
Analogously, D|‚àºK E means that  {D} ‚à™ Œ¶ ‚à™ {Œ¥j } ‚äë E for the Ô¨Årst D-consistent
Œ¥j in ‚àÜ. We have three options: j = i, j < i or i < j. In the Ô¨Årst case,
the default-assumption associated with C ‚äî D is Œ¥i , and, since  satisÔ¨Åes OR,
 {C ‚äî D} ‚à™ T ‚à™ {Œ¥i } ‚äë E, that is, C ‚äî D|‚àºK E. If j < i, we have that Œ¥j  Œ¥i , and
e
that Œ¥j is the Ô¨Årst C‚äîD-consistent default in ‚àÜ. Hence we have  {D}‚à™Œ¶‚à™{Œ¥
j} ‚äë
e
E, and, by monotonicity,  {C} ‚à™ Œ¶ ‚à™ {Œ¥j } ‚äë E. Since  satisÔ¨Åes OR, we have
e ‚à™ {Œ¥j } ‚äë E, that is, C ‚äî D|‚àº E.
 {C ‚äî D} ‚à™ Œ¶
K
468

Defeasible Inheritance-Based Description Logics

e
(RM ) C 6 |‚àºK ¬¨E corresponds to 6 {C}‚à™ Œ¶‚à™{Œ¥
i } ‚äë ¬¨E, where Œ¥i is the Ô¨Årst C-consistent
e ‚à™ {Œ¥i }, and so Œ¥i
formula in ‚àÜ. This means that E is consistent with {C} ‚à™ Œ¶
e
is the Ô¨Årst C ‚äì E-consistent formula in ‚àÜ. Since  {C} ‚à™ Œ¶ ‚à™ {Œ¥i } ‚äë D, by the
e ‚à™ {Œ¥i } ‚äë D, that is, C ‚äì E|‚àº D.
monotonicity of  we have  {C ‚äì E} ‚à™ Œ¶
K
Proposition 5.3 Given a linear order of the individuals in K, our procedure determines an
ABox extension of K. Vice-versa, every ABox extension of K corresponds to the knowledge
base generated by some linear order of the individuals in O.
Proof. The Ô¨Årst statement is quite immediate. For the second statement, assume that there
is a rational extension hA‚Ä≤ , T i of hA, T , Di that cannot be generated by any sequence s of
the elements of O. A‚Ä≤ associates to every individual x a default concept from ‚àÜ, that we
indicate as Œ¥x .
Now, consider a generic rational extension hAD , T i of hA, T , Di that can be generated
using a sequence of elements of O. The following procedure allows to deÔ¨Åne a sequence s
of the elements of O s.t. hAD , T i can be generated using s, i.e., hAD , T i = hAsD , T i.
Take each element of O and associate to it the strongest default concept in ‚àÜ consistent
with the knowledge base hA, T i (call it Œ≥ x ). Look for an individual x s.t. Œ¥x = Œ≥ x , and
consider x the Ô¨Årst element of the sequence s. Update A with x:Œ¥x , and repeat the procedure, until every individual has been associated to a default formula. With this procedure
we can generate a sequence over the dominion of the individuals that generates hAD , T i
from hA, T , Di.
Since there is no sequence s that can generate hA‚Ä≤ , T i, the above procedure has to fail,
that is, at some point it will not be possible to associate to any x a default Œ≥ x s.t. Œ¥x = Œ≥ x .
That means that, for all the remaining x, Œ¥x 6= Œ≥ x ; for each such x, either Œ¥x  Œ≥ x or
Œ≥ x  Œ¥x . The Ô¨Årst case is not possible, since hA‚Ä≤ , T i would be inconsistent (Œ≥ x has to be a
maximally consistent default). Hence Œ≥ x  Œ¥x and Œ¥x 6= Œ≥ x for all the remaining x. In such
a case, hA‚Ä≤ , T i would not be a rational extension of hA, T , Di, since we could have another
consistent model with stronger defaults associated to some individuals.
Proposition 5.4 Given K and a linear order s of the individuals in K, the consequence
relation s satisfies the properties (REFDL ) ‚àí (RMDL ).
Proof. For REFDL , LLEDL and RWDL the proof is quite immediate. For CTDL and
CMDL , assume hA, T , Di s b:D, that is hAsD , T i  b:D. Hence, b:D is consistent with
hAsD , T i; this implies that for the Ô¨Årst individual in the sequence s, let it be a, and for
every Œ¥i ‚àà ‚àÜ, a:Œ¥i is consistent with hA, T i iÔ¨Ä it is consistent with hA ‚à™ {b:D}, T i, and the
procedure associates to a the same default formula either we start with A or with A‚à™{b:D}.
The same happens for all the following individuals in the sequence s. So we have that
hAsD ‚à™ {b:D}, T i = h(A ‚à™ {b:D})sD , T i and hAsD ‚à™ {b:D}, T i  a:C iÔ¨Ä h(A ‚à™ {b:D})sD , T i 
a:C. Since  satisÔ¨Åes CT and CM , we have that hAsD , T i  a:C iÔ¨Ä h(A‚à™{b:D})sD , T i  a:C,
that is, hA, T , Di s a:C iÔ¨Ä hA ‚à™ {b:D}, T , Di s a:C.
For ORDL , assume that hA ‚à™ {b:D}, T , Di s a:C, hA ‚à™ {b:E}, T , Di s a:C, and that
b is in the nth position in the sequence s. So, for the Ô¨Årst n ‚àí 1 elements of s the association
with the default-formulae is the same in both the models. For b, assume that the procedure
469

Casini & Straccia

assigns b:Œ¥i in case b:D, and b:Œ¥j in case b:E. We can have either Œ¥i = Œ¥j ,  Œ¥i ‚äë Œ¥j , or
 Œ¥j ‚äë Œ¥i . In the Ô¨Årst case the procedure for the assignment of the defaults continues in the
same way in both the knowledge bases, and it is the same also if we have b:D ‚äî E, that
is, hA ‚à™ {b:D}, T , Di, hA ‚à™ {b:E}, T , Di, and hA ‚à™ {b:D ‚äî E}, T , Di are completed exactly
with the same defaults, obtaining, respectively, the ABoxes (A ‚à™ {b:D})sD = A‚Ä≤ ‚à™ {b:D},
(A ‚à™ {b:E})sD , = A‚Ä≤ ‚à™ {b:E}, and (A ‚à™ {b:D ‚äî E})sD = A‚Ä≤ ‚à™ {b:D ‚äî E}, for some ABox
A‚Ä≤ . So we have that A‚Ä≤ ‚à™ {b:D}  a:C and A‚Ä≤ ‚à™ {b:E}  a:C, and, since  satisÔ¨Åes OR,
we obtain A‚Ä≤ ‚à™ {b:D ‚äî E}  a:C, that is, h(A ‚à™ {b:D ‚äî E})sD , T i  a:C. If Œ¥i  Œ¥j and
b:D ‚äî E, the procedure associates to b the strongest of the two defaults, that is, Œ¥i . Since
Œ¥i is not consistent with b:E, in every following consistency check the procedure will be
forced to consider that b:D holds, and the assignment of the defaults to the individuals will
proceed as in the case where b:D holds, and hA ‚à™ {b:D ‚äî E}, T , Di will entail the same
formulae as hA ‚à™ {b:D}, T , Di. Analogously, if Œ¥j  Œ¥i , the default-assumption extension of
hA ‚à™ {b:D ‚äî E}, T , Di will correspond to the one of hA ‚à™ {b:E}, T , Di.
Finally, for RMDL , b:D is consistent with hAsD , T i, so the presence of b:D in the
knowledge base does not inÔ¨Çuence the association of the defaults to the individuals, and
AsD ‚äÜ (A ‚à™ {b:D})sD . Eventually, hAsD , T i  a:C implies h(A ‚à™ {b:D})sD , T i  a:C, i.e.
hA ‚à™ {b:D}, T , Di s a:C.
Proposition 5.7 hA, T , Di  a:C iff hA[a] , T , Di s a:C for every ordering s of the individuals in A[a].
Proof. The proof is quite immediate. Assume hA[a] , T , Di 6s a:C for some s. Let s‚Ä≤ be a
sequence of the individuals named in A obtained using s as initial segment. Hence we have
‚Ä≤
that hA, T , Di 6s a:C, the implies hA, T , Di 6 a:C.
Now assume hA, T , Di 6 a:C. Hence, for some sequence s hA, T , Di 
6 s a:C. Let s‚Ä≤ be a
‚Ä≤
restriction of s to the individuals named in A[a] ; then we have that hA, T , Di 
6 s a:C.

Appendix C. Table of the Main Symbols
Since the paper considers diÔ¨Äerent Ô¨Åelds, the notation has turned out to be quite complex.
We add here a table to summarize the main symbols used in the paper.

N
Cp,q

IN/BIN
nodes
strict conditional
defeasible conditional
consequence relation
conjunction, disjunction
links in the courses/ducts
between p and q

PL
atoms
propositions
strict conditional
defeasible conditional
links in the ducts
between p and q

DL
concept names
concepts
individuals
strict conditional
defeasible conditional
links in the ducts
between p and q

‚àÜN
p,q

materialisations of the
N
links in Cp,q

materialisations of the
N
links in Cp,q

materialisations of the
N
links in Cp,q

ÀÜN
‚àÜ
p,q

conditionals in ‚àÜN
p,q
as exceptional as p

conditionals in ‚àÜN
p,q
as exceptional as p

conditionals in ‚àÜN
p,q
as exceptional as p

p, q, . . .
C, D, . . .
a, b, . . .
‚ä¢
|‚àº
‚äó, ‚äï

470

Defeasible Inheritance-Based Description Logics

References
AlchourroÃÅn, C., GaÃàrdenfors, P., & Makinson, D. (1985). On the logic of theory change:
Partial meet contraction and revision functions. Journal of Symbolic Logic, 50, pp.
510‚Äì530.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2003). The Description Logic Handbook: Theory, Implementation, and Applications.
Cambridge University Press.
Baader, F., & Hollunder, B. (1993). How to prefer more speciÔ¨Åc defaults in terminological
default logic. In Proceedings of IJCAI-93, pp. 669‚Äì674. Morgan Kaufmann Publishers.
Bochman, A. (2001). A logical theory of nonmonotonic inference and belief change. SpringerVerlag.
Bonatti, P. A., Lutz, C., & Wolter, F. (2009). The complexity of circumscription in description logic. Journal of Artificial Intelligence Research, 35, pp. 717‚Äì773.
Bonatti, P. A., Faella, M., & Sauro, L. (2010). EL with default attributes and overriding. In
Patel-Schneider, P. F., Pan, Y., Hitzler, P., Mika, P., Zhang, L., Pan, J. Z., Horrocks,
I., & Glimm, B. (Eds.), International Semantic Web Conference (1), Vol. 6496 of
Lecture Notes in Computer Science, pp. 64‚Äì79. Springer.
Bonatti, P. A., Faella, M., & Sauro, L. (2011a). Adding default attributes to EL++ . In
Burgard, W., & Roth, D. (Eds.), Proceedings of AAAI-11. AAAI Press.
Bonatti, P. A., Faella, M., & Sauro, L. (2011b). Defeasible inclusions in low-complexity
DLs. Journal of Artificial Intelligence Research, 42, pp. 719‚Äì764.
Bonatti, P. A., Faella, M., & Sauro, L. (2011c). On the complexity of el with defeasible
inclusions. In Proceedings of IJCAI-11, pp. 762‚Äì767. AAAI Press/IJCAI.
Brewka, G., & Augustin, D. S. (1987). The logic of inheritance in frame systems. In
Proceedings of IJCAI-87, pp. 483‚Äì488. Morgan Kaufmann Publishers.
Britz, K., Casini, G., Meyer, T., Moodley, K., & Varzinczak, I. (2013). Ordered Interpretations and Entailment for Defeasible Description Logics. Tech. rep., CAIR, CSIR
Meraka and UKZN, South Africa.
Britz, K., Heidema, J., & Meyer, T. A. (2008). Semantic preferential subsumption. In
Brewka, G., & Lang, J. (Eds.), Proceedings of KR-08, pp. 476‚Äì484. AAAI Press.
Britz, K., Meyer, T., & Varzinczak, I. J. (2011). Semantic foundation for preferential
description logics. In Wang, D., & Reynolds, M. (Eds.), Australasian Conference on
Artificial Intelligence, Vol. 7106 of Lecture Notes in Computer Science, pp. 491‚Äì500.
Springer.
Casini, G., Meyer, T., Moodley, K., & Varzinczak, I. (2013). Nonmonotonic reasoning in
description logics. Rational closure for the ABox. In Proceedings of DL-13, pp. 77‚Äì90.
CEUR Workshop Proceedings.
Casini, G., & Straccia, U. (2010). Rational closure for defeasible description logics. In
Janhunen, T., & NiemelaÃà, I. (Eds.), Proceedings of JELIA-10, Vol. 6341 of Lecture
Notes in Computer Science, pp. 77‚Äì90. Springer.
471

Casini & Straccia

Casini, G., & Straccia, U. (2011). Defeasible inheritance-based description logics. In Proceedings of IJCAI-11, pp. 813‚Äì818.
Cormen, T. H., Stein, C., Rivest, R. L., & Leiserson, C. E. (2001). Introduction to Algorithms
(2nd edition). McGraw-Hill Higher Education.
Donini, F. M., & Massacci, F. (2000). EXPTIME tableaux for ALC. Artificial Intelligence,
124 (1), pp. 87‚Äì138.
Donini, F. M., Nardi, D., & Rosati, R. (2002). Description logics of minimal knowledge and
negation as failure. Transactions on Computational Logic, 3 (2), pp. 177‚Äì225.
Freund, M. (1998). Preferential reasoning in the perspective of Poole default logic. Artificial
Intelligence, 98 (1-2), pp. 209‚Äì235.
Gabbay, D. M., & Schlechta, K. (2009). Defeasible inheritance systems and reactive diagrams. Logic Journal of the IGPL, 17 (1), pp. 1‚Äì54.
Giordano, L., Gliozzi, V., Olivetti, N., & Pozzato, G. L. (2012a). A minimal model semantics
for nonmonotonic reasoning. In Proceedings of JELIA-12, Vol. 7519 of Lecture Notes
in Computer Science, pp. 228‚Äì241. Springer.
Giordano, L., Gliozzi, V., Olivetti, N., & Pozzato, G. L. (2012b). A non-monotonic description logic for reasoning about typicality. Artificial Intelligence, 195, pp. 165‚Äì202.
Giordano, L., Olivetti, N., Gliozzi, V., & Pozzato, G. L. (2009). ALC+T: a preferential
extension of description logics. Fundam. Inform., 96 (3), 341‚Äì372.
Grimm, S., & Hitzler, P. (2009). A preferential tableaux calculus for circumscriptive ALCO.
In Proceedings of RR-09, pp. 40‚Äì54. Springer-Verlag.
Horty, J. F. (1994). Some direct theories of nonmonotonic inheritance. In Handbook of
logic in artificial intelligence and logic programming: nonmonotonic reasoning and
uncertain reasoning, Vol. 3, pp. 111‚Äì187. Oxford University Press.
Horty, J. F., & Thomason, R. H. (1990). Boolean extensions of inheritance networks. In
Proceedings of AAAI-90, pp. 633‚Äì639. AAAI Press.
Horty, J. F., Thomason, R. H., & Touretzky, D. S. (1987). A skeptical theory of inheritance
in nonmonotonic semantic networks. In Proceedings of AAAI-87. AAAI Press.
Knorr, M., Alferes, J. J., & Hitzler, P. (2011). Local closed world reasoning with description
logics under the well-founded semantics. Artificial Intelligence, 175 (9-10), 1528‚Äì1554.
Kraus, S., Lehmann, D., & Magidor, M. (1990). Nonmonotonic reasoning, preferential
models and cumulative logics. Artificial Intelligence, 44 (1-2), pp. 167‚Äì207.
Lehmann, D., & Magidor, M. (1992). What does a conditional knowledge base entail?.
Artificial Intelligence, 55 (1), pp. 1‚Äì60.
Lukasiewicz, T. (2008). Expressive probabilistic description logics. Artificial Intelligence,
172 (6-7), pp. 852‚Äì883.
Makinson, D. (1994). General patterns in nonmonotonic reasoning. In Handbook of logic in
artificial intelligence and logic programming: nonmonotonic reasoning and uncertain
reasoning, Vol. 3, pp. 35‚Äì110. Oxford University Press.
472

Defeasible Inheritance-Based Description Logics

Makinson, D. (2005). Bridges from Classical to Nonmonotonic Logic. King‚Äôs College Publications.
Makinson, D., & Schlechta, K. (1991). Floating conclusions and zombie paths. Artificial
Intelligence, 48, pp. 199‚Äì209.
Poole, D. (1988). A logical framework for default reasoning. Artificial Intelligence, 36 (1),
27‚Äì47.
Quantz, J., & Royer, V. (1992). A preference semantics for defaults in terminological logics.
In Proceedings of KR-92, pp. 294‚Äì305.
Rott, H. (2001). Change, Choice and Inference: a study of belief revision and nonmonotonic
reasoning. Oxford University Press.
Sandewall, E. (1986). Nonmonotonic inference rules for multiple inheritance with exceptions.
In Proceedings of the IEEE-86, pp. 1345‚Äì1353.
Sandewall, E. (2010). Defeasible inheritance with doubt index and its axiomatic characterization. Artificial Intelligence, 18 (174), pp. 1431‚Äì1459.
Schlechta, K. (2004). Coherent Systems. Elsevier.
Shoham, Y. (1988). Reasoning about change: time and causation from the standpoint of
artificial intelligence. MIT Press.
Simonet, G. (1996). On sandewall‚Äôs paper: Nonmonotonic inference rules for multiple inheritance with exceptions. Artificial Intelligence, 86, pp. 359‚Äì374.
Straccia, U. (1993). Default inheritance reasoning in hybrid KL-ONE style logics. Proceedings of IJCAI-93, 676‚Äì681.
Thomason, R. H. (1992). NETL and subsequent path-based inheritance theories. In
Lehmann, F. (Ed.), Semantic Networks in Artificial Intelligence, pp. 179‚Äì204. Pergamon Press.
Touretzky, D. S. (1986). The mathematics of inheritance systems. Pitman.
Touretzky, D. S., Horty, J. F., & Thomason, R. H. (1987). A clash of intuitions: the current
state of nonmonotonic multiple inheritance systems. In Proceedings of IJCAI-87 Vol. 1, pp. 476‚Äì482. Morgan Kaufmann Publishers.
Touretzky, D. S., Thomason, R. H., & Horty, J. F. (1991). A skeptic‚Äôs menagerie: conÔ¨Çictors,
preemptors, reinstates, and zombies in nonmonotonic inheritance. In Proceedings of
IJCAI-91, pp. 478‚Äì483. Morgan Kaufmann Publishers.

473

Journal of Artificial Intelligence Research 48 (2013) 253-303

Submitted 11/12; published 10/13

Optimizing SPARQL Query Answering over OWL Ontologies
Ilianna Kollia

ilianna2@mail.ntua.gr

University of Ulm, Germany and
National Technical University of Athens, Greece

Birte Glimm

birte.glimm@uni-ulm.de

University of Ulm, Germany

Abstract
The SPARQL query language is currently being extended by the World Wide Web
Consortium (W3C) with so-called entailment regimes. An entailment regime defines how
queries are evaluated under more expressive semantics than SPARQL‚Äôs standard simple
entailment, which is based on subgraph matching. The queries are very expressive since
variables can occur within complex concepts and can also bind to concept or role names.
In this paper, we describe a sound and complete algorithm for the OWL Direct Semantics entailment regime. We further propose several novel optimizations such as strategies
for determining a good query execution order, query rewriting techniques, and show how
specialized OWL reasoning tasks and the concept and role hierarchy can be used to reduce
the query execution time. For determining a good execution order, we propose a cost-based
model, where the costs are based on information about the instances of concepts and roles
that are extracted from a model abstraction built by an OWL reasoner. We present two
ordering strategies: a static and a dynamic one. For the dynamic case, we improve the
performance by exploiting an individual clustering approach that allows for computing the
cost functions based on one individual sample from a cluster.
We provide a prototypical implementation and evaluate the efficiency of the proposed
optimizations. Our experimental study shows that the static ordering usually outperforms
the dynamic one when accurate statistics are available. This changes, however, when the
statistics are less accurate, e.g., due to nondeterministic reasoning decisions. For queries
that go beyond conjunctive instance queries we observe an improvement of up to three
orders of magnitude due to the proposed optimizations.

1. Introduction
Query answering is important in the context of the Semantic Web since it provides a mechanism via which users and applications can interact with ontologies and data. Several query
languages have been designed for this purpose, including RDQL (Seaborne, 2004), SeRQL
(Broekstra & Kampman, 2006) and, most recently, SPARQL. In this paper, we consider the
SPARQL query language (Prud‚Äôhommeaux & Seaborne, 2008), which was standardized in
2008 by the World Wide Web Consortium (W3C) and which is currently being extended to
SPARQL 1.1 (Harris & Seaborne, 2013). Since 2008, SPARQL has developed into the main
query language for the Semantic Web and is now supported by most RDF triple stores.
The query evaluation mechanism defined in the SPARQL Query specification is based on
subgraph matching. This form of query evaluation is also called simple entailment since
it can equally be defined in terms of the simple entailment relation between RDF graphs
(Hayes, 2004). SPARQL 1.1 includes several entailment regimes (Glimm & Ogbuji, 2013)
c
2013
AI Access Foundation. All rights reserved.

Kollia & Glimm

in order to use more elaborate entailment relations, such as those induced by RDF Schema
(RDFS) (Brickley & Guha, 2004) or OWL (Motik, Patel-Schneider, & Cuenca Grau, 2012b;
Schneider, 2012). Query answering under such entailment regimes is more complex as it
may involve retrieving answers that only follow implicitly from the queried graph, which is
seen as an OWL ontology when using OWL entailment. While several implementations for
SPARQL‚Äôs RDFS entailment regime are available (e.g., Oracle 11g (Oracle, 2013), Apache
Jena (The Apache Software Foundation, 2013), or Stardog (Clark & Parsia, 2013b)), the
development of tools that provide full SPARQL support under OWL semantics is still an
ongoing effort.
Since we consider the OWL Direct Semantics entailment regime of SPARQL 1.1 in this
paper, when we talk about SPARQL queries or the evaluation of SPARQL queries, we
always assume that the OWL Direct Semantics entailment regime is used. In this setting,
the WHERE clause of a query can be seen as a set of extended OWL axioms (an extended
OWL ontology), which can have variables in place of concept, role or individual names.
The query answers contain each instantiation of the variables that leads to OWL axioms
that are entailed by the queried ontology. Thus, a naive query evaluation procedure can be
realized through OWL‚Äôs standard reasoning task of entailment checking.
Please note that there are two types of individual variables in SPARQL; standard (distinguished) variables and anonymous individuals (aka blank nodes). The anonymous individuals are treated like distinguished variables with the difference that they cannot be
selected and, hence, their bindings cannot appear in the query answer. This is in contrast to
conjunctive queries, where anonymous individuals are treated as existential variables. On
the other hand, anonymous individuals can occur in the query answer as bindings to distinguished variables, i.e., SPARQL treats anonymous individuals from the queried ontology as
constants. This treatment of anonymous individuals has been chosen for compatibility with
SPARQL‚Äôs standard subgraph matching semantics. For example, in order to implement
the RDF(S) entailment regime, systems can simply extend the queried graph with inferred
information (materialization) and can then use SPARQL‚Äôs standard evaluation mechanism
over the materialized graph in order to compute the query results. Similarly, when users
move on to systems that support the OWL RL profile (Motik, Cuenca Grau, Horrocks, Wu,
Fokoue, & Lutz, 2012a), the OWL RL rule set from the OWL 2 specification can be used to
compute the query answers (again via materialization). If one were to change the semantics
of blank nodes for SPARQL‚Äôs entailment regimes to reflect conjunctive query semantics, one
could no longer use materialization plus a standard SPARQL query processor to implement
the entailment regime. If one were to change the semantics of blank nodes only for the
OWL Direct Semantics entailment regime, where materialization cannot be used to implement the regime, users would not simply get more answers by moving from systems that
support RDF(S) to systems that support OWL‚Äôs Direct Semantics, but it could also happen
that they get less answers by using a more expressive logic, which is counter-intuitive.
Over the last decade, much effort has been spent on optimizing standard reasoning tasks
such as entailment checking, classification, or realization (i.e., the computation of instances
of all concepts and roles) (Sirin, Cuenca Grau, & Parsia, 2006; Tsarkov, Horrocks, & PatelSchneider, 2007; Glimm, Horrocks, Motik, Shearer, & Stoilos, 2012). The optimization of
query answering algorithms has, however, mostly been addressed for conjunctive queries in
OWL profiles, most notably the OWL 2 QL profile (Calvanese, Giacomo, Lembo, Lenzerini,
254

Optimizing SPARQL Query Answering over OWL Ontologies

& Rosati, 2007; Kontchakov, Lutz, Toman, Wolter, & Zakharyaschev, 2010; PeÃÅrez-Urbina,
Motik, & Horrocks, 2010; Rodriguez-Muro & Calvanese, 2012). An exception to this are
the works on nRQL and SPARQL-DL. The query language nRQL is supported by Racer
Pro (Haarslev, MoÃàller, & Wessel, 2004) and SPARQL-DL is implemented in the Pellet
reasoner (Sirin, Parsia, Grau, Kalyanpur, & Katz, 2007). We discuss this in greater detail
in Section 8.
In this paper, we address the problem of efficient SPARQL query evaluation for OWL 2
DL ontologies by proposing a range of novel optimizations that deal in particular with the
expressive features of SPARQL such as variables in place of concepts or roles. We further
adapt common techniques from databases such as cost-based query planning. The costs
for our cost model are based on information about the instances of concepts and roles
that are extracted from a model abstraction built by an OWL reasoner. We present a
static and a dynamic algorithm for finding an optimal or near optimal execution order and
for the dynamic case, we improve the performance by exploiting an individual clustering
approach that allows for computing the cost functions based on one individual sample from
a cluster. We further propose query rewriting techniques and show how specialized OWL
reasoning tasks and the concept and role hierarchy can be used to reduce the query execution
time. We provide a prototypical implementation and evaluate the efficiency of the proposed
optimizations. Our experimental study shows that the static ordering usually outperforms
the dynamic one when accurate statistics are available. This changes, however, when the
statistics are less accurate, e.g., due to non-deterministic reasoning decisions. For queries
that go beyond conjunctive SPARQL instance queries, we observe an improvement of up to
three orders of magnitude due to the proposed optimizations.
Note that this paper combines and extends two conference papers: I. Kollia and B.
Glimm: Cost based Query Ordering over OWL Ontologies. Proceedings of the 11th International Semantic Web Conference, 2012 and I. Kollia, B. Glimm and I. Horrocks: SPARQL
Query Answering over OWL Ontologies. Proceedings of the 8th Extended Semantic Web
Conference, 2011. In the current paper we have, additionally to the first above mentioned
paper, defined cost functions for general SPARQL queries (i.e., not only for conjunctive instance queries) and added experimental results for these expressive queries. In comparison
to the second of the above mentioned papers, we have defined the notion of concept and role
polarity and presented theorems that let us prune the search space of possible mappings for
axiom templates based on the polarity together with an algorithm that shows the way we
use the optimization. Moreover, more experimental results have been added for complex
queries that make use of this optimization.
The remainder of the paper is organized as follows: we next present some preliminaries,
we then present a general query evaluation algorithm in Section 3 that serves as the basis
for further optimization. In Section 4, we present the foundations for our cost model, which
we then specify in Section 5. In Section 6, we present optimizations for complex queries that
cannot directly be mapped to specialized reasoner tasks. Finally, we evaluate our approach
in Section 7 and discuss related work in Section 8 before we conclude in Section 9.

255

Kollia & Glimm

2. Preliminaries
In this section, we first give a brief introduction into Description Logics since the OWL
Direct Semantics is based on the Description Logic SROIQ (Horrocks, Kutz, & Sattler,
2006). The optimizations we present do not need all features of SROIQ. Hence, we only
present SHOIQ, which allows for a shorter and easier to follow presentation.
After introducing SHOIQ, we clarify the relationship between RDF, SPARQL and
OWL, we present SPARQL‚Äôs OWL Direct Semantics entailment regime and we give an
overview of the model building tableau and hypertableau calculi.
2.1 The Description Logic SHOIQ
We first define the syntax and semantics of roles, and then go on to SHOIQ-concepts,
individuals, and ontologies/knowledge bases.
Definition 1 (Syntax of SHOIQ ). Let NC , NR , and NI be countable, infinite, and
pairwise disjoint sets of concept names, role names, and individual names, respectively.
We call S = (NC , NR , NI ) a signature. The set rol(S) of SHOIQ-roles over S (or roles
for short) is NR ‚à™ {r ‚àí | r ‚àà NR } ‚à™ {‚ä§r , ‚ä•r }, where roles of the form r ‚àí are called inverse
roles, ‚ä§r is the top role (analogous to owl:topObjectProperty), and ‚ä•r is the bottom role
(analogous to owl:bottomObjectProperty). A role inclusion axiom is of the form r ‚äë s with
r, s roles. A transitivity axiom is of the form trans(r) for r a role. A role hierarchy H is a
finite set of role inclusion and transitivity axioms.
For a role hierarchy H, we define the function inv over roles as inv(r) := r ‚àí if r ‚àà NR
and inv(r) := s if r = s‚àí for a role name s ‚àà NR . Further, we define ‚äëH as the smallest
transitive reflexive relation on roles such that r ‚äë s ‚àà H implies r ‚äëH s and inv(r) ‚äëH
inv(s). We write r ‚â°H s if r ‚äëH s and s ‚äëH r. A role r is transitive w.r.t. H (notation
r + ‚äëH r) if a role s exists such that r ‚äëH s, s ‚äëH r, and trans(s) ‚àà H or trans(inv(s)) ‚àà H.
A role s is called simple w.r.t. H if there is no role r such that r is transitive w.r.t. H and
r ‚äëH s.
Given a signature S = (NC , NR , NI ) and a role hierarchy H, the set of SHOIQconcepts (or concepts for short) over S is the smallest set built inductively over symbols
from S using the following grammar, where o ‚àà NI , A ‚àà NC , n ‚àà IN0 , s is a simple role
w.r.t. H, and r is a role w.r.t. H:
C ::= ‚ä§ | ‚ä• | {o} | A | ¬¨C | C ‚äì C | C ‚äî C | ‚àÄr.C | ‚àÉr.C | 6 n s.C | > n s.C.
We now define the semantics of SHOIQ concepts:
Definition 2 (Semantics of SHOIQ-concepts). An interpretation I = (‚àÜI , ¬∑I ) consists
of a non-empty set ‚àÜI , the domain of I, and a function ¬∑I , which maps every concept name
A ‚àà NC to a subset AI ‚äÜ ‚àÜI , every role name r ‚àà NR to a binary relation r I ‚äÜ ‚àÜI √ó ‚àÜI ,
and every individual name a ‚àà NI to an element aI ‚àà ‚àÜI . The top role ‚ä§r is interpreted
as {hŒ¥, Œ¥‚Ä≤ i | Œ¥, Œ¥‚Ä≤ ‚àà ‚àÜI } and the bottom role ‚ä•r as ‚àÖ. For each role name r ‚àà NR , the
I
interpretation of its inverse role (r ‚àí ) consists of all pairs hŒ¥, Œ¥‚Ä≤ i ‚àà ‚àÜI √ó ‚àÜI for which
hŒ¥‚Ä≤ , Œ¥i ‚àà r I .
256

Optimizing SPARQL Query Answering over OWL Ontologies

The semantics of SHOIQ-concepts over a signature S is defined as follows:
‚ä§I
(¬¨C)I
(‚àÄr.C)I
(‚àÉr.C)I
(6 n s.C)I
(> n s.C)I

=
=
=
=
=
=

‚àÜI
‚àÜI \ C I
{Œ¥ ‚àà ‚àÜI
{Œ¥ ‚àà ‚àÜI
{Œ¥ ‚àà ‚àÜI
{Œ¥ ‚àà ‚àÜI

‚ä•I = ‚àÖ
({o})I = {oI }
I
I
I
(C ‚äì D) = C ‚à© D
(C ‚äî D)I = C I ‚à™ D I
‚Ä≤
I
‚Ä≤
I
| if hŒ¥, Œ¥ i ‚àà r , then Œ¥ ‚àà C }
| there is a hŒ¥, Œ¥‚Ä≤ i ‚àà r I with Œ¥‚Ä≤ ‚àà C I }
| ‚ôØ(sI (Œ¥, C)) ‚â§ n}
| ‚ôØ(sI (Œ¥, C)) ‚â• n}

where ‚ôØ(M ) denotes the cardinality of the set M and sI (Œ¥, C) is defined as
{Œ¥‚Ä≤ ‚àà ‚àÜI | hŒ¥, Œ¥‚Ä≤ i ‚àà sI and Œ¥‚Ä≤ ‚àà C I }.
Definition 3 (Syntax and Semantics of Axioms and Ontologies, Entailment). For
C, D concepts, a (general) concept inclusion axiom (GCI) is an expression C ‚äë D. We
introduce C ‚â° D as an abbreviation for C ‚äë D and D ‚äë C. A finite set of GCIs is called
a TBox. An (ABox) (concept or role) assertion axiom is an expression of the form C(a),
r(a, b), ¬¨r(a, b), a ‚âà b, or a 6‚âà b, where C ‚àà NC is a concept, r ‚àà NR is a role, and a, b ‚àà NI
are individual names. An ABox is a finite set of assertion axioms. An ontology O is a
triple (T , H, A) with T a TBox, H a role hierarchy, and A an ABox. We use NCO , NRO ,
and NIO to denote, respectively, the set of concept, role, and individual names occurring in
O.
Let I = (‚àÜI , ¬∑I ) be an interpretation. Then I satisfies a role inclusion axiom r ‚äë s
if r I ‚äÜ sI , I satisfies a transitivity axiom trans(r) if r I is a transitive binary relation,
and a role hierarchy H if it satisfies all role inclusion and transitivity axioms in H. The
interpretation I satisfies a GCI C ‚äë D if C I ‚äÜ D I ; and I satisfies a TBox T if it satisfies
each GCI in T . The interpretation I satisfies an assertion axiom C(a) if aI ‚àà C I , r(a, b)
if haI , bI i ‚àà r I , ¬¨r(a, b) if haI , bI i ‚àà
/ r I , a ‚âà b if aI = bI , and a 6‚âà b if aI 6= bI ; I satisfies
an ABox if it satisfies each assertion in A. We say that I satisfies O if I satisfies T , H,
and A. In this case, we say that I is a model of O and write I |= O. We say that O is
consistent if O has a model.
Given an axiom Œ±, we say that O entails Œ± (written O |= Œ±) if every model I of O
satisfies Œ±.
Description Logics can further be extended with concrete domains, which correspond to
OWL‚Äôs datatypes. In such a case, one distinguishes between abstract roles that relate two
individuals and concrete roles that relate an individual with a data value. The Description
Logic SROIQ further allows for a number of features such as role chains of the form
hasFather ‚ó¶ hasBrother ‚äë hasUncle, support for the special concept Self, which can be
used in axioms of the form Narcissist ‚äë ‚àÉloves.Self, or for defining roles that are reflexive,
irreflexive, symmetric, or asymmetric.
Description Logic ontologies can equally be expressed in terms of OWL ontologies, which
in turn can be mapped into RDF graphs (Patel-Schneider & Motik, 2012). The other direction is, however, not always possible, i.e., a mapping from RDF graphs to OWL ontologies is
only defined for certain well-formed RDF graphs that correspond to an OWL 2 DL ontology.
257

Kollia & Glimm

2.2 The Relationship between RDF, SPARQL, and OWL
SPARQL queries are evaluated over RDF graphs which remain the basic data structure
even when adopting a more elaborate semantic interpretation.
Definition 4 (RDF Graphs). RDF is based on the set I of International Resource
Identifiers (IRIs), the set L of RDF literals, and the set B of blank nodes. The set
T of RDF terms is I ‚à™ L ‚à™ B. An RDF graph is a set of RDF triples of the form
(subject, predicate, object) ‚àà (I ‚à™ B) √ó I √ó T .
We generally abbreviate IRIs using prefixes rdf, rdfs, owl, and xsd to refer to the RDF,
RDFS, OWL, and XML Schema Datatypes namespaces, respectively. The empty prefix is
used for an imaginary example namespace, which we completely omit in Description Logic
syntax.
An example of a SPARQL query is
SELECT ?x FROM <ontologyIRI> WHERE { ?x rdf:type :C . ?x :r ?y }
The WHERE clause of the SPARQL query consists of a basic graph pattern (BGP): an
RDF graph written in Turtle syntax (Beckett, Berners-Lee, Prud‚Äôhommeaux, & Carothers,
2013), where some nodes or edges are replaced by variables. A basic graph pattern is more
precisely defined as follows:
Definition 5 (Basic Graph Pattern). Let V be a countably infinite set of query variables
disjoint from T . A triple pattern is a member of the set (T ‚à™ V ) √ó (I ‚à™ V ) √ó (T ‚à™ V ), and
a basic graph pattern (BGP) is a set of triple patterns.
We do not recall the complete surface syntax of SPARQL here since the only part
that is specific to the evaluation of SPARQL queries under OWL‚Äôs Direct Semantics is
the evaluation of BGPs. More complex WHERE clauses, which use operators such as
UNION for alternative selection criteria or OPTIONAL to query for optional bindings
(Prud‚Äôhommeaux & Seaborne, 2008), can be evaluated simply by combining the results
obtained by the BGP evaluation. Similarly, operations such as the projection of variables
from the SELECT clause is a straightforward operation over the results of the evaluation of
the WHERE clause. Therefore, we focus here on BGP evaluation only. For a more detailed
introduction to SPARQL queries and their algebra we refer interested readers to the work
of Hitzler, KroÃàtzsch, and Rudolph (2009) or Glimm and KroÃàtzsch (2010).
Since the Direct Semantics of OWL is defined in terms of OWL structural objects, i.e.,
OWL axioms, we map the BGPs of SPARQL queries into structural objects, which can have
variables in place of class (concept), object or data property (abstract or concrete role), or
individual names or literals. Since there is a direct mapping between OWL axioms and
Description Logic axioms, BGPs can be expressed as Description Logic axioms in which
variables can occur in place of concept, role and individual names. For example, the BGP
of the previous example is mapped to ClassAssertion(C ?x) and ObjectPropertyAssertion(r
?x ?y) in functional-style syntax or to C(?x) and r(?x, ?y) in Description Logic syntax.
For further details, we refer interested readers to the W3C specification that defines
the mapping between OWL structural objects and RDF graphs (Patel-Schneider & Motik,
2012) and to the specification of the OWL Direct Semantics entailment regime of SPARQL
258

Optimizing SPARQL Query Answering over OWL Ontologies

(Glimm & Ogbuji, 2013) that defines the extension of this mapping between BGPs and
OWL objects with variables.
2.3 SPARQL Queries
In the following, we directly write BGPs in Description Logic notation extended to allow for variables in place of concept, role and individual names in axioms. It is worth
reminding that SPARQL does not support existentially quantified variables, which is in
contrast to database-style conjunctive queries, where one typically also has existential/nondistinguished variables.
For brevity and without loss of generality, we assume here that neither the query nor
the queried ontology contains anonymous individuals. We further do not consider data
properties and literals, but the presented optimizations can easily be transferred to this
case.
Definition 6 (Query). Let S = (NC , NR , NI ) be a signature. A query signature Sq w.r.t.
S is a six-tuple (NC , NR , NI , VC , VR , VI ), where VC , VR , and VI are countable, infinite,
and pairwise disjoint sets of concept variables, role variables, and individual variables
disjoint from NC , NR , and NI . A concept term is an element from NC ‚à™ VC . A role term
is an element from NR ‚à™ VR . An individual term is an element from NI ‚à™ VI . An axiom
template over Sq is a SROIQ axiom over S, where one can also use concept variables from
VC in place of concept names, role variables from VR in place of role names, and individual
variables from VI in place of individual names. A query q w.r.t. a query signature Sq is a
non-empty set of axiom templates over Sq . We use Vars(q) (Vars(at) for an axiom template
at) to denote the set of all variables in q (at) and |q| to denote the number of axiom templates
in q. Let t, t‚Ä≤ be individual terms; we call axiom templates of the form A(t) with A ‚àà NC ,
r(t, t‚Ä≤ ) with r ‚àà NR , or t ‚âà t‚Ä≤ query atoms. A conjunctive instance query q w.r.t. a query
signature Sq is a non-empty set of query atoms.
For a function ¬µ, we use dom(¬µ) to denote the domain of ¬µ. Let O be an ontology over
S and q = {at1 , . . . , atn } a query over Sq consisting of n axiom templates. A mapping ¬µ
for q over O is a total function ¬µ : Vars(q) ‚Üí NCO ‚à™ NRO ‚à™ NIO such that
1. ¬µ(v) ‚àà NCO for each v ‚àà VC ‚à© dom(¬µ),
2. ¬µ(v) ‚àà NRO for each v ‚àà VR ‚à© dom(¬µ),
3. ¬µ(v) ‚àà NIO for each v ‚àà VI ‚à© dom(¬µ), and
4. O ‚à™ ¬µ(q) is a SROIQ ontology.
We write ¬µ(q) (¬µ(at)) to denote the result of replacing each variable v in q (at) with
O
¬µ(v). The set ŒìO
q of the compatible mappings for q over O is defined as Œìq := {¬µ |
¬µ is a mapping for q over O}. A mapping ¬µ is a solution mapping or a certain answer for
q over O if O |= ¬µ(q). We denote the set containing all solution mappings for q over O
with ‚Ñ¶O
q . The result size or the number of answers of a query q over O is given by the
cardinality of the set ‚Ñ¶O
q .
Note that the last condition in the definition of mappings is required to ensure decidability of query entailment. For example, without the condition, a reasoner might have to
259

Kollia & Glimm

test instantiated axiom templates where a role variable has been replaced by a non-simple
role in a number restriction, which is not allowed in Description Logic axioms. Note also
that we do not indicate which variables are to be selected since we do not consider the
straightforward task of projection here.
Examples of queries according to the above definition are the following (where ?x is a
concept variable, ?y a role variable, and ?z an individual variable):
C ‚äë ‚àÉ?y.?x
(‚àÉr.?x)(?z)
In the remainder, we use S for a signature (NC , NR , NI ), O to denote a SROIQ ontology
over S, A, B ‚àà NC for concept names from O, r, s ‚àà NR for role names from O, a, b ‚àà NI
for individual names from O, ?x, ?y for variables, c1 , c2 for concept terms, r1 , r2 for role
terms, t, t‚Ä≤ for individual terms, q = {at1 , . . . , atn } for a query with n axiom templates over
the query signature Sq = (NC , NR , NI , VC , VR , VI ), ŒìO
q for the compatible mappings and
‚Ñ¶O
for
the
solution
mappings
of
q
over
O.
q
2.4 Model-building (Hyper)Tableau Calculi
In this section, we give a brief overview over the main reasoning techniques for OWL DL
ontologies since our cost-based query planning relies on these techniques.
In order to check whether an ontology O entails an axiom Œ±, one typically checks whether
O ‚à™ {¬¨Œ±} has a model. If that is not the case, then every model of O satisfies Œ± and
O |= Œ±. For example, to check whether an individual a0 is an instance of a concept C
w.r.t. an ontology O, we check whether adding the concept assertion ¬¨C(a0 ) to O leads
to an inconsistency. To check this, most OWL reasoners use a model construction calculus
such as tableau or hypertableau. In the remainder, we focus on the hypertableau calculus
(Motik, Shearer, & Horrocks, 2009), but a tableau calculus could equally be used and we
state how our results can be transferred to tableau calculi.
The hypertableau calculus starts from the initial set of ABox assertions and, by applying
derivation rules, it tries to construct (an abstraction of) a model of O. Derivation rules
usually add new concept or role assertion axioms, they may introduce new individuals, they
can be nondeterministic, leading to the need to choose between several alternative assertion
axioms to add or they can lead to a clash when a contradiction is detected. To show that
an ontology O is (in)consistent, the hypertableau calculus constructs a derivation, i.e., a
sequence of sets of assertions A0 , . . . , An , such that A0 contains all ABox assertions in O,
Ai+1 is the result of applying a derivation rule to Ai and An is the final set of assertions
where no more rules are applicable. If a derivation exists such that An does not contain a
clash, then O is consistent and An is called a pre-model of O. Otherwise O is inconsistent.
Each assertion in a set of assertions Ai is derived either deterministically or nondeterministically. An assertion is derived deterministically if it is derived by the application of a
deterministic derivation rule from assertions that were all derived deterministically. Any
other derived assertion is derived nondeterministically. It is easy to know whether an assertion was derived deterministically or not because of the dependency directed backtracking
that most (hyper)tableau reasoners employ. In the pre-model, each individual s0 is assigned
a label L(s0 ) representing the concepts it is (non)deterministically an instance of and each
260

Optimizing SPARQL Query Answering over OWL Ontologies

pair of individuals hs0 , s1 i is assigned a label L(hs0 , s1 i) representing the roles through which
individual s0 is (non)deterministically related to individual s1 .

3. Motivation
A straightforward algorithm to compute the answers for a query q is to test, for each
mapping ¬µ, whether O |= ¬µ(q). Since only terms that are used in O can occur in the range
of a mapping ¬µ for q over O, there are finitely many mappings to test. In the worst case,
however, the number of mappings that have to be tested is still exponential in the number
of variables in the query. Such an algorithm is sound and complete if the reasoner used to
decide entailment is sound and complete since we check all mappings for variables that can
constitute actual solution mappings.
Optimizations cannot easily be integrated into the above sketched algorithm since it uses
the reasoner to check for the entailment of the instantiated query as a whole and, hence,
does not take advantage of relations or dependencies that may exist between the individual
axiom templates in q. For a more optimized evaluation, one can evaluate the query axiom
template by axiom template. Initially, the solution set contains only the identity mapping,
which does not map any variable to a value. One then picks the first axiom template,
extends the identity mapping to cover the variables of the chosen axiom template and then
uses a reasoner to check which of the mappings instantiate the axiom template into an
entailed axiom. One then picks the next axiom template and again extends the mappings
from the previous round to cover all variables and checks which of those mappings lead to
an entailed axiom. Thus, axiom templates which are very selective and are only satisfied by
very few solutions reduce the number of intermediate solutions. Choosing a good execution
order, therefore, can significantly affect the performance.
For example, let q = {A(?x), r(?x, ?y)} with ?x, ?y ‚àà VI . The query belongs to the
class of conjunctive instance queries. We assume that the queried ontology contains 100
individuals, only 1 of which belongs to the concept A. This A instance has 1 r-successor,
while we have overall 200 pairs of individuals related with the role r. If we first evaluate
A(?x), we test 100 mappings (since ?x is an individual variable), of which only 1 mapping
satisfies the axiom template. We then evaluate r(?x, ?y) by extending the mapping with
all 100 possible mappings for ?y. Again only 1 mapping yields a solution. For the reverse
axiom template order, the first axiom template requires the test of 100 ¬∑ 100 mappings. Out
of those, 200 remain to be checked for the second axiom template and we perform 10, 200
tests instead of just 200. Note also that the number of intermediate results when the query
is evaluated in the order A(?x), r(?x, ?y) is smaller than when it is evaluated in the reverse
order (2 versus 201).
In the context of databases or triple stores, cost-based ordering techniques for finding an
optimal or near optimal join ordering have been widely applied (Steinbrunn, Moerkotte, &
Kemper, 1997; Stocker, Seaborne, Bernstein, Kiefer, & Reynolds, 2008). These techniques
involve the maintenance of a set of statistics about relations and indexes, e.g., number of
pages in a relation, number of pages in an index, number of distinct values in a column,
together with formulas for the estimation of the selectivity of predicates and the estimation
of the CPU and I/O costs of query execution that depends amongst others, on the number
of pages that have to be read from or written to secondary memory. The formulas for the
261

Kollia & Glimm

estimation of selectivities of predicates (result output size of axiom templates) estimate
the data distributions using histograms (Ioannidis & Christodoulakis, 1993), parametric
or sampling methods or combinations of them. Ordering strategies as implemented in
databases or triple stores are, however, not directly applicable in our setting. In the presence
of expressive schema level axioms, we cannot rely on counting the number of occurrences of
triples. We also cannot, in general, precompute all relevant inferences to base our statistics
on materialized inferences. Furthermore, we should not only aim at decreasing the number
of intermediate results, but also take into account the cost of checking or computing the
solutions. This cost can be very significant with OWL reasoning and its precise estimation
before query evaluation is difficult as this cost takes values from a wide range, e.g., due to
nondeterminism and the high worst-case complexity of the standard reasoning tasks.1
For several kinds of axiom templates we can, however, directly retrieve the solutions
from the reasoner instead of checking entailment. For example, for C(?x), reasoners typically have a method to retrieve concept instances. Although this might internally trigger
several tests, most methods of reasoners are highly optimized and avoid as many tests as
possible. Furthermore, reasoners typically cache several results such as the computed concept hierarchy and retrieving sub-concepts can then be realized with a cache lookup. Thus,
the actual execution cost might vary significantly. Notably, we do not have a straight correlation between the number of results for an axiom template and the actual cost of retrieving
the solutions as is typically the case in triple stores or databases. This requires cost models
that take into account the cost of the specific reasoning operations (depending on the state
of the reasoner) as well as the number of results.
As motivated above, we distinguish between simple and complex axiom templates. Simple axiom templates are those that correspond to dedicated reasoning tasks. Let c1 be a
concept term, C, C ‚Ä≤ (complex) concepts or concept variables, r1 , r2 role terms or role inverses and t, t‚Ä≤ individual terms. The set of simple axiom templates contains templates of
the form: C ‚äë C ‚Ä≤ , ‚àÉr1 .‚ä§ ‚äë c1 (domain restriction template), ‚ä§ ‚äë ‚àÄr1 .c1 (range restriction
template), r1 ‚äë r2 , C(t), r1 (t, t‚Ä≤ ), t ‚âà t‚Ä≤ , t 6‚âà t‚Ä≤ . Complex axiom templates can, in contrast, not be evaluated by dedicated reasoning tasks and might require iterating over the
compatible mappings and by checking entailment for each instantiated axiom template. An
example of a complex axiom template is (‚àÉr.?x)(?y).

4. Preprocessing for Extracting Information for Queries
In this section, we describe a way of preprocessing the queried ontology to extract information that is useful for ordering the axiom templates in a query. This preprocessing is useful
for axiom templates of the form c1 (t), r1 (t, t‚Ä≤ ), or t ‚âà t‚Ä≤ , where c1 is a concept term, r1 is a
role term and t, t‚Ä≤ are individual terms.
4.1 Extracting Individual Information from Reasoner Models
The first step in the ordering of query atoms is the extraction of statistics by exploiting
information generated by reasoners. We use the labels of an initial pre-model to pro1. For example, the description logic SROIQ, which underpins the OWL 2 DL standard, has a worst case
complexity of 2-NExpTime (Kazakov, 2008) and typical implementations are not worst case optimal.

262

Optimizing SPARQL Query Answering over OWL Ontologies

Algorithm 1 initializeKnownAndPossibleConceptInstances(O)
Input: a consistent SROIQ ontology O
1: An := buildM odelF or(O)
2: for all a ‚àà NIO do
3:
for all C ‚àà LAn (a) do
4:
if C was derived deterministically then
5:
K[C] := K[C] ‚à™ {a}
6:
else
7:
P [C] := P [C] ‚à™ {a}
8:
end if
9:
end for
10: end for
vide information about the concepts the individuals belong to or the roles with which one
individual is connected to another one. We exploit this information similarly as was suggested for determining known or possible (non-)subsumers for concepts during classification
(Glimm et al., 2012). In the hypertableau calculus, the following two properties hold for
each ontology O and each constructed pre-model An for O:
(P1) for each concept name C (role name r), each individual s0 (pair of individuals hs1 , s2 i)
in An , if C ‚àà LAn (s0 ) (r ‚àà LAn (hs1 , s2 i)) and the assertion C(s0 ) (r(s1 , s2 )) was
derived deterministically, then it holds O |= C(s0 ) (O |= r(s1 , s2 )).
(P2) for an arbitrary individual s0 in An (pair of individuals hs1 , s2 i in An ) and an arbitrary
concept name C (simple role name r), if C 6‚àà LAn (s0 ) (r 6‚àà LAn (hs1 , s2 i)), then
O 6|= C(s0 ) (O 6|= r(s1 , s2 )).
For simplicity, we assume here that equality (‚âà) is axiomatized and ‚âà is treated as a
reflexive, symmetric, and transitive role. We use these properties to extract information
from the pre-model of a satisfiable ontology O.
Definition 7 (Known and Possible Instances). Let An be a pre-model for an ontology
O. An individual a is a known (possible) instance of a concept name C in An , denoted
a ‚àà KAn [C] (a ‚àà PAn [C]), if C ‚àà LAn (a) and C(a) is derived deterministically (nondeterministically) in An . A pair of individuals ha1 , a2 i is a known (possible) instance of a simple
role name r in An , denoted ha1 , a2 i ‚àà KAn (r), if r ‚àà LAn (ha1 , a2 i) and r(a1 , a2 ) is derived
deterministically (nondeterministically) in An . The individual a1 is (possibly) equal to the
individual a2 , written a1 ‚àà K‚âà [a2 ] and a2 ‚àà K‚âà [a1 ] (a1 ‚àà P‚âà [a2 ] and a2 ‚àà P‚âà [a1 ]) if
a1 ‚âà a2 has been deterministically (nondeterministically) derived in O.
In the remainder, we assume that the known and possible instances are defined w.r.t.
some arbitrary pre-model An for O and we simply write K[C], K[r], K‚âà [a], P [C], P [r],
and P‚âà [a]. Intuitively, K[C] contains individuals that can safely be considered instances of
the concept name C. On the other hand, the possible instances require costly consistency
checks in order to decide whether they are real instances of the concept, while individuals
that neither belong to K[C] nor P [C] can safely be assumed to be non-instances of C.
263

Kollia & Glimm

Algorithm 1 outlines a procedure to initialize the relations for known and possible concept instances. The information we extract involves the maintenance of the sets of known
and possible instances for all concepts of O. One can define a similar algorithm for initializing the known and possible instances of simple roles and for (possibly) equal individuals.
In our implementation, we use a more involved procedure to only store the direct types of
each individual, where a concept name C is a direct type of an individual a in an ontology
O if O |= C(a) and there is no concept name D such that O |= D ‚äë C, O |= D(a) and
O 6|= D ‚â° C.
Hypertableau and tableau reasoners typically do not deal with transitivity directly. In
order to deal with non-simple roles, O is expanded with additional axioms that capture
the semantics of the transitive relations before a pre-model is built. In particular, for each
individual a and non-simple role r, new concepts Ca and Car are introduced and the axioms
Ca (a) and Ca ‚äë ‚àÄr.Car are added to O. The consequent application of the transitivity
encoding (Motik et al., 2009) produces axioms that propagate Car to each individual b that
is reachable from a via an r-chain. The known and possible r-successors for a can then be
determined from the Car instances.
The technique presented in this paper can be used with any (hyper)tableau calculus for
which properties (P1) and (P2) hold. All (hyper)tableau calculi used in practice that we are
aware of satisfy property (P1). Pre-models produced by tableau algorithms as presented
in the literature also satisfy property (P2); however, commonly used optimizations, such
as lazy unfolding, can compromise property (P2), which we illustrate with the following
example. Let us assume we have an ontology O containing the axioms
A ‚äë ‚àÉr.(C ‚äì D)

(1)

B ‚â° ‚àÉr.C

(2)

A(a)

(3)

It is obvious that in this ontology A is a subconcept of B (hence, O |= B(a)) since every
individual that is r-related to an individual that is an instance of the intersection of C
and D is also r-related to an individual that is an instance of the concept C. However,
even though the assertion A(a) occurs in the ABox, the assertion B(a) is not added in the
pre-model when we use lazy unfolding. With lazy unfolding, instead of treating (2) as two
disjunctions ¬¨B ‚äî ‚àÉr.C and B ‚äî ‚àÄr.(¬¨C) as is typically done for general concept inclusion
axioms, B is only lazily unfolded into its definition ‚àÉr.C once B occurs in the label of an
individual. Thus, although (‚àÉr.(C ‚äì D))(a) would be derived, this does not lead to the
addition of B(a).
Nevertheless, most (if not all) implemented calculi produce pre-models that satisfy at
least the following weaker property:
(P3) for an arbitrary individual s0 in An and an arbitrary concept name C where C is
primitive in O,2 if C 6‚àà LAn (s0 ), then O 6|= C(s0 ).
Hence, properties (P2) and (P3) can be used to extract (non-)instance information from
pre-models. For tableau calculi that only satisfy (P3), for each non-primitive concept name
2. A concept C is considered primitive in O if O is unfoldable (Tsarkov et al., 2007) and it contains no
axiom of the form C ‚â° E

264

Optimizing SPARQL Query Answering over OWL Ontologies

C in O we need to add to P [C] the individuals in O that do not include the concept C in
their label.
The proposed technique for determining known and possible instances of concept and
role names can be used in the same way with both tableau and hypertableau reasoners.
Since tableau algorithms often introduce more nondeterminism than hypertableau, one
might, however, find less deterministic derivations, which results in less accurate statistics.
4.1.1 Individual Clustering
In this section, we describe the procedure for creating clusters of individuals within an
ontology O using a constructed pre-model An of O. Two types of clusters are created:
concept clusters and role clusters. Concept clusters contain individuals having the same
concepts in their label and role clusters contain individuals with the same concept and role
labels. Role clusters are divided into three categories, those that are based on the first
individual of role instances, those based on the second individual and those based on both
individuals.
Definition 8 (Concept and Role Clusters). Let O be an ontology and An a pre-model
for O. We define the following two relations P1 and P2 that map an individual a from O
to the roles for which a has at least one successor or predecessor, respectively:
P1 (a) = {r | r ‚àà LAn (ha, bi) for some b ‚àà NIO }
P2 (a) = {r | r ‚àà LAn (hb, ai) for some b ‚àà NIO }
Based on these relations, we build three different partitions over NIO : concept clusters CC,
role successor clusters P C1 , and role predecessor clusters P C2 such that the clusters satisfy:
for each C ‚àà CC.(for each a1 , a2 ‚àà C.(LAn (a1 ) = LAn (a2 )))
for each C ‚àà P C1 .(for each a1 , a2 ‚àà C.(LAn (a1 ) = LAn (a2 ) and P1 (a1 ) = P1 (a2 )))
for each C ‚àà P C2 .(for each a1 , a2 ‚àà C.(LAn (a1 ) = LAn (a2 ) and P2 (a1 ) = P2 (a2 ))).
We further partition NIO √ó NIO into role clusters P C12 such that the clusters satisfy:
for each C ‚àà P C12 .(for each ha1 , a2 i, ha3 , a4 i ‚àà C.(LAn (a1 ) = LAn (a3 ), LAn (a2 ) = LAn (a4 )
and LAn (ha1 , a2 i) = LAn (ha3 , a4 i))).
We use these clusters in the next section to optimize the dynamic query ordering strategy.

5. Query Answering and Axiom Template Ordering
In this section, we describe two different algorithms (a static and a dynamic one) for ordering
the axiom templates of a query based on some costs and then we deal with the formulation
of these costs. We first introduce the abstract graph representation of a query q by means
of a labeled graph Gq on which we define the computed statistical costs.
Definition 9 (Query Join Graph). A query join graph Gq for a query q is a tuple
(V, E, EL ), where
265

Kollia & Glimm

‚Ä¢ V = q is a set of vertices (one for each axiom template);
‚Ä¢ E ‚äÜ V √ó V is a set of edges; such that hat1 , at2 i ‚àà E if Vars(at1 ) ‚à© Vars(at2 ) 6= ‚àÖ and
at1 6= at2 ;
‚Ä¢ EL is a function that assigns a set of variables to each hat1 , at2 i ‚àà E such that
EL (at1 , at2 ) = Vars(at1 ) ‚à© Vars(at2 ).
In the remainder, we use Gq for the query join graph of q.
Our goal is to find a query execution plan, which determines the evaluation order for
axiom templates in q. Since the number of possible execution plans is of order |q|!, the
ordering task quickly becomes impractical. In the following, we focus on greedy algorithms
for determining an execution order, which prune the search space considerably. Roughly
speaking, we proceed as follows: We define a cost function, which consists of two components
(i) an estimate for the costs of the reasoning tasks needed for the evaluation of an axiom
template and (ii) an estimate for the intermediate result size, i.e., the number of results
that the evaluation of an axiom template will incur. Both components are combined to
induce an order among axiom templates. In this paper, we simply build the sum of the
two cost components, but different combinations such as a weighted sum of the two values
could also be used. For the query plan construction we distinguish static from dynamic
planning. For the former, we start constructing the plan by adding a minimal template
according to the order. Variables from this template are then considered bound, which
changes the cost function and might induce a different order among the remaining axiom
templates. Considering the updated order, we again select the minimal axiom template that
is not yet in the plan and update the costs. This process continues until the plan contains
all templates. Once a complete plan has been determined the templates are evaluated.
The dynamic case differs in that after selecting a template for the plan, we immediately
determine the solutions for the chosen template, which are then used to update the cost
function. While this yields accurate cost estimates, it can be very costly when all solutions
are considered for updating the cost function. Sampling techniques can be used to only test
a subset of the solutions, but we show in Section 7 that random sampling, i.e., randomly
choosing a percentage of the individuals from the so far computed solutions, is not adequate.
For this reason, we propose an alternative sampling approach that is based on the use of the
previously described individual clusters. We first present an example to make the difference
between static and dynamic planning clearer and justify why dynamic ordering can be
beneficial in our setting.
Example 1. Let O be an ontology and q = {C(?x), r(?x, ?y), D(?y)} a conjunctive instance
query over O. Suppose that for the known and possible instances of the query concepts and
roles we have
K[C] = {a}

K[r] = ‚àÖ

K[D] = {b}

P [C] = {c, e}

P [r] = {hc, di, he, f i}

P [D] = {f, g, h}

And let us assume that the possible instances of C, D and r are, in fact, real instances (note
that we do not have this information from the beginning). Please have in mind that the
possible instances of concepts or roles are more costly to evaluate than the known instances
266

Optimizing SPARQL Query Answering over OWL Ontologies

since they require expensive consistency checks in order to decide whether they are real
instances.
According to static planning, an ordering for query atoms is first determined. In particular, the atom r(?x, ?y) is chosen first since it has the least number of known and possible instances (0 known and 2 possible versus 1 known and 2 possible for C(?x) and
1 known and 3 possible for D(?y)). Then the atom C(?x) is chosen since it has less
known and possible instances than D(?y), i.e., 1 known and 2 possible versus 1 known
and 3 possible for D(?y). Hence the chosen execution plan in static planning is P =
(r(?x, ?y), C(?x), D(?y)). Afterwards, the query is evaluated according to the chosen execution plan, i.e., the atom r(?x, ?y) is evaluated first, which gives the solution mappings
‚Ñ¶1 = {{?x 7‚Üí c, ?y 7‚Üí d}, {?x 7‚Üí e, ?y 7‚Üí f }}. This requires 2 consistency checks for the 2
possible instances of r. Afterwards, we check which of the ?x mappings, c and e, are known
or possible instances of C. Since both c and e are possible instances, we check whether they
are real instances of C (this requires 2 consistency checks). Hence, the solution mappings
are ‚Ñ¶2 = ‚Ñ¶1 = {{?x 7‚Üí c, ?y 7‚Üí d}, {?x 7‚Üí e, ?y 7‚Üí f }}. In the end, we check which of
the ?y mappings, d and f , are known or possible instances of D. For the only possible
instance, f , we find after one consistency check that f is indeed an instance of D. Hence,
the solution mappings for q are ‚Ñ¶O
q = {{?x 7‚Üí e, ?y 7‚Üí f }} and finding the solution required
5 consistency checks.
According to dynamic planning, an ordering is determined while we evaluate the query.
For the same reasons as before, the atom r(?x, ?y) is chosen to be evaluated first and the
solution mappings are, as before, ‚Ñ¶1 = {{?x 7‚Üí c, ?y 7‚Üí d}, {?x 7‚Üí e, ?y 7‚Üí f }} (this requires
2 consistency checks). We afterwards check which of the ?y mappings, d and f , are known
or possible instances of D. Note that this only requires a look-up since if we find d or f to be
among the possible instances, we do not check whether the individual is indeed an instance
or not. Here only f is a possible instance. We also check which of the ?x mappings, c and
e, are known or possible instances of C. Here, both c and e are possible instances, i.e., we
have 2 relevant possible instances for C(?x) and 1 for D(?y). Hence, the atom D(?y) is
chosen to be evaluated next, resulting in the solution sequence ‚Ñ¶2 = {{?x 7‚Üí e, ?y 7‚Üí f }} for
the (partial) execution plan (r(?x, ?y), D(?y)), requiring 1 consistency check. In the end,
we check whether the ?x mapping, e, is a known or possible instance of C. Since e is a
possible instance, we check whether it is a real instance (this requires 1 consistency check).
Hence, the solution mappings for q are ‚Ñ¶O
q = {{?x 7‚Üí e, ?y 7‚Üí f }}, which have been found
by performing 4 consistency checks, one less than in the static case.
Note that in dynamic ordering we perform less checks than in static ordering, since in
this case we can exploit the results of joins of query atoms and more information regarding
the possible instances of atoms (i.e., which of them are real instances), which is determined
as a result of evaluating the atoms while ordering them.
We now make the process of query plan construction more precise, but we leave the
exact details of defining the cost function and the ordering it induces to later.
Definition 10 (Static and Dynamic Ordering). A static (dynamic) cost function w.r.t.
O
q over O is a function s : q √ó 2V ars(q) ‚Üí R √ó R (d : q √ó 2Œìq ‚Üí R √ó R), where with ŒìO
q we
s
s
d
denote the set of compatible mappings for q over O. The two costs hEcat , Rsat i (hEcat , Rsdat i)
for an axiom template at ‚àà q are combined to yield a static ordering s ( dynamic ordering
267

Kollia & Glimm

d ), which is a total order over the axiom templates of q such that, for at, at‚Ä≤ ‚àà q, we say
that at s at‚Ä≤ (at d at‚Ä≤ ) iff Ecsat + Rssat ‚â§ Ecsat‚Ä≤ + Rssat‚Ä≤ (Ecdat + Rsdat ‚â§ Ecdat‚Ä≤ + Rsdat‚Ä≤ ).
An execution plan for q is a duplicate-free sequence of axiom templates from q. The
initial execution plan is the empty sequence and a complete execution plan is a sequence
containing all templates of q. Let Pi = (at1 , . . . , ati ) with i < |q| be an execution plan for
q with query join graph Gq = (V, E, EL ). The set of bound variables of ati within Pi is
Vb (ati ) = Vars(ati ) ‚à© Vars({at1 , . . . , ati‚àí1 }). Let Cq be the set of complex axiom templates
in q. We next define which axiom templates can be used to extend an incomplete execution
plan. Let at be an axiom template in Pi , the set suci (at) contains the axiom templates
that are connected to at and not yet in Pi , i.e., suci (at) = {at‚Ä≤ ‚àà q | hat, at‚Ä≤ i ‚àà E, at‚Ä≤ ‚àà
/
{at1 , . . . ati }}. Based on this, we define the set of connected successor axiom templates for
Pi as Si = {at | at‚Ä≤ ‚àà {at1 , . . . , ati } and at ‚àà suci (at‚Ä≤ )}. We further allow for including
axiom templates that are only connected to a complex axiom template from Si and define
the potential next templates qi for Pi w.r.t. Gq as qi = q if Pi is the initial execution plan
and otherwise
[
q i = Si ‚à™
suci (at).
at ‚àà Cq ‚à© Si

Given Pi , the static (dynamic) ordering induces an execution plan Pi+1 = (at1 , . . . , ati , ati+1 )
with ati+1 ‚àà qi and ati+1 s at (ati+1 d at) for each at ‚àà qi such that at 6= ati+1 .
Note that according to the above definition, for Pi an execution plan, it can be the case
that qi contains templates that are assigned the same minimal cost by the cost function.
In such case, one can choose any of these atoms to add to Pi . Moreover, according to
the above definition for the case of queries containing only simple axiom templates we
have that, for i > 0, the set of potential next templates only contains templates that are
connected to a template that is already in the plan since unconnected templates cause
an unnecessary blowup of the number of intermediate results. For queries with complex
templates the set of potential next axiom templates can additionally contain templates that
do not share common variables with any template that is already in the plan. This different
handling of queries with complex templates is reasonable since, before evaluating a complex
axiom template that requires many consistency checks, we want to reduce the number of
candidate bindings, by first evaluating other simple (cheaper) templates that bind variables
which appear in the complex one.
Example 2. Let O be an ontology and q = {?x ‚äë A, ?y ‚äë r, B ‚äë ‚àÉ?y.?x} a query over
O. Assuming that systems usually precompute the concept and role hierarchies before they
accept queries, the evaluation of the first two templates, i.e., ?x ‚äë A and ?y ‚äë r, require
cheap cache lookups, whereas the axiom template B ‚äë ‚àÉ?y.?x, requires costly consistency
checks. Hence, it is reasonable to first evaluate the first two (cheap) templates to reduce the
mappings for ?x and ?y and then evaluate the third (expensive) template, by checking which
of the reduced mappings yield an entailed axiom.
An example that shows the actual gain we get from handling the ordering of complex
axiom templates in this way is presented in Section 7.
Let n = |q| and Pn = (at1 , . . . , atn ) be a complete execution plan for q over O determined
by static ordering. The procedure to find the solution mappings ‚Ñ¶O
q for Pn is recursively
268

Optimizing SPARQL Query Answering over OWL Ontologies

defined as follows: Initially, our solution set contains only the identity mapping ‚Ñ¶0 = {¬µ0 },
which does not map any variable to any value. Assuming that we have evaluated the
sequence Pi = (at1 , . . . , ati ), i < n and we have found the set of solution mappings ‚Ñ¶i ,
in order to find the solution mappings ‚Ñ¶i+1 of Pi+1 , we use specific reasoning tasks to
extend the mappings in ‚Ñ¶i to cover the new variables of ati+1 if ati+1 is a simple axiom
template or the entailment check service of reasoners if ati+1 does not contain new variables
or if ati+1 is a complex axiom template. In dynamic planning the difference is that the
execution plan construction is interleaved with query evaluation. In particular, let n = |q|
and Pi = (at1 . . . ati ) with i < n be a (partial) execution plan for q determined by dynamic
ordering and let ‚Ñ¶i be the solution mappings of Pi . In order to find Pi+1 we extend Pi with
a new template, ati+1 , from q, i.e., Pi+1 = (at1 , . . . ati+1 ), which, according to the dynamic
cost function, has the minimal cost among the remaining templates q \ {at1 , . . . ati }. The
dynamic cost function assigns costs to templates at iteration i + 1 taking into account the
solution mappings ‚Ñ¶i . We afterwards evaluate the atom ati+1 , i.e., we find the solution
mappings ‚Ñ¶i+1 of Pi+1 by extending the solution mappings ‚Ñ¶i of Pi in the same way as in
the static case. In Section 6.3 in Algorithm 3, we show the complete procedure we follow
to answer a query.
We now define the cost functions s and d more precisely, which estimate the cost of the
required reasoner operations (first component) and the estimated result output size (second
component) of evaluating an axiom template. The intuition behind the estimated value
of the reasoner operation costs is that the evaluation of possible instances is much more
costly than the evaluation of known instances since possible instances require expensive
consistency checks whereas known instances require cheap cache lookups. The estimated
result size takes into account the number of known and possible instances and the probability
that possible instances are actual instances.
The time needed for an entailment check can change considerably between ontologies
and even within an ontology (depending on the involved concepts, roles and individuals).
In order to more accurately determine the entailment cost we use different entailment cost
values depending on whether the template under consideration is a template of the form i)
c1 (t), ii) r1 (t, t‚Ä≤ ), iii) t ‚âà t‚Ä≤ , where c1 is a concept term, r1 is a role term and t, t‚Ä≤ are individual
terms, iv) one of the rest simple axiom templates (that require consistency checks to be
evaluated) or a complex axiom template. In the following we write CL to denote the cost of
a cache lookup in the internal structures of the reasoner, CE as a placeholder for the relevant
entailment cost value and PIS for the possible instance success, i.e, the estimated percentage
of possible instances that are actual instances. The costs CL and CE are determined by
recording the average time of previously performed lookups and entailment checks for the
queried ontology, e.g., during the initial consistency check, classification, or for previous
queries. The possible instance success, PIS , was determined by testing several ontologies
and checking how many of the initial possible instances were real ones, which was around
50% in nearly all ontologies.
Apart from the relations for the known and possible instances from Section 4.1, we use
the following auxiliary relations:
Definition 11 (Successor and Predecessor Relations). Let r be a role and a an individual. We define sucK[r] and preK[r] as the set of individuals with known r-successors and
269

Kollia & Glimm

r-predecessors, respectively:
sucK[r] := {a | ‚àÉb.ha, bi ‚àà K[r]}

and

preK[r] := {a | ‚àÉb.hb, ai ‚àà K[r]}.

Similarly, we define sucK[r, a] and preK[r, a] as the known r-successors of a and the known
r-predecessors of a, respectively:
sucK[r, a] := {b | ha, bi ‚àà K[r]}

and

preK[r, a] := {b | hb, ai ‚àà K[r]}.

We analogously define the functions sucP[r], preP[r], sucP[r, a], and preP[r, a] by replacing
K[r] with P [r].
Next, we define the cost functions for the case of conjunctive instance queries, i.e.,
queries containing only query atoms. In Section 5.2 we extend the cost functions to deal
with general queries.
5.1 The Static and Dynamic Cost Functions for Conjunctive Instance Queries
The static cost function s takes two components as input: a query atom and a set containing
the variables of the query atom that are considered bound. The function returns a pair of
real numbers for the reasoning cost and the result size for the query atom.
Initially, all variables are unbound and we use the number of known and possible instances or successors/predecessors to estimate the number of required lookups and consistency checks for evaluating the query atom and for the resulting number of mappings. For
an input of the form hC(?x), ‚àÖi or hr(?x, ?y), ‚àÖi the resulting pair of real numbers for the
computational cost and the estimated result size is computed as
h|K[at]| ¬∑ d ¬∑ CL + |P [at]| ¬∑ d ¬∑ CE , |K[at]| + PIS ¬∑ |P [at]|i,
where at denotes the predicate of the query atom (C or r). For at a concept (role) atom,
the factor d represents the depth of the concept (role) in the concept (role) hierarchy.
We use this factor since we only store the direct types of each individual (roles of which
individuals are instances) and, in order to find the instances of a concept (role), we may
need to check all its subconcepts (subroles) for known or possible instances. If the query
atom is a role atom with a constant in the first place, i.e., the input to the cost function is
of the form hr(a, ?x), ‚àÖi, we use the relations for known and possible successors to estimate
the computational cost and result size:
h|sucK[r, a]| ¬∑ d ¬∑ CL + |sucP[r, a]| ¬∑ d ¬∑ CE , |sucK[r, a]| + PIS ¬∑ |sucP[r, a]|i.
Analogously, we use preK and preP instead of sucK and sucP for an input of the form
hr(?x, a), ‚àÖi. Finally, if the atom contains only constants, i.e., the input to the cost function
is of the form hC(a), ‚àÖi, hr(a, b), ‚àÖi, the function returns hd ¬∑ CL , 1i if the individual is a
known instance of the concept or role, hd ¬∑ CE , PIS i if the individual is a possible instance
and hd ¬∑ CL , 0i otherwise, i.e., if the individual is a known non-instance.
For equality atoms of the form ?x ‚âà?y, a ‚âà?x, ?x ‚âà a or a ‚âà b, we again exploit
information from the initial pre-model as described in Section 4.1. Based on the cardinality
of K‚âà [a] and P‚âà [a], we can define cost functions for the different cases of query atoms and
270

Optimizing SPARQL Query Answering over OWL Ontologies

bound variables. For inputs of the form h?x ‚âà a, ‚àÖi and ha ‚âà ?x, ‚àÖi, the cost function is
defined as:
h|K‚âà [a]| ¬∑ CL + |P‚âà [a]| ¬∑ CE , |K‚âà [a]| + PIS ¬∑ |P‚âà [a]|i.
For inputs of the form h?x ‚âà ?y, ‚àÖi, the cost function is computed as:
*
+
X
X
(|K‚âà [a]| ¬∑ CL + |P‚âà [a]| ¬∑ CE )/2,
(|K‚âà [a]| + PIS ¬∑ |P‚âà [a]|)/2 .
a‚ààNIO

a‚ààNIO

For inputs of the form ha ‚âà b, ‚àÖi, the function returns hCL , 1i if b ‚àà K‚âà [a], hCE , PIS i if
b ‚àà P‚âà [a], and hCL , 0i otherwise (i.e., b is not equivalent to a).
After determining the cost of an initial query atom, at least one variable of a consequently considered atom is bound, since during the query plan construction we move over
atoms sharing a common variable and we assume that the query is connected. We now define the cost functions for atoms with at least one variable bound. We make the assumption
that atoms with unbound variables are more costly to evaluate than atoms with all their
variables bound. For a query atom r(?x, ?y) with only ?x bound, i.e., function inputs of
the form hr(?x, ?y), {?x}i, we use the average number of known and possible successors of
the role to estimate the computational cost and result size:


|P [r]|
|K[r]|
|P [r]|
|K[r]|
¬∑ d ¬∑ CL +
¬∑ d ¬∑ CE ,
+
¬∑ PIS .
|sucK[r]|
|sucP[r]|
|sucK[r]| |sucP[r]|
In case only ?y in r(?x, ?y) is bound, we use the predecessor functions preK and preP instead
of sucK and sucP. Note that we now work with an estimated average number of successors
(predecessors) for one individual.
For atoms with all their variables bound, we use formulas that are comparable to the
ones above for an initial plan, but normalized to estimate the values for one individual. For
an input query atom of the form C(?x) with ?x a bound variable we use


|K[C]| ¬∑ d ¬∑ CL + |P [C]| ¬∑ d ¬∑ CE |K[C]| + PIS ¬∑ |P [C]|
,
.
|NIO |
|NIO |
Such a simple normalization is not always accurate, but leads to good results in most
cases as we show in Section 7. Similarly, we normalize the formulas for role atoms of the
form r(?x, ?y) such that {?x, ?y} is the set of bound variables of the atom. The two cost
components for these atoms are computed as


|K[r]| ¬∑ d ¬∑ CL + |P [r]| ¬∑ d ¬∑ CE |K[r]| + PIS ¬∑ |P [r]|
,
.
|NIO | ¬∑ |NIO |
|NIO | ¬∑ |NIO |
For role atoms with a constant and a bound variable, i.e., atoms of the form r(a, ?x)
(r(?x, a)) with ?x a bound variable, we use sucK[r, a] and sucP[r, a] (preK[r, a] and preP[r, a])
instead of K[r] and P [r] in the above formulas and we normalize by |NIO |.
Similarly, we normalize the cost functions for inputs with equality atoms and bound
variables, depending on whether the atoms contain one or two bound variables. For inputs
of the form h?x ‚âà a, {?x}i, ha ‚âà?x, {?x}i, we divide the cost function components for inputs
271

Kollia & Glimm

already executed
1
2
3
4
5
6
7

r(?x, ?y)
r(?x, ?y)
r(?x, ?y), D(?y)
r(?x, ?y), C(?x)

current atom at
C(?x)
r(?x, ?y)
D(?y)
C(?x)
D(?y)
C(?x)
D(?y)

K[at]
200
200
700
100
50
45
45

P [at]
350
200
600
150
50
35
40

real from P [at]
200
50
400
100
40
25
25

Table 1: Query Ordering Example
of the form h?x ‚âà a, ‚àÖi and ha ‚âà?x, ‚àÖi by |NIO |. For an input of the form h?x ‚âà y, {?x, ?y}i,
we divide the cost function components for input of the form h?x ‚âà?y, ‚àÖi by |NIO | ¬∑ |NIO |.
For inputs of the form h?x ‚âà?y, {?x}i, and h?x ‚âà?y, {?y}i, we divide the cost function
components for input of the form h?x ‚âà?y, ‚àÖi by |NIO |.
The dynamic cost function d is based on the static function s, but only uses the first
equations, where the atom contains only unbound variables or constants. The function
takes a pair hat, ‚Ñ¶i as input, where at is a query atom and ‚Ñ¶ is the set of solution mappings
for the atoms that have already been evaluated, and returns a pair of real numbers using
matrix addition as follows:
X
d(at, ‚Ñ¶) =
s(¬µ(at), ‚àÖ)
¬µ‚àà‚Ñ¶

When sampling techniques are used, we compute the costs for each of the potential next
atoms for an execution plan by only considering one individual of each relevant cluster.
Which cluster is relevant depends on the query atom for which we compute the cost function
and the previously computed bindings. For instance, if we compute the cost of a role atom
r(?x, ?y) and we have already determined bindings for ?x, we use the role successor cluster
P C1 . Among the ?x bindings, we then just check the cost for one binding per cluster and
assign the same cost to all other ?x bindings of the same cluster.
Example 3. Let us assume that we have a conjunctive instance query q and that we have
to find the cost (using the dynamic function) of the atom C(?x) within an execution plan
for q. We further assume that from the evaluation of previous query atoms in the plan
we have already determined a set of intermediate solutions ‚Ñ¶ with the mappings a, b, or c
for ?x. Let us assume that a, b, and c belong to the same concept cluster. According to
dynamic ordering we need to find the cost of each instantiated atom using the static cost
function, i.e., d(C(?x), ‚Ñ¶) = s(C(a), ‚àÖ) + s(C(b), ‚àÖ) + s(C(c), ‚àÖ). If we additionally use
cluster based sampling, we find the cost for only one individual of each cluster, let us say a,
and then assign the same cost to all other individuals from the cluster which are mappings
for ?x in ‚Ñ¶. Hence, the cost of the atom C(?x) when sampling is used, is computed as
d(C(?x), ‚Ñ¶) = 3 ¬∑ s(C(a), ‚àÖ) avoiding the computation of s(C(b), ‚àÖ) and s(C(c), ‚àÖ).
An example that is similar to Example 1 (but with a greater number of instances) and
shows how ordering is achieved by the use of the defined static and dynamic functions is
shown below. We assume that q is a query consisting of the three query atoms: C(?x),
272

Optimizing SPARQL Query Answering over OWL Ontologies

r(?x, ?y), D(?y). Table 1 gives information about the known and possible instances of
these atoms within a sequence. The second column shows already executed sequences
Pi‚àí1 = (at1 , . . . , ati‚àí1 ) for the atoms of q. Column 3 gives the current atom ati and column
4 (5) gives the number of mappings to known (possible) instances of at that satisfy at the
same time the atoms (at1 , . . . , ati‚àí1 ) from column 2. Column 6 gives the number of real
instances from the possible instances for the current atom. For example, row 4 says that we
have evaluated the atom r(?x, ?y) and, in order to evaluate C(?x), we only consider those
100 known and 150 possible instances of C that are also mappings for ?x. We further assume
that we have 10,000 individuals in our ontology O. We now explain, using the example,
how the above described formulas work. We assume that CL ‚â§ CE , which is always the
case since a cache lookup is less expensive than a consistency check and that the CE values
are the same for all query concepts and roles. For ease of presentation, we further do not
consider the factor for the depth of the concept (role) within the concept (role) hierarchy.
In both techniques (static and dynamic) the atom r(?x, ?y) is chosen first since it has the
least number of possible instances (200) while it has the same (or smaller) number of known
instances (200) as the other atoms (¬µ0 is the initial solution mapping that does not map
any variable):
s(r(?x, ?y), ‚àÖ) = d(r(?x, ?y), {¬µ0 }) = h200 ¬∑ CL + 200 ¬∑ CE , 200 + PIS ¬∑ 200i,
s(C(?x), ‚àÖ) = d(C(?x), {¬µ0 }) = h200 ¬∑ CL + 350 ¬∑ CE , 200 + PIS ¬∑ 350i,
s(D(?y), ‚àÖ) = d(D(?y), {¬µ0 }) = h700 ¬∑ CL + 600 ¬∑ CE , 700 + PIS ¬∑ 600i.
In the case of static ordering, the atom C(?x) is chosen after r(?x, ?y) since C has less
possible (and known) instances than D (350 versus 600):


350
200 + 350 ¬∑ PIS
200
¬∑ CL +
¬∑ CE ,
,
s(C(?x), {?x}) =
10, 000
10, 000
10, 000


700
600
700 + 600 ¬∑ PIS
s(D(?y), {?y}) =
¬∑ CL +
¬∑ CE ,
.
10, 000
10, 000
10, 000
Hence, the order of evaluation in this case is P = (r(?x, ?y), C(?x), D(?y)) leading to
200 (row 2) + 150 (row 4) + 40 (row 7) entailment checks. In the dynamic case, after the
evaluation of r(?x, ?y), which gives a set of solutions ‚Ñ¶1 , the atom D(?y) has fewer known
and possible instances (50 known and 50 possible) than the atom C(?x) (100 known and
150 possible) and, hence, a lower cost:
d(D(?y), ‚Ñ¶1 ) = h50 ¬∑ CL + 150 ¬∑ CL + 50 ¬∑ CE , 50 + 0 + 50 ¬∑ PIS i,
d(C(?x), ‚Ñ¶1 ) = h100 ¬∑ CL + 0 ¬∑ CL + 150 ¬∑ CE , 100 + 0 + 150 ¬∑ PIS i.
Note that applying a solution ¬µ ‚àà ‚Ñ¶1 to D(?y) (C(?x)) results in a query atom with a
constant in place of ?y (?x). For D(?y), it is the case that out of the 250 r-instances, 200
can be handled with a look-up (50 turn out to be known instances and 150 turn out not
to be instances of D), while 50 require an entailment check. Similarly, when considering
C(?x), we need 100 lookups and 150 entailment checks. Note that we assume the worst
case in this example, i.e., that all values that ?x and ?y take are different. Therefore,
the atom D(?y) is chosen next, leading to the execution of the query atoms in the order
P = (r(?x, ?y), D(?y), C(?x)) and the execution of 200 (row 2) + 50 (row 5) + 35 (row 6)
entailment checks.
273

Kollia & Glimm

5.2 Cost Functions for General Queries
We now explain how we order the remaining simple and complex axiom templates. We
again use statistics from the reasoner, whenever these are available. In case the reasoner
cannot give estimates, one can still work with statistics computed from explicitly stated
information or use upper bounds to estimate the reasoner costs and the result size of axiom
templates.
We first consider a general concept assertion axiom template. Let KC [a] be the concepts
of which a is a known instance, PC [a] the concepts of which a is a possible instance. These
sets are computed from the sets of known and possible instances of concepts. For an input
of the form h?x(a), ‚àÖi the cost function is defined as
h|KC [a]| ¬∑ d ¬∑ CL + |PC [a]| ¬∑ d ¬∑ CE , |KC [a]| + PIS ¬∑ |PC [a]|i.
For an input of the form h?x(?y), ‚àÖi, the cost function is defined as
*
+
X
X
(|K[C]| ¬∑ d ¬∑ CL + |P [C]| ¬∑ d ¬∑ CE ),
(|K[C]| + PIS ¬∑ |P [C]|) .
C‚ààNCO

C‚ààNCO

For inputs of the form h?x(a), {?x}i and h?x(?y), {?x, ?y}i, we normalize the above functions
by |NCO | and |NIO |¬∑|NCO | respectively. For inputs of the form h?x(?y), {?x}i and h?x(?y), {?y}i
we normalize the function for inputs of the form h?x(?y), ‚àÖi by |NCO | and |NIO | respectively.
For general role assertion axiom templates, there are several cases of cost functions depending on the bound variables. We next define the cost functions for some cases. The cost
functions for the other cases can similarly be defined. For an input of the form h?z(?x, ?y), ‚àÖi,
the cost function is defined as :
*
+
X
X
(|K[r]| ¬∑ d ¬∑ CL + |P [r]| ¬∑ d ¬∑ CE ),
(|K[r]| + PIS ¬∑ |P [r]|) .
r‚ààNRO

r‚ààNRO

For inputs of the form h?z(a, ?y), ‚àÖi, the cost function is defined as:
*
+
X
X
(|sucK[r, a]| ¬∑ d ¬∑ CL + |sucP[r, a]| ¬∑ d ¬∑ CE ),
(|sucK[r, a]| + PIS ¬∑ |sucP[r, a]|) .
r‚ààNRO

r‚ààNRO

For an input of the form h?z(?x, ?y), {?z}i, the cost function is defined as:
+
*
X |K[r]| ¬∑ d ¬∑ CL + |P [r]| ¬∑ d ¬∑ CE X |K[r]| + PIS ¬∑ |P [r]|
,
.
|NRO |
|NRO |
O
O
r‚ààNR

r‚ààNR

Last, for inputs of the form h?z(?x, ?y), {?x}i, the two cost components are computed as:
*
+
X |K[r]|
X |K[r]|
|P [r]|
|P [r]|
(
¬∑ d ¬∑ CL +
¬∑ d ¬∑ CE ),
+
¬∑PIS ) .
(
|sucK[r]|
|sucP[r]|
|sucK[r]| |sucP[r]|
O
O
r‚ààNR

r‚ààNR

274

Optimizing SPARQL Query Answering over OWL Ontologies

For concept (role) inclusion axiom templates of the form c1 ‚äë c2 (r1 ‚äë r2 ), where c1 , c2
concept terms (r1 , r2 role terms), that contain only concept (role) names and variables we
need lookups in the computed concept (role) hierarchy in order to compute the answers
(assuming that the concept (role) hierarchy is precomputed).
One can define similar cost functions for other types of axiom templates by either using
the available statistics or by relying on told information from the ontology. For this paper,
however, we just define a cost function based on the assumption that we iterate over all
possible values of the respective variables and do one consistency check for each value.
Hence, we define the following general cost function for these cases:
h|N | ¬∑ CE , |N |i,
where N ‚àà {NCO , NRO , NIO } as appropriate for the variable that is tested. As discussed in
Section 5.1, the dynamic function is based on the static one and is applied only to the above
described cases for an empty set of bound variables.
Proposition 1. Let q be a query over an ontology O, s and d the static and dynamic cost
functions defined in Sections 5.1 and 5.2. The ordering induced by s and d is a total order
over the axiom templates of q.
Proof. The cost functions s and d are defined for all kinds of axiom templates and return
two real numbers to each possible input. Since, according to Definition 10, the orders s
and d are based on the addition of the two real numbers, addition of reals yields again a
real number, and since ‚â§ is a total order over the reals, we immediately get that s and
d are total orders.
It is obvious that the ordering of axiom templates does not affect soundness and completeness of a query evaluation algorithm.

6. Complex Axiom Template Optimizations
In this section, we first describe some optimizations that we have developed for complex
axiom templates (Sections 6.1, 6.2) and then we present the procedure for evaluating queries
(Section 6.3).
6.1 Axiom Template Rewriting
Some costly to evaluate axiom templates can be rewritten into axiom templates that can
be evaluated more efficiently and yield an equivalent result. Before we go on to describe the
axiom template rewriting technique, we define what a concept template is, which is useful
throughout the section.
Definition 12 (Concept Template). Let Sq = (NC , NR , NR , VC , VR , VI ) be a query
signature w.r.t. a signature S = (NC , NR , NI ). A concept template over Sq is a SROIQ
concept over S, where one can also use concept variables from VC in place of concept names,
role variables from VR in place of role names and individual variables from VI in place of
individual names.
275

Kollia & Glimm

Definition 13 (Rewriting). Let O be an ontology, at ‚àà q an axiom template over Sq ,
t, t1 , . . . tn individuals or individual variables from Sq , and C, C1 , . . . , Cn concept templates
over Sq . The function rewrite takes an axiom template and returns a set of axiom templates
as follows:
‚Ä¢ if at = (C1 ‚äì . . . ‚äì Cn )(t), then rewrite(at) = {C1 (t), . . . , Cn (t)};
‚Ä¢ if at = C ‚äë C1 ‚äì . . . ‚äì Cn , then rewrite(at) = {C ‚äë C1 , . . . , C ‚äë Cn };
‚Ä¢ if at = C1 ‚äî . . . ‚äî Cn ‚äë C, then rewrite(at) = {C1 ‚äë C, . . . , Cn ‚äë C};
‚Ä¢ if at = t1 ‚âà . . . ‚âà tn , then rewrite(at) = {t1 ‚âà t2 , t2 ‚âà t3 , . . . , tn‚àí1 ‚âà tn }.
To understand the intuition behind such transformation, we consider a query with only
the axiom template: ?x ‚äë ‚àÉr.?y ‚äì A. Its evaluation requires a quadratic number of consistency checks in the number of concepts (since ?x and ?y are concept variables). The
rewriting yields: ?x ‚äë A and ?x ‚äë ‚àÉr.?y. The first axiom template is now evaluated with a
cheap cache lookup (assuming that the concept hierarchy has been precomputed). For the
second one, we only have to check the usually few resulting bindings for ?x combined with
all other concept names for ?y.
Note that Description Logics typically do not support n-ary equality axioms t1 ‚âà . . . ‚âà
tn , but only binary ones, whereas in OWL, one can typically also write n-ary equality axioms.
Since our cost functions are only defined for binary equality axioms, we equivalently rewrite
an n-ary one into several binary ones. One could even further optimize the evaluation of
such atoms by just evaluating one binary equality axiom template and by then propagating
the binding for the found equivalent individuals to the other equality axioms. This is valid
since equality is a congruence relation.
6.2 Concept and Role Hierarchy Exploitation
The number of consistency checks required to evaluate a query can be further reduced
by taking the concept and role hierarchies into account. Once the concepts and roles are
classified (this can ideally be done before a system accepts queries), the hierarchies are
stored in the reasoner‚Äôs internal structures. We further use the hierarchies to prune the
search space of solutions in the evaluation of certain axiom templates. We illustrate the
intuition with the example Infection ‚äë ‚àÉhasCausalLinkTo.?x. If A is not a solution and
B ‚äë A holds, then B is also not a solution. Thus, when searching for solutions for ?x, we
choose the next binding to test by traversing the concept hierarchy top-down. When we find
a non-solution A, the subtree rooted in A of the concept hierarchy can safely be pruned.
Queries over ontologies with a large number of concepts and a deep concept hierarchy
can, therefore, gain the maximum advantage from this optimization. We employ similar
optimizations using the role hierarchies.
In the example above, we can prune the subconcepts of A because ?x has positive
polarity in the axiom template Infection ‚äë ‚àÉhasCausalLinkTo.?x., i.e., ?x occurs positively
on the right hand side of the axiom template. In case a variable ?x has negative polarity
in an axiom template of the form C1 ‚äë C2 , i.e., ?x occurs directly or indirectly under a
negation on the right hand side of the axiom template or positively on the left-hand side of
an axiom template, one can, instead, prune the superconcepts.
276

Optimizing SPARQL Query Answering over OWL Ontologies

We next specify more precisely the polarity of a concept variable in a concept or axiom
template.
Definition 14 (Concept Polarity). Let ?x ‚àà VC be a concept variable and C, C1 , C2 , D
concept templates, r a role, and n ‚àà IN0 . We define the polarity of ?x in C as follows: ?x
occurs positively in ?x. Furthermore, ?x occurs positively (negatively)
‚Ä¢ in ¬¨D if ?x occurs negatively (positively) in D,
‚Ä¢ in C1 ‚äì C2 or C1 ‚äî C2 if ?x occurs positively (negatively) in C1 or C2 ,
‚Ä¢ in ‚àÉr.D, ‚àÄr.D, or > n r.D if ?x occurs positively (negatively) in D,
‚Ä¢ in 6 n r.D if ?x occurs negatively (positively) in D
‚Ä¢ in = n r.D if ?x occurs in D.
We further say that ?x occurs positively (negatively) in C1 ‚äë C2 if ?x occurs negatively
(positively) in C1 or positively (negatively) in C2 . Note that ?x can occur both positively
and negatively in a concept template. We further define a partial function polc that maps
a concept variable ?x and a concept template C (axiom template of the form C1 ‚äë C2 ) to
pos if ?x occurs only positively in C (C1 ‚äë C2 ) and to neg if ?x occurs only negatively in
C (C1 ‚äë C2 ).
Note that no matter whether ?x occurs positively or negatively in a concept template D,
in any concept template C of the form = n r.D, ?x occurs positively as well as negatively.
This is due to the fact that C is equivalent to the concept template 6 n r.D ‚äì > n r.D
in which ?x occurs positively as well as negatively. Since the function polc is not defined
for variables that appear both positively and negatively, the concept hierarchy cannot be
exploited in this case. For example, consider the concept template ¬¨?x ‚äî ‚àÉr.?x, (axiom
template ?x ‚äë ‚àÉr.?x), where ?x appears negatively in ¬¨?x and positively in ‚àÉr.?x. Now,
let Œ¥ ‚àà ‚àÜI be an arbitrary element from a model I = (‚àÜI , ¬∑I ) of the ontology. It is obvious
that if Œ¥ is an instance of ¬¨A ‚äî ‚àÉr.A and either A ‚äë B or B ‚äë A holds, we cannot deduce
that Œ¥ is an instance of ¬¨B ‚äî ‚àÉr.B.
Before proving the correctness of the proposed optimization, we first show the relationship between entailment and concept membership, which is used in the subsequent proofs.
Lemma 1. Let q be a query over O w.r.t. the query signature Sq = (NC , NR , NI , VC , VR , VI ),
at ‚àà q be an axiom template of the form C1 ‚äë C2 where C1 and C2 are concept templates
and let ¬µ be a mapping for at over O. It holds that O 6|= ¬µ(C1 ‚äë C2 ) iff there exists an
interpretation I = (‚àÜI , ¬∑I ) and an element Œ¥ ‚àà ‚àÜI such that I |= O and Œ¥ 6‚àà ¬µ(¬¨C1 ‚äî C2 )I .
Proof. O 6|= ¬µ(C1 ‚äë C2 ) holds iff there exists an interpretation I = (‚àÜI , ¬∑I ) and an element
Œ¥ ‚àà ‚àÜI such that I |= O and Œ¥ ‚àà ¬µ(C1 )I and Œ¥ 6‚àà ¬µ(C2 )I , which holds iff Œ¥ ‚àà ¬µ(C1 )I
and Œ¥ ‚àà ¬µ(¬¨C2 )I , which is equivalent to Œ¥ ‚àà ¬µ(C1 ‚äì ¬¨C2 )I , which is equivalent to Œ¥ ‚àà
¬µ(¬¨(¬¨C1 ‚äî C2 ))I , which holds iff Œ¥ 6‚àà ¬µ(¬¨C1 ‚äî C2 )I .
The following theorem holds for every axiom template of the form C1 ‚äë C2 . Note that
we assume here that concept assertion templates of the form C(a) are expressed as the
equivalent axiom templates {a} ‚äë C. We use C¬µ(?x)=A , where A is a concept name, to
denote the concept obtained by applying the extension of ¬µ that also maps ?x to A.
277

Kollia & Glimm

Theorem 1. Let O be an ontology, A, B concept names such that O |= A ‚äë B, C1 , C2
concept templates, C1 ‚äë C2 an axiom template, C = ¬¨C1 ‚äî C2 , ?x ‚àà VC a concept variable
occurring in C and ¬µ a mapping that covers all variables of C apart from ?x.
1. For polc (?x, C) = pos it holds that if O 6|= (C1 ‚äë C2 )¬µ(?x)=B , then O 6|= (C1 ‚äë C2 )¬µ(?x)=A .
2. For polc (?x, C) = neg it holds that if O 6|= (C1 ‚äë C2 )¬µ(?x)=A , then O 6|= (C1 ‚äë C2 )¬µ(?x)=B .
Proof. Due to Lemma 1, it suffices to show for some model I = (‚àÜI , ¬∑I ) of O and some
element Œ¥ ‚àà ‚àÜI the following (which is formalized in contrapositive form):
1. For polc (?x, C) = pos it holds that if Œ¥ ‚àà (C¬µ(?x)=A )I , then Œ¥ ‚àà (C¬µ(?x)=B )I .
2. For polc (?x, C) = neg it holds that if Œ¥ ‚àà (C¬µ(?x)=B )I , then Œ¥ ‚àà (C¬µ(?x)=A )I .
We prove the claim by induction on the structure of the concept template C:
‚Ä¢ For C =?x, ?x occurs positively in C. Now, if Œ¥ ‚àà (?x¬µ(?x)=A )I , that is Œ¥ ‚àà AI , it is
easy to see that Œ¥ ‚àà B I since O |= A ‚äë B by assumption. Hence, Œ¥ ‚àà (?x¬µ(?x)=B )I .
‚Ä¢ For C = ¬¨D and polc (?x, C) = pos, if Œ¥ ‚àà (¬¨D¬µ(?x)=A )I , we have to show that
Œ¥ ‚àà (¬¨D¬µ(?x)=B )I . Note that polc (?x, D) = neg. In contrary to what is to be shown,
assume that Œ¥ ‚àà (D¬µ(?x)=B )I . Since O |= A ‚äë B and by induction hypothesis Œ¥ ‚àà
(D¬µ(?x)=A )I and Œ¥ ‚àà (¬¨D¬µ(?x)=A )I which is a contradiction. The proof is analogous
for polc (?x, C) = neg.
‚Ä¢ For C = C1 ‚äì C2 and polc (?x, C) = pos, if Œ¥ ‚àà ((C1 ‚äì C2 )¬µ(?x)=A )I , then Œ¥ ‚àà
(C1¬µ(?x)=A )I and Œ¥ ‚àà (C2¬µ(?x)=A )I . Since O |= A ‚äë B and by induction hypothesis, Œ¥ ‚àà (C1¬µ(?x)=B )I and Œ¥ ‚àà (C2¬µ(?x)=B )I . Thus, Œ¥ ‚àà ((C1 ‚äì C2 )¬µ(?x)=B )I . The
proof is analogous for polc (?x, C) = neg.
‚Ä¢ The proof for C1 ‚äî C2 is analogous to the one for C1 ‚äì C2 .
‚Ä¢ For C = ‚àÉr.D and polc (?x, C) = pos, if Œ¥ ‚àà ((‚àÉr.D)¬µ(?x)=A )I , then Œ¥ has at least one rsuccessor, say Œ¥‚Ä≤ , that is an instance of D¬µ(?x)=A . Since O |= A ‚äë B and by induction
hypothesis, Œ¥‚Ä≤ ‚àà D¬µ(?x)=B . Hence, Œ¥ ‚àà (‚àÉr.(D¬µ(?x)=B ))I = ((‚àÉr.D)¬µ(?x)=B )I . The
proof is analogous for polc (?x, C) = neg.
‚Ä¢ For C = ‚àÄr.D and polc (?x, C) = pos, if Œ¥ ‚àà ((‚àÄr.D)¬µ(?x)=A )I , then Œ¥ ‚àà (‚àÄr.(D)¬µ(?x)=A )I
and each r-successors of Œ¥ is an instance of D¬µ(?x)=A . Since O |= A ‚äë B and by induction hypothesis, these r-successors are also instances of D¬µ(?x)=B . Hence, Œ¥ ‚àà
(‚àÄr.(D¬µ(?x)=B ))I = ((‚àÄr.D)¬µ(?x)=B )I . The proof is analogous for polc (?x, C) = neg.
‚Ä¢ For C = > n r.D and polc (?x, C) = pos, if Œ¥ ‚àà ((> n r.D)¬µ(?x)=A )I , then Œ¥ has at
least n distinct r-successors which are instances of D¬µ(?x)=A . Since O |= A ‚äë B and
by induction hypothesis, these successors are instances of D¬µ(?x)=B . Hence, Œ¥ has
at least n distinct r-successors that are instances of D¬µ(?x)=B and, therefore, Œ¥ ‚àà (>
n r.(D)¬µ(?x)=B )I = ((> n r.D)¬µ(?x)=B )I . The proof is analogous for polc (?x, C) = neg.
278

Optimizing SPARQL Query Answering over OWL Ontologies

‚Ä¢ For C = 6 n r.D and polc (?x, C) = pos, if Œ¥ ‚àà ((6 n r.D)¬µ(?x)=A )I , we have to show
that Œ¥ ‚àà ((6 n r.D)¬µ(?x)=B )I . Note that polc (?x, D) = neg. In contrary to what is to
be shown, assume that Œ¥ ‚àà (¬¨(6 n r.D)¬µ(?x)=B )I , i.e., Œ¥ ‚àà ((> n + 1 r.D)¬µ(?x)=B )I .
Hence, Œ¥ has at least n + 1 distinct r-successors which are instances of D¬µ(?x)=B .
Since polc (?x, D) = neg and by induction hypothesis, these D¬µ(?x)=B instances are
also D¬µ(?x)=A instances and Œ¥ ‚àà (> n + 1 r.(D)¬µ(?x)=A )I = ((> n + 1 r.D)¬µ(?x)=A )I ,
which is a contradiction. The proof is analogous for polc (?x, C) = neg.
‚Ä¢ For C = (= n r.D), the polarity of ?x in C is always positive and negative, so
polc (?x, C) is undefined and the case cannot occur.
We now extend this optimization to the case of role variables and we first define the
polarity of a role variable in a concept or axiom template.
Definition 15 (Role Polarity). Let ?x ‚àà VR be a role variable, C, C1 , C2 , D concept
templates, r a role, and n ‚àà IN0 . We define the polarity of ?x in C as follows: ?x occurs
positively in ‚àÉ?x.D, ‚àÉ?x‚àí .D, > n ?x.D, > n ?x‚àí .D, = n ?x.D, and = n ?x‚àí .D; ?x
occurs negatively in ‚àÄ?x.D, ‚àÄ?x‚àí .D, 6 n ?x.D, 6 n ?x‚àí .D, = n ?x.D, and = n ?x‚àí .D.
Furthermore, ?x occurs positively (negatively)
‚Ä¢ in ¬¨D if ?x occurs negatively (positively) in D,
‚Ä¢ in C1 ‚äì C2 or C1 ‚äî C2 if ?x occurs positively (negatively) in C1 or C2 ,
‚Ä¢ in ‚àÉr.D, ‚àÉ?x.D, ‚àÉ?x‚àí .D, > n r.D, > n ?x.D, > n ?x‚àí .D, ‚àÄr.D, ‚àÄ?x.D, or ‚àÄ?x‚àí .D
if ?x occurs positively (negatively) in D,
‚Ä¢ in 6 n r.D, 6 n ?x.D, or 6 n ?x‚àí .D if ?x occurs negatively (positively) in D,
‚Ä¢ in = n r.D if ?x occurs in D.
We further say that ?x occurs positively (negatively) in C1 ‚äë C2 if ?x occurs negatively
(positively) in C1 or positively (negatively) in C2 . We define a partial function polr that
maps a role variable ?x and a concept template C (axiom template of the form C1 ‚äë C2 ) to
pos if ?x occurs only positively in C (C1 ‚äë C2 ) and to neg if ?x occurs only negatively in
C (C1 ‚äë C2 ).
Note also that we do not make any assumption about occurrences of ?x in D in the first
part of the definition.
We now show, that the hierarchy optimization is also applicable to role variables, provided they occur only positively or only negatively.
Theorem 2. Let O be an ontology, r, s role names such that O |= r ‚äë s, C1 , C2 concept
templates, C1 ‚äë C2 an axiom template, C = ¬¨C1 ‚äî C2 , ?x ‚àà VR a role variable occurring
in C and ¬µ a mapping that covers all variables of C apart from ?x.
1. For polr (?x, C) = pos it holds that if O 6|= (C1 ‚äë C2 )¬µ(?x)=s , then O 6|= (C1 ‚äë C2 )¬µ(?x)=r .
2. For polr (?x, C) = neg it holds that if O 6|= (C1 ‚äë C2 )¬µ(?x)=r , then O 6|= (C1 ‚äë C2 )¬µ(?x)=s .
279

Kollia & Glimm

Proof. Due to Lemma 1, it suffices to show for some model I = (‚àÜI , ¬∑I ) of O and some
element Œ¥ ‚àà ‚àÜI the following (which is formalized in contrapositive form):
1. For polr (?x, C) = pos it holds that if Œ¥ ‚àà (C¬µ(?x)=r )I , then Œ¥ ‚àà (C¬µ(?x)=s )I .
2. For polr (?x, C) = neg it holds that if Œ¥ ‚àà (C¬µ(?x)=s )I , then Œ¥ ‚àà (C¬µ(?x)=r )I .
We prove the claim by induction on the structure of the concept template C:
‚Ä¢ For C = ‚àÉ?x.D, where D is a concept template that does not contain ?x. We have
polr (?x, C) = pos. Assume, Œ¥ ‚àà ((‚àÉ?x.D)¬µ(?x)=r )I , that is, Œ¥ ‚àà (‚àÉr.¬µ(D))I . Then
there is some Œ¥‚Ä≤ ‚àà ‚àÜI such that hŒ¥, Œ¥‚Ä≤ i ‚àà r I and Œ¥‚Ä≤ ‚àà ¬µ(D)I . Since O |= r ‚äë s, we also
have hŒ¥, Œ¥‚Ä≤ i ‚àà sI and, therefore, Œ¥ ‚àà (‚àÉs.¬µ(D))I = ((‚àÉ?x.D)¬µ(?x)=s )I .
‚Ä¢ For C = ‚àÄ?x.D, where D is a concept template that does not contain ?x. We have
polr (?x, C) = neg. If Œ¥ ‚àà ((‚àÄ?x.D)¬µ(?x)=s )I , we have to show that Œ¥ ‚àà ((‚àÄ?x.D)¬µ(?x)=r )I .
In contrary to what is to be shown, assume that Œ¥ ‚àà (¬¨(‚àÄ?x.D)¬µ(?x)=r )I , i.e., Œ¥ ‚àà
(‚àÉr.¬µ(¬¨D))I . Hence, there is some Œ¥‚Ä≤ ‚àà ‚àÜI such that hŒ¥, Œ¥‚Ä≤ i ‚àà r I and Œ¥‚Ä≤ ‚àà ¬µ(¬¨D)I .
Since O |= r ‚äë s, we also have hŒ¥, Œ¥‚Ä≤ i ‚àà sI and, therefore, Œ¥ ‚àà
/ (‚àÄs.¬µ(D))I =
I
((‚àÄ?x.D)¬µ(?x)=s ) , which is a contradiction.
‚Ä¢ For C = > n ?x.D where D is a concept template that does not contain ?x. We have
polr (?x, C) = pos. Assume, Œ¥ ‚àà ((> n ?x.D)¬µ(?x)=r )I , that is Œ¥ ‚àà (> n r.¬µ(D))I and
Œ¥ has at least n distinct r-successors which are instances of ¬µ(D). Since O |= r ‚äë s
these r-successors are also s-successors of Œ¥ and, therefore, Œ¥ ‚àà (> n s.¬µ(D))I = ((>
n ?x.D)¬µ(?x)=s )I .
‚Ä¢ For C = 6 n ?x.D where C is a concept template that does not contain ?x. We
have polr (?x, C) = neg. If Œ¥ ‚àà ((6 n ?x.D)¬µ(?x)=s )I , we have to show that Œ¥ ‚àà
((6 n ?x.D)¬µ(?x)=r )I . In contrary to what is to be shown, assume that Œ¥ ‚àà (¬¨(6
n ?x.D)¬µ(?x)=r )I , i.e., Œ¥ ‚àà (> n + 1 r.¬µ(D))I . Hence, Œ¥ has at least n + 1 distinct
r-successors, which are instances of ¬µ(D). Since O |= r ‚äë s, these r-successors are
also s-successors and Œ¥ ‚àà ((> n + 1 s.¬µ(D)))I = ((> n + 1 ?x.D)¬µ(?x)=s )I , which is a
contradiction.
‚Ä¢ For C = C1 ‚äìC2 and polr (?x, C) = pos, if Œ¥ ‚àà ((C1 ‚äìC2 )¬µ(?x)=r )I , then Œ¥ ‚àà (C1 ¬µ(?x)=r )I
and Œ¥ ‚àà (C2 ¬µ(?x)=r )I . Since O |= r ‚äë s and by the induction hypothesis, Œ¥ ‚àà
(C1¬µ(?x)=s )I and Œ¥ ‚àà (C2¬µ(?x)=s )I . Thus, Œ¥ ‚àà ((C1 ‚äì C2 )¬µ(?x)=s )I . The proof is
analogous for polr (?x, C) = neg.
‚Ä¢ The proof for C1 ‚äî C2 is analogous to the one for C1 ‚äì C2 .
‚Ä¢ For C = ¬¨D and polr (?x, C) = pos, if Œ¥ ‚àà (¬¨D¬µ(?x)=r )I , we have to show that
Œ¥ ‚àà (¬¨D¬µ(?x)=s )I . Note that polr (?x, D) = neg. In contrary to what is to be shown,
assume that Œ¥ ‚àà (D¬µ(?x)=s )I . Since O |= r ‚äë s and by induction hypothesis Œ¥ ‚àà
(D¬µ(?x)=r )I and Œ¥ ‚àà (¬¨D¬µ(?x)=r )I which is a contradiction. The proof is analogous
for polr (?x, C) = neg.
280

Optimizing SPARQL Query Answering over OWL Ontologies

‚Ä¢ For C = ‚àÉp.D and polr (?x, C) = pos, we also have polr (?x, D) = pos. Now, if
Œ¥ ‚àà ((‚àÉp.D)¬µ(?x)=r )I , then Œ¥ has at least one p-successor that is an instance of D¬µ(?x)=r .
Since O |= r ‚äë s and by induction hypothesis, this p-successor is an instance of
D¬µ(?x)=s . Hence, Œ¥ ‚àà ((‚àÉp.D)¬µ(?x)=s )I . The proof is analogous for polr (?x, C) = neg.
‚Ä¢ For C = ‚àÉ?x.D and polr (?x, C) = pos, we also have polr (?x, D) = pos. Note
that ?x occurs in D since otherwise the case is handled already above. Now, if
Œ¥ ‚àà ((‚àÉ?x.D)¬µ(?x)=r )I , then Œ¥ has at least one r-successor which is an instance of
D¬µ(?x)=r . Since O |= r ‚äë s and by induction hypothesis, Œ¥ has at least one s-successor
that is an instance of D¬µ(?x)=s . Hence, Œ¥ ‚àà ((‚àÉ?x.D)¬µ(?x)=s )I .
‚Ä¢ For C = ‚àÄp.D and polr (?x, C) = pos, we also have polr (?x, D) = pos. Now, if Œ¥ ‚àà
((‚àÄp.D)¬µ(?x)=r )I , then Œ¥ ‚àà (‚àÄp.(D)¬µ(?x)=r )I and each p-successor of Œ¥ is an instance
of D¬µ(?x)=r . Since O |= r ‚äë s and by induction hypothesis, these p-successors are also
instances of D¬µ(?x)=s . Hence, Œ¥ ‚àà (‚àÄp.(D¬µ(?x)=s ))I = ((‚àÄp.D)¬µ(?x)=s )I . The proof is
analogous for polr (?x, C) = neg.
‚Ä¢ For C = ‚àÄ?x.D and polr (?x, C) = neg, we also have polr (?x, D) = neg. Note
that ?x occurs in D since otherwise the case is handled already above. Now, if
Œ¥ ‚àà ((‚àÄ?x.D)¬µ(?x)=s )I , we have to show that Œ¥ ‚àà ((‚àÄ?x.D)¬µ(?x)=r )I . In contrary to
what is to be shown, assume that Œ¥ ‚àà
/ ((‚àÄ?x.D)¬µ(?x)=r )I , i.e., Œ¥ ‚àà (‚àÉr.(¬¨D)¬µ(?x)=r )I .
Hence, there is some Œ¥‚Ä≤ ‚àà ‚àÜI such that hŒ¥, Œ¥‚Ä≤ i ‚àà r I and Œ¥‚Ä≤ ‚àà ((¬¨D)¬µ(?x)=r )I . Since
O |= r ‚äë s, Œ¥‚Ä≤ is also an s-successor of Œ¥ and, by induction hypothesis, we have
Œ¥‚Ä≤ ‚àà ((¬¨D)¬µ(?x)=s )I which is a contradiction.
‚Ä¢ For C = > n p.D and polr (?x, C) = pos, if Œ¥ ‚àà (( > n p.D)¬µ(?x)=r )I , then Œ¥ has at
least n distinct p-successors that are instances of D¬µ(?x)=r . Since O |= r ‚äë s and
by induction hypothesis, these p-successors are also instances of D¬µ(?x)=s . Hence,
Œ¥ ‚àà (( > n p.D)¬µ(?x)=s )I . The proof is analogous for polr (?x, C) = neg
‚Ä¢ For C = > n ?x.D and polr (?x, C) = pos, we also have polr (?x, D) = pos. Note
that ?x occurs in D since otherwise the case is handled already above. Now, if
Œ¥ ‚àà (( > n ?x.D)¬µ(?x)=r )I , then Œ¥ has at least n distinct r-successors which are
instances of D¬µ(?x)=r . Since O |= r ‚äë s and by induction hypothesis, Œ¥ has at least n
distinct s-successors that are instances of D¬µ(?x)=s . Hence, Œ¥ ‚àà (( > n ?x.D)¬µ(?x)=s )I .
‚Ä¢ For C = 6 n p.D and polr (?x, C) = pos, if Œ¥ ‚àà ((6 n p.D)¬µ(?x)=r )I , we have to show
that Œ¥ ‚àà ((6 n p.D)¬µ(?x)=s )I . Note that polr (?x, D) = neg. In contrary to what is to
be shown, assume that Œ¥ ‚àà (¬¨(6 n p.D)¬µ(?x)=s )I , i.e., Œ¥ ‚àà ((> n + 1 p.D)¬µ(?x)=s )I .
Hence, Œ¥ has at least n + 1 distinct p-successors which are instances of D¬µ(?x)=s .
Since polr (?x, D) = neg and by induction hypothesis, these D¬µ(?x)=s instances are
also D¬µ(?x)=r instances and Œ¥ ‚àà (> n + 1 p.(D)¬µ(?x)=r )I = ((> n + 1 p.D)¬µ(?x)=r )I ,
which is a contradiction. The proof is analogous for polr (?x, C) = neg.
‚Ä¢ For C = 6 n ?x.D and polr (?x, C) = neg, we have polr (?x, D) = pos. Note that
?x occurs in D since otherwise the case is handled already above. If Œ¥ ‚àà ((6
n ?x.D)¬µ(?x)=s )I we have to show that Œ¥ ‚àà ((6 n ?x.D)¬µ(?x)=r )I . In contrary
281

Kollia & Glimm

Algorithm 2 getPossibleMappings(O, ?x, at, ¬µ)
Input: O: the queried SROIQ ontology
?x: a concept or role variable
at: an axiom template in which ?x occurs
¬µ: a mapping with ?x ‚àà dom(¬µ)
Output: a set of mappings
1: S := ‚àÖ
2: if ?x ‚àà VC then
3:
if polc (?x, at) = pos then
4:
S := {¬µ‚Ä≤ | ¬µ‚Ä≤ (?x) = A, A is a direct subconcept of ¬µ(?x) in O,
¬µ‚Ä≤ (?y) = ¬µ(?y) for ?y ‚àà dom(¬µ) \ {?x}}
5:
else
6:
S := {¬µ‚Ä≤ | ¬µ‚Ä≤ (?x) = A, A is a direct superconcept of ¬µ(?x) in O,
¬µ‚Ä≤ (?y) = ¬µ(?y) for ?y ‚àà dom(¬µ) \ {?x}}
7:
end if
8: else
9:
if polr (?x, at) = pos then
10:
S := {¬µ‚Ä≤ | ¬µ‚Ä≤ (?x) = r, r is a direct subrole of ¬µ(?x) in O,
¬µ‚Ä≤ (?y) = ¬µ(?y) for ?y ‚àà dom(¬µ) \ {?x}}
11:
else
12:
S := {¬µ‚Ä≤ | ¬µ‚Ä≤ (?x) = r, r is a direct superrole of ¬µ(?x) in O,
¬µ‚Ä≤ (?y) = ¬µ(?y) for ?y ‚àà dom(¬µ) \ {?x}}
13:
end if
14: end if
15: return S
to what is to be shown, assume that Œ¥ ‚àà (¬¨(6 n ?x.D)¬µ(?x)=r )I , i.e., Œ¥ ‚àà ((>
n + 1 ?x.D)¬µ(?x)=r )I . Hence, Œ¥ has at least n + 1 distinct r-successors which are instances of D¬µ(?x)=r . Since O |= r ‚äë s, and by induction hypothesis, these r-successors
are also s-successors and instances of D¬µ(?x)=s . Hence, Œ¥ ‚àà ((> n + 1 ?x.D)¬µ(?x)=s )I
and Œ¥ ‚àà ((6 n ?x.D)¬µ(?x)=s )I , which is a contradiction.
‚Ä¢ For C = (= n ?x.D) or C = (= n r.D), the polarity of ?x in C is always positive
and negative, so polr (?x, C) is undefined and the case cannot occur.
‚Ä¢ The cases for ?x occurring in the form of an inverse (?x‚àí ) are analogous, given that
O |= r ‚äë s iff O |= r ‚àí ‚äë s‚àí .
Algorithm 2, which we explain in detail in Section 6.3, shows how we use the above
theorems to create possible concept and role mappings for a concept or role variable ?x
that appears only positively or only negatively in an axiom template C1 ‚äë C2 .
6.3 Query Answering Algorithm
Algorithm 3 shows an optimized way of evaluating queries using static ordering. First,
axiom templates are simplified where possible (method rewrite in line 1). Next, the method
282

Optimizing SPARQL Query Answering over OWL Ontologies

Algorithm 3 evaluate(O, q)
Input: O: the queried SROIQ ontology
q: a query over O
Output: a set of solutions for evaluating q over O
1: At := rewrite(q)
2: At1 , . . . , Atm :=connectedComponents(At)
3: for j=1, . . . , m do
4:
Rj := {¬µ0 | dom(¬µ0 ) = ‚àÖ}
5:
at1 , . . . , atn := order(Atj )
6:
for i = 1, . . . , n do
7:
R := ‚àÖ
8:
for each ¬µ ‚àà Rj do
9:
if isSimple(ati ) and Vars(ati ) \ dom(¬µ) 6= ‚àÖ then
10:
R := R ‚à™ {¬µ‚Ä≤ ‚à™ ¬µ | ¬µ‚Ä≤ ‚àà callSpecificReasonerTask(¬µ(ati ))}
11:
else if Vars(ati ) \ dom(¬µ) = ‚àÖ then
12:
if O |= ¬µ(ati ) then
13:
R := R ‚à™ {¬µ}
14:
end if
15:
else
16:
Vopt := {?x |?x 6‚àà dom(¬µ), Theorem 1 or 2 applies to ?x and ati }
17:
B := initializeVariableMappings(O, ati , ¬µ, Vopt )
18:
while B 6= ‚àÖ do
19:
¬µ‚Ä≤ := removeMapping(B)
20:
if O |= ¬µ‚Ä≤ (ati ) then
21:
R := R ‚à™ {¬µ‚Ä≤‚Ä≤ | ¬µ‚Ä≤‚Ä≤ (?x) = ¬µ‚Ä≤ (?x) if ?x ‚àà
/ Vopt and
¬µ‚Ä≤‚Ä≤ (?x) = C if ?x ‚àà Vopt ‚à© VC , O |= C ‚â° ¬µ‚Ä≤ (?x) and
¬µ‚Ä≤‚Ä≤ (?x) = r if ?x ‚àà Vopt ‚à© VR , O |= r ‚â° ¬µ‚Ä≤ (?x)}
22:
for each ?x ‚àà Vopt do
23:
B := B ‚à™ getPossibleMappings(O, ?x, ati , ¬µ‚Ä≤ )
24:
end for
25:
end if
26:
end while
27:
end if
28:
end for
29:
Rj := R
30:
end for
31: end for
32: Rans := {¬µ1 ‚à™ . . . ‚à™ ¬µm | ¬µj ‚àà Rj , 1 ‚â§ j ‚â§ m}
33: return Rans

connectedComponents (line 2) partitions the axiom templates into sets of connected components, i.e., within a component the templates share common variables, whereas between
components there are no shared variables. Unconnected components unnecessarily increase
the amount of intermediate results and, instead, one can simply combine the results for the
283

Kollia & Glimm

Algorithm 4 initializeVariableMappings(O, at, ¬µ, Vopt )
Input: O: the queried SROIQ ontology
at: an axiom template
¬µ: a partial mapping
Vopt : the variables of at to which Theorem 1 or 2 applies
Output: a set of mappings
1: S := {¬µ}
2: for each ?x ‚àà Vars(at) \ dom(¬µ) do
3:
R := ‚àÖ
4:
if ?x ‚àà VC and ?x ‚àà Vopt then
5:
for each ¬µ‚Ä≤ ‚àà S do
6:
if polc (?x, at) = pos then
7:
¬µ‚Ä≤ (?x) := ‚ä§
8:
else
9:
¬µ‚Ä≤ (?x) := ‚ä•
10:
end if
11:
R := R ‚à™ {¬µ‚Ä≤ }
12:
end for
13:
else if ?x ‚àà VR and ?x ‚àà Vopt then
14:
for each ¬µ‚Ä≤ ‚àà S do
15:
if polr (?x, at) = pos then
16:
¬µ‚Ä≤ (?x) := ‚ä§r
17:
else
18:
¬µ‚Ä≤ (?x) := ‚ä•r
19:
end if
20:
R := R ‚à™ {¬µ‚Ä≤ }
21:
end for
22:
else
23:
R := {¬µ‚Ä≤ | ¬µ‚Ä≤ (?x) = a, a ‚àà NCO or a ‚àà NRO or a ‚àà NIO and ¬µ‚Ä≤ (?y) = ¬µ1 (?y)
for ¬µ1 ‚àà S and ?y ‚àà dom(¬µ1 )}
24:
end if
25:
S := R
26: end for
27: return S

components in the end (line 32). For each component, we proceed as described below: we
first determine an order (method order in line 5) as described in Section 5. For a simple axiom template, which contains so far unbound variables, we call a specialized reasoner method
to retrieve entailed results, i.e., mappings for unbound variables (callSpecificReasonerTask
in line 10). Note that the mappings ¬µ‚Ä≤ do not assign values to any of the variables covered
by the already computed (partial) solution ¬µ since we instantiate the atom ati by ¬µ. This
allows for defining the union of ¬µ and ¬µ‚Ä≤ by setting (¬µ ‚à™ ¬µ‚Ä≤ )(v) = ¬µ(v) if v ‚àà dom(¬µ),
and (¬µ ‚à™ ¬µ‚Ä≤ )(v) = ¬µ‚Ä≤ (v) otherwise. For templates with all their variables bound, we check
whether the mappings lead to entailed axioms (lines 11 to 14). For all other cases, i.e.,
284

Optimizing SPARQL Query Answering over OWL Ontologies

for complex axiom templates with unbound variables, we check which compatible mappings
yield an entailed axiom (lines 15 to 27). In particular, we first initialize a set B of candidate mappings for the unbound variables of the axiom template (line 17, which refers to
Algorithm 4). Algorithm 4 initializes the unbound variables of axiom templates on which
Theorem 1 or 2 applies to ‚ä§ (‚ä§r ) or ‚ä• (‚ä•r ) depending on whether the respective polarity
function returns pos or neg. For template variables on which the optimization is not applicable, all compatible mappings are returned. The method removeMapping (line 19) returns
a mapping from B and deletes this mapping from B. We then instantiate the axiom template and check entailment. In case the entailment holds, we first extend the set R with the
current mapping ¬µ‚Ä≤ and with mappings that map the optimization variables to equivalent
concepts or roles of the respective variable mappings in ¬µ‚Ä≤ (line 21) and we afterwards extend the set B of possible mappings for the variables to which the hierarchy optimization
is applicable (getPossibleMappings in line 23). For example, if we just checked a mapping ¬µ
that maps a concept variable ?x to the concept A and ?x only occurs positively in the axiom
template, then we add to the set B all mappings that map ?x to a direct subconcept3 of
A (see Algorithm 2 line 4). In the implementation we use a more involved procedure, i.e.,
in order to avoid checking entailment of an instantiated axiom template more than once
with the same mapping, which can be the case with the concept (role) hierarchy traversal
that we perform, we keep track of already processed mappings and check only those that
have not been checked in a previous iteration of the while loop (lines 18 to 26). For ease
of presentation, this is not shown in Algorithm 3. We then repeat the procedure until B is
empty (lines 18 to 26).
For the dynamic ordering, Algorithm 3 has to be changed as follows: We first compute
the number of axiom templates in Atj ; n := |Atj |. We then swap line 5 and line 6, i.e.,
instead of ordering all axiom templates before the loop that evaluates the axiom templates,
we order within the for loop. The function order gets as additional input parameter the
set of currently computed solutions and returns only the next cheapest axiom template
according to the dynamic ordering function. Hence, we have ati := order(Atj , Rj ) instead
of at1 , . . . , atn := order(Atj ). We further insert a line after calling order to remove the
cheapest axiom template from the current component: Atj := Atj \ {ati }. As a result, the
next iteration of the for loop will compute the cheapest axiom template amongst the not
yet evaluated templates until, in the last iteration, we only have one axiom template left.
Algorithm 3 is sound and complete. The soundness and completeness of the algorithm
is based on the following facts:
‚Ä¢ The method rewrite (see Definition 13) does not affect the answers to a query q, since
it rewrites axiom templates to templates with the same set of answers.
‚Ä¢ The method connectedComponents does not affect the answers of q; it just splits the
query into several components that are evaluated separately and we then take the
cartesian product of the answers.
‚Ä¢ The method order does not change the query in any way; it just reorders the axiom
templates.
3. We say that a concept name A is a direct subconcept of a concept name B w.r.t. O, if O |= A ‚äë B and
there is no other concept name A‚Ä≤ such that O |= A‚Ä≤ ‚äë B, O |= A ‚äë A‚Ä≤ and O 6|= A ‚â° A‚Ä≤ . In a similar
way we can define the direct superconcept, the direct subrole and direct superrole.

285

Kollia & Glimm

‚Ä¢ For the actual axiom template evaluation, we iterate over all the templates of the
query by taking into account the mappings that have already been computed from
the evaluation of previous templates and we distinguish between three cases:
1. The axiom template is a simple one and contains unbound variables. We use
specialized reasoner tasks to compute entailed mappings and since we use a
sound and complete reasoner the result is indeed sound and complete.
2. The axiom template does not contain unbound variables. In this case, we simply
check entailment using a sound and complete reasoner.
3. The axiom template is a complex template that has at least one variable unbound.
For variables for which the optimization of Section 6.2 is applicable, we initialize
the variables to ‚ä§/‚ä§r (‚ä•/‚ä•r ) and we traverse the concept/role hierarchy topdown (bottom-up). We prune mappings according to Theorems 1 and 2 in case
a checked mapping does not constitute a solution mapping. In this case, we do
not extend the set of possible mappings B. For variables of axiom templates
to which the hierarchy optimization is not applicable, we check all compatible
mappings. Thus, due to Theorem 1 and 2 the procedure is sound and complete.
Although the above algorithm was implemented in the HermiT reasoner, one can compute the answers of a query using any (hyper)tableau reasoner.

7. Evaluation
We tested the developed optimizations with standard benchmarks and a range of custom
queries that test complex axiom template evaluation over more expressive ontologies. All
experiments were performed on a Mac OS X Lion machine with a 2.53 GHz Intel Core i7
processor and Java 1.6 allowing 1GB of Java heap space. We measure the time for one-off
tasks such as classification separately since such tasks are usually performed before the
system accepts queries. The ontologies and all code required to perform the experiments
are available online (Kollia & Glimm, 2013). The developed system (Glimm & Kollia,
2013), called OWL-BGP, is implemented as a SPARQL Wrapper that can be used with
any reasoner that implements the OWLReasoner interface of the OWL API (Horridge &
Bechhofer, 2009). In Section 7.1 we compare the different ordering strategies that have been
developed on two benchmarks (LUBM and UOBM) that contain queries with variables only
in place of individuals (query atoms). We also show the effect of ordering on LUBM using
some custom queries with simple axiom templates created for SPARQL-DL (Kremen &
Sirin, 2008). In Section 7.2 we show the effect of the proposed optimizations for queries
with complex axiom templates. For the evaluation we have used the HermiT hypertableau
reasoner (Motik, Shearer, Glimm, Stoilos, & Horrocks, 2013). Other reasoners such as
Pellet (Clark & Parsia, 2013a) or Racer Pro (Racer Systems GmbH & Co. KG, 2013) could
equally well be used with our implementation as long as they provide an interface with the
required statistics, i.e., the number of known and possible instances of concepts and roles for
the computation of the cost functions used for query ordering. Without any optimizations,
providing this interface with statistics can easily be realized as described in the current
paper. The presented query ordering techniques can also be used when optimizations such
286

Optimizing SPARQL Query Answering over OWL Ontologies

as caching, pseudo model merging techniques, binary instance retrieval, or absorption are
employed. The cost functions might, however, require some adaptation to take the reduction
in the required number of consistency checks into account. For example, Pellet uses binary
instance retrieval, where testing possible instances of a concept A is realized by splitting
the candidate instances into two partitions. For each partition, a single consistency check
is performed. If the consistency check is successful, it is safe to consider all individuals
belonging to the partition as non-instances of the tested concept A. Otherwise, we further
split the partition and process the resulting partitions in the same way. In this case, one
performs one consistency check to potentially determine several (non-)instances of A, which
should be reflected in the cost functions.
It is also worth noting that the TrOWL reasoning framework (Thomas, Pan, & Ren,
2013) started to use our SPARQL wrapper to provide SPARQL support. An adaptation to
also provide statistics is, to the best of our knowledge, still outstanding, although this should
be straightforward. TrOWL is based on two approximate reasoners: one that underapproximates (computation of concept and role instances is sound, but incomplete) (Ren, Pan, &
Zhao, 2010) and one that overapproximates (computation of concept and role instances is
complete, but unsound) (Pan, Thomas, & Zhao, 2009). In such a setting, the underapproximation can straightforwardly be seen as the known instances and the overapproximation
minus the underapproximation as the possible instances.
7.1 Query Ordering
We tested our ordering techniques with the Lehigh University Benchmark (LUBM) (Guo,
Pan, & Heflin, 2005) as a case where no disjunctive information is present and with the
more expressive University Ontology Benchmark (UOBM) (Ma, Yang, Qiu, Xie, Pan, &
Liu, 2006).
We first used the 14 conjunctive ABox queries provided in LUBM. From these, queries
2, 7, 8, 9 are the most interesting ones in our setting since they contain many atoms and
ordering them can have an effect in running time. We tested the queries on LUBM(1,0) and
LUBM(2,0) which contain data for one or two universities respectively, starting from index
0. LUBM(1,0) contains 17,174 individuals and LUBM(2,0) contains 38,334 individuals.
LUBM(1,0) took 19 s to load and 0.092 s for classification and initialization of known and
possible instances of concepts and roles. The clustering approach for concepts took 1 s
and resulted in 16 clusters. The clustering approach for roles lasted 4.9 s and resulted in
17 role successor clusters, 29 role predecessor clusters and 87 role clusters. LUBM(2,0)
took 48.5 s to load and 0.136 s for classification and initialization of known and possible
instances. The clustering approach for concepts took 3.4 s and resulted in 16 clusters. The
clustering approach for roles lasted 16.3 s and resulted in 17 role successor clusters, 31 role
predecessor clusters and 102 role clusters. Table 2 shows the execution time for each of
the four queries for LUBM(1,0) and LUBM(2,0) for four cases: i) when we use the static
algorithm (columns 2 and 6), ii) when we use the dynamic algorithm (columns 3 and 7), iii)
when we use random sampling, i.e., taking half of the individuals that are returned (from
the evaluation of previous query atoms) in each run, to decide about the next cheapest atom
to be evaluated in the dynamic case and iv) using the proposed sampling approach that
is based on clusters constructed from individuals in the queried ontology (columns 4 and
287

Kollia & Glimm

Q
‚àó2
7
8
‚àó9

Static
51
25
485
1,099

LUBM(1,0)
Dynamic RSampling
119
390
29
852
644
639
2,935
3,021

CSampling
37
20
551
769

Static
162
70
622
6,108

LUBM(2,0)
Dynamic RSampling
442
1,036
77
2,733
866
631
23,202
14,362

CSampling
153
64
660
3,018

Table 2: Query answering times in milliseconds for LUBM(1,0) and LUBM(2,0) using i) the
static algorithm ii) the dynamic algorithm, iii) 50% random sampling (RSampling),
iv) the constructed individual clusters for sampling (CSampling)

Q

PlansNo

2
7
8
9

336
14
56
336

Chosen Plan Order
Static Dynamic Sampling
2
1
1
1
1
1
1
1
1
173
160
150

Pellet Plan

Worst Plan

51
25
495
1,235

4,930
7,519
1,782
5,388

Table 3: Statistics about the constructed plans and chosen orderings and running times in
milliseconds for the orderings chosen by Pellet and for the worst constructed plans

8). The queries marked with (*) are the queries where the static and dynamic algorithms
result in a different ordering. In Queries 7 and 8 we observe an increase in running
time when the dynamic technique is used (in comparison to the static) which is especially
evident on Query 8 of LUBM(2,0), where the number of individuals in the ontology and
the intermediate result sizes are larger. Dynamic ordering also behaves worse than static
in Queries 2 and 9. This happens because, although the dynamic algorithm chooses a
better ordering than the static algorithm, the intermediate results (that need to be checked
in each iteration to determine the next query atom to be executed) are quite large and
hence the cost of iterating over all possible mappings in the dynamic case far outweighs the
better ordering that is obtained. We also observe that a random sampling for collecting the
ordering statistics in the dynamic case (checking only 50% of individuals in ‚Ñ¶i‚àí1 randomly
for detecting the next query atom to be executed) leads to much worse results in most
queries than plain static or dynamic ordering. This happens since random sampling often
leads to the choice of a worse execution order. The use of the cluster based sampling method
performs better than the plain dynamic algorithm in all queries. In Queries 2 and 9, the
gain we have from the better ordering of the dynamic algorithm when sampling is used is
much more evident. This is the case since we use at most one individual from every cluster
for the cost functions computation and the number of clusters is much smaller than the
number of the otherwise tested individuals in each run.
In order to show the effectiveness of our proposed cost functions we compared the
running times of all the valid plans (plans that comply to the connectedness condition of
Definition 10, i.e., plans on which consecutive atoms share at least one common variable)
288

Optimizing SPARQL Query Answering over OWL Ontologies

LUBM(3,0) LUBM(4,0) LUBM(5,0) LUBM(6,0) LUBM(7,0) LUBM(8,0) LUBM(9,0)
55,664
78,579
102,368
118,500
144,612
163,552
183,425
Table 4: Number of individuals in LUBM with increasing number of universities
with the running time of the plan chosen by our method. In the following we show the results
for LUBM(1, 0), but the results for LUBM(2,0) are comparable. In Table 3 we show, for
each query, the number of valid plans that were constructed according to Definition 10
(column 2), the order of the plan chosen by the static, dynamic, and cluster based sampling
methods if we order the valid plans by their execution time (columns 3,4,5; e.g., a value
of 2 indicates that the ordering method chose the second best plan), the running time of
HermiT for the plan that was created by Pellet (column 6) as well as the running time of
the worst constructed plan (column 7).
The comparison of our ordering approach with the approach followed by other reasoners
that support conjunctive query answering such as Pellet or Racer Pro is not very straightforward. This is the case because Pellet and Racer have many optimizations for instance
retrieval (Sirin et al., 2007; Haarslev & MoÃàller, 2008), which HermiT does not have. Thus,
a comparison between the execution times of these reasoners and HermiT would not convey
much information about the effectiveness of the proposed query ordering techniques. The
idea of comparing only the orderings computed by other reasoners with those computed by
our methods is also not very informative since the orderings chosen by different reasoners
depend much on the way that queries are evaluated and on the costs of specific tasks in
these reasoners and, hence, are reasoner dependent, i.e., an ordering that is good for one
reasoner and which leads to an efficient evaluation may not be good for another reasoner.
We should note that when we were searching for orderings according to Pellet, we switched
off the simplification optimization that Pellet implements regarding the exploitation of domain and range axioms of the queried ontology for reducing the number of query atoms to
be evaluated (Sirin & Parsia, 2006). This has been done in order to better evaluate the
difference of the plain ordering obtained by Pellet and HermiT since our cost functions take
into account all the query atoms.
We observe that for all queries apart from Query 9 the orderings chosen by our algorithms
are the (near)optimal ones. For Queries 2 and 7, Pellet chooses the same ordering as our
algorithms. For Query 8, Pellet chooses an ordering which, when evaluated with HermiT,
results in higher execution time. For Query 9, our algorithms choose plans from about the
middle of the order over all the valid plans w.r.t. the query execution time, which means that
our algorithms do not perform well in this query. This is because of the greedy techniques
we have used to find the execution plan which take into account only local information to
choose the next query atom to be executed. Interestingly, the use of cluster based sampling
has led to the finding of a better ordering, as we can see from the running time in Table 2
and the better ordering of the plan found with cluster based sampling techniques compared
to static or plain dynamic ordering (Table 3). The ordering chosen by Pellet for Query 9
does also not perform well. We see that, in all queries, the worst running times are many
orders of magnitude greater than the running times achieved by our ordering algorithms.
In general, we observe that in LUBM static techniques are adequate and the use of dynamic
ordering does not improve the execution time much compared to static ordering.
289

Kollia & Glimm

Q LUBM(3,0) LUBM(4,0) LUBM(5,0) LUBM(6,0) LUBM(7,0) LUBM(8,0) LUBM(9,0)
2
0.35
0.62
1.26
1.71
2.26
3.11
4.18
7
0.11
0.16
0.23
0.32
0.33
0.33
0.40
8
0.77
0.91
1.27
1.29
1.34
1.44
1.65
9
18.49
42.98
85.54
116.88
181.07
235.06
312.71
all
20.64
55.16
90.99
138.84
213.59
241.85
323.15
Table 5: Query answering times in seconds for LUBM with increasing number of universities
Q Static Dynamic CSampling PlansNo
4 13.35
9 186.30
11
0.98
12
0.01
14 94.61
q1 191.07
q2 47.04

13.40
188.58
0.84
0.01
90.60
98.24
22.20

13.41
185.40
1.67
0.01
93.40
100.25
22.51

14
8
30
4
14
6
6

Chosen Plan Order
Pellet
Static Dynamic Sampling
Plan
1
1
1
13.40
1
1
1
636.91
1
1
1
0.98
1
1
1
0.01
2
1
1 > 30 min
2
1
1 > 30 min
2
1
1
22.2

Worst
Plan
271.56
636.91
> 30 min
> 30 min
> 30 min
> 30 min
> 30 min

Table 6: Query answering times in seconds for UOBM (1 university, 3 departments) and
statistics

In order to show the scalability of the system, we next run the LUBM queries with
different numbers of universities, i.e., LUBM(i,0) where i ranges from 3 to 9. Table 4 shows
the number of individuals appearing in each ABox of different university size. The running
times of Queries 2, 7, 8, 9 as well as the running time of all the 14 LUBM queries are
shown in Table 5. The results for LUBM(1,0) and LUBM(2,0) are shown in Table 2. Note
that the results shown are for the case that static ordering is performed. From this table
we see that for all queries, the running time increases when the number of individuals of
the ABox increases, which is reasonable. We observe that query answering over ontologies
is still not as scalable as query answering over databases and this is so, because of the more
expressive schema that has to be taken into account and the fact that we have incomplete
information in contrast to databases where we have complete information.
Unlike LUBM, the UOBM ontology contains disjunctions and the reasoner makes also
nondeterministic derivations. In order to reduce the reasoning time, we removed the nominals and only used the first three departments containing 6,409 individuals. The resulting
ontology took 16 s to load and 0.1 s to classify and initialize the known and possible instances. The clustering approach for concepts took 1.6 s and resulted in 356 clusters. The
clustering approach for roles lasted 6.3 s and resulted in 451 role successor clusters, 390
role predecessor clusters and 4,270 role clusters. We present results for the static and dynamic algorithms on Queries 4, 9, 11, 12 and 14 provided in UOBM, which are the most
interesting ones because they consist of many atoms. Most of these queries contain one
atom with possible instances. As we see from Table 6, static and dynamic ordering show
290

Optimizing SPARQL Query Answering over OWL Ontologies

similar performance in Queries 4, 9, 11 and 12. Since the available statistics in this case are
quite accurate, both methods find the optimal plans and the intermediate result set sizes
are small. For both ordering methods, atoms with possible instances for these queries are
executed last. In Query 14, the dynamic algorithm finds a better ordering which results in
comparable performance. The effect that the cluster based sampling technique has on the
running time is not as obvious as in the case of LUBM. This happens because in the current
experiment the intermediate result sizes are not very large and, most importantly, because
the gain obtained due to sampling is in the order of milliseconds whereas the total query
answering times are in the order of seconds obscuring the small improvement in running
time due to sampling. In all queries the orderings that are created by Pellet result in the
same or worse running times than the orderings created by our algorithms.
In order to illustrate when dynamic ordering performs better than static, we also created
the two custom queries:
q1 = { isAdvisedBy(?x,?y), GraduateStudent(?x), Woman(?y) }
q2 = { SportsFan(?x), GraduateStudent(?x), Woman(?x) }
In both queries, P [GraduateStudent], P [Woman] and P [isAdvisedBy] are non-empty, i.e.,
the query concepts and roles have possible instances. The running times for dynamic
ordering are smaller since the more accurate statistics result in a smaller number of possible
instances that have to be checked during query execution. In particular, for the static
ordering, 151 and 41 possible instances have to be checked in query q1 and q2 , respectively,
compared to only 77 and 23 for the dynamic ordering. Moreover, the intermediate results
are generally smaller in dynamic ordering than in static leading to a significant reduction
in the running time of the queries. Interestingly, query q2 could not be answered within the
time limit of 30 minutes when we transformed the three query concepts into a conjunction,
i.e., when we asked for instances of the intersection of the three concepts. This is because for
complex concepts the reasoner can no longer use the information about known and possible
instances and falls back to a more naive way of computing the concept instances. Again, for
the same reasons as before, the sampling techniques have no apparent effect on the running
time of these queries.
For each query of the SPARQL-DL tests issued over LUBM(1,0) (Kremen & Sirin, 2008)
(cf. Table 7), Table 8 shows the running time of the plan chosen by our method (column
2), the number of valid plans, i.e., plans that comply to the connectedness condition of
Definition 10 (column 3), the order of the chosen plan if we order the valid plans by their
execution times (column 4), the running time of HermiT for the plan that was created by
Pellet (column 5) as well as the running time of the worst constructed plan (column 6). The
queries as shown in Table 7 are ordered according to our static ordering algorithm. Since
reasoning for LUBM is deterministic, we use static planning to order the axiom templates.
Dynamic planning does not improve the execution times (actually it makes them worse)
since, as it has been explained before, with only deterministic reasoning we have most of the
important information for ordering from the beginning and the overhead caused by dynamic
ordering results in worse query execution time.
From the results of Table 8 one can observe that for Queries 1, 2, 3, 4 and 8 the
proposed ordering chooses the optimal plan among all valid plans. For Queries 5, 6, 7, 9
and 10 the optimal plan is not chosen according to the proposed cost estimation algorithm.
For Queries 5, 7, 9 and 10 this is due to the greedy techniques we have used for finding in
291

Kollia & Glimm

GraduateStudent(?x)
?y(?x, ?z)
Course(?w)

1

GraduateStudent(?x)
?y(?x, ?w)
?z(?w)
GraduateCourse ‚äë ¬¨?z
7
?c ‚äë ‚ä§
?c(?x)
teachingAssistantOf(?x, ?y)
takesCourse(?x, ?y)
8
?c ‚äë Person
?c(?x)
advisor(?x, ?y)
9
?c ‚äë Person
?c(?x)
teachingAssistantOf(?x, ?y)
Course(?y)
10
?p ‚äë worksFor
?p(?y, ?w)
?c(?y)
?c ‚äë Faculty
advisor(?x, ?y)
GraduateStudent(?x)
memberOf(?x, ?w)
6

?c ‚äë Employee
?c(?x)
Student(?x)
undergraduateDegreeFrom(?x, ?y)
3
?y ‚äë memberOf
?y(?x, University0)
Person(?x)
4
?y(GraduateStudent5, ?w)
?z(?w)
?z ‚äë Course
2

?z ‚äë Course
?z(?w)
?y(?x, ?w)
GraduateStudent(?x)

5

Table 7: Queries used for SPARQL-DL tests
Query
1
2
3
4
5
6
7
8
9
10

Chosen Ordering
Time
0.36
0.03
0.05
0.01
26.10
10.49
0.42
0.23
0.19
0.80

PlansNo
2
14
4
4
8
8
14
4
8
812

Chosen Plan
Order
1
1
1
1
5
2
6
1
4
21

Pellet Plan
Time
0.36
0.37
5.44
0.01
0.95
10.49
2.68
0.23
0.19
0.80

Worst Plan
Time
0.58
0.61
5.45
11.46
454.25
499.65
2.68
0.80
0.47
992.77

Table 8: Query answering times in seconds for the queries of Table 7 over LUBM(1,0) and
statistics

each iteration of our ordering algorithm the next cheapest axiom template to be evaluated.
For example, the optimal plan for Query 10 starts with the template GraduateStudent(?x),
which is not the cheapest one according to our cost based technique and then, while moving
292

Optimizing SPARQL Query Answering over OWL Ontologies

over connected templates, a different order is chosen than the order chosen by our algorithm.
It turns out that all valid plans beginning with the atom GraduateStudent(?x) lead to better
execution times than the plan chosen by our algorithm resulting in the existence of several
better plans than the chosen one.
For Query 6 we do not find the optimal plan because we have overestimated the cost of
the disjoint axiom template and hence have missed the optimal ordering. Nevertheless, the
chosen plans lead to execution times for all queries that are up to three orders of magnitude
lower than those when the worst plans are chosen. For queries in which the proposed
ordering does not lead to the optimal plan, one has to additionally take into account the
time we saved from not computing the costs for the |q!| possible orderings, which can be
very high. Apart from Queries 4, 6 and 8, we observe that the plans produced by Pellet
are not optimal when evaluated with HermiT. As we have discussed before, this happens
because the statistics created for ordering are reasoner specific and hence a good ordering
for one reasoner may not be good for another reasoner.
7.2 Complex Axiom Template Optimizations
In the absence of suitable standard benchmarks for arbitrary SPARQL queries, we created
a custom set of queries as shown in Tables 10 and 12 for the GALEN and the FBbt XP
ontology, respectively. Systems that fully support the SPARQL Direct Semantics entailment
regime are still under development, which makes it hard to compare our results for these
kinds of queries with other systems.
GALEN is a biomedical ontology. It‚Äôs expressivity is (Horn-)SHIF and it consists
of 2,748 concepts and 413 abstract roles. FBbt XP is an ontology taken from the Open
Biological Ontologies (OBO) Foundry (OBO Foundry, 2013). It falls into the SHI fragment
of SROIQ and consists of 7,221 concepts and 21 abstract roles. We only consider the
TBox part of FBbt XP since the ABox is not relevant for showing the different effects of
the proposed optimizations on the execution times of the considered queries. GALEN took
3.7 s to load and 11.1 s to classify (concepts and roles), while FBbt XP took 1.5 s to load
and 7.4 s to classify.
The execution times for the queries of Tables 10 and 12 are shown on the right-hand
side of Tables 9 and 11, respectively. We have set a time limit of 30 minutes for each
query. For each query, we tested the execution once without optimizations and once for
each combination of applicable optimizations from Sections 5 and 6. In Tables 9 and 11,
one can also see the number of consistency checks that were performed for the evaluation
of each query and each combination of the applicable optimizations as well as the number
of results of each query. In these tables we have taken the time of the worst ordering of
query atoms for the cases in which the ordering optimization is applicable but not enabled.
Note that only the complex axiom templates require consistency checks to be evaluated;
the simple ones (subsumption axiom templates in this case) need only cache lookups in the
reasoner‚Äôs internal structures since the concepts and roles are already classified.
GALEN Queries: As expected, an increase in the number of variables within an axiom
template leads to a significant increase in the query execution time because the number of
mappings that have to be checked grows exponentially in the number of variables. This can,
in particular, be observed from the difference in execution time between Query 1 and 2.
293

Kollia & Glimm

Query
1
1
2
2
3
3
3
4
4
4
4
5
5
5

Reordering

Hierarchy
Exploitation

Rewriting

x
x
x

x
x
x
x
x

x
x
x
x
x

Consistency
Checks
2,750
50
1,141,250
1,291

x
x

19,250
3,073

x
x
x

16,135
197
1,883
1,883

x

Time

AnswersNo

1.68
0.18
578.98
9.85
>30 min
102.37
2.69
> 30 min
> 30 min
7.68
1.12
> 30 min
0.67
0.8

10
10
214
214
2,816
2,816

51
51
4,392
4,392

Table 9: Query answering times in seconds for the queries of Table 10 with and without
optimizations
1
Infection ‚äë ‚àÉhasCausalLinkTo.?x
2
Infection ‚äë ‚àÉ?y.?x
3
?x ‚äë Infection ‚äì ‚àÉhasCausalAgent.?y
4 NAMEDLigament ‚äë NAMEDInternalBodyPart ‚äì ?x
?x ‚äë ‚àÉhasShapeAnalagousTo?y ‚äì ‚àÉ?z.linear
5
?x ‚äë NonNormalCondition
?z ‚äë ModifierAttribute
Bacterium ‚äë ‚àÉ?z.?w
?y ‚äë StatusAttribute
?w ‚äë AbstractStatus
?x ‚äë ‚àÉ?y.Status
Table 10: Sample complex queries for the GALEN ontology
From these two queries, it is evident that the use of the hierarchy exploitation optimization
leads to a decrease in execution time of up to two orders of magnitude. Query 3 can only be
completed in the time limit if at least the query rewriting optimization is enabled. We can
get an improvement of up to three orders of magnitude in this query, by using rewriting in
combination with the hierarchy exploitation. Query 4 can only be completed in the given
time limit if at least reordering and rewriting is enabled. Rewriting splits the first axiom
template into the following two simple axiom templates, which are evaluated much more
efficiently:
NAMEDLigament ‚äë NAMEDInternalBodyPart
294

and

NAMEDLigament ‚äë?x

Optimizing SPARQL Query Answering over OWL Ontologies

After the rewriting, the ordering optimization has an even more pronounced effect since
both rewritten axiom templates can be evaluated with a simple cache lookup. Without
ordering, the complex axiom template could be executed before the simple ones, which
leads to the inability of answering the query within the time limit of 30 min. Without
a good ordering, Query 5 can also not be answered within the time limit. The ordering
chosen by our algorithm is shown below. Note that the query consists of two connected
components: one for the axioms containing ?z and ?w and another one for the axioms
containing ?x and ?y.
?z ‚äë ModifierAttribute
?w ‚äë AbstractStatus
Bacterium ‚äë ‚àÉ?z.?w
?y ‚äë StatusAttribute
?x ‚äë NonNormalCondition
?x ‚äë ‚àÉ?y.Status
In this query, the hierarchy exploitation optimization does not improve the execution time
since, due to the chosen ordering, the variables on which the hierarchy optimization can
be applied, are already bound when it comes to the evaluation of the complex templates.
Hence, the running times with and without the hierarchy exploitation are similar. The
number of consistency checks is significantly lower than the number of answers because the
overall results are computed by taking the cartesian products of the results for the two
connected components. Interestingly, for queries with complex axiom templates, it does
not make sense to require that the next axiom template to evaluate shares a variable with
the previously evaluated axiom templates, as in the case of simple axiom templates. For
example, if we would require that, the first connected component of the query would be
executed in the following order:
?z ‚äë ModifierAttribute
Bacterium ‚äë ‚àÉ?z.?w
?w ‚äë AbstractStatus
this results in 294,250 instead of 1,498 consistency checks since we no longer use a cheap
cache look-up check to determine the bindings for ?w, but first iterate over all possible
?w bindings and check entailment of the complex axiom template and then reduce the
computed candidates when processing the last axiom template.
Although our optimizations can significantly improve the query execution time, the
required time can still be quite high. In practice, it is, therefore, advisable to add as many
restrictive axiom templates (axiom templates which require only cache lookups) for query
variables as possible. For example, the addition of ?y ‚äë Shape to Query 4 reduces the
runtime from 1.12 s to 0.65 s. We observe, as expected, that the execution time for each
query and applicable optimization is analogous to the number of consistency checks that
are performed for the evaluation of the query.
FBbt XP Queries: For Queries 1, 2, 3, 5 and 6, on which the ordering optimization
is applicable, we observe a decrease in execution time up to two orders of magnitude when
295

Kollia & Glimm

Query

Reordering

1
1
1
2
2
2
3
3
3
4
4
5
5
5
5
6
6
6
6

x
x
x
x
x
x

Hierarchy
Exploitation

Rewriting

x
x

11,262
14,446

x
x

12,637
72,230

x
x

54,186
166,129
1335
166,129
21,669
907
3

x
x
x
x
x
x

x
x
x
x
x

Consistency
Checks
151,683

x
x
x

43,338
32,490

Time

AnswersNo

44.13
> 30 min
5.64
37.38
> 30 min
39.20
357.59
> 30 min
252.41
486.81
17.03
457.84
19.68
11.74
0.01
> 30 min
183.66
> 30 min
152.38

7,243
7,243
7,224
7,224
188
188
68
68
0
0
0
0
43,338
43,338

Table 11: Query answering times in seconds for the queries of Table 12 with and without
optimizations

1 ?x ‚äë ‚àÄpart of.?y
?x ‚äë FBbt 00005789
2 ?y ‚äë part of
?x ‚äë ‚àÄ?y.FBbt 00001606
3 ?x ‚äë ‚àÉ?y.FBbt 00025990
?y ‚äë overlaps

4 FBbt 00001606 ‚äë ‚àÉ?y.?x
5 FBbt 00001606 ‚äë ‚àÉ?y.?x
?y ‚äë develops from
6
?y ‚äë FBbt 00001884
?p ‚äë part of
?x ‚äë ‚àÉ?p.?y ‚äì ?w

Table 12: Sample complex queries for the FBbt XP ontology
the ordering optimization is used. The ordering optimization is important for answering
Queries 1, 2 and 3 within the time limit. For all queries, the additional use of the hierarchy
exploitation optimization leads to an improvement of up to three orders of magnitude.
We observe that in some queries the effect of the hierarchy exploitation is more profound
than in others. More precisely, the smaller the ratio of the result size to the number of
consistency checks without the hierarchy optimization, the more pronounced is the effect
when enabling this optimization. In other words, when more tested mappings are indeed
solutions, one can prune fewer parts of the hierarchy since pruning can only be performed
when we find a non-solution. In Query 2, we even observe a slight increase in running
296

Optimizing SPARQL Query Answering over OWL Ontologies

time when the hierarchy optimization is used. This is because the optimization can only
prune few candidate mappings, which does not outweigh the overhead caused by maintaining
information about which hierarchy parts have already been tested. In Query 6, the rewriting
optimization is important to answer the query within the time limit. When all optimizations
are enabled, the number of consistency checks is less than the result size (32,490 versus
43,338) since only the complex axiom template requires consistency checks.

8. Related Work
There is not yet a standardized and commonly implemented query language for OWL ontologies. Several of the widely deployed systems support, however, some query language.
Pellet supports SPARQL-DL (Sirin & Parsia, 2007), which is a subset of SPARQL, adapted
to work with OWL‚Äôs Direct Semantics. The kinds of SPARQL queries that are supported in
SPARQL-DL are those that can directly be mapped to reasoner tasks. Therefore, SPARQLDL can be understood as queries that only use simple axiom templates in our terminology.
Similarly, KAON2 (Hustadt, Motik, & Sattler, 2004) supports SPARQL queries, but restricted to ABox queries/conjunctive instance queries. To the best of our knowledge, there
are no publications that describe any ordering strategies for KAON2. Racer Pro (Haarslev
& MoÃàller, 2001) has a proprietary query language, called nRQL (Haarslev et al., 2004),
which allows for queries that go beyond ABox queries, e.g., one can retrieve sub- or superconcepts of a given concept. TrOWL (Thomas et al., 2013) is another system that supports
SPARQL queries, but the reasoning in TrOWL is approximate, i.e., an OWL DL ontology
is rewritten into an ontology that uses a less expressive language before reasoning is applied (Thomas, Pan, & Ren, 2010). TrOWL is based on the SPARQL framework presented
here, but instead of using HermiT as background reasoner, it uses its approximate reasoners for the OWL 2 EL and OWL 2 QL profiles. Furthermore, there are systems such as
QuOnto (Acciarri, Calvanese, De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2013) or
Requiem (PeÃÅrez-Urbina, Motik, & Horrocks, 2013), which support profiles of OWL 2, and
which support conjunctive queries, e.g., written in SPARQL syntax, but with proper nondistinguished variables. Of the systems that support all of OWL 2 DL, only Pellet supports
non-distinguished variables as long as they are not used in cycles, since decidability of cyclic
conjunctive queries is to the best of our knowledge still an open problem.
The problem of finding good orderings for the templates of a query issued over an ontology has already been preliminarily studied (Sirin & Parsia, 2006; Kremen & Sirin, 2008;
Haarslev & MoÃàller, 2008). Similarly to our work, Sirin and Parsia as well as Kremen and
Sirin exploit reasoning techniques and information provided by reasoner models to create
statistics about the cost and the result size of axiom template evaluations within execution
plans. A difference is that they use cached models for cheaply finding obvious concept
and role (non-)instances, whereas in our case we do not cache any model or model parts.
Instead we process the pre-model constructed for the initial ontology consistency check and
extract the known and possible instances of concepts and roles from it. We subsequently
use this information to create and update the query atom statistics. Moreover, Sirin and
Parsia and Kremen and Sirin compare the costs of complete execution plans ‚Äîafter heuristically reducing the huge number of possible complete plans ‚Äî and choose the one that is
most promising before the beginning of query execution. This is different from our cheap
297

Kollia & Glimm

greedy algorithm that finds, at each iteration, the next most promising axiom template.
Our experimental study shows that this is equally effective as the investigation of all possible execution orders. Moreover, in our work we have additionally used dynamic ordering
combined with clustering techniques, apart from static ones, and have shown that these
techniques lead to better performance particularly in ontologies that contain disjunctions
and do now allow for purely deterministic reasoning.
Haarslev and MoÃàller discuss by means of an example the ordering criteria they use
to find efficient query execution plans in Racer Pro. In particular, they use traditional
database cost based optimization techniques, which means that they take into account only
the cardinality of concept and role atoms to decide about the most promising ordering.
As previously discussed, this can be inadequate especially for ontologies with disjunctive
information.
A significant amount of work on the estimation of cost metrics and the search for optimal
orders for evaluating joins has been performed in the context of databases. As discussed
in Section 3, in databases, cost formulas are defined that estimate the CPU and I/O costs
(similar to our reasoning costs) and the number of returned tuples (similar to our result
sizes). These estimates are used to find good join orders. The System R query optimizer, for
example, is among the first works to use extended statistics and a novel dynamic programming algorithm to find effective (minimal) join orders of query atoms (Selinger, Astrahan,
Chamberlin, Lorie, & Price, 1979). A heuristic similar to ours (for the case of conjunctive
instance queries) is used in this work, according to which the join order permutations are
reduced by avoiding Cartesian products of result sets of query atoms. Regarding join order selection, apart from dynamic programming, also other algorithmic paradigms based on
branch-and-bound or simulated annealing have, since then, been presented in the literature.
Dynamic ordering has also been explored in the literature in the context of adaptive query
processing techniques (Gounaris, Paton, Fernandes, & Sakellariou, 2002), which have been
proposed to overcome the problems caused by the lack of necessary statistics, good selectivity estimates, knowledge for the runtime mappings of a query at compile time. These
techniques take into account changes that happen to the evaluation environment at runtime
and modify the execution plan at runtime (i.e., they change the used operators for joins or
the order in which the (remaining) query atoms are evaluated).

9. Conclusions
In the current paper, we presented a sound and complete query answering algorithm and
novel optimizations for the OWL Direct Semantics entailment regime of SPARQL 1.1. Our
prototypical query answering system combines existing tools such as ARQ, the OWL API,
and the HermiT OWL reasoner. Apart from the query ordering optimization‚Äîwhich uses
(reasoner dependent) statistics provided by HermiT‚Äîthe system is independent of the reasoner used, and could employ any reasoner that supports the OWL API.
We propose two cost-based ordering strategies for finding (near-)optimal execution orders for conjunctive instance queries. The cost formulas are based on information extracted
from models of a reasoner (in our case HermiT). We show through an experimental study
that static techniques are quite adequate for ontologies in which reasoning is deterministic.
When reasoning is nondeterministic, however, dynamic techniques often perform better.
298

Optimizing SPARQL Query Answering over OWL Ontologies

The use of cluster based sampling techniques can improve the performance of the dynamic
algorithm when the intermediate result sizes of queries are sufficiently large, whereas random sampling is not beneficial and often leads to suboptimal query execution plans.
The presented approach can be used to find answers to queries issued over SROIQ
ontologies. Since it is based on entailment checking for finding answers to conjunctive
instance queries it is not as scalable as other techniques, such as query rewriting, which
are applied to ontologies of lower expressivity, such as DL-Lite. In other words, there is
a trade-off between scalability and ontology expressivity and one needs to consider if it is
more important for one‚Äôs application to use a more scalable query answering system with a
less expressive ontology or a less scalable system with a more expressive ontology.
The module for ordering is based on the extraction of statistics from a reasoner model,
which is computed off-line. Any update of the ontology ABox would then cause the construction of a new model from scratch and the consequent recompilation of known and
possible instances of concepts and roles unless an incremental reasoner is used. An incremental reasoner could, for example, find modules of the pre-model that are affected by the
update and recompute only model parts. One could then also incrementally update the
statistics that are used for ordering. To the best of our knowledge, OWL DL reasoners only
partially support incremental reasoning and we have not considered this case in the current
paper.
For queries that go beyond conjunctive instance queries we further provide optimizations such as rewriting into equivalent, but simpler queries. Another highly effective and
frequently applicable optimization prunes the number of candidate solutions that have to
be checked by exploiting the concept and role hierarchies. One can, usually, assume that
these hierarchies are computed before a system accepts queries. Our empirical evaluation
shows that this optimization can reduce the query evaluation times up to three orders of
magnitude.

Acknowledgments
This work was done within the Transregional Collaborative Research Centre SFB/TRR
62 ‚ÄúA Companion-Technology for Cognitive Technical Systems‚Äù funded by the German
Research Foundation (DFG).

References
Acciarri, A., Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Palmieri, M., &
Rosati, R. (2013). QuOnto. Available at http://www.dis.uniroma1.it/‚àºquonto/.
Beckett, D., Berners-Lee, T., Prud‚Äôhommeaux, E., & Carothers, G. (Eds.). (19 February
2013). Turtle ‚Äì Terse RDF Triple Language. W3C Candidate Recommendation.
Available at http://www.w3.org/TR/turtle/.
Brickley, D., & Guha, R. V. (Eds.). (10 February 2004). RDF Vocabulary Description
Language 1.0: RDF Schema. W3C Recommendation. Available at http://www.w3.
org/TR/rdf-schema/.
299

Kollia & Glimm

Broekstra, J., & Kampman, A. (2006). An RDF query and transformation language. In
Staab, S., & Stuckenschmidt, H. (Eds.), Semantic Web and Peer-to-Peer, pp. 23‚Äì39.
Springer.
Calvanese, D., Giacomo, G. D., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning and efficient query answering in description logics: The DL-Lite family.
Journal of Automated Reasoning, 39 (3), 385‚Äì429.
Clark & Parsia (2013a). Pellet. Available at http://clarkparsia.com/pellet/.
Clark & Parsia (2013b). Stardog. Available at http://stardog.com.
Glimm, B., Horrocks, I., Motik, B., Shearer, R., & Stoilos, G. (2012). A novel approach to
ontology classification. Journal of Web Semantics: Science, Services and Agents on
the World Wide Web, 14, 84‚Äì101. Special Issue on Dealing with the Messiness of the
Web of Data.
Glimm, B., & Kollia, I. (2013). OWL-BGP. Available at http://code.google.com/p/owl-bgp/.
Glimm, B., & KroÃàtzsch, M. (2010). SPARQL beyond subgraph matching. In Proceedings
of the 9th International Semantic Web Conference (ISWC‚Äô10), Vol. 6414 of Lecture
Notes in Computer Science, pp. 241‚Äì256. Springer.
Glimm, B., & Ogbuji, C. (2013). SPARQL 1.1 entailment regimes. W3C Recommendation.
Available at http://www.w3.org/TR/sparql11-entailment/.
Gounaris, A., Paton, N. W., Fernandes, A. A., & Sakellariou, R. (2002). Adaptive query
processing: A survey. In In 19th BNCOD, pp. 11‚Äì25. Springer.
Guo, Y., Pan, Z., & Heflin, J. (2005). LUBM: A benchmark for OWL knowledge base
systems. Journal of Web Semantics, 3 (2-3), 158‚Äì182.
Haarslev, V., & MoÃàller, R. (2001). Racer system description. In Gor, R., Leitsch, A., & Nipkow, T. (Eds.), Proceedings of the 1st International Joint Conference on Automated
Reasoning (IJCAR‚Äô01), Vol. 2083 of LNCS, pp. 701‚Äì705. Springer.
Haarslev, V., & MoÃàller, R. (2008). On the scalability of description logic instance retrieval.
Journal of Automated Reasoning, 41 (2), 99‚Äì142.
Haarslev, V., MoÃàller, R., & Wessel, M. (2004). Querying the semantic web with Racer
+ nRQL. In Proceedings of the KI-2004 International Workshop on Applications of
Description Logics.
Harris, S., & Seaborne, A. (Eds.). (2013). SPARQL 1.1 Query Language. W3C Recommendation. Available at http://www.w3.org/TR/sparql11-query/.
Hayes, P. (Ed.). (10 February 2004). RDF Semantics. W3C Recommendation. Available
at http://www.w3.org/TR/rdf-mt/.
Hitzler, P., KroÃàtzsch, M., & Rudolph, S. (2009). Foundations of Semantic Web Technologies.
Chapman & Hall/CRC.
Horridge, M., & Bechhofer, S. (2009). The OWL API: A Java API for working with OWL
2 ontologies. In Patel-Schneider, P. F., & Hoekstra, R. (Eds.), Proceedings of the
OWLED 2009 Workshop on OWL: Experiences and Directions, Vol. 529 of CEUR
Workshop Proceedings. CEUR-WS.org.
300

Optimizing SPARQL Query Answering over OWL Ontologies

Horrocks, I., Kutz, O., & Sattler, U. (2006). The even more irresistible SROIQ. In Doherty, P., Mylopoulos, J., & Welty, C. A. (Eds.), Proceedings of the 10th International
Conference on Principles of Knowledge Representation and Reasoning (KR‚Äô06), pp.
57‚Äì67. AAAI Press.
Hustadt, U., Motik, B., & Sattler, U. (2004). Reducing SHIQ‚àí description logic to disjunctive datalog programs. In Proceedings of the 9th International Conference on
Principles of Knowledge Representation and Reasoning (KR‚Äô04), pp. 152‚Äì162. AAAI
Press.
Ioannidis, Y. E., & Christodoulakis, S. (1993). Optimal histograms for limiting worst-case
error propagation in the size of join results. ACM Transactions on Database Systems,
18 (4), 709‚Äì748.
Kazakov, Y. (2008). RIQ and SROIQ are harder than SHOIQ. In Brewka, G., & Lang, J.
(Eds.), Proceedings of the 11th International Conference on Principles of Knowledge
Representation and Reasoning (KR‚Äô08), pp. 274‚Äì284. AAAI Press.
Kollia, I., & Glimm, B. (2013). Evaluation sources. Available at http://code.google.com/
p/query-ordering/.
Kontchakov, R., Lutz, C., Toman, D., Wolter, F., & Zakharyaschev, M. (2010). The combined approach to query answering in DL-Lite. In Lin, F., & Sattler, U. (Eds.),
Proceedings of the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR‚Äô10). AAAI Press.
Kremen, P., & Sirin, E. (2008). SPARQL-DL implementation experience. In Clark, K.,
& Patel-Schneider, P. F. (Eds.), Proceedings of the 4th OWLED Workshop on OWL:
Experiences and Directions Washington, Vol. 496 of CEUR Workshop Proceedings.
CEUR-WS.org.
Ma, L., Yang, Y., Qiu, Z., Xie, G., Pan, Y., & Liu, S. (2006). Towards a complete OWL
ontology benchmark. In The Semantic Web: Research and Applications, Lecture Notes
in Computer Science, chap. 12, pp. 125‚Äì139. Springer.
Motik, B., Cuenca Grau, B., Horrocks, I., Wu, Z., Fokoue, A., & Lutz, C. (Eds.). (11
December 2012a). OWL 2 Web Ontology Language: Profiles. W3C Recommendation.
Available at http://www.w3.org/TR/owl2-profiles/.
Motik, B., Patel-Schneider, P. F., & Cuenca Grau, B. (Eds.). (11 December 2012b). OWL 2
Web Ontology Language: Direct Semantics. W3C Recommendation. Available at
http://www.w3.org/TR/owl2-direct-semantics/.
Motik, B., Shearer, R., Glimm, B., Stoilos, G., & Horrocks, I. (2013). HermiT. Available
at http://www.hermit-reasoner.com/.
Motik, B., Shearer, R., & Horrocks, I. (2009). Hypertableau reasoning for description logics.
Journal of Artificial Intelligence Research, 36, 165‚Äì228.
OBO Foundry (2013). The open biological and biomedical ontologies. Available at http:
//www.obofoundry.org/.
Oracle (2013). Oracle database documentation library 11g release 2. Available at http:
//www.oracle.com/pls/db112/homepage.
301

Kollia & Glimm

Pan, J. Z., Thomas, E., & Zhao, Y. (2009). Completeness guaranteed approximation for owl
dl query answering. In Proceedings of the 2009 International Workshop on Description
Logics (DL‚Äô09).
Patel-Schneider, P. F., & Motik, B. (Eds.). (11 December 2012). OWL 2 Web Ontology
Language: Mapping to RDF Graphs. W3C Recommendation. Available at http:
//www.w3.org/TR/owl2-mapping-to-rdf/.
PeÃÅrez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering and rewriting
under description logic constraints. Journal of Applied Logic, 8 (2), 186‚Äì209.
PeÃÅrez-Urbina, H., Motik, B., & Horrocks, I. (2013). Requiem. Available at http://www.
comlab.ox.ac.uk/projects/requiem/home.html.
Prud‚Äôhommeaux, E., & Seaborne, A. (Eds.). (15 January 2008). SPARQL Query Language for RDF. W3C Recommendation. Available at http://www.w3.org/TR/
rdf-sparql-query/.
Racer Systems GmbH & Co. KG (2013).
racer-systems.com.

RacerPro 2.0.

Available at http://www.

Ren, Y., Pan, J. Z., & Zhao, Y. (2010). Soundness preserving approximation for tbox
reasoning. In Proceedings of the 25th National Conference on Artificial Intelligence
(AAAI‚Äô10). AAAI Press.
Rodriguez-Muro, M., & Calvanese, D. (2012). High performance query answering over
dl-lite ontologies. In Proc. of the 13th Int. Conf. on the Principles of Knowledge
Representation and Reasoning (KR 2012), pp. 308‚Äì318.
Schneider, M. (Ed.). (11 December 2012). OWL 2 Web Ontology Language: RDFBased Semantics. W3C Recommendation. Available at http://www.w3.org/TR/
owl2-rdf-based-semantics/.
Seaborne, A. (9 January 2004). RDQL ‚Äì A Query Language for RDF. W3C Member
Submission. Available at http://www.w3.org/Submission/RDQL/.
Selinger, P. G., Astrahan, M. M., Chamberlin, D. D., Lorie, R. A., & Price, T. G. (1979).
Access path selection in a relational database management system. In Bernstein,
P. A. (Ed.), Proceedings of the 1979 ACM SIGMOD International Conference on
Management of Data, Boston, Massachusetts, May 30 - June 1, pp. 23‚Äì34. ACM.
Sirin, E., Cuenca Grau, B., & Parsia, B. (2006). From wine to water: Optimizing description logic reasoning for nominals. In Doherty, P., Mylopoulos, J., & Welty, C. A.
(Eds.), Proceedings of the 10th International Conference on Principles of Knowledge
Representation and Reasoning (KR‚Äô06), pp. 90‚Äì99. AAAI Press.
Sirin, E., & Parsia, B. (2006). Optimizations for answering conjunctive ABox queries: First
results. In Proceedings of the 2006 International Workshop on Description Logics
(DL‚Äô06), Vol. 189 of CEUR Workshop Proceedings. CEUR-WS.org.
Sirin, E., & Parsia, B. (2007). SPARQL-DL: SPARQL query for OWL-DL. In Golbreich,
C., Kalyanpur, A., & Parsia, B. (Eds.), Proceedings of the OWLED 2007 Workshop on
OWL: Experiences and Directions, Vol. 258 of CEUR Workshop Proceedings. CEURWS.org.
302

Optimizing SPARQL Query Answering over OWL Ontologies

Sirin, E., Parsia, B., Grau, B. C., Kalyanpur, A., & Katz, Y. (2007). Pellet: A practical
OWL-DL reasoner. Journal of Web Semantics, 5 (2), 51‚Äì53.
Steinbrunn, M., Moerkotte, G., & Kemper, A. (1997). Heuristic and randomized optimization for the join ordering problem. VLDB Journal, 6, 191‚Äì208.
Stocker, M., Seaborne, A., Bernstein, A., Kiefer, C., & Reynolds, D. (2008). SPARQL basic
graph pattern optimization using selectivity estimation. In Proceedings of the 17th
International Conference on World Wide Web (WWW‚Äô08), pp. 595‚Äì604. ACM.
The Apache Software Foundation (2013). Apache jena. Available at http://jena.apache.org.
Thomas, E., Pan, J. Z., & Ren, Y. (2010). TrOWL: Tractable OWL 2 reasoning infrastructure. In Proceedings of the Extended Semantic Web Conference (ESWC‚Äô10).
Thomas, E., Pan, J. Z., & Ren, Y. (2013). TrOWL. Available at http://trowl.eu.
Tsarkov, D., Horrocks, I., & Patel-Schneider, P. F. (2007). Optimizing terminological reasoning for expressive description logics. Journal of Automated Reasoning, 39 (3), 277‚Äì316.

303

Journal of Artificial Intelligence Research 48 (2013) 583-634

Submitted 4/13; published 11/13

Protecting Moving Targets with Multiple Mobile Resources
Fei Fang
Albert Xin Jiang
Milind Tambe

feifang@usc.edu
jiangx@usc.edu
tambe@usc.edu

University of Southern California
Los Angeles, CA 90089 USA

Abstract
In recent years, Stackelberg Security Games have been successfully applied to solve resource allocation and scheduling problems in several security domains. However, previous
work has mostly assumed that the targets are stationary relative to the defender and the
attacker, leading to discrete game models with finite numbers of pure strategies. This paper
in contrast focuses on protecting mobile targets that leads to a continuous set of strategies
for the players. The problem is motivated by several real-world domains including protecting ferries with escort boats and protecting refugee supply lines. Our contributions include:
(i) A new game model for multiple mobile defender resources and moving targets with a
discretized strategy space for the defender and a continuous strategy space for the attacker.
(ii) An efficient linear-programming-based solution that uses a compact representation for
the defender‚Äôs mixed strategy, while accurately modeling the attacker‚Äôs continuous strategy using a novel sub-interval analysis method. (iii) Discussion and analysis of multiple
heuristic methods for equilibrium refinement to improve robustness of defender‚Äôs mixed
strategy. (iv) Discussion of approaches to sample actual defender schedules from the defender‚Äôs mixed strategy. (iv) Detailed experimental analysis of our algorithms in the ferry
protection domain.

1. Introduction
In the last few years, game-theoretic decision support systems have been successfully deployed in several domains to assist security agencies (defenders) in protecting critical infrastructure such as ports, airports and air-transportation infrastructure (Tambe, 2011; Gatti,
2008; Marecki, Tesauro, & Segal, 2012; Jakob, VaneÃåk, & PeÃåchoucÃåek, 2011). These decision support systems assist defenders in allocating and scheduling their limited resources
to protect targets from adversaries. In particular, given limited security resources it is not
possible to cover or secure all target at all times; and simultaneously, because the attacker can observe the defender‚Äôs daily schedules, any deterministic schedule by the defender
can be exploited by the attacker (Paruchuri, Tambe, OrdoÃÅnÃÉez, & Kraus, 2006; Kiekintveld,
Islam, & Kreinovich, 2013; Vorobeychik & Singh, 2012; Conitzer & Sandholm, 2006).
One game-theoretic model that has been deployed to schedule security resources in such
domains is that of a Stackelberg game between a leader (the defender) and a follower (the
attacker). In this model, the leader commits to a mixed strategy, which is a randomized
schedule specified by a probability distribution over deterministic schedules; the follower
then observes the distribution and plays a best response (Korzhyk, Conitzer, & Parr, 2010).
Decision-support systems based on this model have been successfully deployed, including
ARMOR at the LAX airport (Pita, Jain, Marecki, OrdoÃÅnÃÉez, Portway, Tambe, Western,
c
2013
AI Access Foundation. All rights reserved.

Fang, Jiang, & Tambe

Paruchuri, & Kraus, 2008), IRIS for the US Federal Air Marshals service (Tsai, Rathi,
Kiekintveld, Ordonez, & Tambe, 2009), and PROTECT for the US Coast Guard (Shieh,
An, Yang, Tambe, Baldwin, DiRenzo, Maule, & Meyer, 2012).
Most previous work on game-theoretic models for security has assumed either stationary
targets such as airport terminals (Pita et al., 2008), or targets that are stationary relative to
the defender and the attacker, e.g., trains (Yin, Jiang, Johnson, Kiekintveld, Leyton-Brown,
Sandholm, Tambe, & Sullivan, 2012) and planes (Tsai et al., 2009), where the players can
only move along with the targets to protect or attack them). This stationary nature leads
to discrete game models with finite numbers of pure strategies. In this paper we focus
on security domains in which the defender needs to protect a mobile set of targets. The
attacker can attack these targets at any point in time during their movement, leading to a
continuous set of strategies. The defender can deploy a set of mobile escort resources (called
patrollers for short) to protect these targets. We assume the game is zero-sum, and allow
the values of the targets to vary depending on their locations and time. The defender‚Äôs
objective is to schedule the mobile escort resources to minimize attacker‚Äôs expected utility.
We call this problem Multiple mobile Resources protecting Moving Targets (MRMT).
The first contribution of this paper is a novel game model for MRMT called MRMTsg .
MRMTsg is an attacker-defender Stackelberg game model with a continuous set of strategies for the attacker. In contrast, while the defender‚Äôs strategy space is also continuous, we
discretize it in MRMTsg for three reasons. Firstly, if we let the defender‚Äôs strategy space
to be continuous, the space of mixed strategies for the defender would then have infinite
dimensions, which makes exact computation infeasible. Secondly, in practice, the patrollers
are not able to have such fine-grained control over their vehicles, which makes the actual
defender‚Äôs strategy space effectively a discrete one. Finally, the discretized defender strategy space is a subset of the original continuous defender strategy space, so the optimal
solution calculated under our formulation is a feasible solution in the original game and
gives a lower-bound guarantee for the defender in terms of expected utility for the original continuous game. On the other hand, discretizing the attacker‚Äôs strategy space can be
highly problematic as we will illustrate later in this paper. In particular, if we deploy a
randomized schedule for the defender under the assumption that the attacker could only
attack at certain discretized time points, the actual attacker could attack at some other
time point, leading to a possibly worse outcome for the defender.
Our second contribution is CASS (Solver for Continuous Attacker Strategies), an efficient
linear program to exactly solve MRMTsg . Despite discretization, the defender strategy
space still has an exponential number of pure strategies. We overcome this shortcoming by
compactly representing the defender‚Äôs mixed strategies as marginal probability variables.
On the attacker side, CASS exactly and efficiently models the attacker‚Äôs continuous strategy
space using sub-interval analysis, which is based on the observation that given the defender‚Äôs
mixed strategy, the attacker‚Äôs expected utility is a piecewise-linear function. Along the way
to presenting CASS, we present DASS (Solver for Discretized Attacker Strategies), which
finds minimax solutions for MRMTsg games while constraining the attacker to attack at
discretized time points. For clarity of exposition we first derive DASS and CASS for the
case where the targets move on a one-dimensional line segment. We later show that DASS
and CASS can be extended to the case where targets move in a two-dimensional space.
584

Protecting Moving Targets with Multiple Mobile Resources

Our third contribution is focused on equilibrium refinement. Our game has multiple
equilibria, and the defender strategy found by CASS can be suboptimal with respect to uncertainties in the attacker‚Äôs model, e.g., if the attacker can only attack during certain time
intervals. We present two heuristic equilibrium refinement approaches for this game. The
first, route-adjust, iteratively computes a defender strategy that dominates earlier strategies. The second, flow-adjust, is a linear-programming-based approach. Our experiments
show that flow-adjust is computationally faster than route-adjust but route-adjust is more
effective in selecting robust equilibrium strategies.
Additionally, we provide several sampling methods for generating practical patrol routes
given the defender strategy in compact representation. Finally we present detailed experimental analyses of our algorithm in the ferry protection domain. CASS has been deployed
by the US Coast Guard since April 2013.
The rest of the article is organized as follows: Section 2 provides our problem statement.
Section 3 presents the MRMTsg model and an initial formulation of the DASS and CASS for
a one-dimensional setting. Section 4 discusses equilibrium refinement, followed by Section
5 which gives the generalized formulation of DASS and CASS for two-dimensional settings.
Section 6 describes how to sample a patrol route and Section 7 provides experimental
results in the ferry protection domain. Section 8 discusses related work, followed by Section
9, which provides concluding remarks, and Section 10, which discusses future work. At the
end of the article, Appendix A provides a table listing all the notations used in the article,
and Appendix B provides the detailed calculation for finding the intersection points in the
2-D case.

2. Problem Statement
One major example of the practical domains motivating this paper is the problem of protecting ferries that carry passengers in many waterside cities. Packed with hundreds of
passengers, these may present attractive targets for an attacker. For example, the attacker
may ram a suicide boat packed with explosives into the ferry as happened with attacks on
French supertanker Limburg and USS Cole (Greenberg, Chalk, & Willis, 2006). In this
case, the intention of the attacker can only be detected once he gets very close to the ferry.
Small, fast and well-armed patrol boats (patrollers) can provide protection to the ferries
(Figure 1(a)), by detecting the attacker and stopping him with the armed weapons. However, there are often limited numbers of patrol boats, i.e., they cannot protect the ferries
at all times at all locations. We first focus on the case where ferries and patrol boats move
in a one-dimensional line segment (this is a realistic setting and also simplifies exposition);
we will discuss the two-dimensional case in Section 5.
2.1 Domain Description
In this problem, there are L moving targets, F1 , F2 , ..., FL . We assume that these targets
move along a one-dimensional domain, specifically a straight line segment linking two terminal points which we will name A and B. This is sufficient to capture real-world domains
such as ferries moving back-and-forth in a straight line between two terminals as they do
in many ports around the world; an example is the green line shown in Figure 1(b). We
will provide an illustration of our geometric formulation of the problem in Figure 2.1. The
585

Fang, Jiang, & Tambe

(a)

(b)

Figure 1: (a) Protecting ferries with patrol boats; (b) Part of the map of New York Harbor Commuter Ferry Routes. The straight line linking St. George Terminal and
Whitehall Terminal indicates a public ferry route run by New York City Department of Transportation.

targets have fixed daily schedules. The schedule of each target can be described as a continuous function Sq : T ‚Üí D where q = 1, ..., L is the index of the target, T = [0, 1] is a
continuous time interval (e.g., representing the duration of a typical daily patrol shift) and
D = [0, 1] is the continuous space of possible locations (normalized) with 0 corresponding
to terminal A and 1 to terminal B. Thus Sq (t) denotes the position of the target Fq at a
specified time t. We assume Sq is piecewise linear.
The defender has W mobile patrollers that can move along D to protect the targets,
denoted as P1 , P2 , ..., PW . Although capable of moving faster than the targets, they have a
maximum speed of vm . While the defender attempts to protect the targets, the attacker will
choose a certain time and a certain target to attack. (In the rest of the paper, we denote the
defender as ‚Äúshe‚Äù and the attacker as ‚Äúhe‚Äù). The probability of attack success depends on
the positions of the patrollers at that time. Specifically, each patroller can detect and try
to intercept anything within the protection radius re but cannot detect the attacker prior
to that radius. Thus, a patroller protects all targets within her protective circle of radius
re (centered at her current position), as shown in Figure 2.1.
‡Øò

‡¨∂

‡¨µ



‡¨∂

‡¨∑

‡¨µ



Figure 2: An example with three targets (triangles) and two patrollers (squares). The
protective circles of the patrollers are shown with protection radius re . A patroller
protects all targets in her protective circle. Patroller P1 is protecting F2 and P2
is protecting F3 .

586

Protecting Moving Targets with Multiple Mobile Resources

Symmetrically, a target is protected by all patrollers whose protective circles can cover
it. If the attacker attacks a protected target, then the probability of successful attack is a
decreasing function of the number of patrollers that are protecting the target. Formally, we
use a set of coefficients {CG } to describe the strength of the protection.
Definition 1. Let G ‚àà {1, ..., W } be the total number of patrollers protecting a target Fq ,
i.e., there are G patrollers such that Fq is within radius re of each of the G patrollers. Then
CG ‚àà [0, 1] specifies the probability that the patrollers can successfully stop the attacker. We
require that CG1 ‚â§ CG2 if G1 ‚â§ G2 , i.e., more patrollers offer better protection.
As with previous work in security games (Tambe, 2011; Yin et al., 2012; Kiekintveld,
Jain, Tsai, Pita, OrdoÃÅnÃÉez, & Tambe, 2009), we model the game as a Stackelberg game, where
the defender commits to a randomized strategy first, and then the attacker can respond to
such a strategy. The patrol schedules in these domains were previously created by hand;
and hence suffer the drawbacks of hand-drawn patrols, including lack of randomness (in
particular, informed randomness) and reliance on simple patrol patterns (Tambe, 2011),
which we remedy in this paper.
2.2 Defender Strategy
A pure strategy of the defender is to designate a movement schedule for each patroller.
Analogous to the target‚Äôs schedule, a patroller‚Äôs schedule can be written as a continuous
function Ru : T ‚Üí D where u = 1, ..., W is the index the patroller. Ru must be compatible
with the patroller‚Äôs velocity range. A mixed defender strategy is a randomization over the
pure strategies, denoted as f .
2.3 Attacker Strategy
The attacker conducts surveillance of the defender‚Äôs mixed strategy and the targets‚Äô schedules; he may then execute a pure strategy response to attack a certain target at a certain
time. The attacker‚Äôs pure strategy can be denoted as hq, ti where q is the index of target
to attack and t is the time to attack.
2.4 Utility Function
We assume the game is zero-sum. If the attacker performs a successful attack on target Fq
at location x at time t, he gets a positive reward Uq (x, t) and the defender gets ‚àíUq (x, t),
otherwise both players get utility zero. The positive reward Uq (x, t) is a known function
which accounts for many factors in practice. For example, an attacker may be more effective
in his attack when the target is stationary (such as at a terminal point) than when the target
is in motion. As the target‚Äôs position is decided by the schedule, the utility function can be
written as Uq (t) ‚â° Uq (Sq (t), t). We assume that for each target Fq , Uq (t) can be represented
as a piecewise linear function of t.
2.5 Equilibrium
Since our game is zero-sum, the Strong Stackelberg Equilibrium can be calculated by finding
the minimax/maximin strategy (Fudenberg & Tirole, 1991; Korzhyk et al., 2010). That is,
587

Fang, Jiang, & Tambe

we can find the optimal defender strategy by finding a strategy that minimizes the maximum
of attacker‚Äôs expected utility.
Definition 2. For single patroller case, the attacker expected utility of attacking target Fq
at time t given defender mixed strategy f is
AttEUf (Fq , t) = (1 ‚àí C1 œâf (Fq , t))Uq (t)

(1)

Uq (t) is the reward for a successful attack, œâf (Fq , t) is the probability that the patroller
is protecting target Fq at time t and C1 is the protection coefficient of single patroller. We
drop the subscript if f is obvious from the context. As C1 and Uq (t) are constants for a given
attacker‚Äôs pure strategy hq, ti, AttEU(Fq , t) is purely decided by œâ(Fq , t). The definition
with multiple patrollers will be given in Section 3.4. We further denote the attacker‚Äôs
maximum expected utility as
AttEUm
f = max AttEUf (Fq , t)
q,t

(2)

So the optimal defender strategy is a strategy f such that the AttEUm
f is minimized, formally
f ‚àà arg minf 0 AttEUm
f0

(3)

2.6 Assumptions
In our problem, the following assumptions are made based on discussions with domain
experts. Here we provide our justifications for these assumptions. While appropriate for the
current domain of application, relaxing these assumptions for future applications remains
an issue for future work; and we provide an initial discussion in Section 10.
‚Ä¢ The attacker‚Äôs plan is decided off-line, i.e., the attacker does not take into account the
patroller‚Äôs current partial route (partial pure strategy) in executing an attack: This
assumption is similar to the assumption made in other applications of security games
and justified elsewhere (An, Kempe, Kiekintveld, Shieh, Singh, Tambe, & Vorobeychik, 2012; Pita, Jain, Ordonez, Portway, Tambe, Western, Paruchuri, & Kraus,
2009; Tambe, 2011). One key consideration is that given that attackers have limited
resources as well, for them to generate and execute complex conditional plans that
change based on ‚Äúon-line‚Äù observations of defender‚Äôs pure strategy is both difficult
and risky.
‚Ä¢ A single attacker is assumed instead of multiple attackers: This assumption arises
because performing even a single attack is already costly for the attacker. Thus,
having coordinating attackers at the same time will be even harder and therefore
significantly less likely for the attacker.
‚Ä¢ The game is assumed to be zero-sum: In this case, the objectives of the defender and
attacker are in direct conflict: preventing an attack with higher potential damage is
a bigger success to the defender in our game.
588

Protecting Moving Targets with Multiple Mobile Resources

‚Ä¢ The schedules for the targets are deterministic: For the domains we focus on, potential
delays in the targets‚Äô schedules are usually within several minutes if any, and the
targets will try to catch up with the fixed schedules as soon as possible. Therefore,
even when delays occur, the deterministic schedule for a target can be viewed as a
good approximation of the actual schedule.

3. Models
In this section, we introduce our MRMTsg model that uses a discretized strategy space for
the defender and a continuous strategy space for the attacker. For clarity of exposition, we
then introduce the DASS approach to compute a minimax solution for discretized attacker
strategy space (Section 3.2), followed by CASS for the attacker‚Äôs continuous strategy space
(Section 3.3). We first assume a single patroller in Sections 3.1 through 3.3 and then
generalize to multiple patrollers in Section 3.4.
3.1 Representing Defender‚Äôs Strategies
In this subsection, we introduce the discretized defender strategy space and the compact
representation used to represent the defender‚Äôs mixed strategy. We show that the compact
representation is equivalent to the intuitive full representation, followed by several properties
of the compact representation.
Since the defender‚Äôs strategy space is discretized, we assume that each patroller only
makes changes at a finite set of time points T = {t1 , t2 , ..., tM }, evenly spaced across the
original continuous time interval. t1 = 0 is the starting time and tM = 1 is the normalized
ending time. We denote by Œ¥t the distance between two adjacent time points: Œ¥t = tk+1 ‚àí
tk = M1‚àí1 . We set Œ¥t to be small enough such that for each target Fq , the schedule Sq (t)
and the utility function Uq (t) are linear in each interval [tk , tk+1 ] for k = 1, . . . , M ‚àí 1, i.e.,
the target is moving with uniform speed and the utility of a successful attack on it changes
linearly during each of these intervals. Thus, if t0 is a breakpoint of Sq (t) or Uq (t) for any
q, it can be represented as t0 = Œ¥tK0 where K0 is an integer.
In addition to discretization in time, we also discretize the line segment AB that the
targets move along into a set of points D = {d1 , d2 , ..., dN } and restrict each patroller to be
located at one of the discretized points di at any discretized time point tk . Note that D is not
necessarily evenly distributed and the targets‚Äô locations are not restricted at any tk . During
each time interval [tk , tk+1 ], each patroller moves with constant speed from her location di
at time tk to her location dj at time tk+1 . Only movements compatible with the speed limit
vm are possible. The points d1 , d2 , ..., dN are ordered by their distance to terminal A, and
d1 refers to A and dN refers to B. Since the time interval is discretized into M points, a
patroller‚Äôs route Ru can be represented as a vector Ru = (dru (1) , dru (2) , ..., dru (M ) ). ru (k)
indicates the index of the discretized distance point where the patroller is located at time
tk .
As explained in Section 1, we discretized the defender‚Äôs strategy space not only for
computational reasons. It is not even clear whether an equilibrium exists in the original
game with continuous strategy space for both players. The discretization is made also
because of the practical constraint of patrollers.
589

Fang, Jiang, & Tambe

For expository purpose, we first focus on the case with a single defender resource and
then generalize to larger number of resources later. For a single defender resource, the
defender‚Äôs mixed strategy in full representation assigns a probability to each of the patrol
routes that can be executed. Since at each time step a patroller can choose to go to at most
N different locations, there are at most N M possible patrol routes in total and this number
is achievable if there is no speed limit (or vm is large enough). The exponentially growing
number of routes will make any analysis based on full representation intractable.
Therefore, we use the compact representation of the defender‚Äôs mixed strategy.
Definition 3. The compact representation for a single defender resource is a compact
way to represent the defender‚Äôs mixed strategy using flow distribution variables {f (i, j, k)}.
f (i, j, k) is the probability of the patroller moving from di at time tk to dj at time tk+1 .
The complexity of the compact representation is O(M N 2 ), which is much more efficient
compared to the full representation.
Proposition 1. Any strategy in full representation can be mapped into a compact representation.
Proof sketch: If there are H possible patrol routes R1 , R2 , ..., RH , a mixed defender
strategy can be represented in full representation as a probability vector (p(R1 ), ...p(RH ))
where p(Ru ) is the probability of taking route Ru . Taking route Ru means the patroller
moves from dru (k) to dru (k+1) during time [tk , tk+1 ], so the edge ERu (k),Ru (k+1),k is taken
when route Ru is chosen. Then the total probability of taking edge Ei,j,k is the sum of
probabilities of all the routes Ru where Ru (k) = i and Ru (k + 1) = j. Therefore, given
any strategy in full presentation specified by the probability vector (p(R1 ), ...p(RH )), we
can construct a compact representation consisting of a set of flow distribution variables
{f (i, j, k)} where
X
f (i, j, k) =
p(Ru ).
(4)
Ru :Ru (k)=i and Ru (k+1)=j

Figure 3 shows a simple example illustrating the compact representation. Numbers on
the edges indicate the value of f (i, j, k). We use Ei,j,k to denote the directed edge linking
nodes (tk , di ) and (tk+1 , dj ). For example, f (2, 1, 1), the probability of the patroller moving
from d2 to d1 during time t1 to t2 , is shown on the edge E2,1,1 from node (t1 , d2 ) to node
(t2 , d1 ). While a similar compact representation was used earlier by Yin et al. (2012), we
use it in a continuous setting.
Note that different mixed strategies in full representation can be mapped to the same
compact representation. Table 1 shows two different mixed defender strategies in full representations that can be mapped to the same mixed strategy in compact representation as
shown in Figure 3. The probability of a route is labeled on all edges in the route in full
representation. Adding up the numbers of a particular edge Ei,j,k in all routes of a full
representation together, we can get f (i, j, k) for the compact representation.
Theorem 1. Compact representation does not lead to any loss in solution quality.
590

ƒö≈ù∆ê∆öƒÇ≈∂ƒêƒû

Protecting Moving Targets with Multiple Mobile Resources

›Ä‡¨∂
›Ä‡¨µ
‚Ä´›ê‚Ä¨‡¨µ

∆ö≈ù≈µƒû
œ¨Õòœ≤ ‚Ä´›ê‚Ä¨
‡¨∂

œ¨Õòœ≤

‚Ä´›ê‚Ä¨‡¨∑

Figure 3: Compact representation: x-axis shows time intervals; y-axis the discretized
distance-points in the one-dimensional movement space.

R1 = (d1 , d1 , d1 )
œ¨Õòœ≤

œ¨Õòœ≤

R1 = (d1 , d1 , d1 )
œ¨ÕòœÆ

œ¨ÕòœÆ

Full Representation 1
R2 = (d1 , d1 , d2 )
R3 = (d2 , d1 , d1 )
œ¨

R4 = (d2 , d1 , d2 )

œ¨

Full Representation 2
R2 = (d1 , d1 , d2 )
R3 = (d2 , d1 , d1 )

R4 = (d2 , d1 , d2 )

œ¨Õòœ∞

œ¨Õòœ∞

Table 1: Two full representations that can be mapped into the same compact representation
shown in Figure 3.

Proof sketch: The complete proof of the theorem relies on the calculations in Section
3.2 and 3.3. Here we provide a sketch. Recall our goal is to find an optimal defender
strategy f that minimizes the maximum attacker expected utility AttEUm
f . As we will
show in the next subsections, œâ(Fq , t) can be calculated from the compact representation
{f (i, j, k)}. If two defender strategies under the full representation are mapped to the same
compact representation {f (i, j, k)}, they will have the same œâ function and then the same
AttEU function according to Equation 1. Thus the value of AttEUm
f is the same for the
two defender strategies. So an optimal mixed defender strategy in compact representation
is still optimal for the corresponding defender strategies in full representation.
We exploit the following properties of the compact representation.
Property 1.
ForPany time interval [tk , tk+1 ], the sum of all flow distribution variables
PN
N
equals to 1:
i=1
j=1 f (i, j, k) = 1.
Property 2. The sum of flows that go into a particular node equals the sum
P of flows that
go out of the node. Denote the sum for node (tk , di ) by p(i, k), then p(i, k) = N
j=1 f (j, i, k ‚àí
PN
1) = j=1 f (i, j, k). Each p(i, k) is equal to the marginal probability that the patroller is at
location di at time tk .
P
Property 3. Combining Property 1 and 2, N
i=1 p(i, k) = 1.
591

Fang, Jiang, & Tambe

3.2 DASS: Discretized Attacker Strategies
In this subsection, we introduce DASS, a mathematical program that efficiently finds minimax solutions for MRMTsg -based games under the assumption that the attacker will attack
at one of the discretized time points tk . In this problem, we need to minimize v where v
is the maximum of attacker‚Äôs expected utility. Here, v is the maximum of AttEU(Fq , t) for
any target Fq at any discretized time point tk .
From Equation (1), we know that AttEU(Fq , t) is decided by œâ(Fq , t), the probability
that the patroller is protecting target Fq at time t. Given the position of the target Sq (t), we
define the protection range Œ≤q (t) = [max{Sq (t)‚àíre , d1 }, min{Sq (t)+re , dN }]. If the patroller
is located within the range Œ≤q (t), the distance between the target and the patroller is no
more than re and thus the patroller is protecting Fq at time t. So œâ(Fq , t) is the probability
that the patroller is located within range Œ≤q (t) at time t. For the discretized time points
tk , the patroller can only be located at a discretized distance point di , so we define the
following.

Definition 4. I(i, q, k) is a function of two values. I(i, q, k) = 1 if di ‚àà Œ≤q (tk ), and
otherwise I(i, q, k) = 0.

In other words, I(i, q, k) = 1 means that a patroller located at di at time tk can protect target Fq . Note that the value of I(i, q, k) can be calculated directly from the input
parameters (di , Sq (t) and re ) and stored in a look-up table. In particular, I(i, q, k) is not
a variable in the formulations that follow. It simply encodes the relationship between di
and the location of target Fq at tk . The probability that the patroller is at di at time tk is
p(i, k). So we have
œâ(Fq , tk ) =

X


AttEU(Fq , tk ) =

1 ‚àí C1

i:I(i,q,k)=1

p(i, k),

X
i:I(i,q,k)=1


p(i, k) Uq (tk ).

(5)

(6)

Equation (6) follows from Equations (1) and (5), expressing attacker‚Äôs expected utility for
discretized time points. Finally, we must address speed restrictions on the patroller. We set
all flows corresponding to actions that are not achievable to zero,1 that is, f (i, j, k) = 0 if
|dj ‚àí di | > vm Œ¥t. Thus, DASS can be formulated as a linear program. This linear program

1. Besides the speed limit, we can also model other practical restrictions of the domain by placing constraints
on f (i, j, k).

592

Protecting Moving Targets with Multiple Mobile Resources

solves for any number of targets but only one defender resource.
min

z

(7)

f (i,j,k),p(i,k)

f (i, j, k) ‚àà [0, 1],

‚àÄi, j, k

(8)

f (i, j, k) = 0,

‚àÄi, j, k such that |dj ‚àí di | > vm Œ¥t

(9)

p(i, k) =

N
X

f (j, i, k ‚àí 1),

‚àÄi, ‚àÄk > 1

(10)

f (i, j, k),

‚àÄi, ‚àÄk < M

(11)

‚àÄk

(12)

‚àÄq, ‚àÄk

(13)

j=1

p(i, k) =

N
X
j=1

N
X

p(i, k) = 1,

i=1

z ‚â• AttEU(Fq , tk ),

Constraint 8 describes the probability range. Constraint 9 describes the speed limit. Constraints 10‚Äì11 describes Property 2. Constraint 12 is exactly Property 3. Property 1 can
be derived from Property 2 and 3, so it is not listed as a constraint. Constraint (13) shows
the attacker chooses the strategy that gives him the maximal expected utility among all
possible attacks at discretized time points; where AttEU(¬∑) is described by Equation (6).
3.3 CASS: Continuous Attacker Strategies
In this subsection, we generalize the problem to one with continuous attacker strategy set
and provides a linear-programming-based solution CASS. CASS efficiently finds optimal
mixed defender strategy under the assumption that the attacker can attack at any time
in the continuous time interval T = [0, 1]. With this assumption, DASS‚Äôs solution quality
guarantee may fail: if the attacker chooses to attack between tk and tk+1 , he may get
a higher expected reward than attacking at tk or tk+1 . Consider the following example,
with the defender‚Äôs compact strategy between tk and tk+1 shown in Figure 4. Here the
defender‚Äôs strategy has only three non-zero flow variables f (3, 4, k) = 0.3, f (3, 1, k) = 0.2,
and f (1, 3, k) = 0.5, indicated by the set of three edges E + = {E3,4,k , E3,1,k , E1,3,k }. A
target Fq moves from d3 to d2 at constant speed during [tk , tk+1 ]. Its schedule is depicted
by the straight line segment Sq . The dark lines L1q and L2q are parallel to Sq with distance
re . The area between them indicates the protection range Œ≤q (t) for any time t ‚àà (tk , tk+1 ).
Consider the time points at which an edge from E + intersects one of L1q , L2q , and label them
r , r = 1 . . . 4 in Figure 4). Intuitively, these are all the time points at which a defender
as Œ∏qk
patrol could potentially enter or leave the protection range of the target. To simplify the
0 and t
5
notation, we denote tk as Œ∏qk
k+1 as Œ∏qk . For example, a patroller moving from d3
0 to Œ∏ 1 because
to d4 (or equivalently, taking the edge E3,4,k ) protects the target from Œ∏qk
qk
0 , Œ∏ 1 ], during which the distance to the target is less or
E3,4,k is between L11 and L21 in [Œ∏qk
qk
r and Œ∏ r+1 , for
equal than protection radius re . Consider the sub-intervals between each Œ∏qk
qk
r = 0 . . . 4. Since within each of these five sub-intervals, no patroller enters or leaves the
593

Fang, Jiang, & Tambe

protection range, the probability that the target is being protected is a constant in each
sub-interval, as shown in Figure 5(a).

ƒö≈ù∆ê∆öƒÇ≈∂ƒêƒû

›Ä‡¨∏
‚Ä´›é‚Ä¨
›Ä‡¨∑ ‚Ä´›é‚Ä¨‡Øò
‡Øò
›Ä‡¨∂
›Ä‡¨µ
‡¨¥ ‡¨µ
‡¨∂
‡¨∑
‡¨∏
‡¨π
ﬂ†‡Ø§‡Øû ﬂ†‡Ø§‡Øû
ﬂ†‡Ø§‡Øû
ﬂ†‡Ø§‡Øû
ﬂ†‡Ø§‡Øû
ﬂ†‡Ø§‡Øû
‚Ä´›ê‚Ä¨‡Øû
‚Ä´›ê‚Ä¨‡Øû‡¨æ‡¨µ

∆ö≈ù≈µƒû

Figure 4: An example to show how a target moving from d3 to d2 during [tk , tk+1 ] is pror , Œ∏ r+1 ], a patroller either always protects the target
tected. In a sub-interval [Œ∏qk
qk
or never protects the target. Equivalently, the target is either always within the
protective circle of a patroller or always outside the circle.

Suppose Uq (t) decreases linearly from 2 to 1 during [tk , tk+1 ] and C1 = 0.8. We can then
calculate the attacker‚Äôs expected utility function AttEU(Fq , t) for (tk , tk+1 ), as plotted in
Figure 5(b). AttEU(Fq , t) is linear in each sub-interval but the function is discontinuous at
1 , . . . , Œ∏ 4 because of the patroller leaving or entering the protection
the intersection points Œ∏qk
qk
r from the left as:
range of the target. We denote the limit of AttEU when t approaches Œ∏qk
r‚àí
lim AttEU(Fq , t) = AttEU(Fq , Œ∏qk
)

r‚àí
t‚ÜíŒ∏qk

Similarly, the right limit is denoted as:
r+
lim AttEU(Fq , t) = AttEU(Fq , Œ∏qk
)

r+
t‚ÜíŒ∏qk

2 ,
If Fq is the only target, an attacker can choose to attack at a time immediately after Œ∏qk
getting an expected utility that is arbitrarily close to 1.70. According to Equation (6), we
2+
can get AttEU(Fq , tk ) = 1.20 and AttEU(Fq , tk+1 ) = 1.00, both lower than AttEU(Fq , Œ∏qk
).
Thus, the attacker can get a higher expected reward by attacking between tk and tk+1 ,
violating DASS‚Äôs quality guarantee.
However, because of discontinuities in the attacker‚Äôs expected utility function, a maximum might not exist. This implies that the minimax solution concept might not be welldefined for our game. We thus define our solution concept to be minimizing the supremum
of AttEU(Fq , t).

594

Protecting Moving Targets with Multiple Mobile Resources





0.50

1.70
1.43
1.20
1.00

0.20
0.00
‡Øû‡¨¥ ‡Øû‡¨µ ‡Øû‡¨∂
‡Øû

‡Øû‡¨∑

‡Øû‡¨∏

‡Øû‡¨π ∆ö≈ù≈µƒû
‡Øû‡¨æ‡¨µ


‡Øû‡¨¥ 
‡Øû‡¨µ 
‡Øû‡¨∂
‡Øû

(a) Probability that the target is protected
is a constant in each sub-interval.


‡Øû‡¨∑


‡Øû‡¨∏


‡Øû‡¨π ∆ö≈ù≈µƒû
‡Øû‡¨æ‡¨µ

(b) The attacker‚Äôs expected utility is linear
in each sub-interval.

Figure 5: Sub-interval analysis in (tk , tk+1 ) for the example shown in Figure 4.]
Definition 5. The supremum of attacker‚Äôs expected utility is the smallest real number
that is greater than or equal to all elements of the infinite set {AttEU(Fq , t)}, denoted as
sup AttEU(Fq , t).
The supremum is the least upper bound of the function AttEU(Fq , t). So for CASS
model, Equation 2 should be modified as
AttEUm
f = sup AttEUf (Fq , t)

(14)

q,t

So a defender strategy f is minimax if AttEUm
f is maximized, i.e.,
f ‚àà arg minf 0 sup AttEUf 0 (Fq , t)
2+
)=
In the above example, the supremum of attacker‚Äôs expected utility in (tk , tk+1 ) is AttEU(Fq , Œ∏qk
1.70. In the rest of the paper, we will not specify when supremum is used instead of maximum as it can be easily inferred from the context.
How can we deal with the possible attacks between the discretized points and find an
optimal defender strategy? We generalize the process above (called sub-interval analysis)
to all possible edges Ei,j,k . We then make use of the piecewise linearity of AttEU(Fq , t)
and the fact that the potential discontinuity points are fixed, which allows us to construct
a linear program that solves the problem to optimality. We name the approach CASS
(Solver for Continuous Attacker Strategies).
We first introduce the general sub-interval analysis. For any target Fq and any time
interval (tk , tk+1 ), we calculate the time points at which edges Ei,j,k and L1q , L2q intersect,
denoted as intersection points. We sort the intersection points in increasing order, denoted
r , r = 1 . . . M , where M
0
as Œ∏qk
qk
qk is the total number of intersection points. Set Œ∏qk = tk and
M

Œ∏qkqk

+1

r , Œ∏ r+1 ), r = 0, ..., M .
= tk+1 . Thus (tk , tk+1 ) is divided into sub-intervals (Œ∏qk
qk
qk

Lemma 1. For any given target Fq , AttEU(Fq , t) is piecewise-linear in t. Furthermore,
there exists a fixed set of time points, independent of the defender‚Äôs mixed strategy, such
that AttEU(Fq , t) is linear between each adjacent pair of points. Specifically, these points
r defined above.
are the intersection points Œ∏qk
595

Fang, Jiang, & Tambe

r , Œ∏ r+1 ) for a target F , a feasible edge E
Proof: In each sub-interval (Œ∏qk
q
i,j,k is either
qk
1
2
totally above or below Lq , and similarly for Lq . Otherwise there will be a new intersection
point which contradicts the definition of the sub-intervals. If edge Ei,j,k is between L1q and
L2q , the distance between a patroller taking the edge and target Fq is less than re , meaning
the target is protected by the patroller. As edge Ei,j,k is taken with probability f (i, j, k),
the total probability that the target is protected (œâ(Fq , t)) is the sum of f (i, j, k) whose
corresponding edge Ei,j,k is between the two lines in a sub-interval. So œâ(Fq , t) is constant
in t in each sub-interval and thus the attacker‚Äôs expected utility AttEU(Fq , t) is linear in
each sub-interval according to Equation 2 as Uq (t) is linear in [tk , tk+1 ]. Discontinuity can
only exist at these intersection points and an upper bound on the number of these points
for target Fq is M N 2 .
r , Œ∏ r+1 ), and 0
Define coefficient Arqk (i, j) to be C1 if edge Ei,j,k is between L1q and L2q in (Œ∏qk
qk
otherwise. According to Equation (1) and the fact that œâ(Fq , t) is the sum of f (i, j, k) whose
r , Œ∏ r+1 ).
corresponding coefficient Arqk (i, j) = C1 , we have the following equation for t ‚àà (Œ∏qk
qk
Ô£∂
Ô£´
N X
N
X
Ô£≠
(15)
AttEU(Fq , t) = 1 ‚àí
Arqk (i, j)f (i, j, k)Ô£∏ ¬∑ Uq (t)
i=1 j=1

Piecewise linearity of AttEU(Fq , t) means the function is monotonic in each sub-interval and
the supremum can be found at the intersection points. Because of linearity, the supremum
r , Œ∏ r+1 ) can only be chosen from the one-sided limits of the endpoints,
of AttEU in (Œ∏qk
qk
(r+1)‚àí

r+
) and AttEU(Fq , Œ∏qk
). Furthermore, if Uq (t) is decreasing in [tk , tk+1 ],
AttEU(Fq , Œ∏qk
the supremum is
(r+1)‚àí
r+
) and otherwise it is AttEU(Fq , Œ∏qk
). In other words, all other attacker‚Äôs
AttEU(Fq , Œ∏qk
r+1
r or Œ∏ r+1 . Thus, CASS
r
strategies in (Œ∏qk , Œ∏qk ) are dominated by attacking at time close to Œ∏qk
qk
adds new constraints to Constraints 8‚Äì13 which consider attacks to occur at t ‚àà (tk , tk+1 ).
We add one constraint for each sub-interval with respect to the possible supremum value
in this sub-interval:

min

z

(16)

f (i,j,k),p(i,k)

subject to constraints (8 . . . 13)
(r+1)‚àí

r+
z ‚â• max{AttEU(Fq , Œ∏qk
), AttEU(Fq , Œ∏qk

)}

(17)

‚àÄk ‚àà {1 . . . M }, q ‚àà {1 . . . L}, r ‚àà {0 . . . Mqk }
This linear program stands at the core of CASS and we will not differentiate the name
for the solver and the name for the linear program in the following. All the linear constraints included by Constraint 17 can be added to CASS using Algorithm 1. The input
of the algorithm include targets‚Äô schedules {Sq }, the protection radius re , the speed limit
vm , the set of discretized time points {tk } and the set of discretized distance points {di }.
Function CalInt(L1q , L2q , vm ) in Line 1 returns the list of all intersection time points between
0 and
all possible edges Ei,j,k and the parallel lines L1q , L2q , with additional points tk as Œ∏qk
M

+1

r , Œ∏ r+1 ) in Line 1 returns the coefficient
tk+1 as Œ∏qkqk . Function CalCoef(L1q , L2q , vm , Œ∏qk
qk
r
r
matrix Aqk . Aqk can be easily decided by checking the status at the midpoint in time. Set

596

Protecting Moving Targets with Multiple Mobile Resources

r + Œ∏ r+1 )/2 and denote the patroller‚Äôs position at t
tmid = (Œ∏qk
mid when edge Ei,j,k is taken as
qk
Ei,j,tmid , thus Arqk (i, j) = C1 if Ei,j,tmid ‚àà Œ≤q (tmid ). Lines 1‚Äì1 add a constraint with respect
(r+1)‚àí

r+
to the larger value of AttEU(Fq , Œ∏qk
) and AttEU(Fq , Œ∏qk
) to CASS for this sub-interval
r+1
r
(Œ∏qk , Œ∏qk ). It means when the attacker chooses to attack Fq in this sub-interval, his best
r , Œ∏ r+1 ).
choice is decided by the larger value of the two side-limits of AttEU in (Œ∏qk
qk

Algorithm 1: Add constraints described in Constraint 17
Input: Sq , re , vm , {tk }, {di };
for k ‚Üê 1, . . . , M ‚àí 1 do
for q ‚Üê 1, . . . , L do
L1q ‚Üê Sq + re , L2q ‚Üê Sq ‚àí re ;
M

+1

0 , . . . , Œ∏ qk
‚Üê CalInt(L1q , L2q , vm );
Œ∏qk
qk
for r ‚Üê 0, . . . , Mqk do
r , Œ∏ r+1 );
Arqk ‚Üê CalCoef(L1q , L2q , vm , Œ∏qk
qk
if Uq (t) is decreasing in [tk , tk+1 ] then
r+
add constraint z ‚â• AttEU(Fq , Œ∏qk
)
end
else
(r+1)‚àí
add constraint z ‚â• AttEU(Fq , Œ∏qk
)
end
end
end
end

Theorem 2. CASS computes (in polynomial time) the exact solution (minimax) of the
game with discretized defender strategies and continuous attacker strategies.
Proof: According to Lemma 1, AttEU(Fq , t) is piecewise linear and discontinuity can
r . These intersection points divide the time space
only occur at the intersection points Œ∏qk
into sub-intervals. Because of piecewise linearity, the supremum of AttEU(Fq , t) equals to
the limit of an endpoint of at least one sub-interval. For any defender‚Äôs strategy f that is
feasible, a feasible z of the linear program 16-17 is no less than any of the limit values at the
intersection points according to Constraint 17 and values at the discretized time points tk
according to Constraint 13, and thus v can be any upper bound of AttEU(Fq , t) for f . As z
is minimized in the objective function, z is no greater than the supremum of AttEU(Fq , t)
given any defender strategy f , and further z will be the minimum of the set of supremum
corresponding to all defender strategies. Thus we get the optimal defender strategy f .
The total number of variables in the linear program is O(M N 2 ). The number of constraints represented in Algorithm 1 is O(M N 2 L) as the number of intersection points is at
most 2(M ‚àí 1)N 2 for each target. The number of constraints represented in Constraints
8‚Äì13 is O(M N 2 ). Thus, the linear program computes the solution in polynomial time.
Corollary 1. The solution of CASS provides a feasible defender strategy of the original
continuous game and gives exact expected value of that strategy.
597

Fang, Jiang, & Tambe

3.4 Generalized Model with Multiple Defender Resources
In this subsection, we generalize DASS and CASS to solve the problem with multiple defender resources. When there are multiple patrollers, the patrollers will coordinate with
each other. Recall the protection coefficient CG in Definition 1, a target is better protected
when more patrollers are close to it (within radius re ). So the protection provided to a
target is determined when all patrollers‚Äô locations are known. Thus it is not sufficient to
calculate the probability that an individual edge is taken as in the single patroller case.
Under the presence of multiple patrollers, we need a more complex representation to explicitly describe the defender strategy. To illustrate generalization to the multiple defender
resources case, we first take two patrollers as an example. If there are two patrollers, the
patrol strategy can be represented using flow distribution variables {f (i1 , j1 , i2 , j2 , k)}. Here
the flow distribution variables are defined on the Cartesian product of two duplicated sets
of all feasible edges {Ei,j,k }. f (i1 , j1 , i2 , j2 , k) is the joint probability of the first patroller
moving from di1 to dj1 and the second patroller moving from di2 to di2 during time tk to
tk+1 , i.e., taking edge Ei1 ,j1 ,k and Ei2 ,j2 ,k respectively. The corresponding marginal distribution variable p(i1 , i2 , k) represents for the probability that the first patroller is at di1 and
the second at di2 at time tk . Protection coefficients C1 and C2 are used when one or two
patrollers are protecting the target respectively.
So the attacker‚Äôs expected utility can be written as
AttEU(Fq , t) = (1 ‚àí (C1 ¬∑ œâ1 (Fq , t) + C2 ¬∑ œâ2 (Fq , t))) ¬∑ Uq (t)
œâ1 (Fq , t) is the probability that only one patroller is protecting the target Fq at time t
and œâ2 (Fq , t) is the probability that both patrollers are protecting the target. For attacks
that happen at discretized points tk , we can make use of I(i, q, k) in Definition 4 and
I(i1 , q, k) + I(i2 , q, k) is the total number of patrollers protecting the ferry at time tk .
X
œâ1 (Fq , tk ) =
p(i1 , i2 , k)
i1 ,i2 :I(i1 ,q,k)+I(i2 ,q,k)=1
X
œâ2 (Fq , tk ) =
p(i1 , i2 , k)
i1 ,i2 :I(i1 ,q,k)+I(i2 ,q,k)=2

Constraints for attacks occurring in (tk , tk+1 ) can be calculated with an algorithm that
looks the same as Algorithm 1. The main difference is in the coefficient matrix Arqk and
the expression of AttEU. We set the values in the coefficient matrix Arqk (i1 , j1 , i2 , j2 ) as C2
if both edges Ei1 ,j1 ,k and Ei2 ,j2 ,k are between L1q and L2q , and C1 if only one of the edges
r , Œ∏ r+1 ) is
protects the target. The attacker‚Äôs expected utility function in (Œ∏qk
qk
X
AttEU(Fq , t) = (1 ‚àí
Arqk (i1 , j1 , i2 , j2 )f (i1 , j1 , i2 , j2 , k)) ¬∑ Uq (t)
i1 ,j1 ,i2 ,j2

For a general case of W defender resources, we can use {f (i1 , j1 , ..., iW , jW , k)} to represent the patrol strategy.
Definition 6. The compact representation for multiple defender resources is a compact way
to represent the defender‚Äôs mixed strategy using flow distribution variables {f (i1 , j1 , ..., iW , jW , k)}.
{f (i1 , j1 , ..., iW , jW , k)} is the joint probability that patroller moving from diu at time tk to
dju at time tk+1 for u = 1 . . . W .
598

Protecting Moving Targets with Multiple Mobile Resources

Given the generalized compact representation, we get the following equations for calculating the attacker‚Äôs expected utility function and the protection probability:
Ô£´
Ô£∂
W
X
AttEU(Fq , t) = Ô£≠1 ‚àí
CQ ¬∑ œâQ (Fq , t)Ô£∏ ¬∑ Uq (t)
Q=1

œâQ (Fq , tk ) =

X
i1 ,...,iW :

W
P

p(i1 , . . . , iW , k)
I(iu ,q,k)=Q

u=1

Q is the number of patrollers protecting the target. We can modify Algorithm 1 to apply
for the multiple defender resource case. Set Arqk (i1 , j1 , ..., iW , jW ) as CQ if Q of the edges
{Eiu ,ju ,k } are between L1q and L2q .
We conclude the linear program for generalized CASS for multiple patrollers as follows.
min

z

(18)

f (i1 ,j1 ,...,iW ,jW ,k),p(i1 ,...,iW ,k)

f (i1 , j1 , . . . , iW , jW , k) = 0, ‚àÄi1 , . . . , iW , j1 , . . . , jW such that ‚àÉu, |dju ‚àí diu | > vm Œ¥t
(19)
n
n
X
X
p(i1 , . . . , iW , k) =
...
f (j1 , i1 , . . . , jW , iW , k ‚àí 1), ‚àÄi1 , . . . , iW , ‚àÄk > 1
j1 =1

jW =1

n
X

n
X

(20)
p(i1 , . . . , iW , k) =

...

j1 =1

f (i1 , j1 , . . . , iW , jW , k), ‚àÄi1 , . . . , iW , ‚àÄk < M

jW =1

(21)
n
X
i1 =1

...

n
X

p(i1 , . . . , iW , k) = 1, ‚àÄk

(22)

iW =1

z ‚â• AttEU(Fq , tk ), ‚àÄq, ‚àÄk
z‚â•

(r+1)‚àí
r+
max{AttEU(Fq , Œ∏qk
), AttEU(Fq , Œ∏qk
)}, ‚àÄk, ‚àÄq, ‚àÄr

(23)
(24)

The number of variables in the linear program is O(M N 2W ) and the number of constraints is O(M N W ). It is reasonable to examine potentially more efficient alternatives.
We summarize the results of such an examination below concluding that using the current
linear program would appear to currently offer our best tradeoff in terms of solution quality and time at least for the current domains of application; although as discussed below,
significant future work might reveal alternatives approaches for other future domains.
The first question to examine is that of the computational complexity of the problem
at hand: generating optimal patrolling strategies for multiple patrollers on a graph. Unfortunately, despite significant attention paid to the topic, currently, the complexity remains
unknown. More specifically, the question of computational complexity of generating patrols
for multiple defenders on graphs of different types has received significant attention (Letchford, 2013; Korzhyk et al., 2010). These studies illustrate that in several cases the problem
is NP-hard, in some cases the problem is known to be polynomial time, but despite significant effort, the problem complexity in many cases remains unknown (Letchford & Conitzer,
599

Fang, Jiang, & Tambe

2013). Unfortunately, our graph turns out to be different from the cases considered in their
work. Indeed, the DASS model can be explained as a game with homogeneous defender
resources patrolling on a graph, similar to the cases that have already been considered.
However, prior results cannot explain the complexity of our game as the structure of our
graph does not fit any of the prior graphs.
Given that computational complexity results are not directly available, we may examine
approaches to provide efficient approximations. Here we provide an overview of two such
approaches (providing experimental results in Section 7.1.6). Our first approach attempts
to provide a more compact representation in the hope of providing a speedup. To that end,
we apply an intuitive approach that uses individual strategy profile for each patroller and
then calculates a best possible mixed strategy combination. Unfortunately, this approach
is inefficient in run-time even for the DASS model and may result in a suboptimal solution.
Thus, although more compact, this approach fails to achieve our goal; we explain this
approach next.
Assume each patroller independently follows her own mixed strategy. Denote the individual mixed strategy for patroller u as fu (iu , ju , tk ), and the probability that a target is
protected by Q players can be represented as a polynomial expression of {fu (iu , ju , tk )} of
order Q. Then our optimization problem is converted to minimizing objective function z
with non-linear constraints. Assume we have two patrollers, and for a potential attack at
target q at time tk , we denote the probability that patroller u is protecting the target as
$u . $u is linear in fu , and the attacker‚Äôs expected utility for this attack can be represented
as
AttEU(Fq , tk ) = (1 ‚àí C1 ((1 ‚àí $1 )$2 + (1 ‚àí $2 )$1 ) ‚àí C2 $1 $2 )Uq (tk )
So a constraint z ‚â• AttEU(Fq , tk ) is quadratic in f , due to the fact that the joint probability
is represented by the product of the individual probability of each patroller. These constraints are not ensured to have a convex feasible region and there is no known polynomial
algorithms for solving this kind of non-convex optimization problems. We attempt to solve
the problem by converting it into a mathematical program with a non-convex objective function and linear constraints, i.e., instead of minimizing z with constraints z ‚â• AttEU(Fq , tk ),
we incorporate the constraints into the objective function as
z = max{AttEU(Fq , tk )}
q,k

(25)

The results in Section 7.1.6 show that when we solve this mathematical program in MATLAB using function fmincon with interior-point method for the DASS model, the algorithm
fails to get to a feasible solution efficiently and even when enough time is given, the solution
can still be suboptimal as it may get stuck at a local minimum. To conclude, although this
approach is more compact and helps in saving memory, it is inefficient in run-time and may
result in loss in solution quality.
Our second approach takes a further step to reduce the run-time complexity, making
it a polynomial approximation algorithm, but it can lead to a high degradation in solution quality. In this approach, we iteratively compute the optimal defender strategy for a
newly added resource unit given the existing strategies for the previous defender resources.
Namely, we first calculate f1 (i1 , j1 , tk ) as if only one patroller is available and then calculate
600

Protecting Moving Targets with Multiple Mobile Resources

f2 (i2 , j2 , tk ) given the value of f1 (i1 , j1 , tk ). In this way, we need to solve W linear programs
with complexity O(M N 2 ) so this approach is much faster compared to the former one. Unfortunately, this approach fails to capture the coordination between the patrollers effectively
and thus may result in a high degradation in solution quality. For example, suppose there
are only two targets of constant utility U , one target stays at terminal A and the other one
stays at terminal B. Further, suppose the protection coefficient is always 1 when a target
is protected by one or more patrollers. When two patrollers are available, the optimal solution would be each protect one of the targets all the way, so both targets are protected
with probability 1 and the expected utility function for the attacker is 0. If the defender
strategy is calculated for each patroller sequentially as discussed above, the solution would
be protect each target with probability 0.5 for both players, making the attacker‚Äôs expected
utility 0.25%U . In other words, we reach a suboptimal solution, wasting resources when
both patrollers end up protecting the same target with probability 0.25. In this case, we
can already see that there is a 0.25 probability that a target is unprotected when clearly
an optimal solution existed that protected all targets with probability 1. Thus, even with
just two patrollers this solution leads to a potentially significant loss in expected utility;
therefore, this solution clearly appears to be inadequate for our purposes.
Given the above discussion, it would appear that a fast approximation may lead to
significant losses in solution quality or may not be efficient enough. Fortunately for current
application domains, such as the current deployment of CASS for protecting ferries (e.g.,
the Staten Island Ferry in New York), the number of defender resources are limited. The
lack of resources is the main reason that optimization using security games becomes critical.
As a result, our current approach of CASS is adequate for current domains such as ferry
protection. Further research about scale-up is an issue for future work.

4. Equilibrium Refinement
A game often has multiple equilibria. Since our game is zero-sum, all equilibria achieve
the same objective value. However, if an attacker deviates from his best response, some
equilibrium strategies for the defender may provide better results than others.
Consider the following example game. There are two targets moving during [t1 , t2 ] (no
further discretization): one moves from d3 to d2 and the other moves from d1 to d2 (See
Figure 6(a)). Suppose d3 ‚àí d2 = d2 ‚àí d1 = ‚àÜd and re = 0.5‚àÜd. There is only one patroller
available and the protection coefficient C1 = 1. Both targets‚Äô utility functions decrease
from 10 to 1 in [t1 , t2 ] (See Figure 6(b)). In one equilibrium, f3,2,1 = f1,2,1 = 0.5, i.e., the
patroller randomly chooses one target and follows it all the way. In another equilibrium,
f3,3,1 = f1,1,1 = 0.5, i.e., the patroller either stays at d1 or at d3 . In either equilibrium,
the attacker‚Äôs best response is to attack at t1 , with a maximum expected utility of 5.
However, if an attacker is physically constrained (e.g., due to launch point locations) to
only attack no earlier than t0 and t0 > Œ∏11 (where Œ∏11 is the only intersection time point and
Œ∏11 = (t1 + t2 )/2), against both defender strategies he will choose to attack either of the
targets at t0 . The attacker‚Äôs expected utility is Uq (t0 )/2 in the first equilibrium because
there is 50% probability that the patroller is following that target. However in the second
equilibrium, he is assured to succeed and get a utility of Uq (t0 ) because the distance between
the chosen target and d1 (or d3 ) is larger than re at t0 , i.e., the chosen target is unprotected
601

Fang, Jiang, & Tambe

at t0 . In this case, the defender strategy in the first equilibrium is preferable to the one in
the second; indeed, the first defender strategy dominates the second one, by which we mean
the first is equally good or better than the second no matter what strategy the attacker
chooses. We provide a formal definition of dominance in Section 4.1.

ƒö≈ù∆ê∆öƒÇ≈∂ƒêƒû
›Ä‡¨∑

‡Ø§ 

‚Ä´›é‚Ä¨‡Øò

10

‚Ä´›é‚Ä¨‡Øò

‡Ø§ ‡¨¥ 
1

‹µ‡¨µ
›Ä‡¨∂
‹µ‡¨∂

›Ä‡¨µ
‚Ä´›ê‚Ä¨‡¨µ

ﬂ†‡¨µ‡¨µ ‚Ä´›ê‚Ä¨‡¨¥

‚Ä´›ê‚Ä¨‡¨∂

‡¨µ

∆ö≈ù≈µƒû

(a) Two targets moves with schedules S1
and S2 .

‡¨µ‡¨µ ‡¨¥

‡¨∂

∆ö≈ù≈µƒû

(b) Utility function is the same for both
targets and is decreasing linearly over
time.

Figure 6: An example to show one equilibrium outperforms another when the attacker is
constrained to attack in [t0 , t2 ] if t0 > Œ∏11 .
Our goal is to improve the defender strategy so that it is more robust against constrained
attackers while keeping the defender‚Äôs expected utility against unconstrained attackers the
same. This task of selecting one from the multiple equilibria of a game is an instance of
the equilibrium refinement problem, which has received extensive study in game theory
(van Damme, 1987; Fudenberg & Tirole, 1991; Miltersen & S√∏rensen, 2007). For finite
security games, An, Tambe, OrdoÃÅnÃÉez, Shieh, and Kiekintveld (2011) proposed techniques
that provide refinement over Stackelberg equilibrium. However there has been little prior
research on the computation of equilibrium refinements for continuous games.
In this section, we introduce two equilibrium refinement approaches: ‚Äúroute-adjust‚Äù
(Section 4.1) and ‚Äúflow-adjust‚Äù (Section 4.2). Both approaches can be applied to improve
any feasible defender strategy and when they are applied to an optimal defender strategy
in an existing equilibrium, we will get new equilibria with more robust optimal defender
strategies.
For expository simplicity, we still use the single-resource case as an example, but both
methods are applicable to the multiple-resources case. The results shown in evaluation
section experimentally illustrates these two refinement methods can significantly improve
the performance.
4.1 Route Adjust
Given that f is the defender strategy of one equilibrium of the game, if we can find a defender
strategy f 0 such that for any attacker strategy (q, t), the defender‚Äôs expected utility under
f 0 is equal to or higher than the one under f , and the one under f 0 is strictly higher than
the one under f for at least one specific attacker strategy, we say that f 0 dominates f .
Intuitively, the defender should choose f 0 instead of f as f 0 is at least as good as f for any
602

Protecting Moving Targets with Multiple Mobile Resources

attacker strategy and can achieve better performance for some attacker strategies. So an
equilibrium with strategy f 0 is more robust to unknown deviations on the attacker side. We
give the formal definition of dominance as follows.
Definition 7. Defender strategy f dominates f 0 if ‚àÄq, t, DefEUf (Fq , t) ‚â• DefEUf 0 (Fq , t),
and ‚àÉq, t, DefEUf (Fq , t) > DefEUf 0 (Fq , t); or equivalently in this zero-sum game, ‚àÄq, t,
AttEUf (Fq , t) ‚â§ AttEUf 0 (Fq , t), and ‚àÉq, t, AttEUf (Fq , t) < AttEUf 0 (Fq , t).
Corollary 2. Defender strategy f dominates f 0 if ‚àÄq, t, œâ(Fq , t) ‚â• œâ 0 (Fq , t) and ‚àÉq, t,
œâ(Fq , t) > œâ 0 (Fq , t).
Definition 7 simply restates the commonly used weak dominance definition in game
theory for this specific game. Corollary 2 follows from Equation (1).
In this section, we introduce the route-adjust approach which gives a procedure for
finding a defender strategy f 1 that dominates the given defender strategy f 0 . Route-adjust
provides final routes using these steps: (i) decompose flow distribution f 0 into component
routes; (ii) for each route, greedily find a route which provides better protection to targets;
(iii) combine the resulting routes into a new flow distribution, f 1 , which dominates f 0 if
f 1 is different from f0 . The detailed process is listed in Algorithm 2. We illustrate this
approach using a simple dominated strategy shown in Figure 3.
To accomplish step (i), we decompose the flow distribution by iteratively finding a route
that contains the edge with minimum probability. As shown in Figure 7, we first randomly
choose a route that contains edge E1,2,2 , as f (1, 2, 2) = 0.4 is the minimum among all flow
variables. We choose R2 = (d1 , d1 , d2 ), and set p(R2 ) = f (1, 2, 2) = 0.4. Then for each
edge of the route R2 we subtract 0.4 from the original flow, resulting in a residual flow. We
continue to extract routes from the residual flow until there is no route left. Denote by Z
the number of non-zero edges in the flow distribution graph, then Z is decreased by at least
1 after each iteration. So the algorithm will terminate in at most Z steps and at most Z
routes are found. The result of step (i) is a sparse description of a defender mixed strategy
in full representation. As we will discuss in Section 6, this decomposition constitutes one
method of executing a compact strategy.
For step (ii), we adjust each of the routes greedily. To that end, we first introduce the
r and the coefficient
dominance relation of edges and routes, using the intersection points Œ∏qk
r
matrix Aqk (i, j) defined in Section 3.3.
Definition 8. Edge Ei,j,k dominates edge Ei0 ,j 0 ,k in [tk , tk+1 ] if Arqk (i, j) ‚â• Arqk (i0 , j 0 ),
‚àÄq = 1..L, ‚àÄr = 0..Mqk , and ‚àÉq, r such that Arqk (i, j) > Arqk (i0 , j 0 ).
The dominance relation of edges is based on the comparison of protection provided to
the targets in each sub-interval. In the following dominance relation of routes, we denote
the edge Eru (k),ru (k+1),k as E(u, k) to simplify the notation, .
Definition 9. Route Ru = (dru (1) , . . . , dru (M ) ) dominates Ru0 = (dru0 (1) , . . . , dru0 (M ) ) if
‚àÄk = 1 . . . M ‚àí 1, E(u, k) = E(u0 , k) or E(u, k) dominates E(u0 , k) and ‚àÉk such that E(u, k)
dominates E(u0 , k).
Route Ru dominates Ru0 if each edge of Ru is either the same as or dominates the
corresponding edge in Ru0 and at least one edge in Ru dominates the corresponding edge
in Ru0 .
603

Fang, Jiang, & Tambe

Algorithm 2: Route-Adjust
Input: a mixed defender strategy f
Output: an updated mixed defender strategy f 0
(i) Decompose f into multiple routes by iteratively finding a route that contains
the edge with minimum probability:
(a) Initialize the remaining flow distribution fÀú = f and route set S = ‚àÖ.
Initialize probability distribution over routes p(Ru ) = 0, ‚àÄu.
(b) while max fÀú(i, j, k) > 0 do
i. Set (i0 , j0 , k0 ) = arg mini,j,k:fÀú(i,j,k)>0 fÀú(i, j, k).
ii. Set fmin = fÀú(i0 , j0 , k0 ).
iii. Find an arbitrary route Ru0 such that ru0 (k0 ‚àí1) = i0 and ru0 (k0 ) =
j0 (i.e., edge Ei0 ,j0 ,k0 is in the route) and fÀú(ru0 (k), ru0 (k+1), k) > 0,
‚àÄk (i.e., all edges in the route has non-zero remaining flow).
iv. Add Ru0 to S and set p(Ru0 ) = fmin .
v. Set fÀú(i, j, k) = fÀú(i, j, k) ‚àí fmin if ru0 (k ‚àí 1) = i and ru0 (k) = j.
end
(ii) Adjust each route in S greedily to get a new set of routes S 0 and the corresponding new probability distribution p0 :
(a) Initialize the new set S 0 = ‚àÖ and new probability distribution p0 (Ru ) = 0,
‚àÄu.
(b) while S 6= ‚àÖ do
i. Pick a route Ru from S.
ii. Adjust Ru to get new route Ru0 : for a given Ru and a specified
k ‚àó , set ru0 (k) = ru (k) if k 6= k ‚àó . Set ru0 (k ‚àó ) = i0 such that: 1)
E(u1 , k ‚àó ‚àí 1) and E(u1 , k ‚àó ) meet the speed constraint; 2) Ru0 dominates Ru with the choice of i0 ; 3) Ru0 is not dominated by a route
with any other choice of i0 . If no such i0 exists, set ru0 (k ‚àó ) = ru (k ‚àó )
iii. Add Ru to S 0 and set p0 (Ru0 ) = p(Ru ).
iv. Remove Ru from S.
end
(iii) Reconstruct a new compact representation f 0 from S 0 and p0 according to
Equation 4.

604

Protecting Moving Targets with Multiple Mobile Resources

‡¨∂  ‡¨µ , ‡¨µ , ‡¨∂
p R ‡¨∂  0.4

‡¨µ  ‡¨µ , ‡¨µ , ‡¨µ
p R‡¨µ  0.2

‡¨∂
‡¨µ
‡¨µ

‡¨∂
œ¨Õòœ∞
‡¨∂

‡¨∂

‡¨∂

‡¨µ
‡¨µ

‡¨µ
‡¨µ

œ¨Õòœ≤ 
‡¨∂

œ¨Õòœ≤

‡¨∑

‡¨µ
‡¨µ

‡¨∑

œ¨ÕòœÆ

œ¨ÕòœÆ
‡¨∂

‡¨∑

‡¨∑  ‡¨∂ , ‡¨µ , ‡¨µ
p R ‡¨∑  0.4
‡¨∂
œ¨ÕòœÆ 
‡¨∂

œ¨Õòœ≤

‡¨∑

‡¨µ
‡¨µ

œ¨Õòœ∞
‡¨∂

‡¨∑

Figure 7: Step (i): decomposition. Every time a route containing the minimal flow variable
is subtracted and a residual graph is left for further decomposition. The original flow distribution is thus decomposed into three routes R2 , R1 , and R3 with
probability 0.4, 0.2 and 0.4 respectively.

Denote the original route to be adjusted as Ru and the new route as Ru0 . A greedy
way to improve the route is to replace only one node in the route. If we want to replace
the node at time tk‚àó , then we have ru0 (k) = ru (k), ‚àÄk 6= k ‚àó and dru (k‚àó ) in the original
route is replaced with dru0 (k‚àó ) . So the patroller‚Äôs route changes only in [tk‚àó ‚àí1 , tk‚àó +1 ]. Thus,
only edges E(u, k ‚àó ‚àí 1) and E(u, k ‚àó ) in the original route are replaced by E(u0 , k ‚àó ‚àí 1) and
E(u0 , k ‚àó ) in the new route.
We are trying to find a new route Ru0 that dominates the original route to provide equal
or more protection to the targets. So the selection of ru0 (k ‚àó ) needs to meet the requirements
specified in Algorithm 2. The first one describes the speed limit constraint. The second
one actually requires the changed edges E(u0 , k ‚àó ‚àí 1) and E(u0 , k ‚àó ) are either equal to or
dominate the corresponding edges in the original route (and dominance relation exist for at
least one edge). The third requirement attains a local maximum. If such a new node does
not exist for a specified k ‚àó , we return the original route Ru .
We can iterate this process for the new route and get a final route denoted by Ru0 after
several iterations or when the state of convergence is reached. When the state of convergence
is reached, the resulting route Ru0 keeps unchanged no matter which k ‚àó is chosen for the
next iteration.
For the example in Figure 7, assume the only target‚Äôs moving schedule is d1 ‚Üí d1 ‚Üí d2 ,
d3 ‚àí d2 = d2 ‚àí d1 = ‚àÜd, re = 0.1‚àÜd and utility function is constant. We adjust each route
for only one iteration by changing the patroller‚Äôs position at time t3 , i.e., ru (3). As t3 is
the last discretized time point, only edge E(u, 2) may be changed. For R1 = (d1 , d1 , d1 ),
we enumerate all possible patroller‚Äôs positions at time t3 and choose one according to the
three constraints mentioned above. In this case, the candidates are d1 and d2 , so the
corresponding new routes are R1 (unchanged) and R2 = (d1 , d1 , d2 ) respectively. Note that
edge Ed1 ,d2 ,2 dominates Ed1 ,d1 ,2 because the former one protects the target all the way in
[t2 , t3 ] and thus R2 dominates R1 . So d2 is chosen as the patroller‚Äôs position at t3 and R2
605

Fang, Jiang, & Tambe

is chosen as the new route. The adjustment for all routes with non-zero probability after
decomposition is shown in Table 2.
Ru
R1 = (d1 , d1 , d1 )
R2 = (d1 , d1 , d2 )
R3 = (d2 , d1 , d1 )

p(Ru ) after decomposition
0.2
0.4
0.4

Adjusted Routes
(d1 , d1 , d2 ) = R2
(d1 , d1 , d2 ) = R2
(d2 , d1 , d2 ) = R4

Table 2: Step (ii): Adjust each route greedily.

R1
R2
R3
R4

Ru
= (d1 , d1 , d1 )
= (d1 , d1 , d2 )
= (d2 , d1 , d1 )
= (d2 , d1 , d2 )

p0 (Ru ) after adjustment
0
0.6
0
0.4

Composed Flow Distribution
›Ä‡¨∂
›Ä‡¨µ
‚Ä´›ê‚Ä¨‡¨µ

œ¨Õòœ≤ ‚Ä´›ê‚Ä¨
‡¨∂

‚Ä´›ê‚Ä¨‡¨∑

Table 3: Step (iii): compose a new compact representation.
The new routes we get after step (ii) are same as the original routes or dominate the
original routes. That is, whenever a route Ru is chosen according to the defender mixed
strategy resulting from step (i), it is always equally good or better to choose the corresponding new route Ru0 instead, because Ru0 provides equal or more protection to the
targets than Ru . Suppose there are H possible routes in the defender strategy after step
(i), denoted as R1 , ..., RH . After adjusting the routes, we get a new defender strategy
(p0 (R1 ), p0 (R2 ), ..., p0 (RH )) in full representation (See Table 3). Some routes are taken with
higher probability (e.g. p0 (R2 ) = 0.2 + 0.4 = 0.6) and some are with lower probability
(e.g. p0 (R3 ) = 0) compared to the original strategy. For step (iii), we reconstruct a new
compact representation according to Equation 4. This is accomplished via a process that
is the inverse of decomposition and is exactly the same as how we map a strategy in full
representation into compact representation. For the example above, the result is shown in
Table 3.
Theorem 3. After steps (i)‚Äì(iii), we get a new defender strategy f 1 that dominates the
original one f 0 if f 1 is different from f 0 .
Proof: We continue to use the notation that the decomposition in step (i) yields the
routes R1 , ..., RH . For each flow distribution variable in the original distribution f 0 (i, j, k), it
is decomposed into H sub-flows {fu0 (i, j, k)} according to the route decomposition. fu0 (i, j, k) =
p(Ru ) if i = ru (k), j = ru (k + 1) and fu0 (i, j, k) = 0 otherwise. Thus we have the following
equation.
XH
f 0 (i, j, k) =
f 0 (i, j, k)
(26)
u=1 u
X
=
fu0 (i, j, k)
(27)
u:ru (k)=i,ru (k+1)=j

After adjust each route separately, each non-zero sub-flow fu0 (i, j, k) on edge E(u, k) is moved
to edge E(u0 , k) as route Ru is adjusted to Ru0 . Reconstructing the flow distribution f 1
606

Protecting Moving Targets with Multiple Mobile Resources

can also be regarded as adding up all the sub-flows after adjustment together on each edge.
That means, f 1 is composed of a set of sub-flows after adjustment, denoted as {fu1 (i0 , j 0 , k)}.
The subscript u represents for the index of the original route to indicate it is moved from
edge E(u, k). So fu1 (i0 , j 0 , k) = fu0 (ru (k), ru (k + 1), k), if i0 = Ru0 (k) and j 0 = Ru0 (k + 1);
otherwise fu1 (i0 , j 0 , k) = 0. Similarly to Equation 27, we have the following equation for f 1 .
f 1 (i0 , j 0 , k) =
=

XH

f 1 (i0 , j 0 , k)
u=1 u

X
u0 :ru0 (k)=i0 ,ru0 (k+1)=j 0

(28)
fu1 (i0 , j 0 , k)

(29)

Based on how the adjustment is made, Ru0 is same as or dominates Ru and thus E(u0 , k)
is same as or dominates E(u, k). So if edge E(u, k) protects target Fq at time t, the
corresponding edge E(u0 , k) after adjustment also protects target Fq at time t.
Recall from Section 3.3 that œâ(Fq , t) is the sum of f (i, j, k) whose corresponding edge
Ei,j,k can protect the target Fq at time t. We denote by œâ 0 (Fq , t) and œâ 1 (Fq , t) the probabilities of protection corresponding to f 0 and f 1 respectively. According to Equation 27,
œâ 0 (Fq , t) can be viewed as the sum of all the non-zero sub-flows fu0 (i, j, k) where the corresponding E(u, k) protects the target Fq at time t. If fu0 (i, j, k) is a term in the summation
to calculate œâ 0 (Fq , t), it means E(u, k) protects Fq at t and thus the corresponding E(u0 , k)
protects Fq at t, so the corresponding sub-flow fu1 (ru0 (k), ru0 (k + 1), k) in f 1 is also a term in
the summation to calculate œâ 1 (Fq , t). It leads to the conclusion œâ 0 (Fq , t) ‚â§ œâ 1 (Fq , t). Note
that if ‚àÄq, t, œâ 0 (Fq , t) = œâ 1 (Fq , t), then all routes kept unchanged in step (ii) as otherwise
it contradicts with the fact that the new route dominates the original route. According to
Corollary 2, we have f 1 dominates f 0 if it is different from f 0 .
In the example in Figure 7, f 0 (1, 1, 2) is decomposed into two non-zero terms f10 (1, 1, 2) =
0.2 and f30 (1, 1, 2) = 0.4 along with routes R1 and R3 (See Figure 7). After adjustment, we
get the corresponding subflows f11 (1, 2, 2) = 0.2, f31 (1, 2, 2) = 0.4. Recall that the target‚Äôs
schedule is d1 ‚Üí d1 ‚Üí d2 . The flow distribution after adjustment (See Table 5) gives more
protection to the target in [t2 , t3 ]. Since the flow is equal from t1 to t2 (and therefore the
protection is the same), overall the new strategy dominates the old strategy.
Therefore, if we apply route-adjust to the optimal defender strategy calculated by CASS
we get a more robust equilibrium. While step (iii) allows us to prove Theorem 3, notice
that at the end of step (ii), we have a probability distribution over a set of routes from
which we can sample actual patrol routes. For two or more defender resources, a generalized
version of Definition 8 can be used to define the dominance relation on the edge tuple
(Ei1 ,j1 ,k , ..., EiW ,jW ,k ) with coefficient matrix for multiple patrollers Arqk (i1 , j1 , ..., iW , jW ).
There are other ways to adjust each route. Instead of adjusting only one node in the
route, we can adjust more consecutive nodes at a time, for example, we can adjust both
ru0 (k ‚àó ) and ru0 (k ‚àó + 1) by checking edges E(u0 , k ‚àó ‚àí 1), E(u0 , k ‚àó ) and E(u0 , k ‚àó + 1). However,
we need to tradeoff the performance and the efficiency of the algorithm. This tradeoff will
be further discussed in Section 7.
4.2 Flow Adjust
Whereas route-adjust tries to select an equilibrium that is robust against attackers playing
suboptimal strategies, the second approach, flow-adjust, attempts to select a new equilibri607

Fang, Jiang, & Tambe

um that is robust to rational attackers that are constrained to attack during any time interval [tk , tk+1 ]. As we will discuss below, flow-adjust focuses on a weaker form of dominance,
which implies that a larger set of strategies are now dominated (and thus could potentially
be eliminated) compared to the standard notion of dominance used by route-adjust; however flow-adjust does not guarantee the elimination of all such dominated strategies. We
denote by DefEUkf the defender expected utility when an attacker is constrained to attack
during time interval [tk , tk+1 ] when the attacker provides his best response given the defender strategy f . Formally, DefEUkf = minq‚àà{1...L},t‚àà[tk ,tk+1 ] {DefEUf (Fq , t)}. We give the
following definition of ‚Äúlocal dominance‚Äù.
Definition 10. Defender strategy f locally dominates f 0 if DefEUkf ‚â• DefEUkf 0 , ‚àÄk.2
Corollary 3. Defender strategy f locally dominates f 0 if
min
q‚àà{1...L},t‚àà[tk ,tk+1 ]

{DefEUf (Fq , t)} ‚â•

min
q‚àà{1...L},t‚àà[tk ,tk+1 ]

{DefEUf 0 (Fq , t)}, ‚àÄk,

or equivalently in this zero-sum game,
max
q‚àà{1...L},t‚àà[tk ,tk+1 ]

{AttEUf (Fq , t)} ‚â§

max
q‚àà{1...L},t‚àà[tk ,tk+1 ]

{AttEUf 0 (Fq , t)}, ‚àÄk.

Corollary 3 follows from the fact that the attacker plays a best response given the
defender strategy, and it means that f locally dominates f 0 if the maximum of attacker
expected utilities in each time interval [tk , tk+1 ] given f is no greater than that of f 0 .
Compared to Definition 7, which gives the standard condition for dominance, local
dominance is a weaker condition; that is, if f dominates f 0 then f locally dominates f 0 ,
however the converse is not necessarily true. Intuitively, whereas in Definition 7 the attacker
can play any (possibly suboptimal) strategy, here the attacker‚Äôs possible deviations from
best response are more restricted. As a result, the set of locally dominated strategies
includes the set of dominated strategies. From Definition 10, if f locally dominates f 0 , and
the attacker is rational (i.e., still playing a best response) but constrained to attack during
some time interval [tk , tk+1 ], then f is preferable to f 0 for the defender. A further corollary
is that even if the rational attacker is constrained to attack in the union of some of these
intervals, f is still preferable to f 0 if f locally dominates f 0 . One intuition for the local
dominance concept is the following: suppose we suspect the attacker will be restricted to
a (unknown) subset of time, due to some logistical constraints. Such logistical constraints
would likely make the restricted time subset to be contiguous or a union of a small number
of contiguous sets. Since such sets are well-approximated by unions of intervals [tk , tk + 1],
local dominance can serve as an approximate notion of dominance with respect to such
attackers.
Flow-adjust looks for a defender strategy f 1 that locally dominates the original defender
strategy f 0 . To achieve this, we simply adjust the flow distribution variables f (i, j, k) while
keeping the marginal probabilities p(i, k) the same. Figure 8 shows an example game with
two discretized intervals [t1 , t2 ] and [t2 , t3 ] (only the first interval is shown). Suppose the
maximal attacker expected utility is 5U0 in this equilibrium and is attained in the second
2. We don‚Äôt require that there exists at least one k such that DefEUkf > DefEUkf 0 .

608

Protecting Moving Targets with Multiple Mobile Resources

interval [t2 , t3 ]. If the attacker‚Äôs utility for success is a constant U0 in the first interval
[t1 , t2 ], then the defender strategy in [t1 , t2 ] could be arbitrarily chosen because the attacker‚Äôs
expected utility in [t1 , t2 ] in worst case is smaller than that of the attacker‚Äôs best response in
[t2 , t3 ]. However, if a attacker is constrained to attack in [t1 , t2 ] only, the defender strategy
in the first interval will make a difference. In this example, there is only one target moving
from d1 to d2 during [t1 , t2 ]. The schedule of the ferry is shown as dark lines and the parallel
lines L11 and L21 with respect to protection radius re = 0.2(d2 ‚àí d1 ) are shown as dashed
lines. The marginal distribution probabilities p(i, k) are all 0.5 and protection coefficient
C1 = 1. In f 0 , the defender‚Äôs strategy is taking edges E1,1,1 and E2,2,1 with probability
0.5 and the attacker‚Äôs maximum expected utility is U0 , which can be achieved around time
(t1 + t2 )/2 when neither of the two edges E1,1,1 and E2,2,1 are within the target‚Äôs protection
range. If we adjust the flows to edge E1,2,1 and E2,1,1 , as shown in Figure 8(b), the attacker‚Äôs
maximum expected utility in [t1 , t2 ] is reduced to 0.5U0 as edge E1,2,1 is within the target‚Äôs
protection range all the way. So a rational attacker who is constrained to attack between
[t1 , t2 ] will get a lower expected utility given defender strategy f 1 than given f 0 , and thus
the equilibrium with f 1 is more robust to this kind of deviation on the attacker side.

›Ä‡¨∂ œ¨Õòœ±

›Ä‡¨µ œ¨Õòœ±
‚Ä´›ê‚Ä¨‡¨µ

œ¨Õòœ±

œ¨Õòœ±

œ¨Õòœ±

›Ä‡¨∂ œ¨Õòœ±

œ¨Õòœ±
‚Ä´›ê‚Ä¨‡¨∂

›Ä‡¨µ œ¨Õòœ±
‚Ä´›ê‚Ä¨‡¨µ

(a) f 0 : the patroller is taking
edges E1,1,1 and E2,2,1 with
probability 0.5.

œ¨

œ¨

œ¨Õòœ±

œ¨Õòœ±
‚Ä´›ê‚Ä¨‡¨∂

(b) f 1 : the patroller is taking
edges E1,2,1 and E2,1,1 with
probability 0.5.

Figure 8: An example of flow adjust. An rational attacker who is constrained to attack in
[t1 , t2 ] will choose to attack around time (t1 + t2 )/2 to get utility U0 given f 0 and
attack around t1 or t2 to get utility 0.5U0 given f 1 .

So in flow-adjust, we construct M ‚àí 1 new linear programs, one for each time interval
[tk‚àó , tk‚àó +1 ], k ‚àó = 1 . . . M ‚àí 1 to find a new set of flow distribution probabilities f (i, j, k ‚àó )
to achieve the lowest local maximum in [tk‚àó , tk‚àó +1 ] with unchanged p(i, k ‚àó ) and p(i, k ‚àó + 1).
609

Fang, Jiang, & Tambe

The linear program for an interval [t‚àók , tk‚àó +1 ] is shown below.
min v

f (i,j,k‚àó )

f (i, j, k ‚àó ) = 0, if |dj ‚àí di | > vm ‚àó Œ¥t
n
X
‚àó
p(i, k + 1) =
f (j, i, k ‚àó ), ‚àÄi ‚àà {1 . . . n}
j=1

p(i, k ‚àó ) =

n
X

f (i, j, k ‚àó ), ‚àÄi ‚àà {1 . . . n}

j=1

v ‚â• AttEU (Fq , tk ), ‚àÄq ‚àà {1 . . . L}, k ‚àà {k ‚àó , k ‚àó + 1}
(r+1)‚àí

r+
v ‚â• max{AttEU (Fq , Œ∏qk
‚àó ), AttEU (Fq , Œ∏qk ‚àó

)}

‚àÄq ‚àà {1 . . . L}, r ‚àà {0 . . . Mqk‚àó }
While the above linear program appears similar to the linear program of CASS, they have
significant differences. Unlike CASS, the marginal probabilities p(i, k ‚àó ) here are known
constants and are provided as input and as mentioned above, there is a separate program
for each [tk‚àó , tk‚àó +1 ]. Thus, we get f (i, j, k ‚àó ) such that the local maximum in [tk‚àó , tk‚àó +1 ] is
minimized. Denote the minimum as vk1‚àó . From the original flow distribution f 0 , we get
AttEUf 0 (Fq , t) and we denote the original local maximum value in [tk‚àó , tk‚àó +1 ] as vk0‚àó . As
the subset {f 0 (i, j, k ‚àó )} of the original flow distribution f 0 is a feasible solution of the linear
program above, we have vk1‚àó ‚â§ vk0‚àó , noting that the equality happens for the interval from
which the attacker‚Äôs best response is chosen.
Note that any change made to f (i, j, k) in an interval [t‚àók , tk‚àó +1 ] will not affect the
performance of f in other intervals as the marginal probabilities p(i, k) are kept the same,
i.e., changing f (i, j, k ‚àó ) based on the linear program above is independent from any change
to f (i, j, k), k 6= k ‚àó . So we can solve the M ‚àí 1 linear programs independently. After
calculating f (i, j, k ‚àó ) for all k ‚àó = 1..M ‚àí 1, we can get the new defender strategy f 1 by
combining the solutions f (i, j, k ‚àó ) of the different linear programs together. As vk1‚àó ‚â§ vk0‚àó ,
we have
max
q‚àà{1...L},t‚àà[tk‚àó ,tk‚àó +1 ]

AttEUf 0 (Fq , t) ‚â§

max
q‚àà{1...L},t‚àà[tk‚àó ,tk‚àó +1 ]

AttEUf 1 (Fq , t)

for all k ‚àó = 1..M ‚àí 1, i.e., f 1 locally dominates f 0 .
On the other hand, while we have restricted the strategies to have the same p(i, k),
there may exist another strategy f 2 with a different set of p(i, k) that locally dominates f 1 .
Finding locally dominating strategies with different p(i, k) from the original is a topic of
future research.
Although the two refinement approaches we provide do not necessarily lead to a nondominated strategy under the corresponding dominance definition, these two approaches
are guaranteed to find a more robust (or at least indifferent) equilibrium when faced with
constrained attackers compared to the original equilibrium we obtain from CASS. Clearly,
these two refinement approaches do not exhaust the space of refinement approaches ‚Äî
other refinement approaches are possible that may lead to other equilibria that are better
610

Protecting Moving Targets with Multiple Mobile Resources

than (e.g. dominate) the one found by CASS. However, it is likely that different defender
strategies resulting from different equilibrium refinements are not comparable to each other
in terms of dominance, i.e., with some constrained attackers, one equilibrium might turn
out to be better and with other constrained attackers, another equilibrium might be better.
Their computational costs may differ as well. Thus, understanding this space of refinement
approaches in terms of their computational cost and output quality, and determining which
approach should be adopted under which circumstances is an important challenge for future
work.

5. Extension To Two-Dimensional Space
Both DASS and CASS presented in Section 3 are based on the assumption that both the
targets and the patrollers move along a straight line. However, a more complex model is
needed in some practical domains. For example, Figure 9 shows a part of the route map of
Washington State Ferries, where there are several ferry trajectories. If a number of patroller
boats are tasked to protect all the ferries in this area, it is not necessarily optimal to simply
assign a ferry trajectory to each of the patroller boat and calculate the patrolling strategies
separately according to CASS described in Section 3. As the ferry trajectories are close to
each other, a patrolling strategy that can take into account all the ferries in this area will be
much more efficient, e.g., a patroller can protect a ferry moving from Seattle to Bremerton
first, and then change direction halfway and protect another ferry moving from Bainbridge
Island back to Seattle.

Figure 9: Part of route map of Washington State Ferries
In this section, we extend the previous model to a more complex case, where the targets and patrollers move in a two-dimensional space and provide the corresponding linearprogram-based solution. Again we use a single defender resource as an example, and generalize to multiple defenders at the end of this section.
5.1 Defender Strategy for 2-D
As in the one-dimensional case, we need to discretize the time and space for the defender
to calculate the defender‚Äôs optimal strategy. The time interval T is discretized into a set
of time points T = {tk }. Let G = (V, E) represents the graph where the set of vertices V
corresponds to the locations that the patrollers may be at, at the discretized time points in
T , and E is the set of feasible edges that the patrollers can take. An edge e ‚àà E satisfies
611

Fang, Jiang, & Tambe

the maximum speed limit of patroller and possibly other practical constraints (e.g., a small
island may block some edges).
5.2 DASS for 2-D
When the attack only occurs at the discretized time points, the linear program of DASS
and described in Section 3 can be applied to the two-dimensional settings when the distance
in Constraint 9 is substituted with Euclidean distance in 2-D space of nodes Vi and Vj .
min

v

(30)

f (i,j,k),p(i,k)

f (i, j, k) ‚àà [0, 1], ‚àÄi, j, k

(31)

f (i, j, k) = 0, ‚àÄi, j, k such that ||Vj ‚àí Vi || > vm Œ¥t

(32)

p(i, k) =

N
X

f (j, i, k ‚àí 1), ‚àÄi, ‚àÄk > 1

(33)

f (i, j, k), ‚àÄi, ‚àÄk < M

(34)

j=1

p(i, k) =

N
X
j=1

N
X

p(i, k) = 1, ‚àÄk

(35)

i=1

v ‚â• AttEU(Fq , tk ), ‚àÄq, ‚àÄk

(36)

Note that f (i, j, k) now represents the probability that a patroller is moving from node Vi to
Vj during [tk , tk+1 ]. Recall in Figure 2.1, a patroller protects all targets within her protective
circle of radius re . However, in the one-dimensional space, we only care about the straight
line AB, so we used Œ≤q (t) = [max{Sq (t) ‚àí re , d1 }, min{Sq (t) + re , dN }] as the protection
range of target Fq at time t, which is in essence a line segment. In contrast, here the whole
circle needs to be considered as the protection range in the two-dimensional space and the
extended protection range can be written as Œ≤q (t) = {V = (x, y) : ||V ‚àí Sq (t)|| ‚â§ re }. This
change affects the value of I(i, q, k) and thus the value of AttEU (Fq , tk ) in Constraint 36.
5.3 CASS for 2-D
When the attacking time t can be chosen from the continuous time interval T , we need to
analyze the problem in a similar way as in Section 3.3. The protection radius is re , which
means only patrollers located within the circle whose origin is Sq (t) and radius is re can
protect target Fq . As we assume that the target will not change its speed and direction
during time [tk , tk+1 ], the circle will also move along a line in the 2-D space. If we track the
circle in a 3-D space where the x and y axes indicate the position in 2-D and the z axis is
the time, we get an oblique cylinder, which is similar to a cylinder except that the top and
bottom surfaces are displaced from each other (See Figure 10). When a patroller moves
from vertex Vi (‚àà V ) to vertex Vj during time [tk , tk+1 ], she protects the target only when
she is within the surface. In the 3-D space we described above, the patroller‚Äôs movement
can be represented as a straight line.
612

Protecting Moving Targets with Multiple Mobile Resources

d≈ù≈µƒû
‚Ä´›ê‚Ä¨‡Øû‡¨æ‡¨µ

‚Ä´›ê‚Ä¨‡Øî
‚Ä´›ê‚Ä¨‡Øû

V‡¨µ



V‡¨∂

‹µ‡Ø§ ·à∫‚Ä´›ê‚Ä¨‡Øû‡¨æ‡¨µ ·àª

‚Ä´›ê‚Ä¨‡Øï



‹µ‡Ø§ ·à∫‚Ä´›ê‚Ä¨‡Øû ·àª

r‡Øò

Figure 10: An illustration of the calculation of intersection points in the two-dimensional
setting. The x and y axes indicates the position in 2-D and the z axis is the
time. To simplify the illustration, z axis starts from time tk . In this example,
there are two intersection points occurring at time points ta and tb .

Intuitively, there will be at most two intersection points between the patroller‚Äôs route
in 3-D space and the surface. This can be proved by analytically calculating the exact
time of these intersection points. Assume the patroller is moving from V1 = (x1 , y1 ) to
V2 = (x2 , y2 ) and the target is moving from Sq (tk ) = (xÀÜ1 , yÀÜ1 ) to Sq (tk+1 ) = (xÀÜ2 , yÀÜ2 ) during
[tk , tk+1 ] (an illustration is shown in Figure 10). To get the time of the intersection points,
we solve a quadratic equation with these coordination parameters and protection radius
re . We present the detailed calculation in Appendix B. If a root of the quadratic equation
is within the interval [tk , tk+1 ], it indicates that the patroller‚Äôs route intersects with the
surface at this time point. So there will be at most two intersection points. Once we find all
these intersection points, the same analysis in Section 3.3 applies and we can again claim
Lemma 1. So we conclude that we only need to consider the attacker‚Äôs strategies at these
r as in the one-dimensional case to denote
intersection points. We use the same notation Œ∏qk
the sorted intersection points and get the following linear program for the 2-D case.
min

v

(37)

f (i,j,k),p(i,k)

subject to constraints(31 . . . 36)
(r+1)‚àí

r+
v ‚â• max{AttEU(Fq , Œ∏qk
), AttEU(Fq , Œ∏qk

)}

(38)

‚àÄk ‚àà {1 . . . M }, q ‚àà {1 . . . L}, r ‚àà {0 . . . Mqk }
Algorithm 1 can still be used to add constraints to the linear program of CASS for the
2-D case. The main difference compared to CASS in the 1-D case is that since Euclidean
distance in 2-D is used in Constraint 32 we need to use the extended definition of Œ≤q (t) in
2-D when deciding the entries in the coefficient matrix Arqk (i, j).
For multiple defender resources, again the linear program described in Section 3.4 is applicable when the extended definition of Œ≤q (t) is used to calculate AttEU and Constraint 19
613

Fang, Jiang, & Tambe

is substituted with the following constraint:
f (i1 , j1 , . . . , iW , jW , k) = 0, ‚àÄi1 , . . . , iW , j1 , . . . , jW such that ‚àÉu, kVju ‚àí Viu k > vm Œ¥t.

6. Route Sampling
We have discussed how to generate an optimal defender strategy in the compact representation; however, the defender strategy will be executed as taking a complete route. So
we need to sample a complete route from the compact representation. In this section, we
give two methods of sampling and show the corresponding defender strategy in the full
representation when these methods are applied.
The first method is to convert the strategy in the compact representation into a Markov
strategy. A Markov strategy in our setting is a defender strategy such that the patroller‚Äôs
movement from tk to tk+1 depends only on the location of the patroller at tk . We denote
by Œ±(i, j, k) the conditional probability of moving from di to dj during time tk to tk+1 given
that the patroller is located at di at time tk . In other words Œ±(i, j, k) represents the chance
of taking edge Ei,j,k given that the patroller is already located at node (tk , di ). Thus, given
a compact defender strategy specified by f (i, j, k) and p(i, k), we have
Œ±(i, j, k) = f (i, j, k)/p(i, k), if p(i, k) > 0.

(39)

Œ±(i, j, k) can be an arbitrary number if p(i, k) = 0. We can get a sampled route by first
determining where to start patrolling according to p(i, 1); then for each tk , randomly choose
where to go from tk to tk+1 according to the conditional probability distribution Œ±(i, j, k).
The distribution from this sampling procedure matches the given marginal variables as each
edge Ei,j,k is sampled with probability p(i, k)Œ±(i, j, k) = f (i, j, k). This sampling method
actually leads to a full representation where route Ru = (dru (1) , dru (2) , ..., dru (M ) ) is sampled
Q ‚àí1
with probability p(ru (1), 1) M
k=1 Œ±(ru (k), ru (k + 1), k), the product of the probability of
the initial distribution and the probability of taking each step. This method is intuitively
straightforward and the patrol route can be decided online during the patrol, i.e., the
position of the patroller at tk+1 is decided when the patroller reaches its position at tk ,
which makes the defender strategy more unpredictable. The downside of the method is
that the number of routes chosen with non-zero probability can be as high as N M . For
2-D case, the patroller is located at node Vi at time tk . The sampling process is exactly
the same when Œ±(i, j, k) is used to denote the probability of moving from Vi to Vj during
[tk , tk+1 ].
The second method of sampling is based on the decomposition process mentioned in
Section 4.1 (step (i)). As we discussed above for the first sampling method, sampling is
essentially restoring a full representation from the compact representation. As shown in
Table 1, there are multiple ways to assign probabilities to different routes and the decomposition process of ‚Äúroute-adjust‚Äù constructively defines one of them. So we can make use
of the information we get from the process, and sample a route according to the probability
assigned to each decomposed route. The number of routes chosen with non-zero probability
is at most N 2 M , much less than the first method and thus it becomes feasible to describe
the strategy in full representation, by only providing the routes that are chosen with positive probability. Different sampling approaches may be necessitated by different application
614

Protecting Moving Targets with Multiple Mobile Resources

requirements. Some applications might require that the defender obtain a strategy in full
representation and only be presented a small number of pure strategies. However, for other
applications, a strategy that can be decided on-line, potentially with a hand-held smartphone such as in (Luber, Yin, Fave, Jiang, Tambe, & Sullivan, 2013) may be preferred.
Therefore, based on the needs of the application, different sampling strategies might be
selected.

7. Evaluation
We use different settings in the ferry protection domain and compare the performance in
terms of the attacker‚Äôs expected utility AttEU(Fq , t). As it is a zero-sum game, a lower
value of AttEU indicates a higher value of defender‚Äôs expected utility.
We will run experiments both for 1-D and 2-D setting. We will evaluate the performance
of CASS and show the sampling results. We will also evaluate the improvement of the two
refinement approaches for 1-D. Section 7.1 shows our results for the 1-D setting; Section
7.2 for the 2-D setting.
7.1 Experiments for One Dimensional Setting
For 1-D setting, we first evaluate the performance of the solvers and then show how much
the performance can be improved by using the refinement methods. We also show sampled
routes for an example setting and evaluate CASS for varying number of patrollers.
7.1.1 Experimental Settings
We used the following setting for the experiments in one dimensional case. This is a complex
spatio-temporal game; rather than a discrete security game as in most previous work. There
are three ferries moving between terminals A and B and the total distance AB = 1. The
simulation time is 30 minutes. The schedules of the ferries are shown in Figure 11, where
the x-axis indicates the time and the y-axis is the distance from terminal A. Ferry 1 and
Ferry 3 are moving from A to B while Ferry 2 is moving from B to A. The maximum speed
for patrollers is vm = 0.1/min and the protection radius is re = 0.1. Experiments in the
one-dimensional case are using 2 patrollers (where C1 = 0.8, and C2 = 1.0), except in
Section 7.1.5 where we report on experiments with different numbers of patrollers.

d ‚àí distance

1

0.5

0
0

Ferry1
Ferry2
Ferry3

10

t ‚àí time

20

30

Figure 11: Schedules of the ferries

615

Fang, Jiang, & Tambe

7.1.2 Performance of Solvers
We compare the strategies calculated by CASS with DASS and a baseline strategy. In the
baseline strategy, the two patrollers choose a ferry with a probability of 1/3 (uniformly
random) and move alongside it to offer it full protection, leaving the other two unprotected
(strategy observed in practice). First we wished to stress-test CASS by using more complex
utility functions than in the realistic case that follows. Therefore, we tested under 4 different
discretization levels (details about discretization levels are included in Table 4) with random
utilities, and at each discretization level, we created 20 problem instances. The problem
instances are different across levels. In this ferry protection domain, the utility function for
each ferry usually depends on the ferry‚Äôs position, so each instance has utilities uniformly
randomly chosen between [0, 10] at discretized distance points; an example is shown in
Figure 12(a). The chosen discretization levels have ensured that Uq (t) is linear in t in each
time interval [tk , tk+1 ] for each target Fq . In Figure 12(a), the x-axis indicates the distance d
from terminal A, the y-axis indicates the utility of a successful attack if the ferry is located
at distance d. In Figure 12(b), x-axis plots the four discretization levels and y-axis plots the
average attacker expected utility if he plays best response over the 20 instances for baseline,
DASS and CASS. CASS is shown to outperform DASS and baseline and the differences
are statistically significant (p < 0.01). Note that different sets of instances are generated
for different discretization levels, so we cannot compare the results across levels directly.
However, it is helpful in better understanding the models. From the figure, we find the
solution quality of DASS varies a lot and sometimes can be worse than the naive strategy
(e.g., level 1). This is because DASS calculates an optimal solution that considers only the
attacks at the discretized time points. In Figure 12(b), the solution quality is measured by
AttEU m , which is calculated as the maximum over the continuous attacker strategy set.
The gap between the optimal objective function of DASS and the actual AttEU m given the
optimal solution of DASS may vary for different strategies and different discretization levels.
Another interesting observation is that the average solution quality of CASS is almost the
same for all discretization levels. Despite the difference in instance sets, this result implies
that the improvement of a finer discretization may be limited for CASS.
Level
1
2
3
4

Œ¥t (minutes)
10
5
2.5
2

M
4
7
13
16

Œ¥d
0.5
0.25
0.125
0.1

N
3
5
9
11

Table 4: Details about discretization levels. In the experiments mentioned in this section,
the distance space is evenly discretized, parameterized by Œ¥d = di+1 ‚àí di .

Next we turn to more realistic utility function in this ferry domain, which is of U -shape
or inverse U -shape. Figure 13(a) shows a sample utility curve where the attacker gains
higher utility closer to the shore. We fix the utility at the shore as 10, vary the utility in
the middle (denoted as Umid ), which is the value on the floor of the U -shape or the top of
the inverse U -shape and evaluate the strategies. In Figure 13(b), Umid is shown on x-axis
616

Protecting Moving Targets with Multiple Mobile Resources

8

Ave(AttEUm)

U ‚àí utility

10

5

0
0

0.5
d ‚àí distance

1

(a) Randomized attacker utility function

NAIVE
DASS
CASS

6
4
2
0

Level1 Level2 Level3 Level4

(b) Average solution quality of different
strategies

Figure 12: Performance under different randomized utility function settings. The utility
function in this set of experiments is a function of the distance to Terminal A.
The utility function is piece-wise linear and the value at discretized distance
points di is chosen randomly between [0,10].

15
Sup(AttEU)

U ‚àí utility

10
8
6
4
0

0.5
d ‚àí distance

5
0
0

1

(a) Realistic attacker utility function with
Umid = 5

10

NAIVE
DASS
CASS

5

10
Umid

15

20

(b) Solution quality of different strategies

Figure 13: Performance under different realistic utility function settings. The utility function is U-shape or inverse U-shape. The utility around distance 0.5 is denoted
as Umid . We compare the defender strategy given by DASS and CASS with the
baseline when Umid is changing from 1 to 20.

and we compare performance of the strategies in terms of attacker‚Äôs expected utility when
he plays best response on the y-axis. We conclude that 1) the strategy calculated by CASS
outperforms the baseline and DASS; 2) DASS may actually achieve worse results than the
baseline.
Among all these different experiment settings of discretization and utility function, we
choose one instance and provide a more detailed analysis for it. We refer to this instance
as example setting in the following of this section. In this example setting, discretization
level 4 is used and the utility curve is as shown in Figure 13(a), other parameters involved
are described in Section 7.1.1. Figure 14 compares the attacker expected utility function
when DASS and CASS is used respectively. The x-axis indicates the time t, and the y-axis
indicates the attacker‚Äôs expected utility if he attacks Ferry 1 at time t. For the strategy calculated by DASS, the worst performance at discretized time points is 3.50 (AttEU(F1 , 20)),
however, the supremum of AttEU(F1 , t), t ‚àà [0, 30] can be as high as 4.99 (AttEU(F1 , 4+ )),
617

Fang, Jiang, & Tambe

5

AttEU

4
3
2
1
0

DASS
CASS
10
20
t ‚àí time

30

Figure 14: The attacker‚Äôs expected utility function given the defender strategy calculated by
DASS vs CASS under example setting. The expected utilities at the discretized
time points are indicated by squares for CASS and dots for DASS. The maximum
of AttEU under CASS is 3.82, 30%less than the maximum of AttEU under
DASS, which is 4.99.

which experimentally shows that taking into consideration the attacks between the discretized time points is necessary. For the strategy calculated by CASS, the supremum of
AttEU(F1 , t) is reduced to 3.82.
7.1.3 Improvement Using Refinement Methods
We compare the refinement approaches described in Section 4 and analyze the tradeoff
between performance improvement and runtime. Three approaches are considered for comparison: route-adjust, flow-adjust and a variation of route-adjust, denoted by route-adjust2.
In step (ii) of route-adjust, we replace every node in the route one-by-one in sequence.3 In
step (ii) of route-adjust2, we replace every consecutive pair of nodes in the route in sequence.
We first show results for the example setting. In Figure 15(a), we compare the AttEU(Fq , t)
function of the defender strategy given by CASS and of the one after route-adjust for Ferry
1. It shows for an attack aiming at any target at any time, the defender strategy after
route-adjust refinement is equally good or better than the one in the original equilibrium,
and thus the defender performs equally or better no matter how the attacker is constrained
in time, i.e., the defender strategy after route-adjust dominates the original strategy. Figure
15(b) is the comparison between AttEU function of the defender strategy after route-adjust
and the one after route-adjust2 for Ferry 1. The one after route-adjust2 does not dominate
the one after route-adjust but overall the former appears to perform better than the latter
more frequently and by larger amounts. If we use the average value of AttEU function as a
metric of performance, we will show that route-adjust2 is better than route-adjust in this
example setting later in Table 5. Figure 15(c) shows the comparison between the AttEU
function of the defender strategy given by CASS and that of the defender strategy after
3. In supplementary experiments, we also tested route-adjust with more iterations, e.g., repeating the
process of replacing every node in sequence five times. The extra benefit is insignificant while the
runtime increases proportionally to the number of iterations. In light of this, we choose to replace each
node only once in the experiments reported in this article.

618

4

4

3

3

AttEU

AttEU

Protecting Moving Targets with Multiple Mobile Resources

2

CASS
Route‚àíAdjust

1
0

10

t ‚àí time

20

2
1
0

30

(a) AttEU function of Ferry 1 after
route-adjust (one node at a time)

Route‚àíAdjust
Route‚àíAdjust2
10

t ‚àí time

20

30

(b) AttEU function of Ferry 1 after
route-adjust2 (two nodes at a time)

AttEU

4
3
2
1
0

CASS
Flow‚àíAdjust
10

t ‚àí time

20

30

(c) Performance of flow-adjust

Figure 15: Performance of equilibrium refinement approaches.
flow-adjust for Ferry 1. The strategy given by CASS is not dominated by the one after
flow-adjust under Definition 7, but if we investigate the maximum of AttEU in each time
interval [tk , tk+1 ], as shown in Table 6, we find that the defender strategy after flow-adjust
locally dominates the original strategy.
We list the worst case performance and the average performance of AttEU function over
all ferries in this example setting for four defender strategies (CASS, route-adjust, routeadjust2, flow-adjust) in Table 5, from which we conclude that 1) the worst case performance
of all strategies of flow-adjust is the same, which means the defender achieves exactly same
expected utility towards an unconstrained rational attacker; 2) the average performance
of flow-adjust is slightly better than the CASS, but is outperformed by route-adjust and
route-adjust2, while it takes much less time to run compared to the other two; 3) in this
example setting, when we adjust two consecutive nodes at a time, the performance is better
than adjusting only one node at a time, but the difference is not significant and it is much
more expensive in terms of run-time.
Strategies
CASS
Route-Adjust
Route-Adjust2
Flow-Adjust

Worst Case Performance
3.82
3.82
3.82
3.82

Average Performance
3.40
2.88
2.76
3.34

Runtime (minutes)
8.96
32.31
0.50

Table 5: Comparison of different refinement approaches in terms of average performance
and runtime. Only the runtime for the refinement process is calculated.

619

Fang, Jiang, & Tambe

time interval [tk , tk+1 ]
[2, 4]
[4, 6]
[6, 8]
[8, 10]
[10, 12]
[12, 14]
[14, 16]

maximum
before
3.7587
3.8182
3.8153
3.8137
3.8052
3.8050
3.7800

maximum
after
3.6675
3.8182
3.6164
3.6316
3.6316
3.5664
3.2100

time interval [tk , tk+1 ]
[16, 18]
[18, 20]
[20, 22]
[22, 24]
[24, 26]
[26, 28]
[28, 30]

maximum
before
3.8111
3.8182
3.8182
3.8182
3.8182
3.8182
3.8182

maximum
after
3.7291
3.8182
3.8182
3.8182
3.8182
3.8182
3.8182

Table 6: The maximum of attacker‚Äôs expected utility in each time interval decreases after
flow-adjust is used.

Figure 16(a) and Figure 16(b) shows the maximum and the average improvement of
route-adjust, route-adjust2 and flow-adjust, averaged over all the 20 instances of Level 4
with randomized utilities that have been used for Figure 12(b); and Figure 16(c) shows the
average runtime. The maximum improvement is the largest difference between the AttEU
function given defender strategy calculated by CASS and the one after refinement. The
average improvement is the average difference between the two functions. The standard
deviations over all instances are shown as error bars. Figure 16 confirms that all the refinement approaches improve the defender strategy calculated by CASS in terms of both the
maximum performance and average performance and thus provide better defender strategies given possible constrained attackers. Route-adjust2 achieves the most improvement,
then route-adjust, and flow-adjust the least. Flow-adjust achieves much less improvement
compared to the other two approaches. One explanation for this is that the constraints are
very strong as they require all marginal probabilities to be unchanged so it is likely that
little changes are made to the original defender strategy. The difference between routeadjust2 and route-adjust is not as significant. In terms of run-time, flow-adjust is the least
expensive, route-adjust the second and route-adjust2 the most. Route-adjust2 is significantly more expensive compared to the other two. So we conclude that route-adjust is a
better choice considering the tradeoff between improvement and the runtime.
7.1.4 Sampled Routes
We first convert the defender strategy under the example setting into a Markov strategy
and sample 1000 pair of patrol routes. The defender strategy used here is the one after
‚Äúroute-adjust‚Äù. In each sample, a pair of routes is chosen step by step for the two patrol
boats according to the joint conditional probability distribution {Œ±(i1, j1, i2, j2, k)}. The
routes for the two patrol routes are chosen simultaneously as they are coordinating with
each other. We cannot show each pair separately for all 1000 samples. Instead, Figure
17(a) shows the frequency of being taken out of the 1000 samples of each edge. The x-axis
indicates the time and the y-axis is the distance to terminal A. The width of the each edge
indicates the frequency of being chosen by at least one patroller. Although Figure 17(a)
does not precisely depict the samples, it provides a rough view of how the routes are taken
by the patrol boats.
620

Protecting Moving Targets with Multiple Mobile Resources

0.6

route‚àíadjust
route‚àíadjust2
flow‚àíadjust

2

Ave Improvement

Max Improvement

2.5

1.5
1
0.5

route‚àíadjust
route‚àíadjust2
flow‚àíadjust

0.4
0.2

0

0

Runtime (minutes)

(a) Average of maximal improvement

(b) Average of average improvement
route‚àíadjust
route‚àíadjust2
flow‚àíadjust

40
30
20
10
0

(c) Average of runtime

Figure 16: Comparison of refinement approaches.

Figure 17(b) shows the pair of routes that is of highest probability when we use the
decomposition method of sampling. The solid lines show the patrol boats‚Äô routes and the
dashed lines show the ferries‚Äô schedules. We get 3958 different pair of patrol routes in total
in the decomposition process and the shown pair of routes is chosen with probability 1.57%.

1

d ‚àí distance

d ‚àí distance

1
0.8
0.6
0.4
0.2
0
0

5

10

15

20

25

0.8
0.6

0.2
0
0

30

t ‚àí time

Patrol Boat 1
Patrol Boat 2

0.4

5

10

15

20

25

30

t ‚àí time

(a)

(b)

Figure 17: Results for sampling under the example setting: (a) Frequency of each edge is
chosen when the first sampling method based on Markov strategy is used. (b)
Decomposed routes with highest probability superimposed on ferry schedules
when the second sampling method based on decomposition is used.

621

Attacker EU

6
4

log(Runtime (seconds))

Fang, Jiang, & Tambe

1 patroller
2 patrollers
3 patrollers
4 patrollers

2
0

1
0
‚àí1

‚àí3

Attacker EU

4

(b) Runtime of Level 1
log(Runtime (seconds))

(a) Solution quality of Level 1
5

1 patroller
2 patrollers
3 patrollers
4 patrollers

‚àí2

1 patroller
2 patrollers
3 patrollers

3
2
1
0

(c) Solution quality of Level 2

3
2

1 patroller
2 patrollers
3 patrollers

1
0
‚àí1
‚àí2

(d) Runtime of Level 2

Figure 18: Performance with varying number of patrollers.

7.1.5 Number of Patrollers
Figure 18(a) shows the improvement in performance of CASS with increasing number of
patrollers under discretization Level 1. The x-axis shows the number of patrollers and the
y-axis indicates the average of attacker‚Äôs maximal expected utility, i.e., the expected reward
when he plays his best response. The results are averaged over 20 random utility settings
of discretization Level 1. With fewer patrollers, the performance of the defender varies a lot
depending on the randomized utility function (as indicated by standard deviation shown as
the error bar). But the variance gets much smaller with more patrollers, which means the
defender has sufficient resources for different instances. Figure 18(b) shows the run-time for
CASS. The y-axis indicates the average of natural logarithm of runtime. Not surprisingly,
the run-time increases when the number of patrollers increases.
Figure 18(c) and 18(d) show the average performance and run-time of CASS with discretization Level 2, using the same set of utility settings as used in Level 1. Only results for
1 to 3 patrollers are shown. The program runs out of memory for 4 patrollers as there are
N 8 M = 2734375 flow distribution variables and at least N 4 M = 8757 constraints. Note
that the average solution quality of Level 2 is better than the result of Level 1 (e.g., the
average attacker EU for 1 patroller is 4.81 in Level 1 and 4.13 in Level 2), which indicates
a higher level of granularity can improve the solution quality. However, granularity clearly
affect the ability to scale-up; which means that we need to consider the tradeoff between the
solution quality and the memory used and one way to combat the scaling-up problem is to
reduce the level of granularity. Nonetheless, the number of patrollers we have encountered
in real-world scenarios such as at New York is of the order of 3 or 4, so CASS is capable at
least for key real-world scenarios.
622

Protecting Moving Targets with Multiple Mobile Resources

7.1.6 Approximation Approach for Multiple Defender Resources
We tested the first approximation approach for multiple defender resources described in
Section 3.4 for the example setting. We used the fmincon function with interior-point
method in MATLAB to minimize the non-linear objective function (Equation 25). Table
7 lists different run-time and the value of the objective function achieved given different
iteration number (denoted as MaxIter ). The function is not ensured to provide a feasible
solution when the iteration number is not large enough, as shown in the first two rows.
We compared the result with our LP formulation of DASS, which was implemented in
MATLAB using linprog function. DASS can be solved within 8.032 seconds and provides
an optimal solution AttEUm = 3.5, this approximation approach is outperformed in both
run-time efficiency and solution quality. This approach fails to provide a feasible solution
efficiently and even when sufficient time is given (more than 400 times the run-time of the
LP formulation), the maximum attacker expected utility is 18% larger than the optimal
solution. This is mainly because the new formulation in the approximation approach is no
longer linear or convex, making it difficult to find a global maximum.
M axIter
3000
10000
900000

Run ‚àí time(sec)
4.14
17.21
3298

AttEUm
infeasible
infeasible
4.0537

Table 7: Performance of approximation approach.

7.2 Experiments for Two Dimensional Setting
The settings in 2-D space are more complex even with single patroller. Here we show
an example setting motivated by the ferry system between Seattle, Bainbridge island and
Bremerton as shown in Figure 9. In this example setting, three terminals (denoted as A,B
and C) are non-collinear in the 2-D space as shown in the Figure 19(a). Ferry 1 and Ferry
2 are moving on the trajectory between Terminal B and C (denoted as Trajectory 1) and
Ferry 3 and Ferry 4 are moving on the trajectory between Terminal B and A (denoted as
Trajectory 2). The schedules of the four ferries are shown in Figure 19(b), where the x-axis
is the time and the y-axis is the distance from the common terminal B. Ferry 1 moves
from C to B, Ferry 2 moves from B to C, Ferry 3 moves from B to A and Ferry 4 moves
from A to B. Similar to the one-dimensional scenario in ferry domain, we assume the utility
is decided by the ferry‚Äôs position and the utility function is shown in Figure 19(c). The
x-axis is the distance from the common terminal B and the y-axis is the utility for the two
trajectories respectively. The 2-D space is discretized into a grid as shown in Figure 19(d)
with Œ¥x = 1.5 and Œ¥y = 1 indicating the interval in the x-axis and y-axis. A patroller will
be located at one of the intersection points of the grid graph at any discretized time points.
The simulation time is 60 minutes and M = 13, i.e., tk+1 ‚àí tk = 5 minutes. The speed limit
for the patroller is ve = 0.38 and all the available edges that a patroller can take during
[tk , tk+1 ] are shown in Figure 19(d). Only one patroller is involved. The protection radius
is set to re = 0.5, and protection coefficient is C1 = 0.8.
623

Fang, Jiang, & Tambe

C

2

y

distance from Terminal B

Terminals in 2D
Trajectory 1
B

1

Trajectory 2
0

A
0

1.5

3

4.5

x

Ferry Schedules
1

0.6
0.4
0.2
0
0

60

Edges Available
2

Ferry Trajectory1
Ferry Trajectory2

6

y

utility

40

(b) Ferry schedules

Utility Function
8

20

time

(a) Three terminals
10

Ferry1
Ferry2
Ferry3
Ferry4

0.8

1

4
2
0
0

0.2

0.4

0.6

0.8

0
0

1

1.5

3

4.5

x

distance from Terminal B
(c) Utility function

(d) Available edges

Figure 19: An example setting in two-dimensional space
Figure 20(a) compares the performance of DASS and CASS for Ferry 2. Ferry 2 is chosen
because in both strategies, the attacker‚Äôs best response is to attack Ferry 2. The x-axis is
the time t, and the y-axis is the attacker expected utility of attacking Ferry 1 at time t. The
maximum of AttEU of CASS is 6.1466, 12% lower compared to the result of DASS, which
is 6.9817. Figure 20(b) and 20(c) show two sampled route given the strategy calculated
by CASS on the 2-D map where the dashed lines represents for the ferry trajectories. The
patroller starts from the node with text ‚Äústart‚Äù and follows the arrowed route, and ends at
the node with text ‚Äúend‚Äù at the end of the patrol. She may stay at the nodes with text
‚Äústay‚Äù. The patrol routes are shown in a intuitive way but can be ambiguous. The exact
route should be listed as a table with time and position. The routes are sampled based on
the converted Markov strategy, and the total number of patrol routes that may be chosen
with non-zero probability is 4.49 √ó 1010 .

8. Related Work
In this section we discuss literature related to our work. We will first discuss work on
the computation of game-theoretic patrolling strategies, then discuss work on continuous
games, and finally discuss work on equilibrium refinement.
As mentioned in the introduction, Stackelberg games have been widely applied to security domains, although most of this work has considered static targets (e.g., Korzhyk
et al., 2010; Krause, Roper, & Golovin, 2011; Letchford & Vorobeychik, 2012; Kiekintveld
624

Protecting Moving Targets with Multiple Mobile Resources

Sampled Route by CASS

7

stay

6
y

AttEU

2

4
0

stay
staystart
end

1

DASS
CASS

5

0

20
40
t ‚àí time

60

0

1.5

3

4.5

x

(a) Solution quality of DASSand CASS for
Ferry 2

(b) Sampled route 1 superimposed on ferry
trajectories

Sampled Route by CASS
staystart

y

2

stay
end

1

0
0

1.5

3

4.5

x
(c) Sampled route 2 superimposed on ferry
trajectories

Figure 20: Experimental results under two-dimensional settings

et al., 2013). Agmon, Kraus, and Kaminka (2008) proposed algorithms for computing
mixed strategies for setting up a perimeter patrol in adversarial settings with mobile robot
patrollers. Similarly, Basilico, Gatti, and Amigoni (2009) computed randomized leader strategies for robotic patrolling in environments with arbitrary topologies. Even when both
of the players are mobile, e.g., in hider-seeker games (Halvorson, Conitzer, & Parr, 2009),
infiltration games (Alpern, 1992) or search games (Gal, 1980), the targets (if any) were assumed to be static. Tsai et al. (2009) applied Stackelberg games to the domain of scheduling
federal air marshals on board flights. The targets (i.e., flights) in this domain are mobile,
but the players are restricted to move along the targets to protect or attack them. This
stationary nature leads to discrete game models with finite numbers of pure strategies.
BosÃåanskyÃÅ, LisyÃÅ, Jakob, and PeÃåchoucÃåek (2011) and VaneÃåk, Jakob, Hrstka, and PeÃåchoucÃåek
(2011) studied the problem of protecting moving targets. However, they both considered
a model in which the defender, the attacker and targets have discretized movements on a
directed graph. Such discretization of attacker strategy spaces can introduce suboptimality
in the solutions, as we have shown with DASS. We, in our work, generalize the strategy space of the attacker to the continuous realm and compute optimal strategies even in
such a setting. Furthermore, while we provide an efficient and scalable linear formulation,
BosÃåanskyÃÅ et al. presented a formulation with non-linear constraints, which faced problems
scaling up to larger games even with a single defender resource.
625

Fang, Jiang, & Tambe

Yin et al. (2012) considered the domain of patrolling in public transit networks (such
as the LA Metro subway train system) in order to catch fare evaders. Because the players
ride along trains that follow a fixed schedule, the domain is inherently discrete and they
modeled the patrolling problem as a finite zero-sum Bayesian game. Yin et al. proposed a
compact representation for defender mixed strategies as flows in a network. We adapt this
compact representation idea to a continuous domain. In particular, in our domain we need
to model the interaction between the defender‚Äôs flow and attacker‚Äôs continuous strategy
space. Our proposed sub-interval analysis used spatio-temporal reasoning to efficiently
reduce the problem into a finite LP.
Games with continuous strategy spaces have been well-studied in game theory. Much of
the economics literature has focused on games whose equilibria can be solved analytically
(and thus the question of computation does not arise), for example the classical theory
of auctions (see e.g., Krishna, 2009). Recent computational approaches for the analysis
and design of auctions have focused on discretized versions of the auction games (e.g.,
Thompson & Leyton-Brown, 2009; Daskalakis & Weinberg, 2012). There has been research
on efficiently solving two-player continuous games with specific types of utility functions,
such as zero-sum games with convex-concave utility functions (Owen, 1995) and separable
continuous games with polynomial utility functions (Stein, Ozdaglar, & Parrilo, 2008).
Johnson, Fang, and Tambe (2012) studied a continuous game model for protecting forests
from illegal logging. In their model the target (i.e., the forest) is stationary, and with further
simplifying assumptions (e.g., the forest having a circular shape) they were able to solve
the game efficiently. In contrast to existing work, our game model has moving targets in a
continuous domain, and the resulting utility functions are discontinuous and thus existing
approaches are not applicable. Our CASS algorithm solves the game optimally without
needing to discretize the attacker‚Äôs strategy space.
There is an extensive literature on equilibrium refinement; however most existing work
on the computation of equilibrium refinement focuses on finite games. For simultaneousmove finite games, solution concepts such as perfect equilibrium and proper equilibrium
were proposed as refinements of Nash equilibrium (Fudenberg & Tirole, 1991). Miltersen
and S√∏rensen (2007) proposed an efficient algorithm for computing proper equilibria in finite zero-sum games. For finite security games, An et al. (2011) proposed a refinement
of Stackelberg equilibrium and techniques for computing such refinements. The resulting
defender strategy is robust against possibilities of constrained capabilities of the attacker.
These existing approaches rely on the finiteness of action sets, and is thus not applicable to
our setting. Simon and Stinchcombe (1995) proposed definitions of perfect equilibrium and
proper equilibrium for infinite games with continuous strategy sets, however they did not
propose any computational procedure for the resulting solution concepts. Exact computation of equilibrium refinements of continuous games such as MRMTsg remains a challenging
open problem.

9. Conclusion
This paper makes several contributions in computing optimal strategies given moving targets and mobile patrollers. First, we introduce MRMTsg , a novel Stackelberg game model
that takes into consideration spatial and temporal continuity. In this model, targets move
626

Protecting Moving Targets with Multiple Mobile Resources

with fixed schedules and the attacker chooses his attacking time from a continuous time
interval. Multiple mobile defender resources protect the targets within their protection
radius, and bring in continuous space in our analysis. Second, we develop a fast solution
approach, CASS, based on compact representation and sub-interval analysis. Compact representations dramatically reduce the number of variables in designing the optimal patrol
strategy for the defender. Sub-interval analysis reveals the piece-wise linearity in attacker
expected utility function and shows there is a finite set of dominating strategies for the attacker. Third, we propose two approaches for equilibrium refinement for CASS‚Äôs solutions:
route-adjust and flow-adjust. Route-adjust decomposes the patrol routes, greedily improves
the routes and composes the new routes together to get the new defender strategy. Flowadjust is a fast and simple algorithm that adjusts the flow distribution to achieve optimality
in each time interval while keeping the marginal probability at the discretized time points
unchanged. Additionally, we provide detailed experimental analyses in the ferry protection
domain. CASS has been deployed by the US Coast Guard since April 2013.

10. Future Work
There are several important avenues for future work. These include: (i) use a decreasing
function to model the protection provided to the targets instead of using a fixed protection
radius; (ii) handle practical constraints on patrol boat schedule as not all are easily implementable; (iii) efficiently handle more complex and uncertain target schedules and utility
functions.
Here we provide an initial discussion about the relaxation of the assumptions that we
listed in Section 2 and used throughout the paper:
‚Ä¢ If we allow for complex and uncertain target schedules, we may model the problem as
a game where the targets follow stochastic schedules. Our framework may still apply
but may need to be enriched (e.g., using approaches such as use of MDPs to represent
defender strategies, see Jiang, Yin, Zhang, Tambe, & Kraus, 2013). Coordinating
multiple such defenders then becomes an important challenge. It may be helpful in
such cases to appeal to more of the prior work on multi-agent teamwork, given the
significant uncertainty in such cases leading to more need for on-line coordination
(Tambe, 1997; Stone, Kaminka, Kraus, & Rosenschein, 2010; Kumar & Zilberstein,
2010; Yin & Tambe, 2011).
‚Ä¢ If we focus on environments where multiple attackers can coordinate their attacks,
then we may need to further enhance our framework. Prior results from Korzhyk,
Conitzer, and Parr (2011) over stationary targets and discrete time would be helpful
in addressing this challenge, although the case of moving targets in continuous space
and time in such cases provides a very significant challenge. Combining with the
previous item for future work, a complex multiple defender multiple attacker scenario
would appear to be a very significant computational challenge.

627

Fang, Jiang, & Tambe

Acknowledgments
We thank the USCG officers, and particularly Craig Baldwin, Joe Direnzo and Francis
Varrichio and officers at sector New York, for their exceptional collaboration. The views
expressed herein are those of the author(s) and are not to be construed as official or reflecting
the views of the Commandant or of the U.S. Coast Guard. This research is supported by
US Coast Guard grant HSHQDC-10-D-00019 and MURI grant W911NF-11-1-0332. We
also thank the anonymous reviewers for valuable suggestions.
A preliminary version of this work appears as the conference paper (Fang, Jiang, &
Tambe, 2013). There are several major advances in this article: (i) Whereas the earlier work
confined targets to move in 1-D space, we provide a significant extension of our algorithms
(DASS and CASS) in this article to enable the targets and the patrollers to move in 2D space; we also provide detailed experimental results on this 2-D extension. (ii) We
provide additional novel equilibrium refinement approaches and experimentally compare
their performance with the equilibrium refinement approach offered in our earlier work;
this allows us to offer an improved understanding of the equilibrium refinement space. (iii)
We discuss several sampling methods in detail to sample actual patrol routes from the mixed
strategies we generate ‚Äì a discussion that was missing in our earlier work. (iv) We provide
detailed proofs that were omitted in the previous version of the work.

628

Protecting Moving Targets with Multiple Mobile Resources

Appendix A. Notation Table

Notation
MRMT
MRMTsg
L
Fq
A, B
T
D
Sq (t)
W
Pu
vm
re
CG
Uq (t)
M
N
tk
di
Œ¥t
Ru
ru (k)
f (i, j, k)
p(i, k)
Ei,j,k
p(Ru )
AttEU(Fq , t)
Œ≤q (t)
œâ(Fq , t)
I(i, q, k)
L1q ,L2q
r
Œ∏qk
r¬±
AttEU(Fq , Œ∏qk
)
Mqk
Arqk (i, j)
E(u, k)

Meaning
The problem of multiple Mobile Resources protecting Moving Targets
Game model with a continuous set of strategies for the attacker for MRMT.
Number of ferries.
Ferry with index q.
Terminal points.
Continuous time interval or a finite set of time points.
Continuous space of possible locations or a set of distance points.
Ferry schedule. Position of the target Fq at a specified time t.
Number of patrollers.
Patroller with index u.
Speed limit of patroller.
Protection radius of patroller.
Probability that the attacker can be stopped with G patrollers.
Positive reward of a successful attack on target Fq at time t for the attacker.
Number of discretized time points.
Number of discretized distance points.
Discretized time point.
Discretized distance point.
Distance between two adjacent time points.
Patrol route for patroller Pu . Under discretization of the defender‚Äôs strategy space,
Ru can be described as a vector.
The patroller is located at dru (k) at time tk .
Flow distribution variable. Probability that the patroller moves from di to dj
during time [tk , tk+1 ].
Marginal distribution variable. Probability that the patroller is located at di tk .
The directed edge linking nodes (tk , di ) and (tk+1 , dj ).
Probability of taking route Ru .
Attacker expected utility of attacking target Fq at time t.
Protection range of target Fq at time t
Probability that the patroller is protecting target Fq at time t.
Whether a patroller located at di at time tk is protecting target Fq .
Lines of Sq (t) ¬± re .
The rth intersection point in [tk , tk+1 ] with respect to target Fq .
r .
Left/right-side limit of AttEU(Fq , t) at Œ∏qk
Number of intersection points in [tk , tk+1 ] with respect to target Fq .
r , Œ∏ r+1 ]; 0 otherwise.
C1 if patroller taking edge Ei,j,k can protect target Fq in [Œ∏qk
qk
Short for Eru (k),ru (k+1),k .
Table 8: Summary of notations involved in the paper.

629

Fang, Jiang, & Tambe

Appendix B. Calculation of Intersection Points in CASS for 2-D Settings
We calculate the time where the patroller‚Äôs route intersects with the protection range for
a target when the patroller is moving from V1 = (x1 , y1 ) to V2 = (x2 , y2 ) and the target
is moving from Sq (tk ) = (xÀÜ1 , yÀÜ1 ) to Sq (tk+1 ) = (xÀÜ2 , yÀÜ2 ) during [tk , tk+1 ]. The patroller‚Äôs
position at a given time t ‚àà [tk , tk+1 ] is denoted as (x, y) and the target‚Äôs position is denoted
as (xÃÇ, yÃÇ). Then we have
t ‚àí tk
(x2 ‚àí x1 ) + x1 ,
tk+1 ‚àí tk
t ‚àí tk
(xÀÜ2 ‚àí xÀÜ1 ) + x1 ,
xÃÇ =
tk+1 ‚àí tk

t ‚àí tk
(y2 ‚àí y1 ) + y1
tk+1 ‚àí tk
t ‚àí tk
yÃÇ =
(yÀÜ2 ‚àí yÀÜ1 ) + yÀÜ1
tk+1 ‚àí tk

x=

y=

(40)
(41)

At an intersection point, the distance from the patroller‚Äôs position to the target‚Äôs position
equals to the protection radius re , so we are looking for a time t such that
(x ‚àí xÃÇ)2 + (y ‚àí yÃÇ)2 = re2

(42)

By substituting the variables in Equation 42 with Equations 40‚Äì41, and denoting
(x2 ‚àí x1 ) ‚àí (xÀÜ2 ‚àí xÀÜ1 )
,
tk+1 ‚àí tk
(y2 ‚àí y1 ) ‚àí (yÀÜ2 ‚àí yÀÜ1 )
A2 =
,
tk+1 ‚àí tk
A1 =

B1 = x1 ‚àí xÀÜ1 ,
B2 = y1 ‚àí yÀÜ1 ,

Equation 42 can be simplified to
(A1 t ‚àí A1 tk + B1 )2 + (A2 t ‚àí A2 tk + B2 )2 = re2 .

(43)

Denote C1 = B1 ‚àí A1 tk and C2 = B2 ‚àí A2 tk , and we can easily get the two roots of this
quadratic equation, which are
p
‚àí2(A1 C1 + A2 C2 ) ¬± 2 (A1 C1 + A2 C2 )2 ‚àí (A21 + A22 )(C12 + C22 ‚àí re2 )
ta,b =
.
(44)
2(A21 + A22 )
ta or tb is the time of a valid intersection point if and only if it is within the time interval
under consideration ([tk , tk+1 ]).

References
Agmon, N., Kraus, S., & Kaminka, G. A. (2008). Multi-robot perimeter patrol in adversarial
settings. In IEEE International Conference on Robotics and Automation (ICRA), pp.
2339‚Äì2345.
Alpern, S. (1992). Infiltration Games on Arbitrary Graphs. Journal of Mathematical Analysis and Applications, 163, 286‚Äì288.
630

Protecting Moving Targets with Multiple Mobile Resources

An, B., Kempe, D., Kiekintveld, C., Shieh, E., Singh, S. P., Tambe, M., & Vorobeychik, Y.
(2012). Security games with limited surveillance. In Proceedings of the Twenty-Sixth
AAAI Conference on Artificial Intelligence, pp. 1241‚Äì1248.
An, B., Tambe, M., OrdoÃÅnÃÉez, F., Shieh, E., & Kiekintveld, C. (2011). Refinement of strong
stackelberg equilibria in security games. In Proceedings of the Twenty-Fifth AAAI
Conference on Artificial Intelligence (AAAI), pp. 587‚Äì593.
Basilico, N., Gatti, N., & Amigoni, F. (2009). Leader-follower strategies for robotic patrolling in environments with arbitrary topologies. In Proceedings of The 8th International Conference on Autonomous Agents and Multiagent Systems (AAMAS) Volume 1, pp. 57‚Äì64.
BosÃåanskyÃÅ, B., LisyÃÅ, V., Jakob, M., & PeÃåchoucÃåek, M. (2011). Computing time-dependent
policies for patrolling games with mobile targets. In The 10th International Conference
on Autonomous Agents and Multiagent Systems (AAMAS) - Volume 3, pp. 989‚Äì996.
Conitzer, V., & Sandholm, T. (2006). Computing the optimal strategy to commit to. In
Proceedings of the 7th ACM Conference on Electronic Commerce, EC ‚Äô06, pp. 82‚Äì90.
Daskalakis, C., & Weinberg, S. M. (2012). Symmetries and optimal multi-dimensional mechanism design. In Proceedings of the 13th ACM Conference on Electronic Commerce,
EC ‚Äô12, pp. 370‚Äì387.
Fang, F., Jiang, A. X., & Tambe, M. (2013). Optimal patrol strategy for protecting moving
targets with multiple mobile resources. In Proceedings of the 2013 International Conference on Autonomous Agents and Multi-agent Systems, AAMAS ‚Äô13, pp. 957‚Äì964.
Fudenberg, D., & Tirole, J. (1991). Game Theory. MIT Press.
Gal, S. (1980). Search Games. Academic Press, New York.
Gatti, N. (2008). Game theoretical insights in strategic patrolling: Model and algorithm in
normal-form. In Proceedings of the 18th European Conference on Artificial Intelligence
(ECAI), pp. 403‚Äì407.
Greenberg, M., Chalk, P., & Willis, H. (2006). Maritime terrorism: risk and liability. Rand
Corporation monograph series. RAND Center for Terrorism Risk Management Policy.
Halvorson, E., Conitzer, V., & Parr, R. (2009). Multi-step Multi-sensor Hider-Seeker Games.
In IJCAI.
Jakob, M., VaneÃåk, O., & PeÃåchoucÃåek, M. (2011). Using agents to improve international
maritime transport security. Intelligent Systems, IEEE, 26 (1), 90‚Äì96.
Jiang, A. X., Yin, Z., Zhang, C., Tambe, M., & Kraus, S. (2013). Game-theoretic randomization for security patrolling with dynamic execution uncertainty. In Proceedings
of the 2013 international conference on Autonomous agents and multi-agent systems,
AAMAS ‚Äô13, pp. 207‚Äì214.
Johnson, M. P., Fang, F., & Tambe, M. (2012). Patrol strategies to maximize pristine forest
area. In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence
(AAAI), pp. 295‚Äì301.
631

Fang, Jiang, & Tambe

Kiekintveld, C., Islam, T., & Kreinovich, V. (2013). Security games with interval uncertainty. In Proceedings of the 2013 International Conference on Autonomous Agents
and Multi-agent Systems, AAMAS ‚Äô13, pp. 231‚Äì238.
Kiekintveld, C., Jain, M., Tsai, J., Pita, J., OrdoÃÅnÃÉez, F., & Tambe, M. (2009). Computing
optimal randomized resource allocations for massive security games. In Proceedings
of The 8th International Conference on Autonomous Agents and Multiagent Systems
- Volume 1, AAMAS ‚Äô09, pp. 689‚Äì696.
Korzhyk, D., Conitzer, V., & Parr, R. (2010). Complexity of computing optimal Stackelberg
strategies in security resource allocation games. In Proceedings of the 24th National
Conference on Artificial Intelligence (AAAI), pp. 805‚Äì810.
Korzhyk, D., Conitzer, V., & Parr, R. (2011). Security games with multiple attacker resources. In Proceedings of the Twenty-Second international joint conference on Artificial Intelligence - Volume Volume One, IJCAI‚Äô11, pp. 273‚Äì279. AAAI Press.
Krause, A., Roper, A., & Golovin, D. (2011). Randomized sensing in adversarial environments. In Proceedings of the 22nd International Joint Conference on Artificial
Intelligence (IJCAI), pp. 2133‚Äì2139.
Krishna, V. (2009). Auction theory. Academic press.
Kumar, A., & Zilberstein, S. (2010). Anytime planning for decentralized POMDPs using
expectation maximization. In Proceedings of the Twenty-Sixth Conference on Uncertainty in Artificial Intelligence, pp. 294‚Äì301.
Letchford, J. (2013). Computational Aspects of Stackelberg Games. Ph.D. thesis, Duke
University.
Letchford, J., & Conitzer, V. (2013). Solving security games on graphs via marginal probabilities. In Proceedings of the Twenty-Seventh AAAI Conference on Artificial Intelligence (AAAI), pp. 591‚Äì597.
Letchford, J., & Vorobeychik, Y. (2012). Computing optimal security strategies for interdependent assets. In The Conference on Uncertainty in Artificial Intelligence (UAI),
pp. 459‚Äì468.
Luber, S., Yin, Z., Fave, F. D., Jiang, A. X., Tambe, M., & Sullivan, J. P. (2013). Gametheoretic patrol strategies for transit systems: the trusts system and its mobile app
(demonstration). In International Conference on Autonomous Agents and Multiagent
Systems (AAMAS)[Demonstrations Track], pp. 1377‚Äì1378.
Marecki, J., Tesauro, G., & Segal, R. (2012). Playing repeated stackelberg games with unknown opponents. In Proceedings of the 11th International Conference on Autonomous
Agents and Multiagent Systems, AAMAS ‚Äô12, pp. 821‚Äì828.
Miltersen, P. B., & S√∏rensen, T. B. (2007). Computing proper equilibria of zero-sum games.
In Proceedings of the 5th International Conference on Computers and Games, CG‚Äô06,
pp. 200‚Äì211.
Owen, G. (1995). Game Theory (3rd ed.). Academic Press.
632

Protecting Moving Targets with Multiple Mobile Resources

Paruchuri, P., Tambe, M., OrdoÃÅnÃÉez, F., & Kraus, S. (2006). Security in multiagent systems
by policy randomization. In Proceedings of the fifth international joint conference on
Autonomous agents and multiagent systems, AAMAS ‚Äô06, pp. 273‚Äì280.
Pita, J., Jain, M., Marecki, J., OrdoÃÅnÃÉez, F., Portway, C., Tambe, M., Western, C., Paruchuri,
P., & Kraus, S. (2008). Deployed ARMOR protection: the application of a game theoretic model for security at the Los Angeles International Airport. In Proceedings of the
7th International Joint Conference on Autonomous Agents and Multiagent Systems:
Industrial Track, AAMAS ‚Äô08, pp. 125‚Äì132.
Pita, J., Jain, M., Ordonez, F., Portway, C., Tambe, M., Western, C., Paruchuri, P., &
Kraus, S. (2009). Using game theory for los angeles airport security.. AI Magazine,
30, 43‚Äì57.
Shieh, E., An, B., Yang, R., Tambe, M., Baldwin, C., DiRenzo, J., Maule, B., & Meyer,
G. (2012). PROTECT: A deployed game theoretic system to protect the ports of the
United States. In Proceedings of the 11th International Conference on Autonomous
Agents and Multiagent Systems - Volume 1, AAMAS ‚Äô12, pp. 13‚Äì20.
Simon, L. K., & Stinchcombe, M. B. (1995). Equilibrium refinement for infinite normal-form
games. Econometrica, 63 (6), 1421‚Äì1443.
Stein, N. D., Ozdaglar, A., & Parrilo, P. A. (2008). Separable and low-rank continuous
games. International Journal of Game Theory, 37 (4), 475‚Äì504.
Stone, P., Kaminka, G. A., Kraus, S., & Rosenschein, J. S. (2010). Ad hoc autonomous
agent teams: Collaboration without pre-coordination. In Proceedings of the 24th AAAI
Conference on Artificial Intelligence, pp. 1504‚Äì1509.
Tambe, M. (1997). Towards flexible teamwork. JOURNAL OF ARTIFICIAL INTELLIGENCE RESEARCH, 7, 83‚Äì124.
Tambe, M. (2011). Security and Game Theory: Algorithms, Deployed Systems, Lessons
Learned. Cambridge University Press.
Thompson, D. R. M., & Leyton-Brown, K. (2009). Computational analysis of perfectinformation position auctions. In Proceedings of the 10th ACM conference on Electronic commerce, EC ‚Äô09, pp. 51‚Äì60.
Tsai, J., Rathi, S., Kiekintveld, C., Ordonez, F., & Tambe, M. (2009). IRIS - a tool for
strategic security allocation in transportation networks. In The Eighth International
Conference on Autonomous Agents and Multiagent Systems - Industry Track, AAMAS
‚Äô09, pp. 37‚Äì44.
van Damme, E. (1987). Stability and Perfection of Nash equilibria. Springer-Verlag.
VaneÃåk, O., Jakob, M., Hrstka, O., & PeÃåchoucÃåek, M. (2011). Using multi-agent simulation
to improve the security of maritime transit. In Proceedings of 12th International
Workshop on Multi-Agent-Based Simulation (MABS), pp. 1‚Äì16.
Vorobeychik, Y., & Singh, S. (2012). Computing stackelberg equilibria in discounted stochastic games. In Proceedings of the Twenty-Sixth Conference on Artificial Intelligence (AAAI), pp. 1478‚Äì1484.
633

Fang, Jiang, & Tambe

Yin, Z., Jiang, A. X., Johnson, M. P., Kiekintveld, C., Leyton-Brown, K., Sandholm, T.,
Tambe, M., & Sullivan, J. P. (2012). TRUSTS: Scheduling randomized patrols for
fare inspection in transit systems. In Proceedings of the Twenty-Fourth Conference
on Innovative Applications of Artificial Intelligence (IAAI), pp. 2348‚Äì2355.
Yin, Z., & Tambe, M. (2011). Continuous time planning for multiagent teams with temporal
constraints. In Proceedings of the Twenty-Second international joint conference on
Artificial Intelligence - Volume Volume One, IJCAI‚Äô11, pp. 465‚Äì471. AAAI Press.

634

Journal of Artificial Intelligence Research 48 (2013) 1-22

Submitted 12/12; published 10/13

Natural Language Inference for Arabic Using Extended Tree
Edit Distance with Subtrees
Maytham Alabbas

maytham.alabbas@gmail.com

Department of Computer Science, University of Basrah,
Basrah, Iraq

Allan Ramsay

Allan.Ramsay@manchester.ac.uk

School of Computer Science, University of Manchester,
Manchester, M13 9PL, UK

Abstract
Many natural language processing (NLP) applications require the computation of similarities between pairs of syntactic or semantic trees. Many researchers have used tree edit
distance for this task, but this technique suffers from the drawback that it deals with single node operations only. We have extended the standard tree edit distance algorithm to
deal with subtree transformation operations as well as single nodes. The extended algorithm with subtree operations, TED+ST, is more effective and flexible than the standard
algorithm, especially for applications that pay attention to relations among nodes (e.g. in
linguistic trees, deleting a modifier subtree should be cheaper than the sum of deleting
its components individually). We describe the use of TED+ST for checking entailment
between two Arabic text snippets. The preliminary results of using TED+ST were encouraging when compared with two string-based approaches and with the standard algorithm.

1. Introduction
Tree edit distance has been widely used as a component of natural language processing (NLP)
systems that attempt to determine whether one text snippet supports an inference to another
(roughly speaking, whether the first entails the second), with the distance between pairs of
dependency trees being taken as a measure of the likelihood that one entails the other. We
extend the standard algorithm for calculating the distance between two trees by allowing
operations to apply to subtrees, rather than just to single nodes. This extension improves
the performance of our technique for Arabic by around 5% in F-score and around 4% in
accuracy compared with a number of well-known techniques. The relative performance
of the standard techniques on our Arabic testset replicates the results reported for these
techniques for English testsets. We have also applied our extended version of tree edit
distance, TED+ST, to the English RTE-2 testset, where it again outperforms the standard
algorithm.
Tree edit distance is a generalisation of the standard string edit distance metric, which
measures the similarity between two strings. It has been used to underpin several NLP
applications such as information extraction (IE), information retrieval (IR) and natural
language inference (NLI). The edit distance between two trees is defined as the minimum
cost sequence of edit operations to transform one tree to another. There have been numerous
approaches to calculating edit distance between trees, as reported by Selkow (1977), Tai
c
!2013
AI Access Foundation. All rights reserved.

Alabbas & Ramsay

(1979), Zhang and Shasha (1989), Klein (1998), Demaine, Mozes, Rossman, and Weimann
(2009) and Pawlik and Augsten (2011). We have chosen to work with Zhang-Shasha‚Äôs
algorithm (Zhang & Shasha, 1989) because the intermediate structures produced by this
algorithm allow us to detect and respond to operations on subtrees. When we refer to the
standard tree edit distance algorithm throughout the rest of this article, we mean ZhangShasha‚Äôs algorithm, for which we will use the short form ZS-TED.
Our ultimate goal is to develop an NLI system for Arabic (Alabbas, 2011).1 NLI is the
problem of determining whether a natural language hypothesis h can reasonably be inferred
from a natural language premise p. The challenges of NLI are quite different from those
encountered in formal deduction: the emphasis is on informal reasoning, lexical semantic
knowledge, and variability of linguistic expression, rather than on long chains of formal
reasoning (MacCartney, 2009). A more recent, and better-known, formulation of the NLI
task is the recognising textual entailment challenge (RTE), described by Dagan and Glickman
(2004) as a task of determining, for two text snippets premise p and hypothesis h, whether
‚Äú. . . typically, a human reading p would infer that h is most likely true.‚Äù According to these
authors, entailment holds if the truth of h, as interpreted by a typical language user, can be
inferred from the meaning of p. A popular method that has been used in recent years for such
tasks is the use of tree edit distance, which compares sentence pairs by finding a minimal
cost sequence of editing operations to transform a tree representation of one sentence into a
tree for the other (Kouylekov, 2006; Heilman & Smith, 2010). Approximate tree matching
of this kind allows users to match parts of two trees, rather than demanding a complete
match of every element of each tree. However, one of the main drawbacks of tree edit
distance is that transformation operations are applied solely on single nodes (Kouylekov,
2006). Kouylekov and Magnini (2005) used the standard tree edit distance, which uses
transformation operations (insert, delete and exchange) solely on single nodes, to check
the entailment between two dependency trees. On the other hand, Heilman and Smith
(2010) extended the available operations in standard tree edit distance to INSERT-CHILD,
INSERT-PARENT, DELETE-LEAF, DELETE-&-MERGE, RELABEL-NODE and RELABEL-EDGE. These
authors also identify three new operations, MOVE-SUBTREE, which means move a node X
in a tree T to be the last child on the left/right side of a node Y in T (s.t. Y is not
a descendant of X ), NEW-ROOT and MOVE-SIBLING, to enable succinct edit sequences for
complex transformation. This extended set of edit operations allows certain combinations
of the basic operations to be treated as single steps, and hence provides shorter (and therefore
cheaper) derivations. The fine-grained distinctions between, for instance, different kinds of
insertions also make it possible to assign different weights to different variations on the same
operation. Nonetheless, these operations continue to operate on individual nodes rather than
on subtrees (despite its name, even MOVE-SUBTREE appears to be defined as an operation
on nodes rather than on subtrees). We have solved this problem by extending the basic
version of the algorithm so that the costs of operations that insert/delete/exchange subtrees
are derived by some appropriate function of the costs of the operations on their parts.
This makes TED+ST more effective and flexible than the standard algorithm, especially for
applications that pay attention to relations among nodes (e.g deleting a modifier subtree, in
linguistic trees, should be cheaper than the sum of deleting its components individually).
1. In particular, for Modern standard Arabic (MSA). When we refer to Arabic throughout this article, we
mean MSA.

2

Natural Language Inference for Arabic

The rest of the paper is organised as follows: Zhang-Shasha‚Äôs algorithm, ZS-TED, is
explained in Section 2. Section 3 presents TED+ST. Section 4 describes dependency trees
matching. Dataset preparation is explained in Section 5. The experimental results are
discussed in Section 6. Conclusions are given in Section 7.

2. Zhang-Shasha‚Äôs TED Algorithm
Our approach extends ZS-TED, which uses dynamic programming to provide an O(n4 )
algorithm for finding the optimal sequence of node-based edit operations for transforming
one tree into another. This section contains a brief recapitulation of this algorithm‚Äìa more
detailed description is given by Bille (2005).
Ordered trees are trees in which the left-to-right order among siblings is significant.
Approximate tree matching allows us to match a tree with just some parts of another tree.
There are three operations, namely deleting, inserting and exchanging a node, which can
transform one ordered tree to another. There is a nonnegative real cost associated with each
edit operation. These costs are changed to match the requirements of specific applications.
Deleting a node x means attaching its children to the parent of x. Insertion is the inverse
of deletion. This means an inserted node becomes a parent of a consecutive sub-sequence
in the left to right order of its parent. Exchanging a node alters its label. All these editing
operations are illustrated in Figure 1 (Bille, 2005).

(a)

l1

l2

(b)

l1

l1

l2

(b)

l1

l1
l2

Figure 1: (a) Relabeling the node label (l1 ‚Üí l2 ). (b) Deleting the node labeled (l2 ‚Üí ‚àß).
(c) Inserting a node labeled l2 as the child of the node labeled l1 (‚àß ‚Üí l2 ).

Each operation is associated with a cost and is allowed on single nodes only. Selecting
a good set of costs for these operations is hard when dealing with complex problems. This
3

Alabbas & Ramsay

is because alterations in these costs or choosing a different combination of them can lead to
drastic changes in tree edit distance performance (Mehdad & Magnini, 2009).
In the ZS-TED algorithm, tree nodes are compared using a postorder traversal, which
visits the nodes of a tree starting with the leftmost leaf descendant of the root and proceeding
to the leftmost descendant of the right sibling of that leaf, the right siblings, and then the
parent of the leaf and so on up the tree to the root. The last node visited will always be
the root. An example of the postorder traversal and the leftmost leaf descendant of a tree is
shown in Figure 2. In this figure, there are two trees, T1 with m=7 nodes and T2 with n=7
nodes. The subscript for each node is considered the order of this node in the postorder
of the tree. So, the postorder of T1 is e,f,b,g,c,d,a and the postorder for T2 is g,c,y,z,x,d,a.
The leftmost leaf descendant of the subtrees of T1 headed by the nodes e,f,b,g,c,d,a are
1,2,1,4,4,6,1 respectively, and similarly the leftmost leaf descendants of g,c,y,z,x,d,a in T2
are 1,1,3,4,3,3,1.
a7

a7
c5

b3
e1

f2

d6

g4

c2

d6

g1

x5
y3

T1

z4

T2

Figure 2: Two trees T1 and T2 with their postorder traversal.
For all the descendants of each node, the least cost mapping has to be calculated before
the node is encountered, in order that the least cost mapping can be selected right away.
To achieve this, the algorithm pursues the keyroots of the tree, which are defined as a
set that contains the root of the tree plus all nodes having a left sibling. Concentrating
on the keyroots is critical to the dynamic nature of the algorithm, since it is the subtrees
rooted at keyroots that allow the problem to be split into independent subproblems of the
same general kind. The keyroots of a tree are decided in advance, permitting the algorithm
to distinguish between tree distance (the distance between two nodes when considered in
the context of their left siblings in the trees T1 and T2 ) and forest distance (the distance
between two nodes considered separately from their siblings and ancestors but not from
their descendants) (Kouylekov, 2006). For illustration, the keyroots in each tree in Figure 2
are marked in bold.
For each node, the computation to find the least cost mapping (the tree distance) between
a node in the first tree and one in the second depends solely on mapping the nodes and their
children. To find the least cost mapping of a node, then, one needs to recognise the least cost
mapping from all the keyroots among its children, plus the cost of its leftmost child. Because
the nodes are numbered according to the postorder traversal, the algorithm proceeds in the
following steps (Kouylekov, 2006): (i) the mappings from all leaf keyroots are determined;
(ii) the mappings for all keyroots at the next higher level are decided recursively; and (iii)
the root mapping is found. Algorithm 1 shows the pseudocode of ZS-TED algorithm (Zhang
& Shasha, 1989). The matrices D and F D are used for recording the results of individual
4

Natural Language Inference for Arabic

subproblems: D is used to store the tree distance between trees rooted at pairs of nodes
in the two trees, and F D is used to store the ‚Äòforest distance‚Äô between sequences of nodes.
F D is used as a temporary store while the tree edit distance between pairs of keyroots
are being calculated. We have extended the standard algorithm, which computes the cost
of the cheapest edit sequence, so that it also records the edit operations themselves. This
involves adding two new matrices, DPATH and FDPATH, to hold the appropriate sequences
of edit operations‚ÄìDPATH to hold the edit sequences for trees rooted at pairs of nodes and
FDPATH to hold the edit sequences for forests. D and DPATH are permanent arrays,
whereas F D and FDPATH are reinitialised for each pair of keyroots.
The algorithm iterates over keyroots, and is split into two main stages for each pair of
keyroots: the initialisation phase (lines 3‚Äì12) deals with the first row and column, where we
assume that every cell in the first row is reached by appending the insert operation ‚Äúi‚Äù to the
cell to its left and every cell in the first column is reached by appending the delete operation
‚Äúd‚Äù to the cell above it, with appropriate costs. This is exactly parallel to the initialisation of
the standard dynamic time warping algorithm for calculating string edit distance, as though
we were treating the task of matching the subsets of the subtrees rooted at T1 [x] and T2 [y]
as a string matching problem between the nodes in these two trees as sequences enumerated
in post-order.
The second stage (lines 13‚Äì37) traces the cost and edit sequence for transforming each
sub-sequence of the sequence of nodes dominated T1 [x] to each sub-sequence of the sequence
of nodes dominated T2 [x], by considering whether the nodes in these were reached from the
cell to the left by an insert, or from the cell above by a delete, or by the cell diagonally above
and left by either a match ‚Äúm‚Äù or an exchange ‚Äúx.‚Äù There are two cases to be considered
here:
i If the two sequences under consideration are both trees (tested at line 15), then we know
that we have considered every possible way of exchanging one into the other, and hence
we can record the cost in both F D and D, and the edit sequence in both FDPATH and
DPATH. In this case, we calculate the cost of moving along the diagonal by inspection
of the two nodes. See Figure 3 for an illustration of this notion.
ii If one or both of the sequences is a forest we retrieve the cost of moving along the diagonal
from DPATH, and we just store the cost in F D and the edit sequence in FDPATH.
In both cases, we gather the set of {cost, path} pairs that result from considering insert/delete/exchange operations on the preceding sub-sequences, and choose the best such
pair to store in the various arrays. This is again very similar to the corresponding element
of the string edit algorithm, with the added complication that calculating the tree edit costs
and sequences for a pair of keyroots involves calculating the costs and edit sequences for all
pairs of sub-sequences of the nodes below those roots. The results for pairs of keyroots are
stored permanently, and are utilised during the calculations for sub-sequences at the next
stage.
Bille (2005) provides detailed worked examples of the calculation of the costs of transforming one tree into another. Figure 4 shows how FDPATH grows as the algorithm iterates
through the keyroots for the trees T1 and T2 in Figure 2. In this figure, the cells representing
5

Alabbas & Ramsay

Algorithm 1 pseudocode for Zhang-Shasha‚Äôs TED algorithm with edit sequences
T [i, j]
ith to jth nodes in the post-order enumeration of tree T (T [i, i] is written T [i])
l(i)
the leftmost leaf descendant of the subtree rooted at i
K(T )
the keyroots of tree T, K(T ) = {k ‚àà T : ¬¨‚àÉk1 > k with l(k1 ) = l(k)}
D[i, j]
the tree distance between two nodes T1 [i] and T2 [j]
F D[T1 [i, i1 ], T2 [j, j1 ]]
the forest distance from nodes i to i1 in T1 to nodes j to j1 in T2
DP AT H[i, j]
edit sequence for trees rooted at two nodes T1 [i] and T2 [j]
F DAT H[T1 [i, i1 ], T2 [j, j1 ]] edit sequence for forests covered by nodes i to i1 in T1 to nodes j to j1 in T2
Œ≥(T1 [i] ‚àí‚Üí ‚àß)
cost of deleting the ith node from T1
Œ≥(‚àß ‚àí‚Üí T2 [j])
cost of inserting the jth node of T2 into T1
Œ≥(T1 [i] ‚àí‚Üí T2 [j])
cost of exchanging the ith node of T1 with the jth node of T2
m, n
the number of nodes in T1 and T2 respectively
best
choose the best cost and path from a set of options
1: for x ‚Üê 1 to |K1 (T1 )| do
2:
for y ‚Üê 1 to |K2 (T2 )| do
3:
F D[‚àÖ, ‚àÖ] ‚Üê 0
4:
F DP AT H[‚àÖ, ‚àÖ] ‚Üê ‚Äú ‚Äù
5:
for i ‚Üê l1 (x) to x do
6:
F D[T1 [l1 (x), i], ‚àÖ] ‚Üê F D[T1 [l1 (x), i-1], ‚àÖ] + Œ≥(T1 [i] ‚àí‚Üí ‚àß)
7:
F DP AT H[T1 [l1 (x), i], ‚àÖ] ‚Üê F DP AT H[T1 [l1 (x), i-1], ‚àÖ] + ‚Äúd‚Äù
8:
end for
9:
for j ‚Üê l2 (y) to y do
10:
F D[‚àÖ, T2 [l2 (y), j]] ‚Üê F D[‚àÖ, T2 [l2 (y), y-1]] + Œ≥(‚àß ‚àí‚Üí T2 [j])
11:
F DP AT H[‚àÖ, T2 [l2 (y), j]] ‚Üê F DP AT H[‚àÖ, T2 [l2 (y), y-1]] + ‚Äúi‚Äù
12:
end for
13:
for i ‚Üê l1 (x) to x do
14:
for j ‚Üê l2 (y) to y do
15:
if (l1 (i) == l1 (x) and l2 (j) == l2 (y)) then
16:
cost, path ‚Üê best({F D[T1 [l1 (x), i-1], T2 [l2 (y), j]] + Œ≥(T1 [i] ‚àí‚Üí ‚àß),
17:
F DP AT H[T1 [l1 (x), i-1], T2 [l2 (y), j]] + ‚Äúd‚Äù},
18:
{F D[T1 [l1 (x), i], T2 [l2 (y), j-1]] + Œ≥(‚àß ‚àí‚Üí T2 [j]),
19:
F DP AT H[T1 [l1 (x), i], T2 [l2 (y), j-1]] + ‚Äúi‚Äù},
20:
{F D[T1 [l1 (x), i-1], T2 [l2 (y), j-1]] + Œ≥(T1 [i] ‚àí‚Üí T2 [j])),
21:
F DP AT H[T1 [l1 (x), i-1], T2 [l2 (y), j-1]] + ‚Äúm‚Äù/‚Äúx‚Äù})
22:
F D[T1 [l1 (x), i], T2 [l2 (y), j]] ‚Üê cost
23:
D[i, j] ‚Üê cost
24:
F DP AT H[T1 [l1 (x), i], T2 [l2 (y), j]] ‚Üê path
25:
DP AT H[i, j] ‚Üê path
26:
else
27:
cost, path ‚Üê best({F D[T1 [l1 (x), i-1], T2 [l2 (y), j]] + Œ≥(T1 [i] ‚àí‚Üí ‚àß),
28:
F DP AT H[T1 [l1 (x), i-1], T2 [l2 (y), j]] + ‚Äúd‚Äù},
29:
{F D[T1 [l1 (x), i], T2 [l2 (y), j-1]] + Œ≥(‚àß ‚àí‚Üí T2 [j]),
30:
F DP AT H[T1 [l1 (x), i], T2 [l2 (y), j-1]] + ‚Äúi‚Äù},
31:
{F D[T1 [l1 (x), i-1], T2 [l2 (y), j-1]] + D[i, j]),
32:
F DP AT H[T1 [l1 (x), i-1], T2 [l2 (y), j-1]] + DP AT H[i][j]})
33:
F D[T1 [l1 (x), i], T2 [l1 (y), j]] ‚Üê cost
34:
F DP AT H[T1 [l1 (x), i], T2 [l1 (y), j]] ‚Üê path
35:
end if
36:
end for
37:
end for
38:
end for
39: end for
40: return D[n, m], DP AT H[n, m]

6

Natural Language Inference for Arabic

i-1,j-1

i,j-1

i-1,j
x/m

d

i

i,j

Figure 3: The edit operation direction used in our algorithm. Each arc that implies an edit
operation is labeled: ‚Äúi‚Äù for an insertion, ‚Äúd‚Äù for deletion, ‚Äúx‚Äù for exchanging and
‚Äúm‚Äù for no operation (matching).

the optimal sequence of edit operations that transform T1 into T2 are highlighted in bold,
with the final optimal path shown in the last cell (at final row and column).
T1
e
f
b
g
c
d
a

T2
d
dd
ddd
dddd
ddddd
dddddd
ddddddd

g
i
x
xd
xdd
dddm
dddmd
dddmdd
dddmddd

c
ii
xi
xid
xdx
dddmi
dddmm
dddmmd
dddmmdd

y
iii
iix
xix
xdxi
xdxx
dddmmi
dddmmx
dddmmxd

z
iiii
iiix
iixx
iixxd
xdxxi
dddmmii
dddmmxi
dddmmxid

x
iiiii
iiixi
xiiix
iixxx
xdxixi
dddmmiii
dddmmxii
dddmmxiid

d
iiiiii
iiixii
xiiiix
iixxxi
xdxixii
xdxixix
dddmmiiim
dddmmiiimd

a
iiiiiii
iiixiii
xiiiixi
iixxxii
iixxxiid
xdxixixi
dddmmiiimi
dddmmiiimm

FDPATH

Figure 4: Computing the optimal path for the trees in Figure 2.
The mapping between two trees can be found from the final sequence of edit operations
by mapping the nodes corresponding to match operation ‚Äúm‚Äù only.
The final distance is 6 which represents the final values (at final row and column) in D.2
The last value in DPATH represents the final sequence of edit operations, namely dddmmiiimm. According to this path, we can define an alignment between two postorder trees.
The alignment between two trees T1 and T2 is obtained by inserting a gap symbol (i.e. ‚Äú_‚Äù)
into either T1 or T2 , according to the type of edit operation, so that the resulting strings S 1
and S 2 are the same length as the sequence of edit operations. The gap symbol is inserted
into S 2 when the edit operation is delete (‚Äúd‚Äù), whereas it is inserted in S 1 when the edit
operation is insert (‚Äúi‚Äù). Otherwise, the nodes of T1 and T2 are inserted into S 1 and S 2
respectively. The following is an optimal alignment between T1 and T2 :
S 1:
S 2:

e
d
_

f
d
_

b
d
_

g
m
g

c
m
c

_
i
y

_
i
z

_
i
x

d
m
d

a
m
a

2. For simplicity here, we assume that the each single operation will cost 1 except that matching will cost
0, as described by Zhang and Shasha (1989).

7

Alabbas & Ramsay

This means:
d:
d:
d:
m:
m:
i:
i:
i:
m:
m:

Delete (e) from T1
Delete (f ) from T1
Delete (b) from T1
Leave (g) without change
Leave (c) without change
Insert (y) into T1
Insert (z ) into T1
Insert (x ) into T1
Leave (d) without change
Leave (a) without change

The final mapping between T1 and T2 is shown in Figure 5. For each mapping figure
the insertion, deletion, matching and exchanging operations are shown with single, double,
single dashed and double dashed outline respectively. The matching nodes (or subtrees) are
linked with dashed arrows.

a7
c5

b3
e1

f2

a7
d6

g4

c2

d6

g1

x5
y3

T1

z4

T2

Figure 5: ZS-TED, mapping between T1 and T2 .

3. Extended TED with Subtree Operations
The main weakness of the ZS-TED algorithm is that it is not able to perform transformations
on subtrees (i.e. delete subtree, insert subtree and exchange subtree). The output of ZSTED is the lowest cost sequence of operations on single nodes. We extend this to find the
lowest cost sequence of operations on nodes and subtrees, TED+ST, as follows:
1. Run ZS-TED and compute the standard alignment from the results (Algorithm 1);
2. Go over the alignment and group subtree operations. Where a sequence of identical
operations applies to a set of nodes comprising a subtree, they are replaced by a
8

Natural Language Inference for Arabic

single operation, whose cost is determined by some appropriate function of the costs
of the individual nodes (Algorithm 2). A variety of functions could be applied here,
depending on the application. When using the algorithm for textual entailment we
use the costs in Figure 8, which are derived from those used by Punyakanok, Roth,
and Yih (2004), but for illustration in the current section we will simply take the cost
of a subtree operation to be half the sum of the costs of the individual operations that
make it up.
It should be noted here that while we apply this technique to modify Zhang-Shasha‚Äôs
O(n4 ) algorithm, it could also be applied to any other algorithm for finding tree edit distance,
e.g. Klein‚Äôs O(n3 logn ) algorithm (Klein, 1998), Demaine et al. O(n3 ) algorithm (Demaine,
Mozes, Rossman, & Weimann, 2009) or Pawlik and Augsten O(n3 ) algorithm (Pawlik &
Augsten, 2011), since the extension operates on the output of the original algorithm. The
additional time cost of O(n2 ) is negligible since it is less than the time cost for any available
tree edit distance algorithm.
3.1 Find a Sequence of Subtree Edit Operations
Extending ZS-TED to cover subtree operations will give us more flexibility when comparing
trees (especially linguistic trees). The key to this algorithm is that we have to find maximal
sequences of identical edit operations which correspond to subtrees. A sequence of nodes
in postorder corresponds to a subtree if the following conditions are satisfied: (i) the first
node is a leaf; and (ii) the leftmost sibling of the last node in the sequence (i.e. the root
of a subtree) is the same as the first node in the sequence. These two conditions can be
checked in constant time, since the leftmost sibling of a node can determined for each node
in advance. We can hence find maximal sequences corresponding to subtrees by scanning
forwards through the sequence of node operations to find sequences of identical operations,
and then scanning backwards through such a sequence until we find the point at which it
covers a subtree. This involves potentially O(n2 ) steps‚Äìn forward steps to find sequences of
identical operations, and then possibly n-1 backward steps each time to find sub-sequences
corresponding to subtrees. As an example, the sequence of nodes e,f,b in tree T1 in Figure 2
is a subtree because e is a leaf and the leftmost of the last node b is 1, which represents
the first node e. On the other hand, the sequence of nodes g,c,d in the same tree is not a
subtree because g is a leaf, but the leftmost of the last node d is 6, which represents itself,
not the first node g.
Algorithm 2 contains the pseudocode to find the optimal sequence of single and subtree
edit operations for transforming T1 into T2 . Ep=1..L ‚àà {‚Äúd‚Äù, ‚Äúi‚Äù, ‚Äúx‚Äù, ‚Äúm‚Äù} in this algorithm
is an optimal sequence of node edits for transforming T1 into T2 , obtained by applying the
technique in Section 2, and S 1 and S 2 are the alignments for T1 and T2 obtained after
applying this sequence of node edits.
As shown in Algorithm 2, to find the optimal single and subtree edit operations sequence
that transforms T1 into T2 , each maximal sequence of identical operations is checked to see
whether it contains subtree(s) or not. Checking whether such a sequence corresponds to a
subtree depends on the type of edit operation, according to the following rules: (i) if the
operation is ‚Äúd,‚Äù the sequence is checked on the first tree; (ii) if the operation is ‚Äúi,‚Äù the
sequence is checked on the second tree; and (iii) otherwise, the sequence is checked on both
9

Alabbas & Ramsay

Algorithm 2 pseudocode to find subtree edit operations
E
L
S1, S2

the sequence of edit operations that transform tree T1 into tree T2 , Ep=1..L ‚àà {‚Äúd‚Äù,‚Äúi‚Äù,‚Äúx‚Äù,‚Äúm‚Äù}
the length of the sequence of edit operations E
the optimal alignment for T1 and T2 respectively, when the length of S 1 = S 2 = L

1: repeat
2:
ERoot ‚Üê EL
3:
F ‚ÜêL
4:
repeat
5:
while (F ‚â• 2 and EF ‚àí1 == ERoot) do
6:
F ‚ÜêF ‚àí1
7:
end while
8:
if (F == L) then
9:
L‚ÜêL‚àí1
10:
ERoot ‚Üê EL
11:
F ‚ÜêL
12:
end if
13:
until (F < L and F ‚â• 2 and EF ‚àí1 )= ERoot) or (L = 0)
14:
F0 ‚Üê F
15:
while (F < L) do
16:
while (F < L) do
17:
IsSubtree ‚Üê true
18:
while (F < L and IsSubtree) do
1
19:
if (ERoot =‚Äúd‚Äù and SF1 ..SL
is subtree) or
2
2
20:
(ERoot =‚Äúi‚Äù and SF ..SL is subtree) or
1
2
21:
((ERoot in {‚Äúx‚Äù,‚Äúm‚Äù}) and (SF1 ..SL
and SF2 ..SL
are subtrees)) then
22:
Replace EF ..EL‚àí1 with ‚Äú+‚Äù
23:
L‚ÜêF ‚àí1
24:
F ‚Üê F0
25:
else
26:
IsSubtree ‚Üê f alse
27:
end if
28:
end while
29:
F ‚ÜêF +1
30:
end while
31:
L‚Üê L‚àí1
32:
F ‚Üê F0
33:
end while
34:
L ‚Üê F0 ‚àí 1
35: until (L ‚â§ 0)
36: return E

trees. After that, if the sequence of operations corresponds to a subtree, then all the symbols
of the sequence are replaced by ‚Äú+‚Äù except the last one (which represents the root of the
subtree). Otherwise, checking starts from a sub-sequence of the original, as explained below.
For instance, let us consider Eh , ..., Et , where 1 ‚â§ h < L, 1 < t ‚â§ L, h < t, is a sequence of
the same edit operation, i.e. Ek=h..t ‚àà {‚Äúd‚Äù, ‚Äúi‚Äù, ‚Äúx‚Äù, ‚Äúm‚Äù}. Let us consider h0 = h, we firstly
check nodes Sh1 , ..., St1 and Sh2 , ..., St2 to see whether or not they are the heads of subtrees. If
Ek is ‚Äúd,‚Äù the nodes Sh1 , ..., St1 are checked, if it is ‚Äúi‚Äù the nodes Sh2 , ..., St2 are checked, and
otherwise, the nodes Sh1 , ..., St1 and Sh2 , ..., St2 are checked. All edit operations Eh , ..., Et‚àí1
are replaced by ‚Äú+‚Äù when this sequence corresponds to a subtree. Then, we start checking
from the beginning of another sequence from the left of the subtree Eh , ..., Et , i.e. t = h ‚àí 1.
10

Natural Language Inference for Arabic

Otherwise, the checking is applied with the sequence starting from the next position, i.e.
h = h+ 1. The checking is continued until h = t. After that, when the (t ‚àí h) sequences that
start with different positions and end with t position do not contain a subtree, the checking
starts from the beginning with the new sequence, i.e. h = h0 and t = t ‚àí 1. The process is
repeated until h = t.
To explain how the subtree operations are applied, let us consider the two trees T1 and
T2 in Figure 2.
According to TED+ST, the cost is 3 and the sequence of operation is as follows: there
is a sequence of ‚Äúd,‚Äù ‚Äúm‚Äù and ‚Äúi‚Äù in the result. These sequences consist of three subtrees
(i.e. the three deleted nodes, the first two matched nodes and the three inserted nodes):
ddd mm iii mm. So, the final result is: ++d +m ++i mm. This means:
++d:
+m:
++i:
m:
m:

Delete subtree (e,f,b) from T1
Leave subtree (g,c) without change
Insert subtree (y,z,x ) into T1
Leave (d) without change
Leave (a) without change

The final mapping between T1 and T2 obtained using TED+ST is shown in Figure 6.

a7
c5

b3
e1

f2

a7
d6

g4

c2

d6

g1

x5
y3

T1

z4

T2

Figure 6: TED+ST, mapping between T1 and T2 .

4. Matching Dependency Trees
As mentioned above, our main goal is to design a textual entailment (TE) system for Arabic
to check whether one text snippet (i.e. premise p) entails another text (i.e. hypothesis h).
To match p and h dependency tree pairs effectively, we use TED+ST. This enables us to
find the minimum edit operations to transform one tree to another. This allows us to be
sensitive to the fact that the links in a dependency tree carry linguistic information about
relations between complex units, and hence to ensure that we are paying attention to these
relations when we compare two trees. For instance, this enables us to pay attention to the
11

Alabbas & Ramsay

fact that operations involving modifiers, in particular, should be applied to the subtree as
a whole rather than to its individual elements. Thus, we transform tree D1 to tree D2 in
Figure 7 by deleting ‚Äúin the park‚Äù in a single operation, removing the modifier as a whole,
rather than three operations removing ‚Äúin,‚Äù ‚Äúthe‚Äù and ‚Äúpark‚Äù one by one, using the costs
in Figure 8 as an initial test for edit operations in our experiments. These costs are an
updated version of the costs used by Punyakanok et al. (2004).3 These authors found that
using tree edit distance gives better results than bag-of-word scoring methods, when they
applied them for question answering.4
saw

saw
I

I

man

in

the

park

man
the

the
D1

D2

Figure 7: Two dependency trees, D1 and D2 .

By using the costs in Figure 8, the cost of transferring D1 into D2 according to ZS-TED
is 19 (i.e. one stop word ‚Äúthe‚Äù (5) and two words (14)), whereas according to TED+ST
operations it is 0. Therefore, it is easy to decide that D1 entails D2 , whereas the reverse is not
true. We also exploited the subset/superset relations encoded by Arabic WordNet (AWN)
(Black, Elkateb, Rodriguez, Alkhalifa, Vossen, Pease, & Fellbaum, 2006) when comparing
items in a tree. Roughly speaking, if comparing one tree to another requires us to swap
two lexical items, we will be happier doing so if the item in the source tree is a synonym or
hyponym of the one in the target tree‚Äìsince ‚Äúwombat‚Äù is a hyponym of ‚Äúanimal,‚Äù swapping
‚Äúwombat‚Äù in a premise such as ‚ÄúI saw a wombat at the zoo‚Äù for ‚Äúanimal‚Äù in ‚ÄúI saw an animal
at the zoo‚Äù is a truth-preserving exchange.
Approaches that make use of lexical relations of this kind have to cope with the fact that
words often have multiple meanings. We follow Hobbs (2005) in assuming that if W1 has a
sense which is a hyponym of some sense of W2 then a sentence involving W1 will entail a
similar sentence involving W2 as shown in (1).
(1) p.
h.

I saw a peach at yesterday‚Äôs party.
I saw a very attractive woman at yesterday‚Äôs party.

3. The stop words here are a list that contains some of the most common Arabic words (e.g. the particle
( +,- ./0# "#! $ AÃån Almdyr m≈°Œ≥wl ‚Äú The director is indeed busy‚Äù
"#! $ AÃån ‚Äúindeed‚Äù). For instance, %&'! )*
( +,- ./0# Almdyr m≈°Œ≥wl ‚Äú The director is busy.‚Äù
entails %&'! )*
4. The transcription of Arabic examples in this document follows Habash-Soudi-Buckwalter (HSB) transliteration scheme (Habash, Soudi, & Buckwalter, 2007) for transcribing Arabic symbols.

12

Natural Language Inference for Arabic

Cost

Single node

Subtree (more than one node)

Delete:

if X is a stop word then cost is 5,
else cost is 7
if a Y is a stop word then cost is
5,
else cost is 100
if X is subsumed by Y cost is 0,
elseif X is a stop word cost is 5,
elseif Y is subsumed by (or is an
antonym of) a X then cost is 100
else cost is 50

0

Insert:

Exchange:

double the sum of the costs of its parts

if S1 is identical to S2 then cost is 0
else half the sum of the costs of its parts

Figure 8: Edit operation costs.
In (1p), for instance, the word ‚Äúpeach‚Äù is ambiguous,5 ‚Äúa shade of pink tinged with yellow‚Äù
(hypernym: Pink) or ‚ÄúDowny juicy fruit with sweet yellowish or whitish flesh‚Äù (hypernym:
Drupe, edible fruit, stone fruit) or ‚Äúa very attractive or seductive looking woman‚Äù (hypernym:
Adult female, women) or ‚Äúcultivated in temperate regions‚Äù (hypernym: Fruit tree). In the
context of (1h), however, any human reader would assume that the second interpretation of
‚Äúpeach‚Äù was intended, despite the fact that it is in general a fairly unusual usage.
This reflects the widely accepted view that contextual information is the key to lexical
disambiguation. Within the RTE task, the premise provides the context for disambiguation
of the hypothesis, and the hypothesis provides the context for disambiguation of the premise.
Almost any human reader would, for instance, accept that (2p) entails (2h), despite the
potential ambiguity of the word ‚Äúbank.‚Äù
(2) p.
h.

My money is all tied up at the bank.
I cannot easily spend my money.

5. Dataset Preparation
In order to train and test our TE system for Arabic, we need an appropriate dataset. To
our knowledge, no such datasets are available for Arabic, so we have had to develop one.
We have followed one of the procedures used for collecting the premise-hypothesis pairs in
the RTE tasks, with a slight alteration. The premises in RTE were collected from a variety
of sources, e.g. newswire text. They contain one or two sentences and tend to be fairly long
(e.g. averaging 25 words in RTE1, 28 words in RTE2, 30 words in RTE3 and 39 words in
RTE4). In contrast, the hypotheses are quite short single sentences (averaging 11 words in
RTE1, 8 words in RTE2 and 7 words in RTE3 and RTE4), which were manually constructed
for each premise. The first three RTE Challenges were presented as a binary classification
task ‚Äòyes‚Äô or ‚Äòno‚Äô with balanced numbers of ‚Äòyes‚Äô and ‚Äòno‚Äô problems. Beginning with RTE4,
there were three-way classifications (‚Äòyes,‚Äô ‚Äòno,‚Äô or ‚Äòcontradict,‚Äô to distinguish cases in which
h contradicts p from those in which h is compatible with, but not entailed by p). In our
5. See Sage‚Äôs dictionary online: http://www.sequencepublishing.com/thesageonline.php. WordNet also
provides all these senses (and more) for ‚Äúpeach.‚Äù

13

Alabbas & Ramsay

dataset, we do not want to produce a set of p-h pairs by hand‚Äìpartly because doing so is a
lengthy and tedious process, but more importantly because hand-coded datasets are liable
to embody biases introduced by the developer. If the dataset is used for training the system,
then the rules that are extracted will be little more than an unfolding of information explicitly
supplied by the developers. If it is used for testing then it will only test the examples that
the developers have chosen, which are likely to be biased, albeit unwittingly, towards the
way they think about the problem.
Our set of Arabic p-h pairs for the TE task was created by a semi-automatic technique
through two stages. The first stage (Section 5.1) is responsible for automatically collecting
p-h pairs from news websites, while the second stage (Section 5.2) uses an online annotation
system that allows annotators to annotate our collected pairs manually. Both stages are
explained in detail below.
5.1 Collecting p-h Pairs
We collected candidate p-h pairs automatically by the so-called headline-lead paragraph
technique (Burger & Ferro, 2005) from the web (e.g. from newspaper corpora, pairing the
first paragraph of article, as p, with its headline, as h). This is based on the observation
that a news article‚Äôs headline is very often a partial paraphrase of the first paragraph of this
article, conveying thus a comparable meaning. We use an updated version of the headlinelead paragraph strategy to improve the quality of the p-h pair.
The key idea here is that we pose queries to a search engine and automatically filter the
responses for text snippets that might entail the query. These pairs are then manually annotated for entailment/non-entailment, but the texts themselves are automatically collected
from freely occurring natural texts. This eliminates the possibility (indeed likelihood) of
unconscious bias that is introduced if the hypotheses are manually generated.
We built a corpus of p-h pairs by using headlines from the websites of Arabic newspapers
and TV channels as queries to be input to Google via the standard Google API, and then
selecting the first paragraph, which usually represents the most related text snippet(s) in
the article with the headline (Burger & Ferro, 2005), of each of the first 10 returned pages.
This technique produces a large number of potential pairs without any bias in either the
premises or the hypotheses. To improve the quality of the pairs that resulted from the query,
we use two conditions to filter the results: (i) the length of a headline must be at least five
words, to avoid very small headlines; and (ii) fewer than 80% of the words in the headline
should appear in the premise, to avoid having very similar sentences.
The problem here is that if p and h are very similar then there would be very little to
learn from them if they were used in the training phase of a TE system; and they would
be almost worthless as a test pair‚Äìvirtually any TE system will get such a pair right, so
they will not serve as a discriminatory test pair. We therefore eliminate excessively similar
p-h pairs from both training and testing, which we assess in terms of the number of shared
uncommon words.
In order to overcome this problem, we matched headlines from one source with stories
from another. Major stories are typically covered by a range of outlets, usually with variations in emphasis or wording. Stories from different sources can be linked by looking for
common words in the headlines‚Äìit is unlikely that there will be two stories about, for in14

Natural Language Inference for Arabic

stance, neanderthals in the news at the same time, so very straightforward matching based
on low frequency words and proper names is likely to find articles about the same topic.
The terminology and structure of the first text snippets of these articles, however, are likely
to be quite different. Thus using a headline from one source and the first text snippet from
an article about the same story but from another source is likely to produce p-h pairs which
are not unduly similar. We can therefore link a headline from one newspaper with related
sentences from another.
5.2 Annotating p-h Pairs
The pairs that are collected in the first stage still have to be marked-up by human annotators,
but at least the process of collecting them is as nearly bias-free as possible. These pairs cover
a number of subjects such as politics, business, sport and general news. The annotation is
performed by eight expert and non-expert human annotators to identify the different pairs as
positive entailment examples ‚Äòyes,‚Äô where p is judged to entails h, and as negative examples
‚Äòno,‚Äô where entailment does not hold. Those annotators follow nearly the same annotation
guidelines as those used for building the RTE task dataset (Dagan, Glickman, & Magnini,
2006).
Each pair was annotated by three annotators. The inter-annotator agreement (where all
annotators agree) is around 74% compared with 89% where each annotator agrees with at
least one co-annotator. This suggests that the annotators found this is a difficult task. The
fact that there was only 74% agreement when the annotations produced by three independent
annotators are taken into account sets an upper bound on what it is reasonable to expect of
an automatic system for carrying out this task. If human annotators can only agree in about
three quarters of the cases, then it is unlikely that a computer-based system can achieve
much more than 75% agreement with any given pair of annotators.6

6. Experiments
To check the effectiveness of TED+ST, we used it to check the entailment between p-h
Arabic pairs of text snippets and compared its results with two string-based approaches
(bag-of-words and Levenshtein distance) and ZS-TED on the same set of pairs. Checking
whether one Arabic text snippet entails another, however, is particularly challenging because
Arabic is more ambiguous than most languages, such as English. For instance, Arabic is
written without diacritics (short vowels), often leading to multiple ambiguities. This makes
morphological analysis very difficult (i.e. a single written form may easily correspond to as
many as ten different lexemes, see Alabbas & Ramsay, 2011a, 2011b, 2012a, 2012c). The
preliminary testing dataset contains 600 pairs, binary annotated as ‚Äòyes‚Äô and ‚Äòno‚Äô (a 50-50
split) using the technique explained in Section 5. The distribution of these pairs over p length
is summarised in Table 1, when the h average length is around 10 words and the average of
common words between p and h is around 4 words. The average length of sentence in this
dataset is 25 words per sentence, with some sentences containing 40+ words.
6. The dataset, including the dependency-tree analysis in CoNLL format, is available in the online appendices to this article or from http://www.cs.man.ac.uk/~ramsay/ArabicTE/

15

Alabbas & Ramsay

p‚Äôs length
<20
20-29
30-39
>39
Total

#pairs
175
329
87
9
600

yes
83
171
43
3
300

no
92
158
44
6
300

Table 1: Distribution of sentence lengths in the testset.

In order to check the entailment between p-h pairs, we follow three steps. First, each
sentence is preprocessed by a tagger and a parser in order to convert both elements of the p-h
pair to dependency trees. A dependency tree is a tree where words are vertices and syntactic
relations are dependency relations. Each vertex therefore has a single parent, except the
root of the tree. A dependency relation holds between a dependent, i.e. a syntactically
subordinate vertex, and a head, i.e. another vertex on which it is dependent. Thus the
dependency structure is represented as a head-dependent relation between vertices that are
classified by dependency types such as SBJ ‚Äúsubject,‚Äù OBJ ‚Äúobject,‚Äù ATT ‚Äúattribute,‚Äù etc.
We have carried out a number of experiments with state-of-the-art taggers such as
AMIRA (Diab, 2009), MADA (Habash, Rambow, & Roth, 2009) and an in-house maximumlikelihood (MXL) tagger (Ramsay & Sabtan, 2009) and parsers such as MALTParser (Nivre,
Hall, Nilsson, Chanev, Eryigit, K√ºbler, Marinov, & Marsi, 2007) and MSTParser (McDonald, Lerman, & Pereira, 2006).7 These experiments show in particular that merging MADA
(97% accuracy) with MSTParser gives better results (around 81% for labelled accuracy)
than the other tagger:parser combinations (Alabbas & Ramsay, 2012b). We therefore use
MADA+MSTParser in the current experiments.
After converting p-h pairs to dependency trees, we matched these dependency trees using
the ZS-TED and TED+ST algorithms, with two string-based algorithms (bag-of-words and
Levenshtein distance) to provide a baseline. The tree edit distance algorithms used the edit
operation costs defined in Figure 8 to find the cost of matching between p-h pairs. The
bag-of-words here measures the similarity between p and h as a number of common words
between them (either in surface forms or lemma forms), divided by the length of h. For all
four algorithms we use AWN as a lexical resource in order to take account of synonymy and
hyponymy relations when calculating the cost of an edit.
We carried out two kinds of experiments using these algorithms: the first was a simple
yes/no experiment, using a single threshold to decide whether the premise was similar enough
to the hypothesis for it to be safe to say that it entailed it, and the second with two thresholds
so that we could say yes/don‚Äôt know/no. The results of these experiments are given below.

7. These parsers are data-driven dependency parsers. For Arabic they are usually trained on an Arabic
dependency treebank, such as Prague Arabic Dependency Treebank (PADT) (Smr≈æ, Bielicky, Kou≈ôilov√°,
Kr√°ƒçmar, Hajiƒç, & Zem√°nek, 2008), or on some version of the Penn Arabic Treebank (PATB) (Maamouri
& Bies, 2004) that has been converted to dependency trees: scoring of such parsers is a matter of counting
dependency links.

16

Natural Language Inference for Arabic

6.1 Binary Decision (‚Äòyes‚Äô and ‚Äòno‚Äô)
p entails h when the cost of matching is less (more in case of bag-of-words) than a threshold.
The results of these experiments, in terms of precision (P), recall (R) and F-score (F) for
‚Äòyes‚Äô class and overall accuracy, are shown in Table 2. This table shows the substantial
improvement obtained by using TED+ST over the bag-of-words (F-score for TED+ST is
around 1.16 times the F-score for bag-of-words, and accuracy is about 1.09 times better)
and ZS-TED (around 1.06 times better in F-score and 1.04 times better in total accuracy).
Method
Bag-of-words
Levenshtein distance
ZS-TED
TED+ST

Pyes
63.5%
64.7%
65.9%
69.7%

Ryes
43.7%
44.1%
51.2%
54.5%

Fyes
0.518
0.525
0.576
0.612

Accuracy
59.3%
60.2%
62.5%
65.5%

Table 2: Performance of TED+ST compared with the string-based algorithms and ZS-TED,
binary decision.
Although we are primarily interested in Arabic, we have carried out parallel sets of experiments on the English RTE2 testset, using the Princeton English WordNet (PWN) as a
resource for deciding whether a word in the premise may be exchanged for one in the hypothesis. Because the tree edit distance algorithms work with dependency tree analyses of the input texts, we have used a set that have been analysed using Minipar (Lin, 1998), downloaded
from http://u.cs.biu.ac.il/~nlp/RTE2 Datasets/RTE2 Preprocessed Datasets.html.
The RTE2 testset contains around 800 p-h pairs, but a number of the Minipar analyses have
multiple heads and hence do not correspond to well-formed trees, and there are also a
number of cases where the segmentation algorithm that was used produces multi-word expressions. After eliminating problematic pairs of this kind we are left with 730 pairs, split
evenly between positive and negative examples. Since we are mainly concerned here with
the difference between ZS-TED and TED+ST, we have omitted the Levenshtein distance
and have simply kept the basic bag-of-words algorithm as a baseline. Previous authors
have shown that tree edit distance consistently outperforms string-based approaches on this
dataset, and there is no need to replicate that result here.
Method
Bag-of-words
ZS-TED
TED+ST

Pyes
53.2%
52.9%
53.2%

Ryes
50.1%
62.5%
66.8%

Fyes
0.516
0.573
0.59

Accuracy
52.1%
53.5%
55.8%

Table 3: Performance of TED+ST compared with the simple bag-of-words and ZS-TED,
binary decision, RTE2 dataset.
The pattern in Table 3 is similar to that in Table 2. ZS-TED is better than bag-of-words,
TED+ST is a further improvement over ZS-TED. Most experiments on textual entailment
tasks only report accuracy: in certain situations it may be more important to have decisions
that are trustworthy (high precision, as in Table 2) or to be sure that you have captured as
17

Alabbas & Ramsay

many positive examples as possible (high recall8 , as in Table 3), or to have a good balance
between these (high F-score). It is easy to change the balance between precision and recall,
simply by changing the threshold that is used for determining whether it is safe to say
that p entails h‚Äìwe could have chosen thresholds for Table 3 that increased the precision
and decreased the recall, so that the results more closely matched Table 2. The key point
here is that in both sets of experiments, the F-scores improve as we move from string-based
measures to ZS-TED and then again when we use TED+ST; and that they are remarkably
similar for the two datasets, despite the fact that they were collected by different means,
are in different languages, and are parsed using different parsers.
6.2 Making a Three-way Decision (‚Äòyes,‚Äô ‚Äòno‚Äô and ‚Äòunknown‚Äô)
For this task we use two thresholds, one to trigger a positive answer if the cost of matching is
lower than the lower threshold (exceeds the higher one for the bag-of-words algorithm) and
the other to trigger a negative answer if the cost of matching exceeds the higher one (mutatis
mutandis for bag-of-words). Otherwise, the result will be ‚Äòunknown.‚Äô The reason for making
a three-way decision is to drive systems to make more precise distinctions. Note that we
are not distinguishing here between {h entails p, h and p are compatible, h contradicts p},
but between {h entails p, I don‚Äôt know whether h entails p, h does not entail p}. This is
a more subtle distinction, reflecting the system‚Äôs confidence in its judgement, but it can be
extremely useful when deciding how to act on its decision.
The results of this experiment, in terms of precision (P), recall (R) and F-score (F),
are shown in Table 4. Again, it shows the large improvement of using TED+ST over the
bag-of-words (F-score is around 1.10 times better) and ZS-TED (F-score around 1.06 times
better).
Method
Bag-of-words
Levenshtein distance
ZS-TED
TED+ST

P
58.9%
61.4%
65.1%
67.4%

R
56.7%
58.0%
56.0%
60.2%

F
0.578
0.597
0.602
0.636

Table 4: Performance of TED+ST compared with string-based algorithms and ZS-TED,
three-way decision.
The scores for the three-way decision on the RTE2 dataset are lower than for our Arabic
dataset, but again TED+ST outperforms ZS-TED on all three measures.

7. Conclusion
We have presented here an extended version, TED+ST, of tree edit distance that solved
one of the main drawbacks of standard tree edit distance, which is that it only supports
8. This might be useful, for instance, with TED+ST being used as a low cost filter in a question-answering
system, where the results of a query to a search engine might be filtered by TED+ST before being passed
to a system employing full semantic analysis and deep reasoning, which are high precision but are also
very time-consuming.

18

Natural Language Inference for Arabic

Method
Bag-of-words
ZS-TED
TED+ST

P
50.8%
52.3%
54.3%

R
48.3%
50.2%
52.7%

F
0.495
0.512
0.535

Table 5: Performance of TED+ST compared with the simple bag-of-word and ZS-TED,
three-way decision, RTE2 dataset.

edit operations (i.e. delete, insert and exchange) on single nodes. TED+ST deals with
subtree transformation operations as well as operations on single nodes: this leads to useful
improvements over the performance of the standard algorithm for determining entailment.
The key here is that subtrees tend to correspond to single information units. By treating
operations on subtrees as less costly than the corresponding set of individual node operations,
TED+ST concentrates on entire information units, which are a more appropriate granularity
than individual words for considering entailment relations.
The current findings, while preliminary, are quite encouraging. The fact that the results
on our original testset, particularly the improvement in F-score, were replicated for a testset
where we had no control over the parser that was used to produce dependency trees from
the p-h pairs provides some evidence for the robustness of the approach. We anticipate
that in both cases having a more accurate parser (our parser for Arabic attains around 81%
accuracy on the PATB, Minipar is reported to attain about 80% on the Suzanne corpus)
would improve the performance of both ZS-TED and TED+ST.
We are currently experimenting with different scoring algorithms for ZS-TED and TED+
ST. The performance of any variant of tree edit distance depends critically on the costs for
the various operations, and on the thresholds that are used for deciding whether h entails
p, and we are therefore investigating the use of various optimisation algorithms for choosing
these weights and thresholds. We also intend to use other Arabic lexical resources, such
as OpenOffice Arabic dictionary and MS Word Arabic dictionary, to provide us with more
information about relations between words, because the information in AWN, while very
useful, is sparse in comparison to PWN (Habash, 2010).

Acknowledgments
We would like to thank the reviewers for their valuable comments, in particular the reviewer
who suggested evaluating the approach on an English dataset as well as our Arabic one.
The extra work has provided support for our belief in the robustness of the approach to a
degree that we did not anticipate.
We would like to extend our thanks to our annotators for the time and effort they have
put into annotating our experimental dataset. Maytham Alabbas owes his deepest gratitude
to Iraqi Ministry of Higher Education and Scientific Research for financial support in his
PhD study. Allan Ramsay‚Äôs contribution to this work was partially supported by the Qatar
National Research Fund (grant NPRP 09 - 046 - 6 - 001).
19

Alabbas & Ramsay

References
Alabbas, M. (2011). ArbTE: Arabic textual entailment. In Proceedings of the Second Student
Research Workshop associated with RANLP 2011, pp. 48‚Äì53, Hissar, Bulgaria. RANLP
2011 Organising Committee.
Alabbas, M., & Ramsay, A. (2011a). Evaluation of combining data-driven dependency
parsers for Arabic. In Proceeding of 5th Language & Technology Conference: Human
Language Technologies (LTC‚Äô11), pp. 546‚Äì550, Pozna≈Ñ, Poland.
Alabbas, M., & Ramsay, A. (2011b). Evaluation of dependency parsers for long Arabic
sentences. In Proceeding of International Conference on Semantic Technology and
Information Retrieval (STAIR‚Äô11), pp. 243‚Äì248, Putrajaya, Malaysia. IEEE.
Alabbas, M., & Ramsay, A. (2012a). Arabic treebank: from phrase-structure trees to dependency trees. In META-RESEARCH Workshop on Advanced Treebanking at the 8th
International Conference on Language Resources and Evaluation (LREC), pp. 61‚Äì68,
Istanbul, Turkey.
Alabbas, M., & Ramsay, A. (2012b). Combining black-box taggers and parsers for modern standard Arabic. In Federated Conference on Computer Science and Information
Systems (FedCSIS-2012), pp. 19 ‚Äì26, Wroclaw, Poland. IEEE.
Alabbas, M., & Ramsay, A. (2012c). Improved POS-tagging for Arabic by combining diverse
taggers. In Proceedings of 8th Artificial Intelligence Applications and Innovations
(AIAI), pp. 107‚Äì116, Halkidiki, Greece. Springer.
Bille, P. (2005). A survey on tree edit distance and related problems. Theoretical Computer
Science, 337 (1-3), 217‚Äì239.
Black, W., Elkateb, S., Rodriguez, H., Alkhalifa, M., Vossen, P., Pease, A., & Fellbaum, C.
(2006). Introducing the Arabic WordNet project. In Proceedings of the 3rd International WordNet Conference (GWC-06), pp. 295‚Äì299, Jeju Island, Korea.
Burger, J., & Ferro, L. (2005). Generating an entailment corpus from news headlines. In
Proceedings of the ACL Workshop on Empirical Modeling of Semantic Equivalence and
Entailment, pp. 49‚Äì54, Ann Arbor, Michigan, USA. Association for Computational
Linguistics.
Dagan, I., & Glickman, O. (2004). Probabilistic textual entailment: generic applied modeling of language variability. In PASCAL Workshop on Learning Methods for Text
Understanding and Mining, pp. 26‚Äì29, Grenoble, France.
Dagan, I., Glickman, O., & Magnini, B. (2006). The PASCAL recognising textual entailment challenge. In Qui√±onero-Candela, J., Dagan, I., Magnini, B., & d‚ÄôAlch√© Buc, F.
(Eds.), Machine Learning Challenges. Evaluating Predictive Uncertainty, Visual Object Classification, and Recognising Tectual Entailment, Vol. 3944 of Lecture Notes in
Computer Science, pp. 177‚Äì190. Springer Berlin, Heidelberg.
Demaine, E., Mozes, S., Rossman, B., & Weimann, O. (2009). An optimal decomposition
algorithm for tree edit distance. ACM Transactions on Algorithms (TALG), 6 (1),
2:1‚Äì2:19.
20

Natural Language Inference for Arabic

Diab, M. (2009). Second generation tools (AMIRA 2.0): fast and robust tokenization, POS
tagging, and base phrase chunking. In Proceedings of the 2nd International Conference
on Arabic Language Resources and Tools, pp. 285‚Äì288, Cairo, Eygpt. The MEDAR
Consortium.
Habash, N. (2010). Introduction to Arabic Natural Language Processing. Synthesis Lectures
on Human Language Technologies. Morgan & Claypool Publishers.
Habash, N., Rambow, O., & Roth, R. (2009). MADA+TOKAN: a toolkit for Arabic tokenization, diacritization, morphological disambiguation, POS tagging, stemming and
lemmatization. In Proceedings of the 2nd International Conference on Arabic Language
Resources and Tools, Cairo, Eygpt. The MEDAR Consortium.
Habash, N., Soudi, A., & Buckwalter, T. (2007). On Arabic transliteration. Arabic Computational Morphology, 15‚Äì22.
Heilman, M., & Smith, N. (2010). Tree edit models for recognizing textual entailments, paraphrases, and answers to questions. In Human Language Technologies: The 2010 Annual
Conference of the North American Chapter of the Association for Computational Linguistics, pp. 1011‚Äì1019, Los Angeles, California, USA. Association for Computational
Linguistics.
Hobbs, J. R. (2005). The handbook of pragmatics, chap. Abduction in Natural Language
Understanding, pp. 724‚Äì740. Blackwell Publishing.
Klein, P. (1998). Computing the edit-distance between unrooted ordered trees. In Proceedings of the 6th Annual European Symposium on Algorithms (ESA ‚Äô98), pp. 91‚Äì102,
Venice, Italy. Springer-Verlag.
Kouylekov, M. (2006). Recognizing Textual Entailment with Tree Edit Distance: application
to Question Answering and Information Extraction. Ph.D. thesis, DIT, University of
Trento, Italy.
Kouylekov, M., & Magnini, B. (2005). Recognizing textual entailment with tree edit distance algorithms. In Proceedings of the1st Challenge Workshop Recognising Textual
Entailment, pp. 17‚Äì20, Southampton, UK.
Lin, D. (1998). Dependency-based evaluation of minipar. In Workshop on the Evaluation of
Parsing systems, pp. 317‚Äì330. Springer.
Maamouri, M., & Bies, A. (2004). Developing an Arabic treebank: methods, guidelines,
procedures, and tools. In Proceedings of the Workshop on Computational Approaches
to Arabic Script-based Languages, pp. 2‚Äì9, Geneva, Switzerland.
MacCartney, B. (2009). Natural Language Inference. Ph.D. thesis, Department of Computer
Science, Stanford University, USA.
McDonald, R., Lerman, K., & Pereira, F. (2006). Multilingual dependency parsing with a
two-stage discriminative parser. In 10th Conference on Computational Natural Language Learning (CoNLL-X), New York, USA.
Mehdad, Y., & Magnini, B. (2009). Optimizing textual entailment recognition using particle
swarm optimization. In Proceedings of the 2009 Workshop on Applied Textual Inference (TextInfer ‚Äô09), pp. 36‚Äì43, Suntec, Singapore. Association for Computational
Linguistics.
21

Alabbas & Ramsay

Nivre, J., Hall, J., Nilsson, J., Chanev, A., Eryigit, G., K√ºbler, S., Marinov, S., & Marsi,
E. (2007). MaltParser: a language-independent system for data-driven dependency
parsing. Natural Language Engineering, 13 (02), 95‚Äì135.
Pawlik, M., & Augsten, N. (2011). RTED: a robust algorithm for the tree edit distance.
Proceedings of the VLDB Endowment, 5 (4), 334‚Äì345.
Punyakanok, V., Roth, D., & Yih, W. (2004). Natural language inference via dependency
tree mapping: An application to question answering. Computational Linguistics, 6,
1‚Äì10.
Ramsay, A., & Sabtan, Y. (2009). Bootstrapping a lexicon-free tagger for Arabic. In Proceedings of the 9th Conference on Language Engineering (ESOLEC‚Äô2009), pp. 202‚Äì215,
Cairo, Egypt.
Selkow, S. (1977). The tree-to-tree editing problem. Information Processing Letters, 6 (6),
184‚Äì186.
Smr≈æ, O., Bielicky, V., Kou≈ôilov√°, I., Kr√°ƒçmar, J., Hajiƒç, J., & Zem√°nek, P. (2008). Prague
Arabic dependency treebank: a word on the million words. In Proceedings of the Workshop on Arabic and Local Languages (LREC 2008), pp. 16‚Äì23, Marrakech, Morocco.
Tai, K. (1979). The tree-to-tree correction problem. Journal of the ACM (JACM), 26 (3),
422‚Äì433.
Zhang, K., & Shasha, D. (1989). Simple fast algorithms for the editing distance between
trees and related problems. SIAM Journal of Computing, 18 (6), 1245‚Äì1262.

22

Journal of Artificial Intelligence Research 48 (2013) 813-839

Submitted 05/13; published 11/13

Single Network Relational Transductive Learning
Amit Dhurandhar
Jun Wang

adhuran@us.ibm.com
wangjun@us.ibm.com

IBM T.J. Watson Research
1101 Kitchawan Road, Yorktown Heights, NY-10598 USA

Abstract
Relational classification on a single connected network has been of particular interest
in the machine learning and data mining communities in the last decade or so. This is
mainly due to the explosion in popularity of social networking sites such as Facebook,
LinkedIn and Google+ amongst others. In statistical relational learning, many techniques
have been developed to address this problem, where we have a connected unweighted homogeneous/heterogeneous graph that is partially labeled and the goal is to propagate the
labels to the unlabeled nodes. In this paper, we provide a different perspective by enabling
the effective use of graph transduction techniques for this problem. We thus exploit the
strengths of this class of methods for relational learning problems. We accomplish this by
providing a simple procedure for constructing a weight matrix that serves as input to a rich
class of graph transduction techniques. Our procedure has multiple desirable properties.
For example, the weights it assigns to edges between unlabeled nodes naturally relate to a
measure of association commonly used in statistics, namely the Gamma test statistic. We
further portray the efficacy of our approach on synthetic as well as real data, by comparing
it with state-of-the-art relational learning algorithms, and graph transduction techniques
with an adjacency matrix or a real valued weight matrix computed using available attributes as input. In these experiments we see that our approach consistently outperforms
other approaches when the graph is sparsely labeled, and remains competitive with the
best when the proportion of known labels increases.

1. Introduction
Given the affluence of large connected relational graphs across diverse domains, single or
within network classification has been one of the popular endeavours in statistical relational
learning (SRL) research (Getoor & Taskar, 2007). Ranging from social networking websites
to movie databases to citation networks, large connected relational graphs1 are banal. In
single network classification, we have a partially labeled data graph and the goal is to extend
this labeling, as accurately as possible, to the unlabeled nodes. The nodes themselves may
or may not have associated attributes. An example where within network classification
could be useful is in forming common interest groups on social networking websites. For
instance, a group of people in the same geography may be interested in playing soccer and
they would be interested in finding more people who are likely to have the same interest.
In a different domain such as entertainment, one might be interested in estimating which
of the new movies is likely to make a splash at the box office. Based on the success of other
movies that had some of the same actors and/or the same director, one could provide a
reasonable estimate of which movies are most likely to be successful.
1. At least with a large connected component.
c
2013
AI Access Foundation. All rights reserved.

Dhurandhar & Wang

Many methods that learn and infer over a data graph have been developed in SRL literature. Some of the more effective methods perform collective classification (Chakrabarti,
Dom, & Indyk, 1998), that is, besides using the attributes of the unlabeled node to infer its
label, they also use attributes and labels of related nodes/entities. These are thus a generalization of methods that assume that the data is independently and identically distributed
(i.i.d.). Examples of such methods are relational markov networks (RMNs) (Taskar, Abbeel,
& Koller, 2002), relational dependency networks (RDNs) (Neville & Jensen, 2007), markov
logic networks (MLNs) (Richardson & Domingos, 2006), probabilistic relational models
(PRMs) (Getoor, Koller, & Small, 2004). These all fall under the umbrella of markov networks. There have been simpler models suggested as baselines such as relational neighbor
classifiers (RN) (Macskassy & Provost, 2003, 2007; Chakrabarti et al., 1998; Sen, Namata,
Bilgic, Getoor, Gallagher, & Eliassi-Rad, 2008), which simply choose the most numerous
class label amongst their neighbors to more involved variants such as those using relaxation
labeling. Interestingly, these simple models perform quite well when the auto-correlation is
high, even though the graph maybe sparsely labeled. Recently, a pseudo-likelihood expectation maximization (PL-EM) (Xiang & Neville, 2008) method was introduced, which seems
to perform favorably to other methods when the graph has a moderate number (around
20-30%) of labeled nodes.
A different class of methods that could potentially address the problem at hand are
graph transduction methods (Zhu, Ghahramani, & Lafferty, 2003; Zhou, Bousquet, Lal,
Weston, & Schlkopf, 2004; Wang, Jebara, & fu Chang, 2008), which are a part of semisupervised learning methods. These methods typically perform well when we are given a
weighted graph and the linked nodes have mostly the same labels ‚Äì unless apriori dissimilar
nodes are explicitly specified (Goldberg, Zhu, & Wright, 2007; Tong & Jin, 2007) ‚Äì, even if
only a small fraction of the labels are known. If a weighted graph is not readily available, it
is constructed from the (explanatory) attributes of the nodes. If an unweighted graph with
no attributes is given, then the adjacency matrix is passed as input.
There are multiple methods that learn weights based on attributes. The simplest is to
use a lp norm. More sophisticated techniques use specialized optimization functions based
on gaussian kernels (Jebara, Wang, & Chang, 2009; Jebara & Shchogolev, 2006) or loglikelihood (Xiang, Neville, & Rogati, 2010) to determine weights. These methods however,
are unsupervised (i.e. ignore labels) and are based on the fundamental assumption of
homophily, that is, linked or closeby datapoints have the same labels. This assumption is
not necessarily satisfied in real-world relational graphs.
There are other methods, which determine weights based on just linkage (Gallagher,
Tong, Eliassi-Rad, & Faloutsos, 2008). Here, besides the edges in the input graph, edges
are added between all labeled and unlabeled nodes. The weights are determined by making
multiple even length random walks starting at each unlabeled node. This strategy works
well for binary labeled graphs that may or may not satisfy the homophily assumption, but
is not necessarily effective when we have more than two labels. Moreover, the method is
still unsupervised and can be computationally expensive.
In literature concerning all the above methods that learn weights given an unweighted
graph, it is seen that an appropriate weighting scheme can help leverage graph semantics and
make the prediction algorithms more robust to noise compared to their unweighted counterparts. In fact, it has been well recognized (Maier, Von Luxburg, & Hein, 2008; Jebara
814

Single Network Relational Transductive Learning

et al., 2009; Zhu, Lafferty, & Rosenfeld, 2005) that accurate edge weighting has significant
influence on various graph based machine learning tasks such as clustering and classification. Moreover, in our own experiments we see that using an unweighted graph leads
to substantially inferior results in most cases, as opposed to using our weighting scheme.
When comparing our scheme with these other methods that learn weights, ours is preferable
for at least the following reasons. First, our method uses the attribute information, link
information alongwith the labels to determine the weights. The other methods use either
the link information or the attribute information and tend to ignore the specific labeling.
Hence, our method is comprehensive and thus more robust as it takes into account all the
three sources of information. Second, our method can be used when data is heterogenous
and is not limited to only homogenous datasets. Third, as we will see in the experiments,
our method performs well across varied labeling percentages, while these other methods
tend to have a higher bias and are not able to fully exploit the settings where more label
information is available.
In relational learning, the graphs are typically unweighted and sometimes may not have
attributes. In many cases, the attributes may not accurately predict the labels, in which
case, weighting the edges solely on them may not provide acceptable results. The links with
the labeling could be viewed as an additional source of information to predict unlabeled
nodes. Some of these intuitions are captured in the relational gaussian process model (Chu,
Sindhwani, Ghahramani, & Keerthi, 2007), but it is limited to undirected graphs and as
mentioned in prior works (Xiang & Neville, 2008) the suggested kernel function is not easy
to adapt to relational settings where we may have heterogeneous data.
In this paper, we provide a lucid way to effectively leverage a rich class of graph transduction methods, namely those based on the graph laplacian regularization framework, for
within network relational classification. Among the existing graph transduction methods,
this class of methods is considered to be one of the most efficient and accurate in real applications (Jebara et al., 2009; Zhu et al., 2003; Zhou et al., 2004). In particular, we provide
a procedure to learn a weight matrix for a graph that may be directed or undirected, that
may exhibit positive or negative auto-correlation and where the edges in the graph may
be between labeled nodes, between unlabeled nodes or between a labeled and an unlabeled
node. The method is semi-supervised in the sense that it uses the label information as well
as the links and the attribute information to determine weights. Being semi-supervised,
the learned weights are robust and effectively capture dependencies much more so than the
unsupervised weight learning methods described above. Moreover, the learning procedure
naturally relates to commonly used statistical measures making it more principled than previous approaches. We first provide a solution for a graph where nodes have no attributes,
only class labels. We then extend the solution to include attributes (and heterogenous data)
by incorporating a conical weighting scheme that weighs importance of the links relative
to the attributes. The construction of the weight matrix assumes binary labeling, however,
recursive application of the chosen graph transduction method with reconstruction of the
weight matrix will accomplish multi-class classification as is witnessed in the experiments
on real data.
The rest of the paper is organized as follows: In Section 2, we describe the construction
of the weight matrix when the nodes just have labels but no attributes. In Section 3, we
discuss interesting characteristics of such a weighting scheme. In Section 4, we extend the
815

Dhurandhar & Wang

-1

?

?

1

1
Figure 1: Example input graph (T ) to our construction method.
construction described in section 2 to be able to model attributes and data heterogeneity.
In Section 5, we suggest a modification to the graph transduction methods so that they
Figure 1
can effectively exploit the richness of our input weight matrix. In Section 6, we show the
efficacy of our ideas through experiments on synthetic and real data. In Section 7, we discuss
promising future directions and then summarize the contributions made in the current work.

2. Weight Matrix Construction
In this section we elucidate a way of constructing the weight matrix for a partially labeled
graph G(V, E, Y ) where V is the set of nodes, E is the set of edges and Y is the set of labels.
We assume that the labeling is binary, i.e any labeled node i has a label Yi ‚àà {1, ‚àí1}. As
mentioned before, the procedure of constructing the weight matrix W , which serves as
input to a graph transduction technique, could be applied recursively or iteratively to each
(binary) classified portion, to attain multi-class classification. Hence, the input in any run
to our weight matrix construction method is a partially (binary) labeled graph as shown in
Figure 1.
The weights Wij we learn for an edge between node i and node j signify the degree of
similarity/dissimilarity between the labels of these nodes. The weights lie in the interval
[‚àí1, 1], where a positive sign indicates that the nodes will tend have similar labels, while
a negative sign indicates that they will tend to have different labels. The numerical value
ignoring the sign indicates the magnitude of these tendencies. Formally,
Wij = f (Yi , Yj , G)

(1)

where Yi and Yj maybe known or unknown and f () ‚àà [‚àí1, 1]. In our case, the value of f ()
depends on the type nodes the edge is connecting, i.e., if the nodes are labeled, unlabeled
or one is labeled and the other is unlabeled, along with the labeled portion of the graph.
The exact assignments of f () for edges connecting the 3 different types of nodes are given in
subsection 2.2. Loosely speaking, f () would be negative and close to -1 if most of the edges
connect nodes with different labels, while it would be positive and close to +1 if most of
the edges connect nodes with the same label. These semantics are consistent even when we
discuss extensions later in the paper, which involve learning these weights in the presence
of attributes and heterogenous data.
816

Single Network Relational Transductive Learning

Symbol
Nq
Nqr

Graph Type
D, U
D

Nqr

U

Np

D, U

Psame

D, U

Popp

D, U

D

D, U

Semantics
# of nodes with label q
# of edges from node with
label q into node with
label r
When q = r,
# of edges between node
with label q and node
with label r
When q 6= r,
Half of the # of edges
between node with label
q and node with label r
Total # of labeled edges
i.e. edges where both
nodes are labeled
Ratio of the # of edges
between nodes with same
label to total # of
labeled edges
Ratio of the # of edges
between nodes with
different labels to total
# of labeled edges
Distribution over labeled
edges

Table 1: Above is the notation used in the paper. Under graph type, D stands for directed
and U stands for undirected.

Given our setup, a partially labeled graph G has 3 types of nodes and consequently 9
types of edges for a directed graph while 6 types of edges for an undirected one. A node
could be labeled 1 or ‚àí1 or may be unlabeled. An edge could be between two nodes with
the same label (i.e. (1 ‚Üí 1) or (‚àí1 ‚Üí ‚àí1)) or between two oppositely labeled nodes (i.e.
(1 ‚Üí ‚àí1) or (‚àí1 ‚Üí 1)) or between a labeled and unlabeled node (i.e. (1 ‚Üí?) or (‚àí1 ‚Üí?)
or (? ‚Üí 1) or (? ‚Üí ‚àí1)) or between two unlabeled nodes (i.e. (? ‚Üí?)). An undirected
example graph T is shown in Figure 1. Our task then is to assign weights to each of these
types of edges.
817

Dhurandhar & Wang

-1

?

?

1

1
Figure 2: Tw is a weighted version of graph T shown in figure 1.
2.1 Notation

Figureto2the different types of edges, we introduce some
Before we describe the weights we assign
notation. Given a graph G, let Nq denote the number of nodes with label q. Let Nqr denote
the number of edges from node with label q into node with label r. In an undirected graph,
this would be the number of edges between nodes labeled q and r, if q = r. If q 6= r, then
Nqr would be half of the number of edges between q and r. Let Np denote the total number
of labeled edges, i.e. the total number of edges where both nodes are labeled. In other
words, Np = N11 + N‚àí11 + N1‚àí1 + N‚àí1‚àí1 . With this let,
Psame =

N11 + N‚àí1‚àí1
N1‚àí1 + N‚àí11
, Popp =
Np
Np

(2)

Hence, Psame + Popp = 1. We denote this empirical distribution derived from labeled edges
by D. A summary of this notation for directed and undirected graphs is shown in table 1.
2.2 Assignment of Weights
We now describe our weight matrix construction which applies to both directed and undirected graphs. We partition the types of edges into 5 categories and suggest a way of
assigning weights to edges in each of these categories.
‚Ä¢ Edges between nodes with the same label: If an edge is between nodes having the same
label, that is if node i and node j have the same label, we assign a weight Wij = Psame
to that edge. This makes intuitive sense since we want to weigh the edge based on
how likely it is to have nodes with the same label being connected.
It is worth mentioning that one might think of assigning label specific weights to edges.
For instance, one strategy would be to assign Wij = NN11
or Wij = N‚àí1‚àí1
depending
Np
p
on if the labels were +1 or ‚àí1 respectively. However, this assignment seems to have a
conceptual issue even for the simple case, where we have a graph with connected nodes
mostly having the same labels. In such a case, the weights of the edges connecting
nodes having the same labels would be devalued undesirably. For example consider a
graph where, N11 = 10, N‚àí1‚àí1 = 10 and N‚àí11 = 1. This is basically a graph with two
large clusters of connected nodes with same labels and one link connecting these two
818

Single Network Relational Transductive Learning

clusters. In this case, the label specific strategy would give weights of Wij = 10
21 ‚âà 0.48,
while our strategy would give weights of Wij = 20
‚âà
0.95
for
the
edges
with
nodes
21
having same labels. It is clear that the latter strategy is preferable since, either of the
labels have a high tendency of being connected to nodes with the same labels. Note
that this reasoning also applies to when N11 might be different than N‚àí1‚àí1 , but the
graph exhibits high positive auto-correlation.
‚Ä¢ Edges between nodes with opposite/different labels: If an edge is between nodes with
opposite labels, that is if node i and node j have different labels, we assign a weight
Wij = ‚àíPopp to that edge. This is also intuitive since, we want to weigh the edge based
on how likely it is to have nodes with opposite labels connected. We assign a negative
sign since simply assigning the magnitude will not create a distinction between nodes
labeled alike and those with different labels.
‚Ä¢ Edges between unlabeled nodes: If an edge is between unlabeled nodes, that is if node
i and node j do not have labels, we assign a weight Wij = ED [Yi , Yj ] to that edge.
ED [Yi , Yj ] denotes the expectation of labeled edges over the distribution D. Yi and
Yj ‚àà {1, ‚àí1} and hence,

ED [Yi , Yj ] =

X

qrP [Yi = q, Yj = r]

q,r‚àà{1,‚àí1}

= P [Yi = 1, Yj = 1] ‚àí P [Yi = 1, Yj = ‚àí1]+
P [Yi = ‚àí1, Yj = ‚àí1] ‚àí P [Yi = ‚àí1, Yj = 1]
N11 N1‚àí1 N‚àí1‚àí1 N‚àí11
=
‚àí
+
‚àí
Np
Np
Np
Np

(3)

Since we do not know the labels of any of the nodes for edges in this category, we
assign our most unbiased estimate which is the indicated expected value.
‚Ä¢ Edges between an unlabeled node and a node with label 1: If an edge is between an
unlabeled node and a node with label 1, we assign a weight Wij = ED [Yi |Yj = 1] to
that edge. Here Yi ‚àà {1, ‚àí1}. In this case,
ED [Yi |Yj = 1] =

N11 N‚àí11 + N1‚àí1
‚àí
N1
N1

(4)

is our unbiased estimate given that one of the nodes has a label of 1.
‚Ä¢ Edges between an unlabeled node and a node with label ‚àí1: If an edge is between an
unlabeled node and a node with label ‚àí1, we assign a weight Wij = ED [Yi |Yj = ‚àí1]
to that edge. Here Yi ‚àà {1, ‚àí1}. In this case,
ED [Yi |Yj = ‚àí1] =

N‚àí1‚àí1 N‚àí11 + N1‚àí1
‚àí
N‚àí1
N‚àí1

is our unbiased estimate given that one of the nodes has a label of ‚àí1.
819

(5)

Dhurandhar & Wang

A weighted version of our example graph T in Figure 1, is shown by graph Tw in Figure
2.

3. Characteristics of Matrix Construction
In the previous section, we elucidated a way of constructing a weight matrix for a partially
labeled graph. In this section, we discuss certain characteristics of this construction. We
discuss aspects such as relationships of the suggested weights to standard statistical measures and the tendencies of the weight matrix as a function of the connectivity and labeling
in the graph. As we will see, our construction seems to have desirable properties.
3.1 Relation to Standard Measures of Association
In the previous section, we described and provided a brief justification of the procedure
to assign weights. It turns out that the weights we assign to edges that have at least one
unlabeled node, besides being unbiased, have more (statistical) semantics.
Remark: The weights assigned to edges between unlabeled nodes equate to the gamma
test statistic (œÅ) in the relational setting i.e. ED [Yi , Yj ] = œÅ.
The gamma test statistic œÅ (Goodman & Kruskal, 1954), is a standard measure of association used in statistics. The value of this statistic ranges from [‚àí1, 1], where positive
values indicate agreement, negative values indicate disagreement/inversion and zero indicates absence of association. The statistic was historically used to compare the sorted order
of observations based on values of two attributes. However, it can also be used to measure
auto-correlation in relational data graphs. Hence, our assignment of weight to edges between unlabeled nodes is the auto-correlation in the graph, which makes intuitive sense. As
it turns out, the statistic also has an interesting relationship to the Student t distribution
(Goodman & Kruskal, 1954).
The weights assigned to edges with one labeled and one unlabeled node i.e. ED [Yi |Yj =
1] or ED [Yi |Yj = ‚àí1], based on equations 4 and 5 can be written as: (Psame |1)‚àí(Popp |1) = œÅ1
and (Psame | ‚àí 1) ‚àí (Popp | ‚àí 1) = œÅ‚àí1 . These could be considered as gamma test statistics
conditioned on one particular type of label and could be referred to as conditional gamma
test statistics.
3.2 Behavior of Weight matrix
We now analyze the behavior of the weight matrix as the labeled edges in our input graph
tend towards only connecting nodes with the same labels or analogously only connecting
nodes with different labels.
As our input graph tends to have only nodes with same labels being connected, it has
the following effect on our weight matrix. The weight of edges between nodes with the same
label tends to one, i.e. Psame ‚Üí 1. The weight of edges between nodes with different labels
tends to zero, i.e. ‚àíPopp ‚Üí 0. The weight of edges between unlabeled nodes tends to 1, i.e.
œÅ ‚Üí 1. The weight of the remaining set of edges also tends to one, i.e. œÅ1 , œÅ‚àí1 ‚Üí 1. Hence,
in this situation the weight matrix becomes an adjacency matrix in the extreme case, with
different labeled edges vanishing (i.e. being weighted 0) and all other edges getting a weight
820

Single Network Relational Transductive Learning

-1

?

?

1

1
Figure 3: Ts is an instantiation of graph Tw , when the labeled edges have only nodes with
same labels.

-1
Figure 3

?

?

1

1
Figure 4: To is an instantiation of graph Tw , when the labeled edges have only nodes with
different labels.

Figure
4 graph T in Figure 2 becomes graph T in
of one. Consequently, our example
weighted
w
s
Figure 3.
As our input graph tends to have only nodes with different labels being connected, it
has the following effect on our weight matrix. The weight of edges between nodes with
the same label tends to zero, i.e. Psame ‚Üí 0. The weight of edges between nodes with
different labels tends to -1, i.e. ‚àíPopp ‚Üí ‚àí1. The weight of edges between unlabeled nodes
tends to -1, i.e. œÅ ‚Üí ‚àí1. The weight of the remaining set of edges also tends to -1, i.e.
œÅ1 , œÅ‚àí1 ‚Üí ‚àí1. Since the graph in the extreme case has no positive weights, the negative
sign in the weights is superfluous in terms of graph structure and can be eliminated. Hence,
in this situation too the weight matrix becomes an adjacency matrix in the extreme case,
with same labeled edges vanishing (i.e. being weighted 0) and all other edges getting a
weight of one. Consequently, our example weighted graph Tw in Figure 2 becomes graph
To in Figure 4.
We thus have Ts ‚à™ To = T , and the labeled edges in Ts and To complement each other
on the labeled portion with respect to the base graph T . We intuitively expect the labeled
edges between differently labeled nodes to slowly disappear while the other edges remain
821

Dhurandhar & Wang

Paper

Paper

Author

Paper
Author

Title

Area

Age

Paper Title
Author

a)

Paper

b)

Figure 5: a) represents a relational schema with node types, Paper and Author. The relationship between them is many-to-many. The rounded boxes linked to these node
types denote their respective attributes. b) is the corresponding data graph, which
shows authors linked to the papers that they authored or co-authored.

present, as edges connecting nodes with the same label become predominant. We also
expect analogous behavior for the diametric case. As we have seen, these intuitions are
captured implicitly, in our modeling of the weight matrix, thus making the construction
procedure more acceptable.

4. Extensions
In the previous sections, we described a procedure for constructing the weight matrix for
a partially labeled graph with no attributes. In this section, we extend the weighting
scheme to include attribute information. Moreover, we also present a solution to handle
data heterogeneity using ideas from relational learning.
4.1 Modeling with Attributes
For data graphs that have attributes, we want to be able to leverage this information in
addition to the information learned from the connectivity of the graph, so as to possibly
further improve the performance of our procedure. In particular, we need to extend our
weight assignment procedure to be able to encapsulate attribute information. A simple way
of combining the already modeled connectivity information with the attributes, is to assign
a weight to an edge that is a conical combination of the weight based on connectivity and
a weight based on the affinity of attribute values of the connected nodes. Hence, if wc is
the weight assigned based on the connectivity for the particular edge type and wa is the
weight assigned based on attributes, then Œªwc + ¬µwa is the new weight of that edge, where
¬µ, Œª ‚â• 0. wc is essentially a weight assignment described in section 2, viz. Psame or œÅ etc.
wa is a function of the attributes of the nodes connected by the corresponding edge, which
we will soon define. ¬µ and Œª are parameters which can be determined through standard
model selection techniques such as cross-validation. A reasonable indicator for the value
of Œª could be the absolute value of the auto-correlation in the graph. While a reasonable
estimate of the value of ¬µ could be the absolute value of the cross-correlation between wa
and the labeling of the corresponding nodes i.e. if the labels are the same or different.
822

Single Network Relational Transductive Learning

Figure 6: The above figure shows the transformed data graph with only Paper node type,
which is obtained from the data graph in Figure 5b.

In the absence of attributes, our weight assignment wc for any type of edge, has a value
in the interval [‚àí1, 1]. To effectively combine the aforementioned two sources of information,
wa needs to be of the same scale as wc . One obvious choice could be cosine similarity which
is commonly used in text analytics (Belkin, Niyogi, & Sindhwani, 2005). Cosine similarity
lies in [‚àí1, 1], where values close to 1 imply that the nodes are similar while values close
to ‚àí1 imply that the nodes are dissimilar. Other choices could be kernel functions (K)
such as gaussian kernel (Wang et al., 2008), which normalize popular distance metrics such
as euclidean distance and other lp norms to value in [0, 1]. Here, values close to 1 imply
similarity and values close to 0 imply dissimilarity. This range can be easily transformed to
our usual range of [-1,1] with the same semantics as before, by a simple linear transformation
of the form, 2K ‚àí 1.
4.2 Modeling with Heterogeneous Data
If the data graph has multiple types of entities, resulting in different types of nodes, the
procedure previously described cannot be directly applied to construct the weight matrix.
In such cases, standard relational learning strategies such as collapsing portions of the graph
and using aggregation can be applied to reduce to a graph with a single type of node with
attributes (Getoor & Taskar, 2007; Dhurandhar & Dobra, 2012). To this new graph the
above extended procedure can be applied.
823

Dhurandhar & Wang

For instance, in a citation graph we may have authors linked to papers, with papers
having multiple authors and vice-versa. An example of this is shown in Figure 5. In Figure
5a, we see that the node type Paper has two attributes, Title and Area, which denote the
title of the paper and the research area it belongs to respectively. Let the attribute Area
be the class label, i.e. we want to classify papers based on their research area. The node
type Author has attributes Paper Title and Age, which relates a particular paper to the
ages of the authors that wrote it. The Title attribute (a primary key) in Paper is the same
as the Paper Title attribute (a foreign key) in Author. Hence, each Paper node has three
attributes namely; Title, Area and Age. The attributes Title and Area are called intrinsic
attributes as they belong to node type Paper and the attribute Age is called a relational
attribute since it belongs to a different linked node type Author. Each paper can have
variable number of authors and thus each paper would be associated with multiple values of
Age. A popular solution to this problem is to aggregate the values of the attribute Age of
Author into a single value such that each paper is associated with only a single Age value.
An aggregation function such as average over the ages of the related authors for each paper
can be used. Now instead of the Age attribute we can introduce a new attribute AvgAge
which denotes average age. With this the attributes of Paper node are; Title, Area and
AvgAge. Linking papers that were co-authored by an author, we now have a data graph
that links only the Paper node type, with each node having two attributes and a class label
as is shown in Figure 6.
We will now see an example weight assignment to this transformed data graph by our
extended method. Let us assume that Paper 1 and Paper 2 are in the same area AI encoded
as 1 and Paper 3 is in systems encoded as ‚àí1. Let the average age corresponding to the
three papers (i.e. Paper 1, Paper 2 and Paper 3) be 30, 30.5 (average of the two authors)
and 31 respectively. Let the ascii value of the titles be 10, 11 and 15. Also let Œª = 0.1 and
||xi ‚àíxj ||2

¬µ = 0.5. If we use a gaussian radial basis kernel K = e‚àí 2œÉ2
with œÉ = 1 to compute wa ,
then the weights of the two edges W12 and W23 are as follows:

W12 = ŒªPsame + ¬µ(2e‚àí

(30‚àí30.5)2 +(10‚àí11)2
2

‚àí 1)

= 0.1 √ó 0.5 + 0.5 √ó 0.071
= 0.086
W23 = Œª(‚àíPopp ) + ¬µ(2e‚àí

(30.5‚àí35)2 +(11‚àí13)2
2

‚àí 1)

= 0.1 √ó ‚àí0.5 + 0.5 √ó ‚àí1
= ‚àí0.55
These weights would then be passed to the enhanced graph transduction framework
that we describe next. It is important to note that if we have heterogeneous link types,
then the described procedures can be applied independently to graphs formed from each
link type and the final result could be obtained by aggregating the individual decisions
through standard ensemble label consolidation techniques such as taking a majority vote
or a weighted majority based on the corresponding auto-correlations.
824

Single Network Relational Transductive Learning

5. Enhancing Graph Transduction Techniques
The graph laplacian regularization based framework is one of the most efficient and popular
frameworks for semi-supervised learning in practical machine learning systems. It has shown
effectiveness in many applications, including those challenging cases with agnostics settings
(Jebara et al., 2009). In particular, graph based transductive learning approaches impose
a trade off between the fitting accuracy of the prediction function on labeled data and
the smoothness of the function over the graph. Typically, the smoothness measure of a
prediction function f over the graph G is calculated as (Zhou et al., 2004):
XX
kf k2G =
Wij kf (xi ) ‚àí f (xj )k2
i

j

1
1
= f (X)> (D ‚àí W )f (X) = f (X)> Lf (X),
2
2

(6)

where Wij is the weight of the edge between nodes xi and xP
j , X is the input matrix denoting
the nodes, f (xi ) is the label of node xi , D = {Dii }, Dii = j Wij is a diagonal matrix and
f (X) = [f (x1 ), ¬∑ ¬∑ ¬∑ , f (xn )]> . Then quantity L is called graph Laplacian, which can be
viewed as an operator on the space of the functions f (Chung, 1997).
Given the above measure of function smoothness, a graph laplacian based regularization
framework estimates the unknown function f as follows:
f opt = arg min Q(Xl , Yl , f ) + Œ∑kf k2G

(7)

where Q(Xl , Yl , f ) is a loss function measuring the accuracy over the labeled set (Xl , Yl ).
For example, Q(Xl , Yl , f ) = kf (Xl ) ‚àí Yl k2 i.e. squared loss, is a popular choice (Belkin,
Niyogi, & Sindhwani, 2006; Zhou et al., 2004).
Note that this graph regularization framework can not be directly applied to prediction
modeling in relational networks directly. This is because, the smoothness measure using
the graph laplacian is based on the assumption that connected nodes tend to have the same
class labels and hence the weights have to be non-negative (i.e. Wij ‚â• 0 ‚àÄi, j). However, it is
well-known that edges in relational networks could connect any type of nodes, as described
earlier. A typical example can be observed in the WEBKB dataset (Craven, DiPasquo,
Freitag, McCallum, Mitchell, Nigam, & Slattery, 1998), where the faculty nodes are mostly
linked to student nodes instead of the same type of nodes, i.e. other faculty nodes. Although
some recent work modeled dissimilarity and incorporated it in their similarity measure to
derive the so called mix graph based prediction models (Tong & Jin, 2007; Goldberg et al.,
2007), they assumed that the similarity/dissimilary relations are apriori known. However,
in our case we automatically estimate the positive and negative correlations from the given
link and attribute information with partial labeling.
As indicated in Section 2, we derive a weighted graph containing both positive weighted
and negative weighted edges. To ensure compatibility with the graph Laplacian based
regularization framework, we modify the smoothness term (Goldberg et al., 2007) using our
derived relational edges as follows,
XX
kf k2G =
WÃÉij kf (xi ) ‚àí sgn(Wij )f (xj )k2 ,
(8)
i

j

825

Dhurandhar & Wang

where we set WÃÉij = |Wij | and the degree matrix DÃÉ = {DÃÉii } is computed as DÃÉii =
accordingly. The positive semidefinite matrix M is defined as:
M = (DÃÉ ‚àí WÃÉ ) + (1 ‚àí sgn(W )) ‚ó¶ W.

P

j

DÃÉij
(9)

The symbol ‚ó¶ represents the Hadamard product. It is easy to see the modified smoothness
measure in Eq. 9 can be written in the matrix form as,
1
(10)
kf k2G = f (X)> M f (X).
2
With the above new smoothness measure, we can extend the existing approaches using the
derived weighted graph for prediction tasks.

6. Experiments
In the previous sections, we described a method to construct a weight matrix for relational
data that serves as input to a rich class of graph based transductive learning algorithms. In
this section, we assess the efficacy of our approach through empirical studies on synthetic
and real data. In these studies, we compare methods across three broad categories, namely:
a) sophisticated relational learning (RL) methods, b) sophisticated graph transduction
methods with the weight matrix computed using available attributes or adjacency matrix
(if no attributes) as input (GTA) and c) relational transductive methods where our learned
weight matrix is passed as input to (enhanced/modified) graph transduction techniques.
The situations where methods in category c) perform favorably to methods in the other two
categories would be the conditions under which, using our procedure would be justified.
When attributes are available we compute the weights using a well accepted method (Jebara et al., 2009). The relational learning methods we consider are: MLNs, RDNs, PL-EM
and RN. We learn MLNs using discriminative learning and the inference is performed using
Markov Chain Monte Carlo (1000 runs). The conditional probability distributions (CPDs)
in RDNs are learned using relational probability trees (RPTs), since they generally have
better performance than relational bayesian classifiers especially when the number of features is large (Neville & Jensen, 2007)). The inference is performed on the sample obtained
after performing Gibbs sampling (burn-in is 100, number of samples is 1000) using the
learned CPDs. The graph transduction methods we consider are: local global consistency
(LGC) method and harmonic functions gaussian fields (HFGF) method. We consider these
methods, since they have been well recognized to be more robust across varied settings in
comparison with other transduction and label propagation methods (Liu & Chang, 2009),
and are thus considered as suitable baselines (Wang, Jebara, & Chang, 2013). The parameter settings we use for these methods are the same as in these prior works (Zhou et al.,
2004; Zhu et al., 2003). The parameters for our method (Œª, ¬µ) for datasets that are heterogenous or have attributes are found using 10 fold cross-validation, for each combination
of Œª, ¬µ ‚àà [0, 1] varied independently in steps of 0.1.
In all of our experiments, we vary the percentage of known labels for training from 5%
to 10% to 30% to 70%. The errors for each of the methods are obtained by randomly
selecting (100 times) the labeled nodes for the specified proportions followed by averaging
the corresponding errors. To avoid clutter in the figures reporting the results, we plot only
the following 4 curves (rather than 8),
826

Single Network Relational Transductive Learning

16

49
Best RL

48

15

Best RL

14
13
12

Percentage Error

Percentage Error

47
Best GTA

HFGFW
LGCW

46

Best GTA

45
44
43

HFGFW

LGCW

42
11
41
10
0

20
40
60
Percentage Labeled

40
0

80

Figure 7: Performance of the methods
in the 3 categories when the
graph is generated using preferential attachment and the
auto-correlation is high, are
shown above.

20
40
60
Percentage Labeled

80

Figure 8: Performance of the methods
in the 3 categories when the
graph is generated using preferential attachment and the
auto-correlation is low, are
shown above.

‚Ä¢ the best performance at each labeled percentage of methods in category a) (BEST
RL)2 ,
‚Ä¢ the best performance at each labeled percentage of methods in category b) (BEST
GTA),
‚Ä¢ the LGC method with our constructed weight matrix as input (LGCW) and
‚Ä¢ the HFGF method with our constructed weight matrix as input (HFGFW) i.e. methods in category c).

6.1 Synthetic Experiments
We generate graphs using well accepted random graph generation procedures that create
real world graphs, namely: forest fire (FF) (Leskovec, Kleinberg, & Faloutsos, 2007) and
2. When the percentage of labeled instances is ‚â§ 10% all the RL methods have roughly the same accuracies,
though RN is obviously most efficient. For moderate labeling i.e. 30% PL-EM is usually the best. For
high labeling i.e. 70% RDNs are the best in most cases.

827

Dhurandhar & Wang

16

Best RL

45

Best GTA

14

Percentage Error

Percentage Error

15

50
Best RL

13
12
11
10
9
0

HFGFW

Best GTA

40

35

LGCW

LGCW

20
40
60
Percentage Labeled

HFGFW

30
0

80

Figure 9: Performance of the methods
in the 3 categories when the
graph is generated using forest
fire and the auto-correlation is
high, are shown above.

20
40
60
Percentage Labeled

80

Figure 10: Performance of the methods in the 3 categories when
the graph is generated using forest fire and the autocorrelation is low, are shown
above.

preferential attachment (PA) (Barabasi & Albert., 1999). These procedures add one node at
a time and as nodes get added, we assign a label to it based on an intuitive label generation
procedure which is described below.
6.1.1 Setup
We generate 100 graphs consisting of 1000 nodes for the two generation techniques mentioned above. The parameter settings for forest fire (forward probability = 0.37, backward
probability = 0.32) and preferential attachment (exponent Œ≤ = 1.6) are derived from studies
(Leskovec et al., 2007; Barabasi & Albert., 1999) which indicate that these settings lead to
most realistic graphs.
On the labeling front, we generate a binary labeling ‚àà {1, ‚àí1} by a simple procedure
for each of these graphs. Whenever a new node is added, with probability p we assign
the majority class amongst its labeled neighbors and with probability 1 ‚àí p we assign one
of the two labels uniformly at random. Hence, the labels generated are dependent on the
particular graph generation procedure and consequently the connectivity of the graph, as
is desired. Its easy to see that as p ‚Üí 1 the auto-correlation in the graph increases, leading
to more homogeneity or less entropy amongst connected nodes. For each of the two graph
828

Single Network Relational Transductive Learning

Years

Publication

Publication

advisedby
taughtby

Person

Pname

Title

ta
Name

Course

Status
Id

Inphase

CT

Person
I

S

H

N

Level

Hasposition

Course
CId
L

b)

a)

Figure 11: a) represents a relational schema of a real dataset UW-CSE with types, Person, Course and Publication. The relationship between the related types is
many-to-many. The rounded boxes denote their respective attributes. b) is the
corresponding model graph which depicts the conditional dependencies between
the relevant attributes of the three types namely; Name (N), Status (S), Inphase
(I), Hasposition (H), Concatenated Titles (CT), Concatenated course Ids (CId)
and Level (L).

generation procedures, we create graphs where p is low i.e. 0.3 and where p is high i.e. 0.8.
The low p leads to an auto-correlation of about 0.2 i.e. œÅ ‚âà 0.2 while the high p leads to an
auto-correlation of about 0.7 i.e. œÅ ‚âà 0.7, which are calculated from the generated graphs.
The model graph for the relational methods in this case is trivial since, there are no
attributes and hence the labels for unknown nodes are generated based known labels of
neighbors.
6.1.2 Observations
From Figures 7, 8, 9 and 10 we see that given a particular graph generation procedure
irrespective of the level of auto-correlation the relative performance of the 3 different class
of methods is qualitatively similar. GTAs are known to perform particularly well when only
a few nodes are labeled (Zhou et al., 2004; Wang et al., 2008) and this is confirmed in our
experiments. As the percentage of known labels increases however, the relational learning
methods start performing better than standard graph transduction techniques. This is
probably due to the fact that most sophisticated relational learning methods have low bias
and relatively high variance, however, with increasing number of labeled nodes this variance
drops rapidly.
829

Dhurandhar & Wang

Figure 12: a) represents a relational schema of a real dataset BREAD with Store type.
The rounded boxes denote their respective attributes. b) is the corresponding
model graph which depicts the conditional dependencies between the relevant
attributes namely; Sales Target (ST), Promotions (P), Orders (O) and Reclaims
(R).

The interesting part is though, that our weight matrix construction technique seems to
capture enough of the complexity of the labeling and the network structure that besides
performing exceedingly well when the graph is sparsely labeled, it remains competitive with
relational learning methods when the percentage of known labels is moderate to high.
6.2 Real Data Experiments
For experiments on real data we choose three datasets, namely: UW-CSE (Richardson &
Domingos, 2006), WEBKB (Craven et al., 1998) and a real industrial dataset, BREAD,
obtained from a large consumer retail company.
6.2.1 Setup
The UW-CSE dataset contains information about the UW computer science department.
The dataset consists of 442 people being either students or professors. The dataset has
information regarding which course is taught by whom, who are the teaching assistants
for a course, the publication record of a person, the phase in which a person is (i.e. prequalifier, post-qualifier), the position of a person (i.e. faculty, affiliate faculty etc.), years
in a program and the advisor (or temporary advisor) of a student (advisedby links). The
relational schema for this dataset is given in Figure 11a. The classification task is to find
out if a person is a Student or Professor. The dataset is divided into five parts; ai.db,
graphics.db, theory.db, language.db and systems.db. We run experiments on each part and
830

Single Network Relational Transductive Learning

21
70

Best RL

HFGFW

65

Best RL

60
19
18
17

Percentage Error

Percentage Error

20

Best GTA

HFGFW

LGCW

55

Best GTA

50
45

LGCW

40
35

16

30
15
0

20

40
60
Percentage Labeled

25
0

80

Figure 13: Performance of the methods
in the 3 categories on the
UW-CSE dataset, are shown
above.

20
40
60
Percentage Labeled

80

Figure 14: Multi-class transductive performance of the methods
in the 3 categories on the
WEBKB dataset, are shown
above.

report error averaged over all the parts. A model graph showing the various conditional
dependencies is shown in Figure 11b. In the model graph we introduce two new attributes
not present in the relational schema namely, CT and CId which are formed by concatenating
the titles of papers written by a person and by concatenating Ids of courses taught (or ta)
by a person. The Year attribute is eliminated since it is not particularly discriminative.
The relational methods are trained based on this model graph, besides offcourse taking into
account labels of neighbors.
The WEBKB dataset has a collection of webpages obtained from computer science
departments of 4 US universities. Each webpage belongs to one of 7 categories namely;
course, faculty, student, staff, project, department or other. The ‚Äùother‚Äù category webpages
were not used as input in the classification task, but were used to link webpages in the
remaining 6 classes (Macskassy & Provost, 2007). We performed experiments on the four
graphs formed ‚Äì one for each university ‚Äì and computed the average error over the four
universities for each of the learning methods. For WEBKB, which is a commonly used
dataset, we use the model graph constructed in prior works (Neville & Jensen, 2007) to
train the relational methods.
The BREAD dataset has sales information about bread products sold in different stores
in the northeastern United States. The dataset has information from 2347 stores. For each
831

Dhurandhar & Wang

50
45

Best RL

Percentage Error

40
Best GTA

35
30
25
20

HFGFW
LGCW

15
10
0

20
40
60
Percentage Labeled

80

Figure 15: Performance of the methods
in the 3 categories on the
BREAD dataset, are shown
above.

store we know its location, we know if the store met3 or underachieved its target quarterly
sales, we know the amounts it had on promotion during that period, we know the quantity
ordered during that period and we know the amount reclaimed during that period. Based
on location, we can form a graph linking the closest stores together. With this, we have a
dataset of size 2347 and where each node in the graph has 4 attributes. Setting the attribute
indicating whether the sales met or underachieved the expected amount as our class label,
we obtain a graph where each node has three explanatory attributes. The relational schema
for this dataset is given in Figure 12a. The corresponding model graph showing the various
conditional dependencies is shown in Figure 12b. Here again, the relational methods are
trained based on this model graph, besides taking into account labels of neighbors.
6.2.2 Observations
On the UW-CSE and WEBKB datasets we see that the best GTA is better than the relational methods when a small percentage (< 20%) of labels are known, but the relational
methods quickly close this gap and start outperforming the GTAs with more label information. Our weight matrix construction method however, performs better than the other
two classes of methods at low label proportions and remains competitive with the rela3. This also includes cases where the sales exceeded the expected amount.

832

Single Network Relational Transductive Learning

tional methods as this proportion increases, unlike the GTAs. This favorable behavior can
most likely be attributed to our method being able to effectively model the strength (i.e.
the numerical value) and direction (i.e. + or ‚àí) of dependencies between linked entities,
something GTAs seemingly fail to capture.
On the BREAD dataset we see that the GTAs are much worse than the other class of
methods. A possible reason for this is that stores near to one another typically compete
with each other for the same type of products and hence, our input graph exhibits strong
negative auto-correlation. Since, GTAs predominantly model similarity between linked
entities, their performance is practically unchanged even when the percentage of known
labels is increased. The relational methods perform much better than GTAs in this setting.
In contrast to GTAs, they effectively capture the dissimilarity between linked nodes as the
number of known labels increases. However, our weight matrix construction method seems
to capture this relationship much earlier with only a small percentage of labels known.

7. Discussion
In this paper, we have provided a simple yet novel way of constructing a weight matrix for
partially labeled relational graphs that may be directed or undirected, that may or may
not have attributes and that may be homogeneous or heterogeneous. We have described
the manner in which such a weight matrix can serve as input to a rich class of graph
transduction methods through a modified graph laplacian based regularization framework.
We have portrayed the desirable properties of this construction method and showcased its
effectiveness in capturing complex dependencies through experiments on synthetic and real
data.
The primary focus of this paper was how to learn effectively over unweighted graphs.
However, there are many real world problems, where we might be given a weighted graph.
For instance, in genome sequence analysis the connection strength between gene expressions
can be estimated from experiments coupled with expert knowledge. In such situations the
question arises as to how can we incorporate the known weights into our methodology? A
logical and consistent way of incorporating these weights into our modeling would be to
combine it with the computed connectivity based weight wc and attribute based weight
wa as a conical combination. This is consistent with the methodology described before
to combine just connectivity based weight and attribute based weight. Thus, if wk is the
known (normalized) weight, then the weight of the edge would be Œªwc + ¬µwa + ŒΩwk , where
¬µ, Œª, ŒΩ ‚â• 0. Same as before, the free parameters can be computed using standard model
selection techniques or based on graph properties and domain knowledge.
In the future, it would be interesting to extend our procedure to perform multi-class
classification in a single shot, rather than having to perform multiple binary classification
tasks. This would most likely improve the actual running time, though not necessarily the
time complexity in terms of O(.). It would also be interesting to learn the weights based
on the local neighborhood of the graph than the entire graph. Thus, we would compute D
based on the local structure around each datapoint and then assign weights. Determining
the locality however, can be tricky especially when there are multiple link types.
On the theory side, it might be of some interest to analyze the synthetic label generation
procedure introduced in this paper, for different types of graphs. One could use ideas from
833

Dhurandhar & Wang

the theory of random walks to determine tendencies of the label generation procedure. From
a learning theory perspective, one could potentially derive error bounds as functions of p
(amongst other parameters), and if one were to express p in terms of auto-correlation œÅ,
one would have error bounds as functions of œÅ. This would be of some interest since œÅ can
be computed from static graphs or given a snapshot of an evolving graph, where one does
not have to know the order in which the nodes were attached, thus making the error bound
applicable to graphs in a larger set of applications.
A related but orthogonal research problem is that of studying influence spread through
social networks (Castillo, Chen, & Lakshmanan, 2012; Kempe, Kleinberg, & Tardos, 2003).
This is an interesting research problem, where one of the primary goals is to study how
information flows through real networks. To that end it is interesting to find out which
nodes/people in the network are likely to be the most influential so that targetting these
people can lead to rapid information spread. This is something that marketing departments
of consumer product companies are very interested in for obvious reasons. Though there are
some commonalities between this research problem and ours, such as having to learn and
perform inference over real graphs, the objectives are quite different. In our case, we mainly
care about correctly labeling unknown nodes based on connectivity and attributes. We are
not really interested in how the information flow would be the fastest and consequently
which nodes to target to achieve this in the most efficient manner. In a certain sense, the
influence spread problem probably could be formulated as an active learning version of our
problem, where we want to choose a small number of nodes to query that would maximize
the performance of a particular class of within network classification algorithms. This is
definitely something interesting to pursue going forward.

Acknowledgments
We would like to thank Katherine Dhurandhar for proofreading the paper. We would also
like to thank the editor and the reviewers for their constructive comments.

Appendix A
We provide figures for the synthetic and real data experiments with plots for all the methods
not just the best. Figures 16, 17, 18 and 19 correspond to the synthetic experiments, while
figures 20, 21 and 22 correspond to the real data experiments.

834

Single Network Relational Transductive Learning

50

16
RN

RN

PL‚àíEM

48
MLN

Percentage Error

Percentage Error

15

LGC

14

HFGF

13

HFGFW

RDN
LGCW

12

LGC

46

HFGF
HFGFW

RDN

44

LGCW
MLN

42

11
10
0

PL‚àíEM

20
40
60
Percentage Labeled

40
0

80

20
40
60
Percentage Labeled

80

Figure 16: Performance of all the methods

Figure 17: Performance of all the methods

for PA with high autocorrelation.

for PA with low autocorrelation.

16
15

50
RN

RDN

Percentage Error

Percentage Error

PL‚àíEM

14
LGC

13
MLN

12
HFGF

11
10
9
0

HFGFW
LGCW

45

LGC

HFGF
PL‚àíEM

40

MLN
RN

35

HFGFW
LGCW

RDN

20
40
60
Percentage Labeled

30
0

80

20
40
60
Percentage Labeled

80

Figure 18: Performance of all the methods

Figure 19: Performance of all the methods

for FF with high autocorrelation.

for FF with low autocorrelation.

835

Dhurandhar & Wang

21
RN

70
MLN

19
18

PL‚àíEM

RN

60
HFGF

HFGFW
RDN

17

HFGFW

65

LGC

Percentage Error

Percentage Error

20

LGCW

HFGF

55

PL‚àíEM

50
45

LGC

LGCW

MLN

40
35

16

RDN

30
15
0

20

40
60
Percentage Labeled

25
0

80

Figure 20: Performance of all the methods

20
40
60
Percentage Labeled

Figure 21: Multi-class transductive perfor-

on the UW-CSE dataset.

mance of all the methods on the
WEBKB dataset.

50
RN

45
Percentage Error

PL‚àíEM

40
MLN

HFGF,LGC

35
30
25
20

RDN
HFGFW
LGCW

15
10
0

80

20
40
60
Percentage Labeled

80

Figure 22: Performance of all the methods
on the BREAD dataset.

836

Single Network Relational Transductive Learning

References
Barabasi, A., & Albert., R. (1999). Emergence of scaling in random networks. Science, 286,
509‚Äì512.
Belkin, M., Niyogi, P., & Sindhwani, V. (2005). On manifold regularization. In Int. Workshop on Artificial Intelligence and Statistics.
Belkin, M., Niyogi, P., & Sindhwani, V. (2006). Manifold Regularization: A Geometric
Framework for Learning from Labeled and Unlabeled Examples. Journal of Machine
Learning Research, 7, 2399‚Äì2434.
Castillo, C., Chen, W., & Lakshmanan, L. (2012).
Kdd‚Äô2012 tutorial: Information and influence spread in social networks. http://research.microsoft.com/enus/people/weic/kdd12tutorial inf.aspx.
Chakrabarti, S., Dom, B., & Indyk, P. (1998). Enhanced hypertext categorization using
hyperlinks. In Proceedings of SIGMOD-98, ACM International Conference on Management of Data, pp. 307‚Äì318, Seattle, US. ACM Press, New York, US.
Chu, W., Sindhwani, V., Ghahramani, Z., & Keerthi, S. (2007). Relational learning with
gaussian processes. In Advances in Neural Information Processing Systems 19, pp.
289‚Äì296. MIT Press.
Chung, F. (1997). Spectral graph theory. No. 92. Amer Mathematical Society.
Craven, M., DiPasquo, D., Freitag, D., McCallum, A., Mitchell, T., Nigam, K., & Slattery,
S. (1998). Learning to extract symbolic knowledge from the world wide web. In Proceedings of the fifteenth national/tenth conference on Artificial intelligence/Innovative
applications of artificial intelligence, AAAI, pp. 509‚Äì516. American Association for
Artificial Intelligence.
Dhurandhar, A., & Dobra, A. (2012). Distribution free bounds for relational classification.
Knowledge and Information Systems, 1.
Gallagher, B., Tong, H., Eliassi-Rad, T., & Faloutsos, C. (2008). Using ghost edges for classification in sparsely labeled networks. In KDD ‚Äô08: Proc. of the 14th ACM SIGKDD
Intl. conf. on Knowledge discovery and data mining, pp. 256‚Äì264, New York, NY,
USA. ACM.
Getoor, L., Koller, D., & Small, P. (2004). Understanding tuberculosis epidemiology using
probabilistic relational models. Journal of Artificial Intelligence in Medicine, 30, 233‚Äì
256.
Getoor, L., & Taskar, B. (2007). Introduction to Statistical Relational Learning. MIT Press.
Goldberg, A., Zhu, X., & Wright, S. (2007). Dissimilarity in graph-based semi-supervised
classification. In Artificial Intelligence and Statistics (AISTATS).
Goodman, L., & Kruskal, W. (1954). Measures of association for cross classifications. Journal of the American Statistical Association, 49, 732‚Äì764.
Jebara, T., & Shchogolev, V. (2006). B-matching for spectral clustering. In Proc. of the 17th
European conf. on Machine Learning, ECML‚Äô06, Berlin, Heidelberg. Springer-Verlag.
837

Dhurandhar & Wang

Jebara, T., Wang, J., & Chang, S. (2009). Graph construction and b-matching for semisupervised learning. In Proc. of the 26th Annual Intl. Conf. on Machine Learning,
ICML ‚Äô09, pp. 441‚Äì448, New York, NY, USA. ACM.
Kempe, D., Kleinberg, J., & Tardos, E. (2003). Maximizing the spread of influence through
a social network. In Proceedings of the ninth ACM SIGKDD international conference
on Knowledge discovery and data mining, KDD ‚Äô03, pp. 137‚Äì146, New York, NY,
USA. ACM.
Leskovec, J., Kleinberg, J., & Faloutsos, C. (2007). Graph evolution: Densification and
shrinking diameters. ACM Trans. Knowl. Discov. Data, 1 (1), 2.
Liu, W., & Chang, S. (2009). Robust multi-class transductive learning with graphs. In
Computer Vision and Pattern Recognition, 2009., pp. 381‚Äì388. IEEE.
Macskassy, A., & Provost, F. (2003). A simple relational classifier..
Macskassy, S., & Provost, F. (2007). Classification in networked data: A toolkit and a
univariate case study. J. Mach. Learn. Res., 8, 935‚Äì983.
Maier, M., Von Luxburg, U., & Hein, M. (2008). Influence of graph construction on graphbased clustering measures. In Proc. of Neural Infor. Proc. Sys.
Neville, J., & Jensen, D. (2007). Relational dependency networks. J. Mach. Learn. Res., 8,
653‚Äì692.
Richardson, M., & Domingos, P. (2006). Markov logic networks. Mach. Learn., 62 (1-2),
107‚Äì136.
Sen, P., Namata, G. M., Bilgic, M., Getoor, L., Gallagher, B., & Eliassi-Rad, T. (2008).
Collective classification in network data. AI Magazine, 29 (3).
Taskar, B., Abbeel, P., & Koller, D. (2002). Discriminative probabilistic models for relational
data. In In Proc. 18th Conference on Uncertainty in AI, pp. 485‚Äì492.
Tong, W., & Jin, R. (2007). Semi-supervised learning by mixed label propagation. In
Proceedings of the National Conference on Artificial Intelligence.
Wang, J., Jebara, T., & Chang, S. (2013). Semi-supervised learning using greedy max-cut.
Journal of Machine Learning Research, 14, 729‚Äì758.
Wang, J., Jebara, T., & fu Chang, S. (2008). Graph transduction via alternating minimization. In In Proceedings of International Conference on Machine Learning.
Xiang, R., & Neville, J. (2008). Pseudolikelihood em for within-network relational learning.
In Proceedings of the 2008 Eighth IEEE International Conference on Data Mining,
pp. 1103‚Äì1108, Washington, DC, USA. IEEE Computer Society.
Xiang, R., Neville, J., & Rogati, M. (2010). Modeling relationship strength in online social
networks. In Proc. of the 19th Intl. conf. on World wide web, New York, NY, USA.
ACM.
Zhou, D., Bousquet, O., Lal, T., Weston, J., & Schlkopf, B. (2004). Learning with local
and global consistency. In Advances in Neural Information Processing Systems 16,
pp. 321‚Äì328. MIT Press.
838

Single Network Relational Transductive Learning

Zhu, X., Ghahramani, Z., & Lafferty, J. (2003). Semi-supervised learning using gaussian
fields and harmonic functions. In Proceedings of ICML, pp. 912‚Äì919.
Zhu, X., Lafferty, J., & Rosenfeld, R. (2005). Semi-supervised learning with graphs. Ph.D.
thesis, Carnegie Mellon University, Language Technologies Institute, School of Computer Science.

839

Journal of Artificial Intelligence Research 48 (2013) 717-732

Submitted 6/13; published 11/13

Research Note
A Case of Pathology in Multiobjective Heuristic Search
JoseÃÅ Luis PeÃÅrez de la Cruz
Lawrence Mandow
Enrique Machuca

perez@lcc.uma.es
lawrence@lcc.uma.es
machuca@lcc.uma.es

Dpto. Lenguajes y Ciencias de la ComputacioÃÅn
Universidad de MaÃÅlaga
Bulevar Louis Pasteur, 35. Campus de Teatinos, 29071
MaÃÅlaga (Spain)

Abstract
This article considers the performance of the MOA* multiobjective search algorithm
with heuristic information. It is shown that in certain cases blind search can be more
efficient than perfectly informed search, in terms of both node and label expansions.
A class of simple graph search problems is defined for which the number of nodes grows
linearly with problem size and the number of nondominated labels grows quadratically. It
is proved that for these problems the number of node expansions performed by blind MOA*
grows linearly with problem size, while the number of such expansions performed with a
perfectly informed heuristic grows quadratically. It is also proved that the number of label
expansions grows quadratically in the blind case and cubically in the informed case.

1. Introduction
Heuristic search algorithms are central to problem solving in Artificial Intelligence and to
many practical applications in Operations Research. In heuristic search some additional
information is provided to the algorithm with the aim of reducing the computational effort
needed to find a solution.
However, sometimes this goal is not achieved. On the contrary, in certain cases it
has been shown that the use of better heuristics implies a worsening of performance. For
example, a well-known fact arising in some bipersonal games is that of lookahead pathology,
that is, that the deeper is the exploration performed (and hence the better is suppossedly
the heuristic minimax value assigned to the position), the worse is the decision taken (Nau,
1982). Recently, the same phenomenon was described in one-agent real-time search (Lustrek
& Bulitko, 2008; Nau, Lustrek, Parker, Bratko, & Gams, 2010).
Even with statically precomputed heuristics some pathologies have been found. For
instance, let us consider the standard A* algorithm (Hart, Nilsson, & Raphael, 1968). It
is known that the algorithm is admissible when provided with optimistic heuristic cost
estimates and that, when these estimates are also consistent, more informed heuristics
always result in equally or more efficient search (see Pearl, 1984, especially pp. 75‚Äì85).
However, when the heuristic is optimistic but not consistent, algorithm A* can perform
O(2n ) node expansions when the search is performed on a graph with n nodes and arc costs
are not bounded (Martelli, 1977). Notice that if no heuristic is used, then A* performs like
Dijkstra‚Äôs algorithm and can never exhibit such exponential performance.
c
2013
AI Access Foundation. All rights reserved.

PeÃÅrez de la Cruz, Mandow, & Machuca

This paper deals with a pathology arising in certain extension of A* to multiobjective
search problems. In decision making situations where more than one criterion is involved,
the concept of optimal solution is frequently replaced by Pareto optimality, that is, a solution is better than other if it improves with respect to at least one criterion without
worsening the others (Ehrgott, 2005). Since Pareto optimality is a partial order relation,
solving these problems usually results in a set of Pareto-optimal solutions, that represent
the optimal trade-offs between the criteria being optimized. The importance of research in
multiobjective search algorithms is two-fold. In the first place, many graph search problems can benefit directly from multiobjective analysis (De Luca Cardillo & Fortuna, 2000;
Gabrel & Vanderpooten, 2002; Refanidis & Vlahavas, 2003; MuÃàller-Hannemann & Weihe,
2006; Dell‚ÄôOlmo, Gentili, & Scozzari, 2005; Ziebart, Dey, & Bagnell, 2008; Wu, Campbell,
& Merz, 2009; Delling & Wagner, 2009; Fave, Canu, Iocchi, Nardi, & Ziparo, 2009; Mouratidis, Lin, & Yiu, 2010; Caramia, Giordani, & Iovanella, 2010; Boxnick, KloÃàpfer, Romaus, &
KloÃàpper, 2010; KloÃàpper, Ishikawa, & Honiden, 2010; Wu, Campbell, & Merz, 2011; Machuca
& Mandow, 2011). On the other hand, other multicriteria preference models used in graph
search typically look for a subset of Pareto-optimal solutions (Mandow & PeÃÅrez de la Cruz,
2003; Perny & Spanjaard, 2005; Galand & Perny, 2006; Galand & Spanjaard, 2007; Galand,
Perny, & Spanjaard, 2010). Therefore, improvements in performance of multiobjective algorithms can guide the development of efficient algorithms for other multicriteria decision
rules.
Two direct extensions of A* that accept general (multiobjective) heuristic functions have
been proposed in the literature: MOA* (Stewart & White, 1991) and NAMOA* (Mandow
& PeÃÅrez de la Cruz, 2005). NAMOA* uses label selection to guide the exploration. From
a formal point of view, a recent analysis (Mandow & PeÃÅrez de la Cruz, 2010a) has shown
that the algorithm is admissible with optimistic heuristics, and that its efficiency, measured
by the number of label expansions, improves with more informed consistent heuristics.
Furthermore, the number of such expansions is optimal with respect to a class of admissible
algorithms. In other words, NAMOA* inherits the beneficial properties of A*.
MOA* uses node selection (as opposed to label selection) to guide the exploration, and
is also known to be admissible with optimistic heuristics (Stewart & White, 1991). The
development of MOA* prompted a number of related formal developments and extensions
(Dasgupta, Chakrabarti, & DeSarkar, 1995, 1999; Perny & Spanjaard, 2002; Mandow &
PeÃÅrez de la Cruz, 2003; Perny & Spanjaard, 2005), and is still cited as an algorithm of
choice in recent applications (De Luca Cardillo & Fortuna, 2000; Fave et al., 2009; KloÃàpper
et al., 2010). A previous formal analysis showed that there exist problems for which blind
MOA* performs Œò(2n ) node expansions on graphs with n nodes (Mandow & PeÃÅrez de la
Cruz, 2010b). However, the formal analysis of MOA* remained incomplete. In particular,
the efficiency of the algorithm was never related to the precision of consistent heuristics. A
recent empirical analysis (Machuca, Mandow, PeÃÅrez de la Cruz, & Ruiz-SepuÃÅlveda, 2010)
has shown that, in certain cases, MOA* performs much worse than NAMOA* over biobjective random problems with different correlations. Quite surprisingly, this analysis has
also revealed that heuristic MOA* actually performs consistently worse than uninformed
MOA*.
This paper is part of an investigation into the formal properties of MOA* and NAMOA*.
We formally show that the performance of MOA*, measured in terms of the number of
718

A Case of Pathology in Multiobjective Heuristic Search

label or node expansions, does not improve in general with more informed heuristics. More
precisely, we define a class of simple graph search problems and prove that the use of
perfect heuristic information in MOA* yields more computational effort than the use of no
heuristic information. In other words, blind MOA* is in these cases more efficient than
perfectly informed MOA*, in terms of both node and label expansions.
The article is organized as follows. First, some necessary concepts are presented and
algorithm MOA* is briefly described (Section 2). Then in Section 3 a class of simple
multiobjective search problems is defined. The performance of MOA* over this class of
problems is analyzed for blind and perfectly informed cases in Sections 4 and 5 in terms of
node expansions, and in Section 6 in terms of label expansions. Finally, some conclusions
and future work are described.

2. Background
In multiobjective decision problems each alternative is evaluated according to a set of q
different objectives usually grouped in a vector ~y = (y1 , y2 , . . . yq ), ~y ‚àà Rq . Preference
between vectors ~x, ~y is defined by the so-called Pareto order or dominance relation (‚â∫) as
follows: ~x ‚â∫ ~y if and only if for all objectives i it holds that xi ‚â§ yi and at least for an
objective j it holds that xj < yj . Given a set of vectors Y , the subset of nondominated
vectors nd(Y ) in Y is defined as nd(Y ) = {~y ‚àà Y | @~x ‚àà Y ~x ‚â∫ ~y }.
The solution to a multiobjective problem consists of the set of Pareto-optimal or nondominated solutions, that is, the set of solutions such that their costs are nondominated in
the set of solution costs.
In a multiobjective graph search problem, a single source and a set of destination nodes
are designated in a given graph G = (N, A). Pairs of nodes n, n0 ‚àà N may be joined by
directed arcs (n, n0 ) ‚àà A labelled with vector costs ~c(n, n0 ) ‚àà Rq . A path P in the graph is
any sequence of nodes joined by consecutive arcs and the cost ~c(P ) of P is the sum of the
costs of its component arcs. The solution to the problem is the set of all paths P joining
source and destination nodes and such that ~c(P ) is nondominated in the set of solution
costs.
2.1 MOA* Algorithm
MOA* is a well-known algorithm that performs multiobjective heuristic graph search (Stewart & White, 1991). Its pseudocode (slightly adapted from the original: Stewart & White,
1991) is presented in Table 1. MOA* presents many similarities with A*. Two sets of nodes
OP EN and CLOSED are used to control the search. Initially, the source node is the only
open node. Newly generated nodes create a pointer to their parents. However, MOA* does
not construct a search tree like A*, but rather an acyclic directed graph. This is due to the
fact that each node may be reached by several optimal (nondominated) paths. The scalar
cost functions g, h, f are generalized to functions G, H, F that return sets of vectors for each
node. Additionally, the LABEL(n0 , n) sets keep the subsets of vectors in G(n0 ) that arise
from paths to n0 coming from n.
Function G(n) refers to the set of nondominated cost vectors among all paths already
found to n. The heuristic function H(n) returns also a set of vectors, estimating the costs of
719

PeÃÅrez de la Cruz, Mandow, & Machuca

1. INITIALIZE a set OP EN with the start node s, and empty sets, SOLN , C, CLOSED and LABEL.
2. CALCULATE the set N D of nodes n in OP EN such that at least one estimate f~ ‚àà F (n) is not
dominated by the estimates of other open nodes or by any solution cost of C.
3. If N D is empty, then
‚ÄîTerminate returning the set of solution paths that reach nodes in SOLN with costs in C.
else
‚ÄîChoose a node n from N D using a domain-specific heuristic, breaking ties in favour of goal nodes,
and move n from OP EN to CLOSED.
4. Do bookkeeping to maintain accrued costs and node selection function values.
5. IDENTIFY SOLUTIONS. If n is solution node, then
‚ÄîInclude n in SOLN and its current costs into C.
‚ÄîRemove dominated costs from C.
‚ÄîGo back to step 2.
6. EXPAND n and examine its successors. For all successors nodes m of n do:
(a) If m is a newly generated node, then
i.
ii.
iii.
iv.

Establish a pointer from m to n.
Set G(m) = LABEL(m, n).
Compute F (m).
Add m to OP EN .

(b) Otherwise, m is not new, so do the following,
i. If any potentially nondominated paths to m have been discovered, then, for each one, do
the following.
‚ÄîEnsure that its cost is in LABEL(m, n), and therefore in G(m).
‚ÄîIf a new cost was added to G(m) then, purge from LABEL(m, n) dominated costs, and
if m was in CLOSED, then move it to OP EN .
7. Go back to step 2.

Table 1: MOA‚àó Algorithm.
all nondominated paths from n to destination nodes. The evaluation function F (n) returns
a set of cost estimates for n, F (n) = nd{~g + ~h | ~g ‚àà G(n) ‚àß ~h ‚àà H(n)}.
Later on it will be useful to define H ‚àó (n) as the function that returns the set of costs of
all actual nondominated paths from n to destinations nodes.
At each iteration MOA* computes ND, the subset of open nodes with a nondominated
cost estimate, and selects a node from this subset. The admissibility of the algorithm does
not depend on the particular selection procedure among nodes in ND. In the following, this
additional selection procedure for nondominated nodes will be called nd-selection rule.
When a destination node is selected, it is added to SOLN, and its costs to C. Values of
F (n) dominated by vectors in C are never considered in ND. Search terminates when ND
is empty, that is, all candidate nodes are dominated or have been explored.
The expansion of n generates all successors n0 of n in the graph and adequate G(n0 )
values for them. If n0 is new, then it is placed in OPEN, and the sets G(n0 ) and LABEL(n0 , n)
store the costs of all paths extended from n to n0 . If n0 is not new, then MOA* checks if
720

A Case of Pathology in Multiobjective Heuristic Search

a new nondominated value of G(n0 ) has been generated at the current step; if this is the
case, G(n0 ) and LABEL(n0 , n) are properly updated, and, if n0 was in CLOSED, it must
be moved back again to OPEN.
Each pair (n, ~g ) such that n is a node and ~g ‚àà G(n) is usually called a label. In MOA*
all labels of a node n are expanded simultaneously once n is selected. Therefore, all labels
reaching a single node at a given time are either simultaneously open or closed.
In the original paper (Stewart & White, 1991), some interesting properties of MOA*
were proved. For example, it was proved that MOA* is admissible when H(n) is optimistic.
Regarding comparison of admissible heuristics, a function H(n) is defined to be at least
as informed as another H 0 (n) whenever for all ~h0 ‚àà H 0 (n) there exists some ~h ‚àà H(n) such
that ~h0  ~h. In such case, it was proved that the set of nodes expanded by MOA* with H is
a subset of those expanded with H 0 (theorem 4, p. 805). However, the authors recognized
that nodes may be reopened even when the heuristic function is consistent, and hence that
the set of expanded nodes is not a significant measure in the analysis of the performance of
MOA*.

Figure 1: Graph M (3, 10, 10, 2)

3. A Class of Multiobjective Search Problems
For every n ‚àà N, let us consider problem graphs (Figure 1) with 2n nodes labeled 1, . . . , 2n‚àí
1, 2n and with 3n ‚àí 2 arcs. For every even node 2i (1 ‚â§ i < n) there are outgoing arcs
of form (2i, 2i + 1) and (2i, 2i + 2). For every odd node 2i + 1 (1 ‚â§ i < n ‚àí 1) there is
an outgoing arc of the form (2i + 1, 2i + 2). There is also an arc (1, 2). The start node
is 1 and the goal node is 2n. The cost of an arc ~c(i, j) is defined as follows: choose Œ±
to be either 2 or 4; then for every i > 0, ~c(2i, 2i + 2) = (Œ±, 6 ‚àí Œ±); and for every i > 0,
~c(2i, 2i + 1) = ~c(2i + 1, 2i + 2) = (3 ‚àí Œ±/2, Œ±/2). In this way, we define only two possible
sets of costs for the arcs, with the exception of ~c(1, 2) = (Œ∫1 , Œ∫2 ) that is not subject to any
restriction.
We shall refer to these problem graphs as multiobjective chain graphs. For every n, the
corresponding set of multiobjective chain graphs will be denoted Mn . We will denote as
M (n, Œ∫1 , Œ∫2 , Œ±) the graph in Mn such that ~c(1, 2) = (Œ∫1 , Œ∫2 ) and c(2i, 2i + 2) = (Œ±, 6 ‚àí Œ±).
For example, Figure 1 shows M (3, 10, 10, 2).
In a graph M ‚àà Mn there are always 2n‚àí1 different paths from the start to the goal
node. In fact, to go from 2i to 2i + 2 you can choose either the simple path < 2i, 2i + 2 >
(with cost (Œ±, 6 ‚àí Œ±)) or the two-arc path < 2i, 2i + 1, 2i + 2 > (with cost (6 ‚àí Œ±, Œ±)) and
there are n ‚àí 1 independent choices like that. On the other hand, there are just n different
path costs given by c~n k = (Œ∫1 , Œ∫2 ) + (2(n ‚àí 1) + 2k, 4(n ‚àí 1) ‚àí 2k), for every k such that
721

PeÃÅrez de la Cruz, Mandow, & Machuca

It. #
1
2
3
4
5
6

OPEN
1‚Üê
2‚Üê
3‚Üê
4
4‚Üê
5‚Üê
6
6‚Üê

G(n) = F (n)
(0, 0)
(10, 10)
(12, 11)
(12, 14)
(12, 14)(14, 12)
(14, 15)(16, 13)
(14, 18)(16, 16)
(14, 18)(16, 16)(18, 14)

Table 2: Trace of uninformed MOA* on M (3, 10, 10, 2)

0 ‚â§ k ‚â§ n ‚àí 1. In an M (n, Œ∫1 , Œ∫2 , 2) graph, the cost c~n k corresponds to a path with n ‚àí 1 ‚àí k
arcs (2i, 2i + 2) and k paths < 2i, 2i + 1, 2i + 2 >. We will denote Cn = {c~n 0 , . . . , c~n n‚àí1 }.
Notice that for every solution cost (y1 , y2 ) ‚àà Cn it holds that y1 + y2 = Œ∫1 + Œ∫2 + 6(n ‚àí 1),
so all solution costs for a given M lie in a line with negative slope and hence none of these
costs dominates another, that is, nd(Cn ) = Cn .

4. Blind MOA* on Mn
A sample run of MOA* over M (3, 10, 10, 2) (Figure 1) with H(n) = {~0} (uninformed case)
is provided in Table 2. Values of G(n) include all nondominated costs from generated paths
to the node. Since we are performing a blind search, values for F (n) are the same as for
G(n).
We can observe in this trace that a node i is not selected until all nodes j < i have
been selected. That means that every node i, 1 ‚â§ i ‚â§ 2n ‚àí 1 is expanded once and just
once. In this way, in our example MOA* performs exactly 2n node selections and 2n ‚àí 1
node expansions. This result is general and can be proved by induction on the number of
iterations for every graph M (n, Œ∫1 , Œ∫2 , Œ±).
Lemma 1 If the input of MOA* is a graph M (n, Œ∫1 , Œ∫2 , Œ±) and ‚àÄn H(n) = {~0}, then MOA*
performs exactly 2n ‚àí 1 node expansions.
Proof. Let us consider the OPEN set at a certain iteration s (s = 1, . . .) of the execution
of MOA*. Let us call the level of s the integer L = bs/2c. It is easily proved by induction
on s that:
(i) at every odd iteration s of the algorithm (s = 3, . . .), OPEN = {s, s+1}, the labels of s
are {(a+3‚àíŒ±/2, b+Œ±/2) | (a, b) ‚àà CL }; the labels of s+1 are {(a+Œ±, b+6‚àíŒ±)| (a, b) ‚àà CL };
and the selected node is s.
(ii) At every even iteration s of the algorithm (s = 4, . . .), OPEN = {s}, the labels of s
are exactly CL and the selected node is s.
From this follows that every node is selected exactly once and therefore the number of
node expansions is exactly 2n ‚àí 1.
/
722

A Case of Pathology in Multiobjective Heuristic Search

n
1
2
3
4
5
6

H ‚àó (n)
(14,18),(16,16),(18,14)
(4,8),(6,6),(8,4)
(4,5),(6,3)
(2,4),(4,2)
(2,1)
(0,0)

Table 3: Heuristic values for M (3, 10, 10, 2)

Figure 2: Search graph at iteration 2

5. Perfectly Informed MOA* on Mn
A sample run of MOA* over M (3, 10, 10, 2) (Figure 1) with H(n) = H ‚àó (n) (perfect information) is provided in Figures 2-9 and Table 4. Figures 2-9 show a trace of the search graph
at each iteration. Closed nodes are shown in gray. Values of G(n) are shown for each node
in the Figures only when they are created, or change from the previous iteration.
In Table 4, for each iteration all nodes in OPEN are displayed and also their G(n)
values (that is, nondominated costs of paths generated from the start to the node). Values
of F (n) are computed adding to G(n) values the estimations in Table 3. Since we are
assuming perfect heuristic information, F (n) values are always optimal solution costs, that
is, nondominated costs of solution paths from node 1 to node 6. Then, for every iteration
and every node n, F (n) ‚äÜ C3 .
Notice also that labels in C3 (and hence in F (n)) are all nondominated, so in general
there will be several open nondominated nodes. It is then necessary to provide an additional
heuristic rule (step 3-else of the algorithm in Table 1) or nd-selection rule. In the example in
Table 4, the following nd-selection rule is applied: select the node with the best lexicographic
nondominated alternative (remember that the lexicographic order is a total order defined
for the biobjective case as (y1 , y2 ) < (z1 , z2 ) if and only if y1 < z1 , or y1 = z1 and y2 < z2 ).
It is also possible that the same nondominated cost appears in several open nodes. Then
another procedure must be provided for breaking ties between open nodes with the same
f~-label. It can be done, for instance, at random, or by selecting the newest node, or the
oldest node in OPEN in a breadth-first fashion. The latter procedure has been followed in
Table 4.
We can observe that the order of node selection in the example is
1‚àí2‚àí4‚àí6‚àí3‚àí4‚àí6‚àí5‚àí6
The pattern is: MOA* selects even nodes until the goal node is reached; then it selects an
odd node 2i + 1 and selects again all even nodes 2j, j > i; and it is done again until every
odd node has been selected once. In this way even nodes are in general selected several
times. In our example node 4 is selected twice and node 6 is selected three times.
723

PeÃÅrez de la Cruz, Mandow, & Machuca

It#
1
2
3
4

5
6
7
8
9

OPEN
1‚Üê
2‚Üê
3
4‚Üê
3
5
6‚Üê
3‚Üê
5
4‚Üê
5
5
6‚Üê
5‚Üê
6‚Üê

G(n)
(0, 0)
(10, 10)
(12, 11)
(12, 14)
(12, 11)
(14, 15)
(14, 18)
(12, 11)
(14, 15)
(12, 14)(14, 12)
(14, 15)
(14, 15)(16, 13)
(14, 18)(16, 16)
(14, 15)(16, 13)
(14, 18)(16, 16)(18, 14))

F (n)
(14, 18)(16, 16)(18, 14)
(14, 18)(16, 16)(18, 14)
(16, 16)(18, 14)
(14, 18)(16, 16)
(16, 16)(18, 14)
(16, 16)
(14, 18)
(16, 16)(18, 14)
(16, 16)
(14, 18)(16, 16)(18, 14)
(16, 16)
(16, 16)(18, 14)
(14, 18)(16, 16)
(16, 16)(18, 14)
(14, 18)(16, 16)(18, 14)

Table 4: Trace of perfectly informed MOA* on M (3, 10, 10, 2)

Figure 3: Search graph at iteration 3

Figure 4: Search graph at iteration 4

Figure 5: Search graph at iteration 5

724

A Case of Pathology in Multiobjective Heuristic Search

Figure 6: Search graph at iteration 6

Figure 7: Search graph at iteration 7

Figure 8: Search graph at iteration 8

Figure 9: Search graph at iteration 9

725

PeÃÅrez de la Cruz, Mandow, & Machuca

The concrete order of expansion will depend on nd-selection and tie-breaking rules.
However, we can prove some general results valid for any nd-selection rule that uses only
heuristic f~ values (irrespective of the tie-breaking rule). Notice that nd-selection rules
usually applied (as best lexicographic or best linear) are of this kind.
Lemma 2 (i) Let M (n, Œ∫1 , Œ∫2 , 2) ‚àà Mn . Let their nondominated solution costs be C =
{~
c 0 , . . . , c~ n‚àí1 }. If the nd-selection rule is such that c~ 0 is selected with preference to
{~
c 1 , . . . , c~ n‚àí1 }, then MOA* performs at least n + n(n‚àí1)
node expansions.
2
(ii) Analogously, let M (n, Œ∫1 , Œ∫2 , 4) ‚àà Mn . If the nd-selection rule is such that c~ n‚àí1 is
selected with preference to {~
c 0 , . . . , c~ n‚àí2 }, then MOA* performs at least n + n(n‚àí1)
node
2
expansions.
Proof. We will prove part (i) (proof of part (ii) is entirely analogous). Let M (n, Œ∫1 , Œ∫2 , 2) ‚àà
Mn . First remember that for each node j and each iteration s of the algorithm, the set
F (j) of estimated costs at j is a subset of Cn = {~
c 0 , . . . , c~ k , . . . , c~ n‚àí1 } = {(Œ∫1 + (2(n ‚àí
1) + 2k, Œ∫2 + 4(n ‚àí 1) ‚àí 2k)) | 0 ‚â§ k ‚â§ n ‚àí 1}. Let us trace the first n + 1 iterations of the
algorithm. It can be shown that for every i > 0, c~ 0 will appear in F (2i), but c~ 0 will never
appear in F (2i + 1). Therefore, in the first iteration node 1 will be selected and expanded.
Then all even nodes will be selected and expanded sequentially until node 2i is selected.
That amounts to the first n expansions.
Elementary computations show that at this step, for every 0 < i ‚â§ n, F (2i) = {~
c 0, . . . ,
n‚àíi
1
n‚àíi
c~
}; for every 0 < i ‚â§ n‚àí1, F (2i+1) = {~
c , . . . , c~
}; and OP EN = {3, 5, . . . , 2n‚àí1}.
Two observations can be made at this step: i) Let us consider odd nodes. Since for every odd
node 2i + 1 (0 < i < n) there is an optimal path going through it, all these open nodes must
be selected and expanded before termination. That amounts to at least n ‚àí 1 expansions,
even if no reexpansion is assumed for such nodes; ii) Let us consider now nongoal even
nodes {2, 4, . . . , 2n ‚àí 2}. At this iteration the number of labels associated to 2i is n + 1 ‚àí i.
Since through every even node there exist n optimal costs, at the termination the number of
labels for every even node must be exactly n, that is, there are 0 + 1 + . . . + (n ‚àí 1) = n(n‚àí1)
2
labels for even nodes missing at this moment. If we prove that those labels are generated
one at a time, that is, one in every expansion, we will have proved that at least another
n(n‚àí1)
expansions are needed.
2
Let us call an episode the subsequence of node expansions comprised between two consecutive odd node expansions (or between the last odd node expansion and the last expansion).
In the example of Table 4, the episodes are < 1, 2, 4, 6 >, < 3, 4, 6 > and < 5, 6 >. When
an episode starts, there is no even node in OPEN (since an even node always has the ndselected label c~ 0 , an odd node never has the nd-selected label c~ 0 , and an odd node has been
selected). At the end of the episode, and by the same reason, there is again no even node in
OPEN. Let us consider an episode e =< 2j ‚àí 1, 2j, 2j 0 , . . . , 2j n >. It is easily seen that the
expansion of an even node 2j originates the opening of just an even node, namely 2(j + 1),
so the episode is always of the form E =< 2j ‚àí 1, 2j, 2(j + 1), 2(j + 2), . . . , 2(j + m) >.
We will prove by induction on episodes that when every episode starts, for every even
node 2i (1 < i ‚â§ n) there exist integers p, q such that: i) F (2i) = {~
c 0 , . . . , ~cp }; ii)
F (2i ‚àí 2) = {~
c 0 , . . . , c~ q } = F (2i ‚àí 1) ‚à™ {~
c 0 }; and iii) either q = p or q = p + 1. This is
obviously true when the first episode finishes and the second episode starts. Assume it is
726

A Case of Pathology in Multiobjective Heuristic Search

true when episode e starts. We will show it remains true when it finishes, that is, when
episode e + 1 starts.
Consider the odd node 2j ‚àí 1 which starts the episode and assume q = p, that is,
that F (2j ‚àí 1) = F (2j) ‚àí {~
c 0 }. Then no new label is added to F (2j), no reexpansion
is needed and no modification is done, hence the stated relation among labels continues
true. On the contrary, assume that q = p + 1, that is, that F (2j ‚àí 1) = {~
c 1 , . . . , c~ p+1 },
0
p+1
0
p
F (2j ‚àí 2) = {~
c , . . . , c~
}, and F (2j) = {~
c , . . . , c~ }. Therefore one label c~ p+1 is added
to 2j. The stated relation between labels remain true for 2j ‚àí 2, 2j ‚àí 1 and 2j (only that
we have now the other alternative p = q). However, F (2j) has been modified and we must
check the relation for F (2j), F (2j + 1) and F (2j + 2). By hypothesis it was F (2j + 1) =
{~
c 1 , . . . , c~ p }, and the expansion of 2j adds c~ p+1 to it, so also it becomes F (2j) = F (2j +1).
Concerning the relation between F (2j) and F (2j + 2), if it was F (2j + 2) = {~
c 0 , . . . , c~ p },
no further label is added to F (2j + 2), the relation holds (since F (2j + 2) has exactly one
label less than F (2j) now) and the episode finishes since no even node remains open. If it
was F (2j + 2) = {~
c 0 , . . . , c~ p‚àí1 }, one label c~ p is added to F (2j + 2) and the relation also
becomes true, but F (2j + 2) has been modified. By induction on the length of the episode
it could be proved that finally the relation holds for all modified nodes.
In any case, we see that each new added label immediately triggers the expansion of the
node and labels are added to even nodes one at a time. Therefore, at least n(n‚àí1)
expansions
2
are needed to complete the labels of even nodes. The first expansion of the episode was one
of an odd node, so it must not be computed; but the last expansion of the episode does not
add any label, so we can compute n(n‚àí1)
additional node expansions.
2
expansions,
Now, adding togheter all performed expansions, we have at least n + n(n‚àí1)
2
q. e. d.
/

Figure 10: Construction of a M (4, Œ∫1 , Œ∫2 , 2) graph for Lemma 3

727

PeÃÅrez de la Cruz, Mandow, & Machuca

Now we can prove the main lemma:
Lemma 3 If the nd-selection rule depends only on f~ values, then for every n ‚àà N there
exists a graph M (n, Œ∫1 , Œ∫2 , Œ±) such that when it is input to MOA* and H(n) = H ‚àó (n), then
MOA* performs at least n + n(n‚àí1)
node expansions.
2
Proof. The idea of the proof is as follows: Lemma 2 asserts that if we order lexicographically the optimal costs of a graph M (n, Œ∫1 , Œ∫2 , 2) ‚àà Mn and the selected one turns out to be
the first one, then MOA* performs at least n + n(n‚àí1)
node expansions (and analogously for
2
every graph M (n, Œ∫1 , Œ∫2 , 4) ‚àà Mn when the selected one is the last one). Then we will have
Lemma 3 proved if for every n and every selection rule depending only on f~ values we show
a graph M (n, Œ∫1 , Œ∫2 , 2) ‚àà Mn satisfying that condition (or a graph M (n, Œ∫1 , Œ∫2 , 4) ‚àà Mn
satisfying the analogous condition).
Let n ‚àà N. Let us consider the line y1 + y2 = 8(n ‚àí 1) + 2 and a sequence of m = 2n ‚àí 1
nondominated points on it, (F 0 , . . . , F m‚àí1 ) given by F i = (2(n‚àí1)+2i+1, 6(n‚àí1)‚àí2i+1)
(Figure 10 shows the line and the seven points F 0 , . . . , F 6 for n = 4). Any nd-selection
rule will select one of them, say F j , with preference over the others; in any case, for any
F j we can extract from (F 0 , . . . , F m‚àí1 ) a subsequence of n points (F j , F j+1 , . . . , F j+n‚àí1 )
or (F j‚àín+1 , . . . , F j‚àí1 , F j ). Assume the first case (that is depicted in Figure 10 for j = 3;
the subsequence is F 3 , F 4 , F 5 , F 6 ). Then we will consider the graph M (n, Œ∫1 , Œ∫2 , 2) with
Œ∫1 = 2j + 1 and Œ∫2 = 2(n ‚àí 1 ‚àí j) + 1 (in Figure 10 the point K is (Œ∫1 , Œ∫2 ) = (7, 1)).
This is always possible, that is, for every n, j we have Œ∫1 , Œ∫2 > 0. But then we have for
every k, 0 ‚â§ k ‚â§ n ‚àí 1, that F j+k = (Œ∫1 , Œ∫2 ) + (2(n ‚àí 1) + 2k, 4(n ‚àí 1) ‚àí 2k) = c~ k , that
is, the extracted subsequence (F j , F j+1 , . . . , F j+n‚àí1 ) is exactly the set of solution costs for
M (n, Œ∫1 , Œ∫2 , 2), (~
c 0 , c~ 1 , . . . , c~ n‚àí1 ). Since F j is nd-selected over (F j+1 , . . . , F j+n‚àí1 ), by
Lemma 2 MOA* performs at least n + n(n‚àí1)
node expansions on M (n, Œ∫1 , Œ∫2 , 2).
2
Analogously we can prove the other case considering a graph of the form M (n, Œ∫3 , Œ∫4 , 4).
/
From Lemmas 1 and 3 we obtain immediately the following result.
Theorem 1 For every nd-selection rule depending only on f~ values, there exists a sequence
of graphs M1 , . . . , Mn , . . . such that:
(i) Every Mn has 2n nodes and 3n ‚àí 2 arcs.
(ii) MOA‚àó performs Œò(n) node expansions when applied to Mn and no heuristic information is given.
(iii) MOA‚àó performs ‚Ñ¶(n2 ) node expansions when applied to Mn and perfect heuristic
information is given.

6. Label Counts
The basic operation of MOA‚àó is node expansion and every node expansion implies ‚Äîin
the general case‚Äî the joint expansion of several labels. However, other algorithms (e.g.
NAMOA‚àó , Mandow & PeÃÅrez de la Cruz, 2010a) use label expansion as the basic operation.
For this reason it could be interesting to analyse MOA‚àó also in terms of label expansions.
Lemma 4 If the input of MOA* is a graph M (n, Œ∫1 , Œ∫2 , Œ±) and H(n) = {~0}, then MOA*
performs exactly n2 ‚àí n + 1 label expansions.
728

A Case of Pathology in Multiobjective Heuristic Search

Proof. Consider again the reasoning for the proof of Lemma 1. It was then proved that,
when selected for expansion, every even node 2i has i labels
Pand every odd node 2i + 1
(with i ‚â• 1) has i labels. Adding all together we have 1 + 2 1‚â§i‚â§n‚àí1 i = 1 + n(n ‚àí 1) =
n2 ‚àí n + 1 label expansions.
/
Lemma 5 For every n ‚àà N there exists a graph M (n, Œ∫1 , Œ∫2 , Œ±) such that when it is input to
MOA* and H(n) = H ‚àó (n), then MOA* performs at least n2 + n(n+1)(n‚àí1)
label expansions.
4
Proof. Every odd node 1, . . . , 2n ‚àí 1 must have at termination n labels, and must be
expanded at least once. That amounts to at least n2 label expansions. On the other hand,
consider even nodes 2, 4, . . . , 2n ‚àí 2. They must also have n labels at termination. Consider
again the reasoning for the proof of Lemma 2. It was then proved that: (i) the first time
an even node 2i is expanded, it has (n ‚àí i + 1) labels; (ii) each time an even node 2i is
expanded, it has exactly one more label. Therefore thePnumber of label expansions for node
2i is (n ‚àí i + 1) + (n ‚àí i + 2) + . . . + (n ‚àí i + i) = 1‚â§j‚â§i (n ‚àí i + j) = (n+1)i
2 . Adding
P
(n+1)i
togheter for all even nodes 2i with 1 ‚â§ i ‚â§ n ‚àí 1 we have 1‚â§i‚â§n‚àí1 2 = n(n+1)(n‚àí1)
4
label expansions. Adding now the expansions of odd and even nodes we have at least
n2 + n(n+1)(n‚àí1)
q. e. d.
4
/
From Lemmas 4 and 5 we obtain immediately the following result.
Theorem 2 For every nd-selection rule depending only on f~ values, there exists a sequence
of graphs M1 , . . . , Mn , . . . such that:
(i) Every Mn has 2n nodes and 3n ‚àí 2 arcs.
(ii) MOA‚àó performs Œò(n2 ) label expansions when applied to Mn and no heuristic information is given.
(iii) MOA‚àó performs ‚Ñ¶(n3 ) label expansions when applied to Mn and perfect heuristic
information is given.

7. Conclusions and Future Work
This paper considers the performance of the MOA* multiobjective heuristic search algorithm. Results show that performance can degrade with better heuristic information. A
class of problems is presented (multiobjective chain graphs) where the use of perfect heuristic information (a trivially consistent informed heuristic) does not result in a reduction in
the number of node or label expansions performed by the algorithm. On the contrary, the
performance of a perfectly informed version of the algorithm is worse than the performance
of the blind version.
Multiobjective chain graphs formalize a not so infrequent situation in practical multiobjective search, when a sequence of nodes is traversed by at least two conflicting paths. Our
analysis has revealed that when MOA* is combined with H ‚àó , the best possible heuristic,
the number of node expansions grows quadratically, while this number grows linearly when
no heuristic information is used; and the number of label expansions grows cubically, while
it grows quadratically when no heuristic information is provided.
729

PeÃÅrez de la Cruz, Mandow, & Machuca

This pathology, together with other results both theoretical (Mandow & PeÃÅrez de la
Cruz, 2010b) and empirical (Machuca, Mandow, PeÃÅrez de la Cruz, & Ruiz-SepuÃÅlveda, 2012),
casts some doubts on the suitability of MOA* for performing heuristic multiobjective search.
In general, other alternatives (such as NAMOA*) for which it has been proved (Mandow
& PeÃÅrez de la Cruz, 2010a) that those pathological behaviours cannot arise, should be
preferred.

Acknowledgments
Partially supported by Gobierno de EspanÃÉa, grant TIN2009-14179. Partially funded by
Consejerƒ±ÃÅa de InnovacioÃÅn, Ciencia y Empresa. Junta de Andalucƒ±ÃÅa (EspanÃÉa), P07-TIC03018.

References
Boxnick, S., KloÃàpfer, S., Romaus, C., & KloÃàpper, B. (2010). Multiobjective search for the
management of a hybrid energy storage system. In IEEE International Conference
on Industrial Informatics (INDIN), pp. 745‚Äì750.
Caramia, M., Giordani, S., & Iovanella, A. (2010). On the selection of k routes in multiobjective hazmat route planning. IMA Journal of Management Mathematics, 21,
239‚Äì251.
Dasgupta, P., Chakrabarti, P., & DeSarkar, S. (1995). Utility of pathmax in partial order
heuristic search. Information Processing Letters, 55, 317‚Äì322.
Dasgupta, P., Chakrabarti, P., & DeSarkar, S. (1999). Multiobjective Heuristic Search.
Vieweg, Braunschweig/Wiesbaden.
De Luca Cardillo, D., & Fortuna, T. (2000). Dea model for the efficiency evaluation of
nondominated paths on a road network. European Journal of Operational Research,
121 (3), 549‚Äì558.
Delling, D., & Wagner, D. (2009). Pareto paths with SHARC. In SEA, pp. 125‚Äì136.
Dell‚ÄôOlmo, P., Gentili, M., & Scozzari, A. (2005). On finding dissimilar Pareto-optimal
paths. European Journal of Operational Research, 162, 70‚Äì82.
Ehrgott, M. (2005). Multicriteria Optimization. Springer.
Fave, F. M. D., Canu, S., Iocchi, L., Nardi, D., & Ziparo, V. A. (2009). Multi-objective
multi-robot surveillance. In 4th International Conference on Autonomous Robots and
Agents (ICARA), pp. 68‚Äì73. IEEE.
Gabrel, V., & Vanderpooten, D. (2002). Enumeration and interactive selection of efficient
paths in a multiple criteria graph for scheduling an earth observing satellite. European
Journal of Operational Research, 139, 533‚Äì542.
Galand, L., & Perny, P. (2006). Search for compromise solutions in multiobjective state
space graphs. In Proc. of the XVII European Conference on Artificial Intelligence
(ECAI‚Äô2006), pp. 93‚Äì97.
730

A Case of Pathology in Multiobjective Heuristic Search

Galand, L., Perny, P., & Spanjaard, O. (2010). Choquet-based optimisation in multiobjective shortest path and spanning tree problems. European Journal of Operational
Research, 204 (2), 303‚Äì315.
Galand, L., & Spanjaard, O. (2007). Owa-based search in state space graphs with multiple
cost functions. In FLAIRS Conference 2007, pp. 86‚Äì91.
Hart, P., Nilsson, N., & Raphael, B. (1968). A formal basis for the heuristic determination
of minimum cost paths. IEEE Trans. Systems Science and Cybernetics SSC-4, 2,
100‚Äì107.
KloÃàpper, B., Ishikawa, F., & Honiden, S. (2010). Service composition with pareto-optimality
of time-dependent QoS attributes. Lecture Notes in Computer Science, LNCS 6470,
635‚Äì640.
Lustrek, M., & Bulitko, V. (2008). Thinking too much: Pathology in path finding. In et al.,
M. G. (Ed.), Proceedings of the European 18th Conference on Artificial Intelligence,
pp. 899‚Äì900. IOS Press.
Machuca, E., Mandow, L., PeÃÅrez de la Cruz, J. L., & Ruiz-SepuÃÅlveda, A. (2010). An
empirical comparison of some multiobjective graph search algorithms. In KI‚Äô2010 LNAI 6359, pp. 238‚Äì245.
Machuca, E., Mandow, L., PeÃÅrez de la Cruz, J. L., & Ruiz-SepuÃÅlveda, A. (2012). A comparison of heuristic best-first algorithms for bicriterion shortest path problems. European
Journal of Operational Research, 217, 44‚Äì53.
Machuca, E., & Mandow, L. (2011). Multiobjective route planning with precalculated
heuristics. In Proc. of the 15th Portuguese Conference on Artificial Intelligence (EPIA
2011), pp. 98‚Äì107.
Mandow, L., & PeÃÅrez de la Cruz, J. L. (2003). Multicriteria heuristic search. European
Journal of Operational Research, 150, 253‚Äì280.
Mandow, L., & PeÃÅrez de la Cruz, J. L. (2005). A new approach to multiobjective A*
search. In Proc. of the XIX Int. Joint Conf. on Artificial Intelligence (IJCAI‚Äô05), pp.
218‚Äì223.
Mandow, L., & PeÃÅrez de la Cruz, J. L. (2010a). Multiobjective A* search with consistent
heuristics. Journal of the ACM, 57 (5), 27:1‚Äì25.
Mandow, L., & PeÃÅrez de la Cruz, J. L. (2010b). A note on the complexity of some multiobjective A* search algorithms. In ECAI 2010, pp. 727‚Äì731.
Martelli, A. (1977). On the complexity of admissible search algorithms. Artificial Intelligence, 8, 1‚Äì13.
Mouratidis, K., Lin, Y., & Yiu, M. (2010). Preference queries in large multi-cost transportation networks. In Proceedings - International Conference on Data Engineering,
pp. 533‚Äì544.
MuÃàller-Hannemann, M., & Weihe, K. (2006). On the cardinality of the Pareto set in bicriteria shortest path problems. Annals of OR, 147 (1), 269‚Äì286.
Nau, D. S. (1982). An investigation of the causes of pathology in games. Artificial Intelligence, 19 (3), 257‚Äì278.
731

PeÃÅrez de la Cruz, Mandow, & Machuca

Nau, D. S., Lustrek, M., Parker, A., Bratko, I., & Gams, M. (2010). When is it better not
to look ahead?. Artificial Intelligence, 174 (16‚Äì17), 1323‚Äì1338.
Pearl, J. (1984). Heuristics. Addison-Wesley, Reading, Massachusetts.
Perny, P., & Spanjaard, O. (2002). On preference-based search in state space graphs. In
Proc. Eighteenth Nat. Conf. on AI, pp. 751‚Äì756. AAAI Press.
Perny, P., & Spanjaard, O. (2005). A preference-based approach to spanning trees and
shortest paths problems. European Journal of Operational Research, 162, 584‚Äì601.
Refanidis, I., & Vlahavas, I. (2003). Multiobjective heuristic state-space search. Artificial
Intelligence, 145, 1‚Äì32.
Stewart, B. S., & White, C. C. (1991). Multiobjective A*. Journal of the ACM, 38 (4),
775‚Äì814.
Wu, P.-Y., Campbell, D., & Merz, T. (2009). On-board multi-objective mission planning
for unmanned aerial vehicles. In IEEE Aerospace Conference Proceedings, pp. 1‚Äì10.
Wu, P.-Y., Campbell, D., & Merz, T. (2011). Multi-objective four-dimensional vehicle
motion planning in large dynamic environments. IEEE Transactions on Systems,
Man, and Cybernetics, Part B: Cybernetics, 41 (3), 621‚Äì634.
Ziebart, B., Dey, A., & Bagnell, J. (2008). Fast planning for dynamic preferences. In ICAPS
2008 - Proceedings of the 18th International Conference on Automated Planning and
Scheduling, pp. 412‚Äì419.

732

Journal of Artificial Intelligence Research 48 (2013) 953-1000

Submitted 09/13; published 12/13

A Constraint Solver for Flexible Protein Models
Federico Campeotto

campe8@nmsu.edu

Dept. Computer Science, New Mexico State University
Depts. Math. & Computer Science, University of Udine

Alessandro Dal PaluÃÄ

alessandro.dalpalu@unipr.it

Dept. Math. & Computer Science, University of Parma

Agostino Dovier

agostino.dovier@uniud.it

Dept. Math. & Computer Science, University of Udine

Ferdinando Fioretto

ffiorett@cs.nmsu.edu

Dept. Computer Science, New Mexico State University
Depts. Math. & Computer Science, University of Udine

Enrico Pontelli

epontell@cs.nmsu.edu

Dept. Computer Science, New Mexico State University

Abstract
This paper proposes the formalization and implementation of a novel class of constraints aimed at modeling problems related to placement of multi-body systems in the
3-dimensional space. Each multi-body is a system composed of body elements, connected
by joint relationships and constrained by geometric properties. The emphasis of this investigation is the use of multi-body systems to model native conformations of protein
structures‚Äîwhere each body represents an entity of the protein (e.g., an amino acid, a
small peptide) and the geometric constraints are related to the spatial properties of the
composing atoms. The paper explores the use of the proposed class of constraints to support
a variety of different structural analysis of proteins, such as loop modeling and structure
prediction.
The declarative nature of a constraint-based encoding provides elaboration tolerance
and the ability to make use of any additional knowledge in the analysis studies. The filtering
capabilities of the proposed constraints also allow to control the number of representative
solutions that are withdrawn from the conformational space of the protein, by means of
criteria driven by uniform distribution sampling principles. In this scenario it is possible to
select the desired degree of precision and/or number of solutions. The filtering component
automatically excludes configurations that violate the spatial and geometric properties of
the composing multi-body system. The paper illustrates the implementation of a constraint
solver based on the multi-body perspective and its empirical evaluation on protein structure
analysis problems.

1. Introduction
Constraint Programming (CP) is a declarative programming methodology that has gained
a predominant role in addressing large scale combinatorial and optimization problems. As
a paradigm, CP provides the tools necessary to guide the modeling and resolution of search
problems‚Äîin particular, it offers declarative problem modeling (in terms of variables and
constraints), the ability to rapidly propagate the effects of search decisions, and flexible
and efficient procedures to explore the search space of possible solutions. The field of CP
c
2013
AI Access Foundation. All rights reserved.

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

has its roots on the seminal work by Sutherland (1963) in the Sketchpad system, and the
successive efforts in systems like CONSTRAINTS (Sussmann & Steele, 1980) and ThingLab
(Borning, 1981). Over the years, CP has become a paradigm of choice to address hard search
problems, drawing and integrating ideas from diverse domains, like Artificial Intelligence
and Operations Research (Rossi, van Beek, & Walsh, 2006). The declarative nature of
CP enables fast and natural modeling of problems, facilitating not only development, but
the rapid exploration of different models and resolution techniques (e.g., modeling choices,
search heuristics).
In recent years, several research groups have started appreciating the potential of constraint programming within the realm of Bioinformatics. The field of Bioinformatics presents
a number of open research problems that are grounded in critical exploration of combinatorial search space, highly suitable to be manipulated through constraint-based search.
Constraint methodologies have been applied to analyze DNA sequences for instance, to
locate Cis-regulatory elements (Guns, Sun, Marchal, & Nijssen, 2010), to DNA restriction
maps construction (Yap & Chuan, 1993), and to pair-wise and multiple sequence alignment (Yang, 1998; Yap, 2001; Tsai, Huang, Yu, & Lu, 2004). Constraint methodologies
have been applied to biological networks (Corblin, Trilling, & Fanchon, 2005; Larhlimi &
Bockmayr, 2009; Ray, Soh, & Inoue, 2010; Gay, Fages, Martinez, & Soliman, 2011; Gebser,
Schaub, Thiele, & Veber, 2011) and to other biological inference problems, such as Haplotype inference (Graca, Marques-Silva, Lynce, & Oliveira, 2011; Erdem & Ture, 2008), and
phylogenetic inference (Erdem, 2011).
A particular area of Bioinformatics that has witnessed an extensive use of CP techniques
is the domain of structural biology‚Äîi.e., the branch of molecular biology and biochemistry
that deals with the molecular structure of nucleic acids and proteins, and how the structure
affects behavior and functions. Constraint Programming has progressively gained a pivotal
role in providing effective ways to explore the space of conformations of macromolecules,
to address problems like secondary and tertiary structure prediction, flexibility, motif discovery, docking (Backofen, Will, & Bornberg-Bauer, 1999; Krippahl & Barahona, 2002;
Thebault, de Givry, Schiex, & Gaspin, 2005; Dal PaluÃÄ, Dovier, & Pontelli, 2007; Mann
& Dal PaluÃÄ, 2010; Shih & Hwang, 2011; Krippahl & Barahona, 2005; Dal PaluÃÄ, Spyrakis,
& Cozzini, 2012b; Chelvanayagam, Knecht, Jenny, Benner, & Gonnet, 1998; Yue & Dill,
2000). Two comprehensive surveys on the use of constraint-based methods in structural
Bioinformatics have been recently proposed (Dal PaluÃÄ, Dovier, Fogolari, & Pontelli, 2012a;
Barahona & Krippahl, 2008).
Our focus in this work is on the use of constraint-based technology to support structural
studies of proteins. Proteins are macromolecules of fundamental importance in the way they
regulate vital functions in all biological processes. Their structural properties are critical in
determining the biological functions of proteins (Skolnick, Fetrow, & Kolinski, 2000; Baker
& Sali, 2001) and in investigating protein-protein interactions, which are central to virtually all cellular processes (Alberts, Johnson, Lewis, Raff, Roberts, & Walter, 2007). We
refer to the Protein Structure Prediction (PSP) problem as the problem of determining the
tertiary structure of a protein from knowledge of its primary structure and/or from knowledge of other structures (e.g., secondary structure components, templates from homologous
proteins). The PSP problem is also often broken down to specialized classes of problems
related to specific aspects of the tertiary structure of a protein, such as side-chain geometry
954

A Constraint Solver for Flexible Protein Models

prediction (Dunbrack, 2002), loop modeling prediction (Go & Scheraga, 1970; Xiang, Soto,
& Honig, 2002; Rufino, Donate, Canard, & Blundell, 1997; Soto, Fasnacht, Zhu, Forrest, &
Honig, 2008), and protein flexibility investigation (Bennett & Huber, 1984).
All these classes of problems share common roots‚Äîthe need to track the possible conformations of chains of amino acids. The variations of the problem relate to factors like the
length of the chain being considered (from short peptides in the case of loop modeling to
entire proteins in the general PSP case) and the diverse criteria employed in the selection
of the solutions, as, for instance, the lowest basin of the effective energy surface, composed
by the intra-molecular energy of the protein plus the solvation free energy (Karplus &
Shakhnovich, 1992; Lazaridis, Archontis, & Karplus, 1995).
Modeling the variability of a protein chain involves many degrees of freedom which are
needed to represent different protein conformations. Tracking this variability requires the
exploration of a vast conformational space. Model simplifications can be adopted to reduce
such computational cost, for instance backbone-only models represent only the backbone of
proteins, the side-chain representation could be simplified to a single central point (centroid)
describing its center of mass, or one can adopt approximated representation of the space
though lattice models.
Nevertheless, even under strong simplifications, the search space remains intractable
and prevents the use of brute-force search methods in the space of possible conformations
(Crescenzi, Goldman, Papadimitriou, Piccolboni, & Yannakakis, 1998).
Constraint programming methodologies have found natural use in addressing PSP and
related problems‚Äîwhere structural and chemical properties have been modeled in terms
of constraints over spatial positions of atoms, transforming the search of conformations
into a constraint satisfaction/optimization problem. The proposed approaches range from
pure ab initio methods (Backofen et al., 1999; Dal PaluÃÄ et al., 2007) to methods based on
NMR data (Krippahl & Barahona, 1999) to methods based on fragments assembly (Dal
PaluÃÄ, Dovier, Fogolari, & Pontelli, 2010). In spite of all these efforts, the design of effective
approaches to filter the space of conformations and lead to a feasible search remains a
challenging and open problem.
In this work we present a constraint solver targeted at modeling a general class of protein
structure studies. In particular our solution is suitable to address protein structure analysis
study, requiring the generation of a set of unbiased sampled diverse conformations which
satisfy certain given restraints. One of the unique features of the solution presented in this
work is its capability to generate a uniformly distributed sampling of target protein regions
among a given portion of Cartesian space and with selected granularity‚Äîaccounting both
for spatial and rotational properties.
We abstract the problem as a general multi-body system, where each composing body is
constrained by means of geometric properties and it is related to other bodies through joint
relationships. Each body can represent an entity in the protein, such as an individual amino
acid or a small peptide (e.g., a protein fragment). Bodies relate to the spatial positions and
organization of individual atoms composing it.
The view of the exploration of protein structures as multi-body systems suggests a number of different constraints, that can be used to model different classes of structural studies
and applied to filter infeasible (or unlikely) conformations. We propose an investigation of
several classes of constraints, in terms of both their theoretical properties and practical use
955

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

for filtering. Particular emphasis is given to the Joined-Multibody (JM) constraint, whose
satisfaction we prove to be NP-complete. Realistic protein models require the assembly of
hundreds of different body versions, making the problem intractable. We study an efficient
approximated propagator, called JM filtering (JMf), that allows us to efficiently compute
classes of solutions, partitioned by structural similarity and controlled tolerance for error.
This perspective is novel and holds strong potential. The structural problems we are investigating are computationally intractable; the use of global constraints specifically designed
to meet their needs enables a more effective exploration of the search space and a greater
potential for effective approximations.
The multi-body model provides an interesting perspective in exploring the space of
conformations‚Äîwhile the actual search operates on discrete sets of alternatives (e.g., sets of
fragments), the filtering process avails of reasoning processes that operates with continuous
domain; this allows the propagation and filtering to be effective.
The proposed multi-body constraints and filtering techniques constitute the core of the
resolution engine of FIASCO (Fragment-based Interactive Assembly for protein Structure
prediction with Constraints), an efficient C++-based constraint solver. We demonstrate
the flexibility and efficiency of FIASCO by using its engine to model and solve a class
of problems derived from loop modeling instances. Throughout the paper we show the
ability of FIASCO of providing a uniform and efficient modeling platform for studying
different structural properties (that have been, so far, addressed only using significantly
distinct methods and tools). The declarative nature of constraint-based methods supports
a level of elaboration tolerance that is not offered by other frameworks for protein structure
prediction, facilitating the integration of additional knowledge in guiding the studies (e.g.,
availability of information about secondary structure elements).
The rest of the paper is organized as follows. In Section 2, we provide a high-level
background on the biological and chemical properties of proteins and review the most commonly used approaches to address structural studies. In Section 3, we develop the constraint
framework for dealing with fragments and multi-body structures. Section 4 describes the
implementation of the constraints and their propagation schemes in the FIASCO system.
In Section 5 we report the experimental results from using FIASCO on a collection of
benchmarks on loop modeling. Section 6 provides some concluding remarks.
A preliminary version of the research pursued in this paper was presented (Campeotto,
Dal PaluÃÄ, Dovier, Fioretto, & Pontelli, 2012). While the work of Campeotto et al. focused
on one new class of constraints targeting the problem of loop closure, the work presented
in this paper provides a comprehensive constraint system, focused on modeling structural
protein properties and investigating different types of problems (e.g., structure prediction,
studies of flexibility). The present manuscript includes also a more precise and detailed
formalization and a more extensive experimentation and comparison.

2. Background, General Context, And Related Work
In this section we will briefly review some basic Biology notions, introduce the problems we
are tackling in this paper and refer to a selection of the related literature.
956

A Constraint Solver for Flexible Protein Models

H

side
chain

N

CŒ±

H

H

N
C'

H
CŒ±

O
C'
side
chain

O

Figure 1: A schematic sequence of two amino acids showing the amino acid backbone and
their side chains. The arrow from C 0 to N denotes the peptidic bond.
2.1 General Background
A protein is a molecule made of smaller building blocks, called amino acids. One amino acid
can be connected to another one by a peptidic bond. Several amino acids can be pairwise
connected into a linear chain that forms the whole protein. The backbone of a protein, as
illustrated in Figure 1, is formed by a sequence of N ‚ÄìCŒ± ‚ÄìC 0 atoms contained in each amino
acid. The backbone is rather flexible and it allows a large degree of freedom to the protein.
Each amino acid is characterized by a variable group of atoms that influences the specific
physical and chemical properties. This group, named side chain, ranges from 1 to 18 atoms
and connects to the CŒ± atom of each amino acid. There are 20 kinds of amino acids found
in common eukaryotic organisms.
Proteins can be made of 10 up to 1, 000 amino acids, while an average globular protein
is about 300 amino acids long. Each amino acid contains 7‚Äì24 atoms, therefore the number
of atoms and arrangements in the space can grow very easily beyond any computational
power. Since the beginning of protein simulation studies, different algorithms for exploring the conformations have been devised, such as molecular dynamics, local search, Monte
Carlo, genetic algorithms, constraint approaches, as well as different geometric representations (Neumaier, 1997).
In the literature, several geometric models for proteins have been proposed. One choice
that influences the quality and the complexity of computational approaches is the number
of points that describe a single amino acid.
The simplest representation is the one where each amino acid is represented by one
point, typically the CŒ± atom, given its robust geometric property: the distance between the
CŒ± atoms of two consecutive amino acids is preserved with a low variance (roughly 3.81AÃä).
Usually, volumetric constraints are enforced over those points, in order to simulate the
average occupancy of each amino acid. This representation can be visualized as a chain of
beads that can be moved in the space.
More refined representation models store some (or all) the points of the backbone, plus
a centroid of mass (CG) that represents the whole side chain that connects to the CŒ± atom.
In these models, each amino acid is described by different CŒ± ‚ÄìCG distances and CG volumes.
The centroid is an approximation of the side-chain flexibility and allows for more refined
energetic models, while the number of points to be taken care of is still low. In this paper

957

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Figure 2: The native structure of ‚Äúintact influenza virus M1 protein‚Äù (indexed as 1EA3
in the PDB) modeled as full atom, with the 5@ model, and with the simple CŒ± ‚ÄìCŒ± model
(from left to right). The secondary structures (Œ±-helices) are emphasized.

Figure 3: Amino acid concatenation in the 5@ model
we use a particular case of these simplified models, the ‚Äú5@‚Äù model, described precisely
below. This is a particular instance of coarse-grained protein models (Clementi, 2008;
Shehu, 2010). At the end of the spectrum, each atom in the amino acid is represented by
one point. This representation is the most accurate, and at the same time allows for the
most accurate energetic considerations. The drawback is that the computational demand
for handling backbone and side-chain flexibility increases significantly.
In Figure 2 we report three representations for the same protein.
In this paper we select the intermediate representation for amino acids where the atoms
N, CŒ± , C 0 of the backbone and the centroid of the side chain (CG) are accounted for. We
also include an oxygen (O) atom attached to the C 0 atom, because this atom together with
the C 0 and N identifies a triangle that is chemically stable along the backbone and it is used
for the assembly of amino acids (see below for a complete formalization). The position of
the two H atoms in the backbone can be deduced by the position the other atoms and we
will not deal with them explicitly. In conclusion, we deal with 5 atomic elements per amino
acid: the 4 atoms N CŒ± C 0 O and the centroid CG. We briefly refer to this representation as to
the ‚Äú5@‚Äù model. Figure 3 illustrates how these atoms are involved in the concatenation of
two consecutive amino acids. Inter-atomic distances between consecutive atoms are fixed‚Äî
due to their chemical bonds; thus, the differences between these structures are identified
by the differences between the angles involved. It is common to find substructures of a

958

A Constraint Solver for Flexible Protein Models

protein where consecutive amino acids are arranged according to repeated and characteristic
patterns. This property is found in almost every protein; we refer to these typical patterns
as secondary structure elements. The most common examples are Œ±-helices and Œ≤-sheets
(see Figure 2).
2.2 Context Of The Proposed Work
In this paper we present a tool for assembling and reasoning about amino acids in the
space. As in other similar approaches (e.g, Simons, Kooperberg, Huang, & Baker, 1997),
the system relies on a set of admissible elementary shapes (or fragments) that represents
the spatial dictionary of arrangements for every part of a protein.
Each element of the dictionary is general enough to describe the specific atomic structure
of either a single amino acid or a longer sequence (even hundreds of amino acids long). For
each amino acid sequence, several alternative arrangements are expected to populate the
database, so that to offer various hypothesis about the local shape of the sequence. The
protein is partitioned into contiguous fragments that can be arranged according to one of
the possible shapes recorded in the database.
A sequence of amino acids is free to rotate its bonds in the space (typically two degrees
of freedom along the backbone and several others along the side chain); however, due to
chemical properties and physical occupancy that are specific to the types of amino acids
involved and the surrounding environment, some arrangements are impossible and/or unlikely. The core assumption in assembling approaches is to rely on a statistical database of
arrangements to describe local and feasible behavior, in order to direct the search to candidates that have high probability and are energetically favorable. The presence of multiple
candidate fragments for every part of the protein requires a combinatorial search among the
possible choices that, once assembled together, leads to alternative putative configurations
for the protein. The search process is in charge of verifying the feasibility of each assembly,
since the combination of local arrangements could generate a non-feasible global shape, e.g.,
one that leads to a spatial clash between atoms from different fragments. If one (or more)
fragment is described by one single arrangement, that part of the protein is rigidly imposed.
This particular degenerate case can be exploited to describe rigid parts of the protein. A
specific combination of fragment length and number of instances for each fragment determines the type of protein problem being modeled. We can range from complete backbone
flexibility (fragments made of hundreds of choices for each amino acids) to secondary structure - loop models (interleaving of longer fragments modeling helices/Œ≤-strands and shorter
fragments).
The library of fragments is usually derived from the content of the Protein Data Bank
(PDB, www.pdb.org) that contains more than 96,000 protein structures. The design adopted
in our study is parametric on the choice of the library of fragments to use. For example,
our experiments use a library of fragments derived from a subset of the PDB known as
top-500 (Lovell, Davis, Arendall, de Bakker, Word, Prisant, Richardson, & Richardson,
2003), which contains non redundant proteins and preserves statistical relevance. Alternative libraries of fragments can be obtained through the use of sophisticated protein database
search algorithms, such as FREAD (Choi & Deane, 2010). We retrieve information depending on the specific amino acid sequence, since local properties greatly influence the typical

959

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

arrangements observed. Moreover, we build libraries for different sequences lengths h, even
if for longer sequences the statistical coverage becomes weak. Nevertheless, Micheletti, Seno,
and Maritan (2000) conjectured that a relatively small set of fragment shapes (a few dozens)
of length 5, is able to describe virtually any protein. Handl, Knowles, Vernon, Baker, and
Lovell (2012) demonstrate how the size and the structure of the search space is affected
by the choice of the fragment length and how this can be used to optimize the search process. Similar considerations have been explored by others (Hegler, LaÃàtzer, Shehu, Clementi,
& Wolynes, 2009). Recent work show how to efficiently build such dictionaries (Fogolari,
Corazza, Viglino, & Esposito, 2012). These models can be easily accommodated into our
framework.
Each considered sequence is associated to several configurations of 5@ models, placed
according to a standardized coordinate system. In this activity, we also consider the C 0 O
group of the preceding amino acid and the N atom of the following amino acid. This
extra information is needed for fragments combination, assuming that the fragment will
be connected by two peptidic bonds. Therefore, for a specific sequence, we store all the
occurrences of
C 0 O N CŒ± C 0 O N
| {z }
h times
and relative positions. In order to reduce the impact of the specific properties of the
database used, we cluster this set in such a way that if two fragments have a RMSD1 less
than a given threshold, just one of them is stored. For example, for length h = 1 and a
RMSD threshold of .2AÃä, we can derive a fragment database of roughly 90 fragments per
amino acid.
The CG information is added later using statistical considerations about side-chain mobility, that are not accounted for during the clustering described above (Fogolari, Esposito,
Viglino, & Cattarinussi, 1996).
2.3 Protein Structure Prediction
In the protein structure prediction problem, the sequence of amino acids composing a protein (known as the primary structure) is given as input; the task is to predict the three
dimensional (3D) shape (known as the native conformation or tertiary structure) of the
protein under standard conditions.
The common assumption, based on Anfinsen‚Äôs work (1973), is that the 3D structure
which minimizes some given energy function modeling the atomic force fields, is the candidate that best approximates the functional state of a protein. In such setting, the choice
of the number of atoms used to represent each amino acid controls the quality and the
computational complexity.
Moreover, the spatial domains where the protein‚Äôs ‚Äúpoints‚Äù (e.g., atoms, centroids) can
be placed have an impact on the type of algorithms and search that can be performed.
The domain can be either continuous, often represented by floating point coordinates, or
discrete, often derived from a discretization of the space based on a crystal lattice structure.
1. The Root Mean Square Deviation captures the overall similarity in space of corresponding atoms, by
performing an optimal roto-translation to best overlap the two structures.

960

A Constraint Solver for Flexible Protein Models

Once the geometric model has been determined, it is necessary to introduce an energy
function, mostly based on the atoms considered and their distances. In the structure prediction problem, the energy function is used to assign a score to each geometrically feasible
candidate; the candidate with the optimal score represents the solution of the prediction
problem.
Let us briefly review some popular approaches to this problem, with a particular emphasis on solutions that rely on constraint programming technology.
The natural approach of investigating protein conformations through simulations of
physical movements of atoms and molecules is, unfortunately, beyond the current computational capabilities (Jauch, Yeo, Kolatkar, & Clarke, 2007; Ben-David, Noivirt-Brik, Paz,
Prilusky, Sussman, & Levy, 2009; Kinch, Yong Shi, Cong, Cheng, Liao, & Grishin, 2011).
This has originated a variety of alternative approaches, many based on comparative modeling‚Äîi.e., small structures from related protein family members are used as templates to
model the global structure of the protein of interest (Jones, 2006; Fujitsuka, Chikenji, &
Takada, 2006; Simons et al., 1997; Lee, Kim, Joo, Kim, & Lee, 2004; Karplus, Karchin,
Draper, Casper, Mandel-Gutfreund, Diekhans, & Source., 2003). In these methods, often
referred to as fragments assembly, a protein structure is assembled using small protein subunits as templates that present relevant sequence similarities (homologous affinity) w.r.t.
the target sequence.
In the literature, Constraint Programming (CP) techniques have shown their potential:
the structural variability of a protein can be modeled as constraints, and constraint solving
is performed in order to deduce the optimal structure (Backofen & Will, 2006; Barahona
& Krippahl, 2008; Dal PaluÃÄ, Dovier, & Fogolari, 2004; Dal PaluÃÄ et al., 2010). CP has
been used to provide approximated solutions for ab-initio lattice-based modeling of protein
structures, by using local search and large neighboring search (Shmygelska & Hoos, 2005;
DotuÃÅ, CebriaÃÅn, Van Hentenryck, & Clote, 2011); exact resolution of the problem on lattice
spaces using CP, along with with clever symmetry breaking techniques, has also been investigated (Backofen & Will, 2006). These approaches solve a constraint optimization problem
based on a simple energy function (HP). A more precise energy function has been used
by Dal PaluÃÄ et al. (2004, 2007), where information on secondary structures (i.e., Œ±-helices,
Œ≤-sheets) is also taken into consideration. Due to the approximation errors introduced by
lattice discretization, these approaches do not scale to medium-size proteins. Off-lattice
models, based on the idea of fragment assembly, and implemented using Constraint Logic
Programming over Finite Domains, have been presented (Dal PaluÃÄ et al., 2010; Dal PaluÃÄ,
Dovier, Fogolari, & Pontelli, 2011), and applied not only to structure prediction but also
to other structural analysis problems. For instance, Dal PaluÃÄ et al. (2012b) use this approach to generate sets of feasible conformations for studies of protein flexibility. The use
of CP to analyze NMR data and the related problem of protein docking has also been
investigated (Barahona & Krippahl, 2008).
In the context of ab-initio prediction, a recent work (Olson, Molloy, & Shehu, 2011)
has shown that increasing the complexity of the conformational search space‚Äîby using
a more refined fragment library‚Äîin combination with a sampling strategy, enhances the
generation of near-native structure sets. The work of Shehu (2009) and Molloy, Saleh, and
Shehu (2013) illustrates various enhancement the fragment-based assembly process leading
to faster computations and an improved sampling of the conformation space‚Äîe.g., using
961

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

tree-based methods inspired from motion planning to guarantee progress towards minimal
energy conformations while maintaining geometrically separate conformations. In terms of
energy landscape, the native state has generally lower free energy than non-native structures,
but it is extremely difficult to locate. Hence, a targeted conformational sampling may aid
protein structure prediction in that different near-native structure can be used to guide
the search; several schemes based on Monte Carlo movements in sampling conformation
space through fragments assembly have been proposed (Shmygelska & Levitt, 2009; Xu &
Zhang, 2012; Debartolo, Hocky, Wilde, Xu, Freed, & Sosnick, 2010). Methods based on
non-uniform probabilistic mass functions (derived from previously generated decoys) have
been proposed to aid in this problem (Simoncini, Berenger, Shrestha, & Zhang, 2012).
Sampling, however, remains a great challenge for protein with complex topologies and/or
large sizes (Kim, Blum, Bradley, & Baker, 2009; Shmygelska & Levitt, 2009).
It is widely accepted that proteins, in their native state, should be considered as dynamic
entities instead of steady rigid structures. Indeed, in recent years the research focus has
shifted towards prediction schemes that take into account the non-static nature of proteins,
supported by recent observations based on magnetic resonance techniques. Processes such
as enzyme catalysis, protein transport and antigen recognition rely on the ability of proteins
to change conformation according to the required conditions. This dynamic nature can be
visualized as a set of different structures that coexist at the same time. The generation
of such sets that capture non-redundant structures (in pure geometric terms) is a great
challenge (Kim et al., 2009). Robotics and inverse kinematics methods have been extensively
explored both in sampling proteins‚Äô conformational space (Zhang & Kavraki, 2002; Cortes
& Al-Bluwi, 2012) and for molecular simulations (Al-Bluwi, Simeon, & Cortes, 2012; Moll,
Schwarz, & Kavraki, 2007; Noonan, O‚ÄôBrien, & Snoeyink, 2005; Kirillova, Cortes, Stefaniu,
& Simeon, 2008).
A motivation for our work is to provide the ability of generating a protein set that
contains optimal and sub-optimal candidates, in order to capture dynamic information
about the behavior of a protein. A desirable property is that the conformations returned
in the pool are sufficiently diverse and uniformly distributed in the 3D space.
2.4 Protein Loop Modeling
The protein loop modeling problem is a restricted version of the structure prediction problem. We will use this problem as a working example in the remaining part of the paper.
In this context, the protein structure is already partially defined, e.g., a large number of
atoms are already placed in the space. Usually, this common scenario derives from an Xray crystallography analysis, where the spatial resolution of atoms degenerates in presence
of some regions of the protein that are exposed on the surface and presents an increased
instability. Since a crystal contains several copies of a protein in order to perform the measurement, such regions appear as more fuzzy, and therefore the placement of atoms in these
regions may be ambiguous. Usually, these regions, referred to as loops, are not involved in
secondary structures, which are instead more stable. When dealing with homology modeling, the same protein found in another organism, typically shows some variations in the
sequence due to evolution, especially in the loop regions, since they are less essential for
protein stability and functionality. Starting from an homologous protein structure, usually

962

A Constraint Solver for Flexible Protein Models

loops need to be recomputed with a specialized loop modeling approach and the use of
minimization techniques.
The length of a loop is typically in the range of 2 to 20 amino acids; nevertheless,
compared to secondary structures, the flexibility of loops produces very large, physically
consistent, conformation search spaces. Constraints on the mutual positions and orientations (dihedral angles) of the loop atoms can be deduced and used to simplify the search.
Such restrictions are defined as the loop closure constraints. In Figure 2, we have a (simple)
possible scenario where two macro-structures (two helices) are connected by a loop. In this
setting, we can assume to know the position of the two helices, while the loop atoms are to
be determined.
A procedure for protein loop modeling typically consists of 3 phases: sampling, filtering,
and ranking (Jamroz & Kolinski, 2010). Sampling is commonly based on a loop candidate generation, using dihedral angles sampled from structural databases (Felts, Gallicchio,
Chekmarev, Paris, Friesner, & Levy, 2008), and subsequent candidate modification in order
to satisfy the loop closure constraints. These conformations are checked w.r.t. the loop constraints and the geometries from the rest of the structure, and the loops that are detected
as physically infeasible, e.g., causing steric clashes, are discarded by a filtering procedure.
Popular methods used for loop modeling include the Cyclic Coordinate Descent (CCD)
method (Canutescu & Dunbrack, 2003), the algorithms based on inverse kinematics (Kolodny,
Guibas, Levitt, & Koehl, 2005; Shehu & Kavraki, 2012), the Self-Organizing (SOS) algorithm (Liu, Zhu, Rassokhin, & Agrafiotis, 2009), which can simultaneously satisfy loop
closure and steric clash restrictions by iteratively superimposing small fragments (amide
and CŒ± ) and adjusting distances between atoms, and the Wriggling method (Cahill, Cahill,
& Cahill, 2003), that employs suitably designed Monte Carlo local moves to satisfy the loop
closure constraints. Multi-method approaches have also been proposed‚Äîe.g., Lee, Lee,
Park, Coutsias, and Seok (2010) propose a loop sampling method which combines fragment
assembly and analytical loop closure, based on a set of torsion angles satisfying the imposed
constraints. Ab initio methods (Rapp & Friesner, 1999; Fiser, Do, & Sali, 2000; Jacobson,
Pincus, Rapp, Day, Honig, Shaw, & Friesner, 2004; Spassov, Flook, & Yan, 2008; Deane
& Blundell, 2001; Felts et al., 2008; Xiang et al., 2002) and methods based on templates
extracted from structural databases (Choi & Deane, 2010) have been explored.
Finally, a ranking step‚Äîe.g., based on statistical potential energy, like in DOPE (Shen
& Sali, 2006), DFIRE (Zhou & Zhou, 2002), or the one proposed in Fogolari et al. (2007),
is used to select the best loop candidates.
The sampling and filtering procedures should work together and direct the search towards structurally diverse and admissible loop conformations, in order to maximize the
probability of including a candidate close to the native one and to reduce the time needed
to analyze the candidates. Our work is motivated by the need of controlling the properties of the resulting set of candidates. In particular, we model structural diversity both in
distance and orientation of the backbone and make the sampling phase guided by the loop
constraints.
Fragment-based assembly methods have also been investigated in the context of loop
modeling (Lee et al., 2010; Zhang & Hauser, 2013). Shehu and Kavraki (2012) review in
great detail loop modeling techniques.

963

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Figure 4: On the left: two fragments B1 (light grey) and B2 (dark grey) such that
points(B1 ) = ((0, 0), (1, 0), (1, 1), (2, 1)) and points(B2 ) = ((4, 0), (3, 0), (3, 1), (4, 1), (4, 2)).
The arrows address their initial points. On the right: observe that by rotating B2 of 90 degrees and then translating it by -3 units on the x-axis, the last three points of B1 (last(B1 ))
and the first three points of B2 (first(B2 )) perfectly overlap. Thus, end(B1 ) _ front(B2 ).

3. Constraint Solving With 3D Fragments
We assume the reader to have familiarity with the basic principles of constraint programming and constraint satisfaction problems (CSP); the reader is referred, e.g., to the Handbook of Constraint Programming (Rossi et al., 2006). In this Section, we introduce the
formalization of an effective solution to tackle practical applications concerning with the
placement of 3D fragments. Such applications are described as combinatorial problems,
modeled as a set of variables, representing the entities the problem deals with, and a set of
constraints, representing the relationships among the entities. In the context of a constraint
programming system, variables and constraints are adopted to provide a solution for the
CSP, that is, an assignment to the variables that satisfies all the constraints. We extend this
concept by enabling the constraint solver to find a representative solution for the CSP that
satisfies some additional properties expressed among the variables of the whole solution set.
3.1 Some Terminology
A fragment B is composed of an ordered list of at least three (distinct) 3D points, denoted
by points(B). The number of points of a fragment is referred to as its length. The front- and
end-anchors of a fragment B, denoted by front(B) and end(B), are the two lists containing
the first three and the last three points of points(B). With B(i) we denote the i-th point
of the fragment B. For two ordered lists of points p~ and ~q, we write p~ _ ~q if they can
be perfectly overlapped by a rigid coordinate translation and/or rotation (briefly, a rototranslation)‚Äîsee Figure 4 (let us assume the z coordinate is 0 for all points and omitted
for simplicity).
A non-empty set of fragments with the same length is called a body. A body can be
used to model a set of possible shapes for a sequence of points. We say that a body has
length k if each fragment it contains has length k.
A multi-body is a sequence S1 , . . . , Sn of bodies.

964

A Constraint Solver for Flexible Protein Models

Figure 5: From left to right: the body S1 composed by an unique fragment, and the bodies
S2 and S3 composed by two fragments each. Arrows address the initial points of fragments.
~ = S1 , S2 , S3 constitutes a multi-body. In the rightmost
All the three bodies have length 4. S
figure we report the spatial shapes associated to the four rigid bodies that can be obtained
~ One of them is identified by full lines, the other three by dashed
from the multi-body S.
lines. Observe that the rigid body identified by ((0, 0), (1, 0), (1, 1), (2, 1), (2, 0), (3, 0)) can
be obtained by a rotation of 180 degrees of the fragment ((2, 0), (3, 0), (3, 1), (4, 1)) of S2 on
the x axis (flipping) and by a translation of ‚àí1 units on x and of +1 units on y. Observe
moreover that the rigid body identified by ((0, 0), (1, 0), (1, 1), (2, 1), (2, 0), (1, 0)) contains
the same point (1, 0) twice.
~ = S1 , . . . , Sn , a rigid body from S
~ is a sequence of fragments
Given a multibody S
B1 , . . . , Bn , where Bi ‚àà Si for i = 1, . . . , n and end(Bi ) _ front(Bi+1 ), for all i = 1, . . . , n‚àí1.
A rigid body is uniquely identified by the sequence B1 , . . . , Bn ; however, when consecutive
fragments are overlapped, the rigid body can be alternatively identified by a list of points
that form a spatial shape. In Figure 5 we report examples of bodies, multi-bodies, and rigid
bodies. As in the previous example, we assume that the z coordinate is 0 for all points.
Remark 3.1 (Working Example) These concepts are related to the loop-modeling problem. Points are atoms. A fragment is a spatial shape of some atoms. If the last three atoms
of one fragment overlap with the first three atoms of another fragment, we can join them.
A body is a set of admissible shapes for a given list of atoms. A multi-body S1 , . . . , Sn is
a sequence of these elements, corresponding to a sequence of atoms (of amino acids). The
idea is that the last three atoms of a body Si are the same as the first three of the successive
body Si+1 . A rigid body is a possible complete shape of those atoms, provided the last three
atoms of the fragment selected in the set Si overlap with the first three atoms of the fragment
selected in Si+1 .
The overlapping points end(Bi ) and front(Bi+1 ) constitute the i-th joint of the rigid
body. The number of rigid bodies that can be obtained from a single multi-body S1 , . . . , Sn
is bounded by Œ†ni=1 |Si |. Figure 6 provides a schematic general representation of a rigid
body.
A rigid body is defined by the overlap of joints, and relies on a chain of relative rototranslations of its fragments. Each points in points(Bi ) is therefore positioned according
to the (homogeneous) coordinate system associated to a fragment Bi‚àí1 . Note that once
the reference system for B1 is defined, the whole rigid body is completely positioned.2 The
2. With the exception of the case where all points of a joint are collinear. Points p1 , . . . , pn , with n ‚â• 3 are
collinear if the points p3 , p4 , . . . , pn belongs to the straight line containing the two points p1 and p2 .

965

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Figure 6: A schematic representation of a rigid body. The joints connecting two adjacent
fragments are emphasized. The points in points(B) of each fragment are represented by
circles. Each fragment extends from the first point of a joint to the last point of the
successive joint.
relative positions of two consecutive fragments Bi‚àí1 and Bi of a rigid body (2 ‚â§ i ‚â§ n) can
be defined by a transformation matrix Ti ‚àà R4√ó4 . Each matrix depends on the standard
Denavit-Hartenberg parameters (Hartenberg & Denavit, 1995) obtained from the start and
end of the fragments‚Äîthe reader is referred to the work of LaValle (2006) for details. We
denote the product T1 ¬∑ T2 ¬∑ . . . ¬∑ Ti ¬∑ (x, y, z, 1)T by Ti (x, y, z).
Let us analyze the first matrix T1 . The fragment B1 can be forced to start in a given
point and oriented in a given way; in this case the matrix T1 defines the roto-translation
of B1 fulfilling these constraints. In the absence of such constraints, we assume that B1 is
normalized by T1 ‚Äîi.e.,its first point is (0, 0, 0), the second point is aligned along the z axis
and the third belongs to the plane formed by the x and z axes. This orientation is referred
as the reference system Œì0 .
For i = 1, . . . , n, the coordinate system conversion (x0 , y 0 , z 0 ), for a point (x, y, z) ‚àà
points(Bi ) into the coordinate system of B1 , is obtained by:
(x0 , y 0 , z 0 , 1)T = T1 ¬∑ T2 ¬∑ . . . ¬∑ Ti ¬∑ (x, y, z, 1)T = Ti (x, y, z)

(1)

Homogeneous transformations are such that the last value of a tuple is always 1.
In the rest of the paper, we focus on the 5@ model; however the proposed formalization
and methods can be used also for other models, e.g., the CŒ± ‚ÄìCŒ± model. In the latter
case, points(Bi ) contains at least 3 amino acids, and the joints are guaranteed to be noncolinear, due to the chemical properties of the backbone. When combining CŒ± fragments,
the specific rotational angles of the full-atom backbone are lost and a more imprecise multibody assembly is produced.
A fragment is a body associated to a sequence of amino acids. A fragment for a sequence
of h ‚â• 1 amino acids is described by a body of length 4h + 3, modeling the concatenation
of the atoms represented by the regular expression: C 0 O(N CŒ± C 0 O)h N . In such representation the first and last sequence of C 0 ON atoms coincide with the front- and end-anchor,
respectively, and are employed during the process of assembling consecutive fragments (i.e.,
they are used in the roto-translation).
A discretized R3 space can be represented as a regular lattice, composed of cubic cells
with side length equal to a given parameter k. Each cell is referred to as a 3D voxel
(or, simply, voxel ); we assume that each voxel receives a unique identifier. We denote
with voxel(p, k) the identifier of the voxel that contains the 3D point p in the context of a
discretization of the space using cubes with side length equal to k. This spatial quantization
allows an efficient treatment of the approximated propagation required by some of the
geometric constraints introduced in the following sections.
966

A Constraint Solver for Flexible Protein Models

3.2 Variables And Domains
Let us now define the variables adopted to describe the entities of a problem with fragments.
The domain of a variable V is the set of allowable values for V , and it will be denoted by
DV . To deal with fragments placements in the 3D space we adopt two distinct types of
variables:
Finite Domain Variables (FDVs): The domain of a finite domain variable is a finite
set of non negative integer numbers.
Point Variables (PVs): These variables will assume the coordinates of a 3D point in R3 .
Their domains are, initially, 3D boxes identified by two opposite vertices hmin, maxi,
as done in the discrete solver COLA (Dal PaluÃÄ, Dovier, & Pontelli, 2005, 2007).
Remark 3.2 (Working Example) Following Remark 3.1, FDVs are the identifiers of the
various fragments in a body, while PVs are used to represent the 3D coordinates assigned
to the various structural points (e.g., atoms, centroids) of interest for each molecule being
considered. Clearly, the values of PVs will depend deterministically on the values of FDVs
(and vice-versa).
A variable is assigned if its domain contains a unique value; in the case of point variables,
this happens if DV = hmin, maxi and min = max.
3.3 Constraints
In this section, we formalize the constraints that define the fragments placement, that can
be used to describe Protein Structure problems in the context of fragment assembly.
3.3.1 Distance Constraints
Distance constraints model spatial properties of point variables operating in the 3D space.
Point variables P and Q can be related by a distance constraint of the form
kP ‚àí Qk op d

(2)

where k ¬∑ k is the Euclidean norm, d ‚àà R+ and op is ‚â§ or ‚â•.
The built-in global constraint alldistant associates a minimal radius di to each point
variable Pi (i = 1, . . . , n) and ensures that spheres surrounding each pair of point variables
do not intersect:
alldistant(P1 , . . . , Pn , d1 , . . . , dn ),
(3)
This constraint is equivalent to the constraints kPi ‚àíPj k ‚â• di +dj for all i, j ‚àà {1, . . . , n}, i <
j. It is used to avoid steric clashes among different atoms (and centroids), which have
different volumes. Checking consistency of the alldistant constraint (given the domains
of the variables Pi ) is NP-complete (Dal PaluÃÄ, Dovier, & Pontelli, 2010)‚Äîthe proof is based
on an encoding of the bin-packing problem using the alldistant constraint, and holds true
even in this particular setting, where the point variables have intervals of R3 as domains.
Remark 3.3 (Working Example) The alldistant constraint is introduced to avoid clashes
when a rigid body is obtained from the multi-body S1 , . . . , Sn . The distance constraints are
967

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Figure 7: Fragments are assembled by overlapping the plane Œ≤R , described by the rightmost
C 0 , O, N atoms of the first fragment (left), with the plane Œ≤L , described by the leftmost
C 0 , O, N atoms of the second fragment (right), on the common nitrogen atom
useful when some extra information is known (e.g., one might have inferred by biological
arguments that a pair of amino acid should stay within a certain distance).
3.3.2 Fragment Constraint
Fragment constraints relate finite domain variables and point variables. Let us assume we
have a database F of fragments, where F [i] represents the i-th fragment in the database.
Thus, given an FDV variable V , F [V ] denotes the fragment indexed by V when V is
instantiated. The fragments are stored in F as an ordered list of 3D points.
Given a list of point variables P~ , the constraint:
fragment(V, P~ , F )

(4)

states that there exists a roto-translation Rot such that P~ = Rot ¬∑ F [V ]‚Äînamely, if V = i
then the list of points P~ should take the form of the fragment F [i]. For simplicity, we
will omit the database F when clear from the context. Intuitively, these constraints ensure
that any fragment choice will reproduce the correct shape for the associated 3D point,
regardless of the space orientation of the fragment. The orientation is determined by the
joined multi-body constraint presented in a following section.
3.3.3 Centroid Constraint
The centroid constraint enforces a relation among four PVs. Intuitively, the first three
of them are associated to the atoms N, CŒ± , C 0 of an amino acid and the fourth is related
to the centroid CG. The constraint is parametric w.r.t. the type a of an amino acid and
deterministically establishes the position of CG depending on the position of the other points:
centroid(PN , PCŒ± , PC 0 , PCG , a)

(5)

In Figure 7 the centroids are displayed along the backbone as purple circles and labeled
‚ÄúCG.‚Äù This constraint can be used when the database of fragment contains only full backbone information. The centroid information is used in place of the missing full-atom side
chain. The side-chain centroid is computed by taking into account the average CŒ± -side-chain
center of mass distance, the average bend angle formed by the side-chain center-of-massCŒ± -C 0 , and the torsional angle formed by the N -CŒ± -C 0 -side-center of mass (Fogolari et al.,
968

A Constraint Solver for Flexible Protein Models

1996). This abstraction allows us to reduce the number of fragments to consider, removing
fragments that would geometrically conflict with the position of the CG. Consider that a
single side chain may have up to 100 main configurations (rotamers).
3.3.4 Table Constraint
This constraint is used to restrict the assignments of a set of FDVs (representing fragments)
to specific tuples of choices. This is useful when modeling a specific local and collaborative
behavior that involves more than one fragment; for example, this happens when modeling a
secondary structure multiple arrangements of underlying amino acids and/or when specific
approximation strategies are employed.
~ a k-tuple of FDVs. A table (or
Let F be a set of k-tuples of integer values and V
combinatorial) constraint, of the form
~ ,F)
table(V

(6)

~ assumes values restricted to the tuples listed in F , i.e.,
requires that the list of variables V
~
there exists t ‚àà F such that V [i] = t[i], with i in 0, . . . , k ‚àí 1.
Remark 3.4 (Working Example) Going back to the loop-modeling problem, the role of
the fragment constraint is evident: it relates the (IDs of the) selected fragments of a multibody with the 3D positions of the various atoms involved. The centroid constraint is
instead introduced to add the position of the centroid that represents the side chain in the
5@ representation. table constraint is a common constraint in constraint languages and it
is useful when some info on consecutive fragments in a rigid body is known due to external
knowledge.
3.3.5 Joined Multibody Constraint
The Joined Multibody (JM) constraint enforces a relation over a list of FDVs encoding a
multibody. It limits the spatial domains of the various fragments composing the multibody
in order to retain those fragments that assemble properly and that do not compenetrate.
~ V
~ , A,
~ E,
~ Œ¥i, where:
The joined-multibody (JM) constraint is described by a tuple: J = hS,
~ = S1 , . . . , Sn is a multi-body. Let B = {B1 , . . . , Bk } be the set of all fragments in S,
~
‚Ä¢ S
Sn
i.e., B = i=1 Si .
~ = V1 , . . . , Vn is a list of FDVs, with domains DVi = {j : Bj ‚àà Si }.
‚Ä¢ V
~ = A1 , A2 , A3 , and E~ = E1 , . . . , E3n are lists of sets of 3D points such that:
‚Ä¢ A
‚ó¶ A1 √ó A2 √ó A3 is the set of admissible points for front(B), with B ‚àà S1 ;
‚ó¶ E3i‚àí2 √ó E3i‚àí1 √ó E3i is the set of admissible points for end(B), with B ‚àà Si , i = 1, . . . , n;
‚Ä¢ Œ¥ is a constant, used to express a minimal distance constraint between different point.
~ ‚àí‚Üí {1, . . . , |B|} s.t. there exist
A solution for the JM constraint J is an assignment œÉ : V
matrices T1 , . . . , Tn (used in T ) with the following properties:
Domain: For all i = 1, . . . , n, œÉ(Vi ) ‚àà DVi .
Joint: For all i = 1, . . . , n ‚àí 1, let (a1 , a2 , a3 ) = end(BœÉ(Vi ) ) and (b1 , b2 , b3 ) = front(BœÉ(Vi+1 ) ),
then it holds that (for j = 1, 2, 3):
Ti (ajx , ajy , ajz ) = Ti+1 (bjx , bjy , bjz )
969

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Spatial Domain: Let (a1 , a2 , a3 ) = front(BœÉ(V1 ) ), then T1 ¬∑ aj ‚àà Aj √ó {1}.3 For all i =
1, . . . , n, let (e1 , e2 , e3 ) = end(BœÉ(Vi ) ) then
Ti (ejx , ejy , ejz ) ‚àà E3(i‚àí1)+j √ó {1}
where 1 ‚â§ j ‚â§ 3 and T2 , . . . , Ti (in Ti ) are the matrices that overlap end(BœÉ(Vi‚àí1 ) ) and
front(BœÉ(Vi ) )
Minimal Distance: For all j, ` = 1, . . . , n, j < `, and for all points a ‚àà points(BœÉ(Vj ) ) and
b ‚àà points(BœÉ(V` ) ), it holds that:4
kTj (ax , ay , az ) ‚àí T` (bx , by , bz )k ‚â• Œ¥
It has been proved that establishing consistency‚Äîi.e., existence of a solution‚Äîof JM
constraints is NP-complete (Campeotto et al., 2012). We have also proved that it remains
NP complete even assuming that all all the fragments of the problem have the same three
atoms with the same spatial position, and that the same holds for the last three atoms (of
course fragments are allowed to contain more than three atoms otherwise the problem is
trivial). The proof is reported in www.cs.nmsu.edu/fiasco/.
Remark 3.5 (Working Example) The JM constraint contains exactly all the ingredients
~ and the corresponding FDs
needed for modeling a loop problem. We have a multi-body S,
~ , we have a set of possible 3D points where the loop starts A
~ and a set of possible 3D
V
~
points where the loop ends E and a weak version of the alldistant constraint between pair of
~
atoms that avoid clashes, the solutions are the (non clashing) rigid bodies that starts in A
~
and ends in E.
Let us observe that the JM constraint does not explicitly forbid spatial positions to PVs
variables (save for the first three and the last three points of the loop). However, these
additional constraints can be explicitly required during domain definition of the PVs variables
used for the encoding.
Remark 3.6 The choice of using three points of overlap resembles the method proposed by
Kolodny, Guibas, Levitt, and Koehl (2005). On the other hand, we should observe that it is
only a technical exercise to modify the JM constraints and so that they allow a parametric
overlap between contiguous fragments.

4. The FIASCO Constraint Solver
We present the overall structure and implementation of a hybrid constraint solver capable
of handling the classes of constraints described in the previous section.
4.1 Constraint Solving
A distinctive feature of FIASCO is the possibility to handle continuous domains at the cost
of keeping a discrete library of choices (finite domain variables). The handling of fragments
allows us to reason about spatial properties in a more efficient and descriptive way than
the pure 3D domain modeling adopted in previous proposals. Moreover, FIASCO allows
3. The product √ó{1} is necessary as we use homogeneous coordinates.
4. Let us observe that this is a weak form of the alldistant constraint where different distances for each
point are allowed. It is, in a sense, closer to the alldifferent constraint.

970

A Constraint Solver for Flexible Protein Models

the solver to uniformly sample the search space by means of a spatial equivalence relation
that is used to control the tradeoff between accuracy and efficiency. This is particularly
effective when the finite domains are heavily populated, and is a critical component to
model real-world problems.
The constraint solver builds on the classical prop-labeling tree exploration where constraint propagation phases are interleaved with non-deterministic branching phases used to
explore different value assignments to variables (Apt, 2009). The solver is able to handle
both point variables and finite domain variables‚Äîthis is the reason why we refer to it as
an hybrid solver. In particular, the assignments to finite domain variables guide the search;
their values imply assignments of the point variables, that in turn may propagate and reduce
the domains of both point variables and finite domain variables. Moreover, the ‚Äúpropagation‚Äù technique implemented for the JM constraint is not a classical filtering technique‚Äîit
is an approximated technique that we describe later.
The presence of point variables allows, in principle, an infinite number of domain values
in R3 . However, we noted that the information carried by assembling fragments (encoded
by finite domain variables) is much more informative than any complex and demanding
model for 3D continuous space (e.g., Oct-trees, CSG, no-goods). In particular, the direct
kinematics encoded by a JM constraint is able to efficiently identify a set of admissible
regions of a point variable in a fast, approximated, and controlled way. Therefore, the
point variables can be seen as an internal aid to propagation. These variables are updated
during the JM propagation phase and can interact with the JM propagator to prune the
corresponding fragment variables. Distance constraints on point variables are included in a
standard AC3 propagation loop for domains updates.
The other aspect that extends the classical solver structure is the capability of controlling the amount of the search tree to be explored. The search tree contains a large number
of branches that are very similar, from the point of view of the geometric distance between
corresponding point variables. The goal is to produce a subset of feasible solutions that
exhibit significant 3D differences between themselves. This is accomplished by introducing
the possibility to explore a subtree of a given depth, by enumerating a specific and limited
number of branches, rather than following the standard recursion of propagation and expansion. To achieve this behavior, it is necessary to selectively interfere with the standard
recursive call to the solver, and implement a non-deterministic assignment of partial tuples
of finite domain variables. This resembles the implementation of a table constraint, which
is dynamically created during the search. This strategy allows us to significantly reduce
the number of branches explored in the subtree, and produces significant results when the
selection of the branches is controlled by an adequate partitioning function. In this work,
we propose an effective partitioning function based on a measure of 3D similarity for point
variables; this is used to direct the search along specific branches of controlled depth that
are adequately ‚Äúseparated‚Äù by the partitioning function. This is practically realized by
introducing a form of look-ahead, controlled by the JM propagator, that returns a set of
partial assignments as well as the filtered domains for the finite domain variables.
4.1.1 The Hybrid Solver

971

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

~ , P~ , D,
~ C, `)
Algorithm 1 search(V
~ , P~ , D,
~ C, `
Require: V
~ | then
1: if ` > |V
2:
output (P~ )
3:
return
4: end if
5: for each fragment index f in Dv` do
~ , P~ , D)
~ then
6:
if AC-3(C ‚à™ {v` = f }, V
n√óm
7:
T
‚Üê get table from JM()
8:
if n > 0 then
9:
Non-deterministically select i in 1..n
10:
for j = 1..m do
11:
C ‚Üê C ‚à™ {v`+j = T [i][j]}
12:
end for
~ , P~ , D,
~ C, ` + m)
13:
search(V
14:
else
~ , P~ , D,
~ C, ` + 1)
15:
search(V
16:
end if
17:
end if
18: end for
The general structure of the solver is highlighted in Algorithm 1. The solver is designed
~ = v1 , . . . , vn of finite domains variables, together with the domains
to process a list V
Dv1 , . . . , Dvn for them. Intuitively, each domain is a set of indices for the set of fragments.
Moreover, the solver receives a list P~ = p1 , . . . , p5n of 5 ‚àó n point variables, where the
variables p4‚àói , . . . , p4‚àói+4 are related to the fragment in the domain Dvi . Each point variable
~
pj has, in turn, a spatial domain Dpj . C represents the constraints between elements of V
and P~ . Finally, the solver receives also as input the ‚Äúcurrent‚Äù level ` in the exploration of
the search tree (set to 1 the first time the procedure is called). For the sake of simplicity,
the choice of variables to be assigned is based on their ordering in the input list (more
sophisticated selection strategies can be easily introduced). When we enter the level `, we
assume that the variables v1 , . . . , v`‚àí1 have already been assigned.
~ have already been assigned
Let us briefly describe the algorithm. If all the variables in V
(lines 1‚Äì4), then the search algorithm terminates and returns the computed solution, represented by the values assigned to the variables P~ . Otherwise, we non-deterministically select
a fragment index in the domain of the variable v` and assign it to the variable. Lines 6‚Äì7
indicate the execution of a standard constraint propagation step (using AC-3). If the propagation step fails, then we assume that another non-deterministic choice is made, if possible.
Every reference to a non-deterministic choice in the algorithm corresponds to the creation
of a choice-point that will be the target of backtracking in case of failure (for simplicity,
we assume chronological backtracking). If it succeeds, leading to a possible reduction of
~ then the computation will proceed. A table constraint might be produced
the domains D,
during the propagation of the JM constraint in the AC-3 procedure (see below for details).
If this is the case (lines 8‚Äì9), some (m) variables are non-deterministically assigned with
the values in the table (lines 9‚Äì12), and the search continues with m less variables to be
972

A Constraint Solver for Flexible Protein Models

assigned (line 13). If this is not the case, then the search will continue with only one less
variable (v` ) to be assigned (line 15).
A peculiar feature of our constraint solver (not reported in the abstract algorithm just
defined) is that it can be used to avoid the search of solutions ‚Äútoo similar‚Äù to each others.
Let us assume that the 3D space is partitioned in cubic voxels of size k AÃä. Then, given a list
~ and a list of PVs P~ , the user can state:
of FDVs V
~ , P~ , k)
uniqueseq(V

(7)

This constraint forces the solver to prune the search tree in the following way. Given
~ be the variable to be assigned at the next step and
a partial assignment œÉ, let v ‚àà V
~
p1 , . . . , ph ‚àà P the PVs to be consequently instantiated. The constraint ensures that for
any two assignments œÉ1 , œÉ2 extending œÉ to v, p1 , . . . , ph it holds that there exists at least
one i ‚àà {1, . . . , h} such that œÉ1 (pi ) and œÉ2 (pi ) do not belong to the same voxel.
4.2 Constraint Propagation
In this section, we discuss the propagation rules associated to the various constraints introduced in Section 3.3; these are applied within the call to the AC-3 procedure (line 6 of
Algorithm 1). The constraint propagation is used to reduce the domain size of the PVs and
FDVs, ensuring constraint consistency. AC-3 is a standard implementation of a fixpoint
propagation loop (Apt, 2009; Rossi et al., 2006).
4.2.1 Joined Multibody Constraint
The JM constraint is a complex constraint that is triggered when the leftmost points involved in the constraint (anchors) are instantiated. The JM propagation (JMf) is based on
the analysis of the distribution in the space of the points involved. The goal of the propagation is to reduce the domains of the FDVs through the identification of those fragments
that cannot contribute to the generation of a rigid body that is compatible with the corresponding Point Variable domains. This can be viewed as a form of hyper-arc consistency
over a set of fragments. Moreover, due to complexity and precision considerations, this
propagator is approximated by the use of a spatial equivalence relation (‚àº), that identifies
classes of tuples of fragments; these classes have the property to be spatially ‚Äúdifferent‚Äù
from one another.
This allows a compact handling of the combinatorics of the multi-body, while a controlled
error threshold allows us to select the precision of the filtering. The equivalence relation
captures those rigid bodies that are geometrically similar, allowing the search to ‚Äúcompact‚Äù
small differences among them.
~ V
~ , A,
~ E,
~ Œ¥i, along with
The JMf algorithm receives as input a JM-constraint hS,
‚Ä¢ A set G of points that are not available for the placement of bodies, and
‚Ä¢ The equivalence relation ‚àº.
For the sake of readability, we assume that the domain information for variables are avail~ , Tab). In this process, the algorithm
able. The algorithm builds a table constraint table (V
makes use of a function œÅ (lines 7 and 8); this function takes as input two lists ~a and ~b of
3D points, and computes the homogeneous transformation to overlap ~b on ~a. A call to
973

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Algorithm 2 The JMf algorithm.
~ V
~ , A,
~ E,
~ Œ¥, G, ‚àº
Require: S,
Ensure: Tab
~ |; Tab = ‚àÖ
1: n ‚Üê |V
Ô£±
Ô£´
Ô£∂ Ô£º
T1 ¬∑ start(B) ‚àà A1 √ó A2 √ó A3 ‚àß
Ô£¥
Ô£¥
Ô£¥
Ô£¥
Ô£≤
Ô£Ω
Ô£¨ T1 ¬∑ end(B) ‚àà E1 √ó E2 √ó E3
Ô£∑
‚àß
Ô£∑
2: R1 ‚Üê (B, T1 ) B ‚àà S1 , ‚àÉT1 Ô£¨
Ô£≠ ‚àÄp ‚àà points(B).‚àÄq ‚àà G. k(T1 ¬∑ p) ‚àí qk ‚â• Œ¥ ‚àß Ô£∏ Ô£¥
Ô£¥
Ô£¥
Ô£¥
Ô£≥
Ô£æ
‚àÄc ‚àà C involving p.consistent(c))
3: P1 ‚Üê {T1 ¬∑ end(B) | (B, T1 ) ‚àà R1 }
4: for each i = 2, . . . , n do
5:
Pi = ‚àÖ; Ri = ‚àÖ;
6:
for each E ‚ààÔ£±
Pi‚àí1 / ‚àº do
Ô£º
T = œÅ(E, start(B)) ‚àß T 6= fail ‚àß
Ô£¥
Ô£¥
Ô£¥
Ô£¥
Ô£Ω
Ô£≤
T ¬∑ end(B) ‚àà E3i‚àí2 √ó E3i‚àí1 √ó E3i ‚àß
7:
Ri ‚Üê Ri ‚à™ B ‚àà Si
‚àÄp ‚àà points(B).‚àÄq ‚àà G. k(T ¬∑ p) ‚àí qk ‚â• Œ¥ ‚àß Ô£¥
Ô£¥
Ô£¥
Ô£¥
Ô£æ
Ô£≥
‚àÄc ‚àà C involving p.consistent(c))
8:
Pi ‚Üê {œÅ(E, start(B)) ¬∑ end(B) | B ‚àà Ri }
9:
end for
10:
compute Pi / ‚àº and filter Ri accordingly
11: end for
12: for each representative L of Pn / ‚àº do
13:
Tab = Tab ‚à™ Œ∑(L)
14: end for
this function will fail if ~a 6_ ~b. For simplicity, the fourth component (always 1) of the
homogeneous transformation is not explicitly reported in the algorithm.
~ |, the algorithm computes the sets Ri and Pi , that will respectively
For i = 1, . . . , n = |V
contain the fragments from Si that can still lead to a solution, and the corresponding allowed
3D positions of their end-points. For each fragment B ‚àà Ri+1 we denote with parent(B)
the set of fragments B 0 ‚àà Ri such that end(B 0 ) _ front(B) via œÅ. For each fragment B, we
denote with label(B) the corresponding FD value associated.
In computing/updating Ri and Pi , only fragments that have end-anchors contained in
the bounds E3i‚àí2 , E3i‚àí1 , E3i are kept. Fragments that would cause points to collapse‚Äîi.e.,
due to a distance smaller than Œ¥ from previously placed points‚Äîare filtered out (lines 2 and
7). Moreover, the spatial positions of the points of the first fragment are validated against A
(line 2); finally, we enforce the consistency check of each constraint c ‚àà C involving points in
points(B) ‚àà Si to retain only those points that can potentially reach the admissible positions
(lines 2 and 7).
~ | ‚àí 1 iterations (lines 4‚Äì11). First Ri and Pi are computed
The algorithm performs |V
on the basis of the sets of end-anchors of the previous level Pi‚àí1 and the starting point of
a selected fragment B, filtering out those that are not overlapping and those that lead to
wrong portions of space (lines 7‚Äì8). The filtering based on ‚àº is applied (line 10). During
this step, the set of triples of 3D points Pi is clustered using ‚àº. A representative of each
equivalence class is chosen (within Pi ) and the corresponding fragment in Ri is identified;
all the other (non-identified) fragments are filtered out from Ri . Let us also note that the

974

A Constraint Solver for Flexible Protein Models

filtering based on clustering is not performed for the initial step P1 , as typically this is
already captured by the restrictions imposed by A.
Once the fragments reachable at last iteration are determined and their representatives
selected, we populate the Tab with the set of tuples associated to each representative L.
~ that allows us to overlap the last point to
The function Œ∑(L) returns the assignments to V
L.
The JMf algorithm is parametric w.r.t. the clustering relation and the function selecting
the representative; they both express the degree of approximation of the rigid bodies to
be built. The proposed clustering relation for loop modeling takes into account two factors: (a) The positions of the end-anchors in the 3D space and (b) The orientation of the
plane formed by the fragment‚Äôs anchor Œ≤L w.r.t. a fixed reference system Œì0 adopted by
FIASCO (c.f. Figure 7). This combination of clusterings allows to capture local geometrical
similarities, since both spatial and rotational features are taken into account.
The spatial clustering (a) used is the following. Given a set of fragments, three end
points C 0 ON (end anchors) of each cluster are considered, and the centroid of the triangle
C 0 ON is computed. We use three parameters: kmin , kmax ‚àà N, kmin ‚â§ kmax , and r ‚àà R,
r ‚â• 0. We start by selecting a set of kmin fragments, pairwise distant at least 2r. These
fragments are selected as representatives of an equivalence class for other fragments that fall
within a sphere of radius r centered in the centroid of the representative. This clustering
ensures a rather even initial distribution of clusters, however some fragments may not fall
within the kmin clusters. We allow to create up to kmax ‚àí kmin new clusters, each of
them covering a sphere of radius r. Remaining fragments are then assigned to the closest
cluster. The employed technique is a variant of the k-means clustering algorithm called
leader clustering algorithm; it allows a fast implementation and acceptable results.
The orientation clustering (b) partitions the fragments according to their relative orientation of planes Œ≤R w.r.t. Œì0 . A plane spatial orientation is described by the Euler angles
œÜ, Œ∏, œà of its frame w.r.t. Œì0 . This algorithm produces a variable number of partitions depending on Œ≤. In particular, given a threshold Œ≤ > 0 there are 3 ¬∑ (360/Œ≤) possible partitions
describing equal regions on a sphere though the interval (œÜ ¬± / Œ≤2 , Œ∏ ¬± / Œ≤2 , œà ¬± / Œ≤2 ). Each
fragment is allotted to the partition determined by Œ≤.
The final cluster is the intersection of the two partitioning algorithms. This defines an
equivalence relation ‚àº depending on kmin , kmax , r, and Œ≤. The representative selection
function selects the fragment for each partition according to some preferences (e.g., most
frequent fragment, closest to the center, etc.).
Note that for r = 0, Œ≤ = 360, and kmax unbounded, no clustering is performed and
this would cause the combinatorial explosion of every possible end-anchor on the whole
problem. The spatial error introduced depends on r and Œ≤. With Œ≤ = 360, the error
introduced at each step can be bounded by 2r for each dimension. At each iteration the
errors are linearly increased, since a new fragment is placed with an initial error gathered
from previous iterations, thus resulting in a 2nr bound for the last end-anchor. Clearly this
bound is very coarse, and on average the experimental results show better performances.
Similar considerations can be argued for rotational errors, however the intersection of the
two clusterings, provide, in general, a much tighter bound.

975

F. Campeotto et al.

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Figure
8: A graphical
representation
of the propagation
a JM constraint
theconstraint
variables Viover
, . . . , Vthe
i+3 .variables Vi , . . . , Vi+
Figure
9: A graphical
representation
of theofpropagation
of over
a JM
(a) A simultaneous placement of all the elements in the domain of the variable Vi+1 is simulated, by
(a) A simultaneous placement of all the elements in the domain of the variable Vi+1 is simulated,
overlapping each corresponding fragment with the end-anchor of the fragment associated to the element in
overlapping
eachsetcorresponding
fragment
the end-anchor
the fragment
to the element
the domain
of Vi . The
of points Pi+1 is
computedwith
and clustered
using theofrelation
‚àº (pointsassociated
within
the domain
Vieach
. The
set one
of points
Pi+1
is computed
andchosen
clustered
using fragments
the relation ‚á† (points with
the dotted
ellipses). ofFor
cluster
fragment
representative
is hence
(highlighted
the dotted
ellipses).
Forcollection
each cluster
one fragment
representative
is hence
(highlighted fragmen
with filled
rightmost
circle). The
of representatives
constitutes
the set Ri+1
(b) Thechosen
previous
step iswith
performed
on the circle).
basis of the
end-anchors
to the fragmentsconstitutes
representatives
ini+1 (b) The previo
filled again
rightmost
The
collectionrelated
of representatives
thechosen
set R
the previous
The filled
box,on
represents
the of
setthe
of points
G that are
not available
the placement
step islevel.
performed
again
the basis
end-anchors
related
to thefor
fragments
representatives chosen
of bodies (for instance due to a distance constraint). and the fragment falling in such area are discarded.
the
previous
level.
The
filled
box,
represents
the
set
of
points
G
that
are
not
available
for the placeme
(c) In the last iteration of the JMf algorithm the set of points Pi+3 is not clustered, but only those that
of
bodies
(for
instance
due
to
a
distance
constraint).
and
the
fragment
falling
in
such
area
are discarde
reach the desired position are retained, for instance the front-anchor associated to the fragment of the next
(c)
In
the
last
iteration
of
the
JMf
algorithm
the
set
of
points
P
is
not
clustered,
but
only
those th
variable, and the sequence of fragments able to lead to such condition (marked by thick
i+3 lines) are selected
to populate
the
table
Tab.
reach the desired position are retained, for instance the front-anchor associated to the fragment of the ne
variable, and the sequence of fragments able to lead to such condition (marked by thick lines) are select
to populate the table Tab.
976

A Constraint Solver for Flexible Protein Models

P
||P-Q||‚â§d

Q
Figure 9: The effect of a distance constraint ||P ‚àí Q|| ‚â§ d propagation. Empty boxes
represent the original PVs domains and the full boxes represent the reduced PVs domains
after the effect of constraint propagation.
4.2.2 Distance Constraints
The propagation of the distance constraints is an approximated technique that reduces the
size of the box domains. We introduce the following operations over PVs box domains of
two variables P and Q that will be used to describe the propagation rule in this and in the
following subsections:
Domain intersection: DP ‚à© DQ = hmax(Pmin , Qmin ), min(Pmax , Qmax )i
Domain union: DP ‚à™ DQ = hmin(Pmin , Qmin ), max(Pmax , Qmax )i
Domain dilatation:
DP + d = hPmin ‚àí d, Pmin + di
where max(P, Q) = (max(Px , Qx ), max(Py , Qy ), max(Pz , Qz )), (and similarly for min), and
P + d = (Px + d, Py + d, Pz + d).
Given two point variables P and Q, with domains DP and DQ , respectively, the simplification rule for the constraint ||P ‚àí Q|| ‚â§ d updates the domains as follows:
DP = ((DQ + d) ‚à© DP )

DQ = ((DP + d) ‚à© DQ )

(8)

which ensures that the points in DP and DQ are positioned within an approximation of a
sphere of radius d. The sphere is approximated by considering the box inscribing it (a cube
of side 2d), as illustrated in Figure 9.
The propagation of the constraint ||P ‚àí Q|| ‚â• d is harder as the coarse representation
of the box domains adopted in this work to model PVs does not allow the description of
more complex polyhedron. We hence apply a simple form of bound consistency described
by the following rule:
	
(DP ‚à™ DQ ) = hl, ui, ||u ‚àí l|| < d
 P
	
||P ‚àí Q|| ‚â• d :
D = ‚àÖ, DQ = ‚àÖ


that establishes unsatisfiability of the constraint.
977

(9)

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

4.2.3 Fragment Constraint
The propagation a fragment constraints fragment(V, P~ , T ) is exploited during the solution
search to enforce the assembly process of the fragment T [V ] along the point variables
P1 , . . . , Pn of P~ . Recall that DV is the domain of V containing the references {j1 , . . . , jk }
to the database of fragments T .
 P1
	
D = {p1 }, DP2 = {p2 }, DP3 = {p3 }, DV = {j1 , . . . , jk }
~
Ô£º
fragment(V, P , T ) : Ô£±
jk
n
Ô£≤^
Ô£Ω
[
{œÅ((p1 , p2 , p3 ), T [f ]) ¬∑ T [f ](i)}
DPi = DPi ‚à©
Ô£≥
Ô£æ
i=1

(10)

f =j1

where œÅ((p1 , p2 , p3 ), T [f ]) is the roto-translation to be applied to overlap the first three
points of the fragment T [f ] with the start-anchor (p1 , p2 , p3 ).
The conjunction in the bottom part of the rule re-evaluates the domains for P1 , P2 , P3 ,
and it may reduce the singleton domains to empty whenever there is no compatible œÅ for
the selected fragment.
4.2.4 Centroid Constraint
When the positions of the atoms N , CŒ± and C 0 for an amino acids a are determined, the
propagation algorithm enforces the value for the PV PCG involved in the centroid constraint.
	
 P
D N = {pN }, DCŒ± = {pCŒ± }, DPC 0 = {pC 0 }
	
centroid(PN , PCŒ± , PC 0 , PCG , a) :  P
(11)
D CG = (DPCG ‚à© {cg(pN , pCŒ± , pC 0 , a)})
where cg(pN , pCŒ± , pC 0 , a) is a support function which returns the center of the mass for
the side chain of the amino acid a by considering the points pN , pCŒ± , pC 0 , as described in
Sect. 3.3.3.
4.2.5 Some Implementation Details
The proposed solver relies on an efficient C++ implementation, and it is carefully designed
to allow additional tailored solving capability without the need of reshaping the core structures.
The internal representation of the domains of the finite domain variables can be abstracted by two arrays of the same length of the size of the initial domain. One array points
to the values and the other is a Boolean bit-mask that states whether a value is still in the
domain. If all flags are set to 0, the current partial assignment cannot be a part of a solution
of the overall constraint; if exactly one is set to 1, then the variable is assigned to a value.
This representation implies a linear scan of the domains during the propagation but it is
justified by the reasonably small size of the domains of the target application (typically less
than 100 values). The internal representation of the domains for point variables is simply a
pair hmin, maxi that uniquely characterizes a 3D box in R3 . Since these variables are used
mostly in distance constraints, this representation is expressive enough (Oct-trees have been
considered but with no significant advantage).
Point Variables propagation has been described above; these variables are instantiated
after fragment selection.
978

A Constraint Solver for Flexible Protein Models

For the management of the uniqueseq property (7) we implemented a dedicated data
structure based on hash tables. Every time a PV is assigned, its value is mapped into a 3D
voxel of fixed size. The 3D grid is implemented via a Hash Table with voxel indexes as keys
and points contained in such voxels as values. All the operations can be performed in OÃÉ(1)
(amortized complexity).
4.3 One Or More JM Constraints
We briefly describe how we have modeled two problems with FIASCO. The JM constraint
is able to model geometrically assembly of fragments and therefore it is used for every
protein model. A single JM that covers a protein ensures its flexibility, however for long
proteins some computational and precision issues arise. It can be beneficial to model a
protein by multiple JM constraints, e.g. JM (i, j) and JM (j, k) so that the amino acids
from i to j are covered and the JM constraints overlap on a common amino acid. This
practical choice improves the approximate search and allows to increase the number of
different solutions produced. In practice, each protein section handled by a JM constraint
is potentially combined to the different arrangements for the other sections. Therefore, it
is expected that the number of solutions found grows exponentially in the number of JM
constraints. The other JM constraint parameters can be used to control clustering precision
and number of conformations found.

5. Experimental Results
We report on the experimental results obtained with the FIASCO system (available at
http://www.cs.nmsu.edu/fiasco). Experiments are conducted on a Linux Intel Core i7
860, 2.5 GHz, memory 8 GB, machine. The solver has been implemented in C++.
The fragment database adopted is the FREAD database which has been shown to be effective in loop structure prediction (Choi & Deane, 2010). For the parameters analysis 5.1.4
we use a database of fragments of length 1. These fragments are classified by their amino
acid class and their frequency of occurrence over the whole top-500.
We set the system to model the two applications described below. In particular, in
Section 5.1 we analyze the loop modeling scenario and we focus on the performances of JM
filtering by examining the filtering power and computational costs. Next, we compare the
quality of the loop conformations generated, by measuring the RMSD of the proposed loop
with respect to the native conformation. We then present some relationships among the
JM parameters to control quality and efficiency.
In Section 5.2 we show some examples of ab-initio protein structure prediction and we
conclude with a comparison of FIASCO against other constraint solvers, for protein models
that can be described by a common subset of constraints.
5.1 Loop Modeling
The loop modeling problem is formalized by the presence of two known (large) fragments
that are both fixed in the space. A sequence of amino acids of length n is given for connecting
these two parts of the protein. A JM constraint is defined over the sequence, with particular
attention to the starting and ending points that are fixed. The start of the first fragment
979

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Figure 10: An example of loop computed by our tool
and the end of the last fragment, namely a sequence C 0 ON (initial points) of coordinates
~a = (a1 , a2 , a3 ), and a sequence C 0 ON (final points) of coordinates ~e = (e1 , e2 , e3 ) are
known. There is one caveat about the end points: due to the discrete nature of fragment
assembly, it is unlikely to exactly reach the final points. We accommodate for some errors,
and require that the JM constraint produces results that fall within some threshold from
the corresponding final points.
In Figure 10 we show an Example of loop computed by our tool (the parts of the protein
to be connected are shown on the left and the connecting loop on the right).
Additional spatial constraints about points (e.g. no-good regions determined by presence
of other atoms) are given. The constant Œ¥ (now Œ¥ = 1.5AÃä) asserts a minimum distance
between pairs of atoms.
5.1.1 Filtered Search Space And Performances
We selected 30 protein targets from a set of non-redundant X-ray crystallography structures
as done by Canutescu and Dunbrack (2003). We partitioned the proteins into 3 classes
according to their loop region lengths (n = 4, 8, and 12). We model a CSP that uses
fragment assembly to model the loop, in particular using the JM constraint over the loop
region.
To assess the filtering capabilities of FIASCO, we perform an exhaustive search generating all the solution for each of the protein targets. Using a clusterization of 0.2AÃä, a number
of different fragments of length 1 is found for each amino acid (see Fig. 11). The size of
the domains for the corresponding FDVs is bound by 100‚Äîthis is an adequate sampling to
describe a reasonable amino acid flexibility. In those cases where the number of fragments
exceeds 100, the 100 most frequent ones are kept.
This increases the likelihood of generating a loop structure that is similar to the native
one. A loop of length n generates an exponential search space of size bounded by 100n . The
selected variable is the leftmost one. Fragments are selected in decreasing frequency order.
We have imposed a JM constraint for every 4 consecutive amino acids. The clustering
parameters are set as follows: the kmin value is equal to the size of the domains, while we

980

100 120 140
80
60
40
0

20

N. of different Fragments

A Constraint Solver for Flexible Protein Models

A

C

D

E

F

G

H

I

K

L

M

N

P

Q

R

S

T

V

W

Y

Amino acids

Figure 11: Number of different fragments (after clustering) per amino acid in the dataset
have used different values for kmax based on loop lengths. The values for r and Œ≤ are set to
120 and 0.5 in each setting. A summary of the parameters is listed in Table 1.
In Table 1 we report the average times needed to exhaustively explore the loop search
space, and the average number of solutions generated.
n
4
8
12

# JM
1
2
3

JM Parameters
kmin kmax
Œ≤
100 1000 120
100
500 120
100
100 120

r
0.5
0.5
0.5

Full JM
# Solutions Time (s)
597
3.13
98507
10.12
328309
28.87

Table 1: Loop Modeling settings and average running times (in seconds) and number of
solutions generated.

5.1.2 JM Approximated Propagator Quality
Even if the approximated JM produces a small set of solutions, we show here that this is
a good representation of the overall variability of the protein structure. For this test, we
compare the solutions by means of RMSD from the original structures. The experiments
were carried out with the same 30 protein targets and settings described in Table 1, with
the only exception of kmax for the loop set of size 12, which was set to 500.
In Figure 12 we show the bar chart for the RMSD of the predictions for each protein
loop within the group of targets analyzed. Precisely, in the x-axis there are the 30 (10 for
each loop length) protein targets. Each bar reports the best RMSD (dark), the average
RMSD (grey), and the worst RMSD (light grey) found. Numbers over the bars represent
the number of loops found (multiplied by the factors indicated underneath). The results
are biased by the fragment database in use: we excluded from it the fragments that belong

981

2.1
0.15

1.1

3.7

0.3

0.38

6
5.6

4.7

1.3
0.78

0.59

0.96
1.3

1.3

1.1

0.67

0.65
0.83

0.64

0.68

0.31

0.77

0.71
0.2

0.52

0.19

1.3

6

0.92

8

Best Rmsd
Avg Rmsd
Worst Rmsd

4
0

2

RMSD (Angstr√∂m)

2.9

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

. 105

. 103

Length 4

Length 8

. 107

Length 12

Figure 12: RMSD comparison for each Loop Set (x-axis: the 30 protein targets)

to the deposited protein targets. Therefore, it is not possible to reconstruct the original
target loop and none of the searches are expected to reach a RMSD equal to 0.
For loops of length 8 and 12, the exploration of the whole conformational search space
using a simple search procedure would result in an excessively long computation time. This
enforces the need for a propagator such as JM, as its filtering algorithm successfully removes
redundant conformations and it allows us to cover the whole search space in a short period
of time.
In Fig. 12 loop predictions are calculated using fragments of length 1. To study how
this choice affects both time and accuracy of the sampling we also model the loops of length
12 using fragment of length 3, 6, and 9. Best RMSDs are reported in Figure 13. For these
experiments we kept the settings used above (kmax = 500). Moreover, each JM constraint
is imposed on the fragments in order to cover the whole fragment (e.g, for fragments of
length 3 we set a JM constraint every three consecutive amino acids) and we set a time-out
of 3600 Seconds.
Notice that increasing the length of the fragments the accuracy decreases due to the
reduced size of the domains. Nevertheless, the time is also reduced since the sampling is
performed on a smaller search space and the JM constraints cover longer sequences of amino
acids. The average times are: 1580.14, 0.98, and 0.74 seconds using fragments of length 3,
6, and 9 respectively.

982

3
2
0

1

RMSD (Angstr√∂m)

4

5

A Constraint Solver for Flexible Protein Models

Len3

Len6

Len9

Figure 13: RMSD comparison for loop sampling on loops of length 12 using fragments of
length 3, 6, and 9.

983

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

5.1.3 Comparison With State-of-the-art Loop Samplers
In this section, we compare our method to three state-of-the-art loop samplers: the Cyclic
Coordinate Descent (CCD) algorithm (Canutescu & Dunbrack, 2003), the Self-Organizing
algorithm (SOS) (Liu, Zhu, Rassokhin, & Agrafiotis, 2009), and the FALCm method (Lee,
Lee, Park, Coutsias, & Seok, 2010).
Table 2 shows the average of the best RMSD for the benchmarks of length 4, 8 and 12
as computed by the four programs. We report the results as given in Table 2 of Canutescu
and Dunbrack for the CCD, Table 1 of Liu et al. for SOS, Table II of Lee et al. for the
FALCm method, and the RMSD‚Äôs obtained adopting the settings for JMf that provided
the best results in the previous section (see also Subsection 5.1.5). It can be noted that our
results are in line with those produced by the other systems.
Loop
Length
4
8
12

Average (best) RMSD
CCD
SOS
FALCm
JMf
0.56
0.20
0.22
0.27
1.59
1.19
0.72
0.93
3.05
2.25
1.81
1.58

Table 2: Comparison of loop sampling methods
The execution time we reported appear to be very competitive (e.g., if we considered
the results reported in Soto et al., 2008).
5.1.4 JM Parameters Analysis
In this section, we analyze the impact of the JM parameters on the quality of the best
solutions found and on the execution times. In particular, the aim of these experiments is
to shed light on the relationship between the JM constraint settings and the results.
In Figure 14, we analyze the impact of the kmax on the execution times (left) and on
the precision (right) of the filtering of the JM constraint. From top to bottom, we use
Œ≤ = 60, 120, 360. The tests are performed over the protein loops of length 4 (see section
above), adopting as cluster parameters, r in {0.5, 1.0, 3.0, 5.0}, and kmin = 100. Each dot in
the plots represents the average of the best RMSD found by each predictions (left) and the
average execution time (right). The RMSD values tend to decrease for smaller clustering
parameters r and Œ≤ and as the number of clusters increases, while the filtering time increases
as kmax increases.
In Figure 15 we study the relation between the RMSD and both the number of JMs that
cover a given target loop or protein and the Voxel-side parameter. For these experiments
we used the values {100, 250, 500, 800, 1000} for the kmax , we set r = 1, Œ≤ = 120, and we
averaged the RMSDs values on the resulting sample set of structures. The relation between
the RMSD and number of JM as well as the average and worst computational times are
shown in Fig. 15 left. Here we use a medium-length loop taken from the protein 1XPC
(res. 216-230) and we vary the number of JMs that cover the loop (the side of the voxel
has been set to 3AÃä). From the figure we observe that increasing the number of JMs (i.e.
covering less amino acids with a single JM) the RMSD decreases but the computational
cost is higher. Notice that the best RMSD is given when the loop is covered by 4 JM

984

A Constraint Solver for Flexible Protein Models

0.9

‚óè

50.0
‚óè

0.8

0.6

10.0
‚óè

r
‚óè

0.5

r

Time (s)

¬∞)
RMSD (A

0.7

0.5
1.0
3.0
5.0

‚óè

0.4

‚óè

0.5
1.0
3.0
5.0

1.0
‚óè

0.3

0.5
‚óè

0.2

‚óè

‚óè

10000

100

0.1

100

1000

5000

1000

5000

JM kmax

10000

JM kmax

50.0
‚óè

0.9
‚óè

0.8
10.0

0.6

r

‚óè

0.5
1.0
3.0
5.0

‚óè

0.5

Time (s)

¬∞)
RMSD (A

0.7
r

‚óè

‚óè

1.0

0.4

0.5
1.0
3.0
5.0

0.5

‚óè

0.3
‚óè
‚óè
‚óè

0.2

100

1000

5000

10000

100

1000

JM kmax

5000

10000

JM kmax

0.9

‚óè

‚óè

0.8

‚óè

0.6

r

‚óè
‚óè

0.5

0.5
1.0
3.0
5.0

Time (s)

¬∞)
RMSD (A

0.7

r

1.0

‚óè

0.5

0.5
1.0
3.0
5.0

0.4
‚óè
‚óè

0.3
‚óè

‚óè

5000

10000

0.2

100

1000

100

JM kmax

1000

5000

10000

JM kmax

Figure 14: Comparison of the best RMSD values and execution times at varying of the
kmax clustering parameter for Œ≤ = 60 (top), 120 (center), 360 (bottom)

985

7
RMSD

1LE0
1MXN
1FDF

0

0

1

2

3

2091.72 (3216.94)

1105.63 (2057.83)

194.70 (411.95)

9.53 (19.54)

11.73 (18.42)

4
2

RMSD

4

5

6

6

8

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

1

2

3

4

5

0

N.of JM

20

40

60

80

100

Voxel‚àíSide

Figure 15: Left: RMSD (best and average) and Time (average and worst) values increasing
the number of JM constraints that completely cover a target loop of length 15. Right:
Average (dotted line) and best (solid line) RMSD for the targets 1LE0 of length 12 (top),
1MXN of length 16 (medium), and 1FDF of length 25 (low). The JM-Voxel-side parameter
for the voxels of the clustering varies from 3 to 100. The JM kmax parameter varies from
100 to 1000. The targets are completely covered by multiple JM-constraints.
constraint (i.e., a JM constraint each four consecutive amino acids). As a rule of thumb
we suggest to use a JM constraint to cover from 3 to 4 consecutive amino acids since this
setting produces the best results within an acceptable time. In Fig. 15 right we report the
best RMSD (solid line) and the average RMSD (dotted line) of the structures found using
multiple JM constraints that cover sequences of 4 consecutive amino acids through the whole
target proteins. Namely, if the protein target has length n, we set the JM constraints from
i to i + 3, where i = 3 ¬∑ j, 0 ‚â§ j < n/3. For these experiments, we considered three proteins
of relatively short length, in order to obtain a complete exploration of the search space in
reasonable computational time: 1LE0 (length 12), 1MXN (length 16), and 1FDF (length
24). Moreover we used the values {3, 5, 10, 20, 30, 50, 100} for the side of the voxels used for
the clustering.
From the Figure 15 we observe that the voxel size (enabled by the uniqueseq) has an
impact on the clustering for values lower than 30AÃä (recall that these proteins have a diameter
less than 30AÃä). For voxel sides lower than 3AÃä we observe no substantial improvement in
terms of quality, while the time required by the solver to compute the solutions increases
exponentially.
5.1.5 Results Summary And Default Parameters
We now provide some guidelines that may be helpful to tune the JM parameters for a given
protein modeling problem. We suggest several levels of parametrization that might be used
according to the user needs with respect to running time or prediction accuracy. We stress

986

A Constraint Solver for Flexible Protein Models

that these are merely guidelines, outlined from our empirical evaluations, and that several
tests should be done to establish the desired tuning.
We suggest to set a JM to model a sequence of at least 3 amino acids and in general not
longer than 8, to payoff the computational load of the JM clustering. The default choice
for kmin is set to be the average size of the variable domains involved in a JM constraint,
while we suggest to set kmax to be at least as kmin and not greater than 10000. The latter,
together with the number of consecutive JM constraints, will have the greatest impact on the
computational cost and prediction accuracy. Computational costs will grow as the number
of consecutive JM increases, and at the same time it will also produce in general higher
accuracy. The same trend is exhibited by the growing kmax parameter. Table 3 illustrates
five basic settings that could be used incrementally to establish a trade off between running
times and prediction accuracy. The first level (Lev. 1) is associated to faster computational
times and lower accuracy while the last one (Lev. 5) is the slowest but also the most accurate.
The second column of the table indicates the length of the amino acid sequence modeled
by a single JM.
Lev.
1
2
3
4
5

n.JM
8
8
6
4
4

kmin
|D|
|D|
|D|
|D|
|D|

kmax
500
1000
100
500
1000

Œ≤
120
120
120
120
120

r
5
3
3
3
1

Speed
‚àó ‚àó ‚àó ‚àó
‚àó ‚àó ‚àó
‚àó ‚àó ‚àó
‚àó‚àó
‚àó

Accuracy
‚àó
‚àó‚àó
‚àó‚àó
‚àó ‚àó ‚àó
‚àó ‚àó ‚àó ‚àó

Table 3: JM default parameters

5.2 An Application In Protein Structure Prediction
In the protein structure prediction problem, we model a generic backbone through multiple
JM constraints. In principle, an unique JM constraint can model the whole problem. As
in the previous cases, we split it into smaller parts, moreover, the presence of secondary
structure is a valid help in the placement of JM constraints that can handle loops between
each consecutive pair. A simple search can generate a pool of conformations, then energy
scoring can select the best candidate. We have used a statistical energy function developed
for the 5@ model, but any other energy function can be used instead.
In this section, we study the applicability of FIASCO to the protein structure prediction
problem. In particular, we consider prediction problems where the secondary structure
elements of the protein are given. Furthermore, in order to assess the potential structure,
we introduce an energy function‚Äîthe same that we have adopted in previous studies, and
more precisely described in http://www.cs.nmsu.edu/fiasco.
For the modeling, we have used the information about the location and the type of
the secondary structure elements on the primary sequence provided directly by the Protein
Data Bank. We have imposed a sequence of JM constraints between every consecutive
pair of secondary structure elements. The number of consecutive JM constraints varied
according to the length of the unstructured sequence being modeled, covering at most 5
amino acids with a single JM constraint. In addition one JM constraint was imposed from
the first amino acid to the beginning of the first secondary structure element and another
987

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

from the end of the last secondary structure element and the last amino acid (the tails of
the protein). The domains for the initial and end points of the JM constraints are the set of
all admissible points (a box large enough to contain the protein). In the search phase, the
‚Äúfirst‚Äù secondary structure is deterministically set in the space. Then the labeling proceeds
with the JM constraint attached to it leading to the next secondary structure and so on.
Tails are instantiated at the end.
The propagation of the constraints generates a set of admissible structures, that represents the possible folds of the target protein. From this set, we select the structure with
minimum energy; we extract also the structure with minimum RMSD, in order to evaluate
the quality of the energy function. For these tests we adopt the FREAD database. Table 4
reports the best energy values found by FIASCO. In the RMSD columns is reported the
corresponding RMSD associated to the conformation with best energy found by the solver.
The #JM column reports the total number of JM used to model each protein, together
with the maximum number of consecutive JM adopted to model a contiguous sequence of
amino acids (within parentheses).
Protein ID
1ZDD
2GP8
2K9D
1ENH
2IGD
1SN1
1AIL
1B4R
1JHG

Len.
35
40
44
54
60
63
69
79
100

# JM
4(2)
4(2)
5(2)
4(1)
7(2)
7(3)
4(1)
11(2)
7(1)

Energy
‚àí100513
‚àí138110
‚àí204693
‚àí309896
‚àí295882
‚àí358874
‚àí411077
‚àí313590
‚àí572950

RMSD
2.05
6.28
2.52
8.21
10.50
5.55
4.59
6.11
4.51

Time (Min.)
11.42
8.55
2.69
31.67
26.47
14.82
4.46
8.41
4.50

Table 4: Ab initio prediction with FIASCO.
The results show that the quality of the predictions computed by FIASCO (6.3 as average
RMSD) is competitive (and, as shown in the following section, at par or better than what
produced by other methods). The results are particularly encouraging for proteins of longer
length, where the sampling of the search space aids in development of admissible structures.
The time required by FIASCO to completely explore the search space depends strongly on
the type and the mutual arrangement of secondary structure elements of the target. For
example, the protein 2K9D and the protein 1ENH have the same length, but FIASCO is
significantly faster on the first protein than on the second one. The same observation can
be made for the proteins 2IGD and 1SN1. The results reported in Table 4 are promising
and they suggest that this is a feasible approach to solve the ab initio prediction problem.
As a future work, we will explore the integration of local search techniques (e.g., largeneighboring search), in order to sample the search space and to further decrease the time
needed to explore it.

988

A Constraint Solver for Flexible Protein Models

5.3 A Comparison of FIASCO with State-of-the-Art Constraint Solvers
In this section, we motivate our choice of designing an ad-hoc solver instead of using a
general-purpose constraint solver. In particular we provide a comparison between FIASCO
and state-of-the-art constraint solving. The results justify the choice of implementing a new
solver from scratch instead of using an available constraint programming library or a constraint programming language. The solver chosen for this comparison is Gecode (Gecode
Team, 2013), a very efficient solver and the winner of the most recent MiniZinc challenges (Stuckey, Becket, & Fischer, 2010).
Gecode has recently introduced (in version 4.0) the handling of floating point variables.
Nevertheless, since Gecode is the fastest solver for FD variables, we have first encoded
the PSP by discretizing fragments and positions. In particular, we multiplied each real
number by a scaling factor (100) to obtain integer values. Each spatial position is encoded
by a triple of variables, representing the coordinates of the point. Each operation (e.g.,
multiplications) applied to such variables requires re-scaling of the result; this unfortunately
leads to ineffective propagation. This is particularly evident when dealing with distance
constraints, that require the implementation of Euclidean distance between pairs of triples
of variables.
In order to understand the solvers capabilities to propagate constraints on the placement of overlapping fragment we implemented three versions of the code, that considered
a different number of constraints, precisely:
1. An implementation that uses only JM constraint (JM only)
2. An implementation that adds the alldistant constraint and
3. An implementation that adds the alldistant and centroid constraints
In all cases we use a complete search (in particular, the clustering and tabling constraints
of lines 10 and 12‚Äì14 of Algorithm 2 are disabled).
In Table 5, we report the execution times required by FIASCO and by Gecode (with the
same considered constraints) to determine an increasing number of solutions, from 1, 000
to 1, 000, 000. These solutions are computed for the target protein 1ZDD which has length
35. Table 5 shows that the execution time of both solvers increases proportionally with the
number of solutions found. However, FIASCO is one order of magnitude faster than Gecode
in the unconstrained case, and two orders of magnitude faster in the other cases. The main
reason is that FIASCO is specifically developed to handle the finite domains and 3D point
variables, while these are approximated by FD variables in Gecode. Constraints on these
approximations propagate poorly and slowly. Moreover, the approximation of fragments
using finite domain variables introduces approximation errors, that grow during the search
phase (and consequently, less solutions are returned in the constrained cases). These errors
may result in final structures that are relatively imprecise when the coordinates of the atoms
are converted back into real values.
In Table 6, we consider a small sequence of four amino acids (SER TRP THR TRP‚Äîthe
first four amino acids of the protein 1LE0), and we generate all solutions. We report the
values of the best and the average RMSD among the structures of the sets of solutions computed using FIASCO and the Gecode implementation after a complete enumeration of the
989

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Number of
solutions
1000
10000
100000
1000000

JM only
0.030
0.312
3.006
29.859

FIASCO
alldistant alldistant + centroid
0.051
0.059
0.476
0.612
4.794
6.040
47.669
61.385

JM only
0.358
2.571
25.407
252.815

Gecode
alldistant alldistant + centroid
2.531
3.807
21.056
35.370
209.569
347.831
2186.83
3632.39

Table 5: Comparison of the execution times of FIASCO and Gecode, for increasing number
of solutions and with different sets of considered constraints.
domains. We can observe that FIASCO is significantly faster in exploring the search space,
moreover, the approximation introduces errors that leads to the loss of feasible solutions.

JM only
alldistant
alldistant + centroid

N. sol.
810000
805322
805322

FIASCO
Time (sec.) RMSD
20.493
0.167
33.493
0.167
38.953
0.167

Avg. RMSD
1.570
1.564
1.564

N. sol
810000
774463
169441

Gecode
Time (sec.) RMSD
181.102
0.190
252.974
0.190
140.644
0.580

Avg. RMSD
1.596
1.591
1.880

Table 6: Number of solutions, time, best RMSD, and average RMSD on the set of structures
found by FIASCO and Gecode after a complete enumeration of the solution space using
different constraints
We have encoded the same constraint satisfaction problem using the new version of
Gecode that allows to employ float variables. We labeled the finite domain variables that
allow to select fragments, while values for the point variables are obtained by constraint
propagation. Since constraint propagation of float variables is based on interval arithmetics,
it turns out that after few amino acids these intervals are too large for being able of reconstructing the protein and or evaluating the energy value. For instance, after a complete
assignment of the variables related to fragments of protein 1ZDD, while the domains of the
float variables associated with the position of the first two amino acids are singletons, those
related to the tenth amino acids are intervals with size from one to two AÃä; even worse,
the domains of the atoms of the eleventh amino acids are unbounded. A further stage of
labeling of the float variables required computational time of orders of magnitude higher
than those reported in Table 6 for the finite domain Gecode implementation.
Constraint solvers like ECLiPSe (Cheadle, Harvey, Sadler, Schimpf, Shen, & Wallace, 2003) and Choco (Choco Team, 2008) also support the mixed use of integer and
real variables. ECLiPSe is a Prolog-based language which handles integer and real variables together. However, the great number of matrix operations required in our application does not fit well with a Prolog implementation. Furthermore, the current trend
of ECLiPSe is to replace a direct constraint solving with a translation to FlatZinc. In
the case of Choco, the current support of Real Variables is still under development (c.f.
http://choco.sourceforge.net/userguide.pdf‚Äîpage 3). Things may change with the
next releases.
We also experimented with another constraint solver, by implementing the multi-body
constraints using the JaCoP library (JaCoP Team, 2012), in a similar way as done for
Gecode. Eventually, we tested the same protein used for the results reported in Table 5,

990

A Constraint Solver for Flexible Protein Models

and we did not observe any substantial difference in terms of execution time, from the
Gecode implementation.
In terms of protein structure prediction, the design of FIASCO has been influenced by
our own previous work on the TUPLES system (Dal PaluÃÄ et al., 2011). TUPLES is also a
constraint solver for protein structure prediction, based on fragments assembly. Figure 16
compares the performance of TUPLES and FIASCO on the same set of proteins discussed
in Section 5.2. To make the comparison fair, we make use of the same energy function in
both systems and assume that the secondary structure elements are known. Note that there
are some important differences between the two systems. TUPLES is implemented using
constraint logic programming techniques, specifically, SICStus Prolog (Swedish Institute for
Computer Science, 2012); TUPLES does not make use of floating point variables; on the
other hand, TUPLES introduces a heuristic search mechanism based on large neighboring
search.
The results show that the quality of the predictions computed by FIASCO (6.3 as average
RMSD) is better than the quality of the predictions computed by TUPLES (9.4 as average
RMSD). The complete sampling of the search space allows us to obtain better results for
the proteins of longer length in the benchmark (‚â• 63). Instead, for shorter proteins, we
obtain comparable results. The similarity of the quality depends on the use of the same
energy function for both the systems. Notice that the energy function used is designed for
the simpler model adopted in TUPLES (CŒ± ‚ÄìCŒ± ). Moreover, TUPLES is based on a Prolog
implementation that does not provide floating point variables and hence each value must
be rounded and approximated. These aspects explain both the quality differences between
the RMSD and the Best RMSD found by FIASCO and the behavior for which for some
proteins (e.g., 1ZDD, 2GP8 ) the (energy) RMSD values are better in FIASCO even if their
corresponding energy (RMSD) values are higher than in TUPLES. The execution times of
FIASCO are significantly faster than TUPLES, in spite of FIASCO‚Äôs lack of a sophisticated
search heuristic.
We also performed a comparison with the state-of-the-art online Robetta predictor (Raman, Vernon, Thompson, Tyka, Sadreyev, Pei, Kim, Kellogg, DiMaio, Lange, Kinch, Sheffler, Kim, Das, Grishin, & Baker, 2009) for the first four proteins of Table 6. We built
the dictionary for 3 and 9 amino acid long peptides through the Robetta interface, and we
disabled any homology inference, in order to maintain a fair comparison. The results are:
1ZDD computed in 21s with 5.92 RMSD, 2GP8 computed in 16s with 5.44 RMSD, 2K9D
computed in 22s with 4.65 RMSD, 1ENH computed in 39s with 2.74 RMSD. It can be noted
that our results are in line with Robetta predictor.
Let us conclude this section mentioning that the results reported in the previous section
(where we compared FIASCO with TUPLES) provide also an implicit comparison with another off-the-shelf solver, the SICStus Prolog constraint logic programming solver (Swedish
Institute for Computer Science, 2012).

6. Conclusions
In this paper, we presented a novel constraint (joined-multibody) to model rigid bodies
connected by joints, with constrained degrees of freedom in the 3D space. We presented a
polynomial time approximated filtering algorithm of the joined-multibody constraint, that
991

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Figure 16: Comparison of RMSD and Execution Time between TUPLES and FIASCO

992

A Constraint Solver for Flexible Protein Models

exploits the geometrical features of the rigid bodies. In particular, the filtering algorithm
is combined with search heuristics that can produce a pool of admissible solutions that are
uniformly sampled. This allows for a direct control of the quality and number of solutions.
The filtering algorithm is based on a 3D clustering procedure that is able to cope with
a high variability of rigid bodies, while preserving the computational cost. The practical
advantages of the joined-multibody constraint are shown by an extensive set of real protein
simulations for two main categories: protein loop reconstruction and structure prediction
(ab-initio). The tests showed how the parameters of the constraint are able to control
effectively the quality and computational cost of the search. In conclusion, the constraint
solver FIASCO is able to model effectively various common protein case-studies analyses.
As future work, from the applications side, we plan to explore the protein loop closure
problem, with the use of specific databases and scoring functions. For the close problem of
protein flexibility, we plan to use FIASCO solver to generate the conformational space of
long scale movements for nuclear receptors (Dal PaluÃÄ et al., 2012b). Finally, we plan to use
FIASCO in the general context of protein structure prediction with the combination of local
search methods and protein-ligand spatial constraints. From the constraint side, we plan
to integrate the JM filtering algorithm with other distance constraints, in order to generate
more accurate clusters; we plan to integrate spatial constraints inferred from bounds on
energy terms (e.g., the favorable contributions provided by pairing secondary structure
elements translate into energy bounds and distance constraints). We plan to investigate the
use of multiple JM constraints to model super-secondary structures placement, which are
useful to capture important functional and structural protein features. The latter can be
thought of as imposing several spatial path preferences to a given chain of points. Finally,
we intend to integrate the constraint solver with a visual interface to make it easily available
to Biologist and other practitioners and porting some parts of this tool within a GPU-based
framework as recently explored by Campeotto, Dovier, and Pontelli (2013).

Acknowledgments
We thank Federico Fogolari for his comments on several parts of this work. The authors
would like to express gratitude to JAIR reviewers that helped us to sensibly improve the
presentation.

References
Al-Bluwi, I., Simeon, T., & Cortes, J. (2012). Motion Planning Algorithms for Molecular
Simulations: A Survey. Computer Science Review, 6 (4), 125‚Äì143.
Alberts, B., Johnson, A., Lewis, J., Raff, M., Roberts, K., & Walter, P. (2007). Molecular
Biology of the Cell (5th Edition edition). Garland Science.
Anfinsen, C. B. (1973). Principles that Govern the Folding of Protein Chains. Science, 181,
223‚Äì230.
Apt, K. (2009). Principles of Constraint Programming. Cambridge University Press.
Backofen, R., & Will, S. (2006). A Constraint-Based Approach to Fast and Exact Structure
Prediction in 3-Dimensional Protein Models. Constraints, 11 (1), 5‚Äì30.
993

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Backofen, R., Will, S., & Bornberg-Bauer, E. (1999). Application of Constraint Programming Techniques for Structure Prediction of Lattice Proteins with Extended Alphabet.
Bioinformatics, 15(3), 234‚Äì242.
Baker, D., & Sali, A. (2001). Protein Structure Prediction and Structual Genomics. Science,
294 (5540), 93‚Äì96.
Barahona, P., & Krippahl, L. (2008). Constraint Programming in Structural Bioinformatics.
Constraints, 13 (1-2), 3‚Äì20.
Ben-David, M., Noivirt-Brik, O., Paz, A., Prilusky, J., Sussman, J. L., & Levy, Y. (2009).
Assessment of CASP8 Structure Predictions for Template Free Targets. Proteins, 77,
50‚Äì65.
Bennett, W., & Huber, R. (1984). Structural and Functional Aspects of Domain Motions
in Proteins. Crit. Rev. Biochem., 15, 291‚Äì384.
Borning, A. (1981). The Programming Language Aspects of ThingLab, a ConstraintOriented Simulation Laboratory. ACM Transactions on Programming Languages and
Systems, 3 (4), 353‚Äì387.
Cahill, S., Cahill, M., & Cahill, K. (2003). On the Kinematics of Protein Folding. Journal
of Computational Chemistry, 24 (11), 1364‚Äì1370.
Campeotto, F., Dovier, A., & Pontelli, E. (2013). Protein Structure Prediction on GPU:
a Declarative Approach in a Multi-agent Framework. In International Conference on
Parallel Processing (ICPP), pp. 474‚Äì479. IEEE Computer Society Press.
Campeotto, F., Dal PaluÃÄ, A., Dovier, A., Fioretto, F., & Pontelli, E. (2012). A Filtering
Technique for Fragment Assembly-Based Proteins Loop Modeling with Constraints.
In Milano, M. (Ed.), CP, Vol. 7514 of Lecture Notes in Computer Science, pp. 850‚Äì866.
Springer.
Canutescu, A., & Dunbrack, R. (2003). Cyclic coordinate descent: a robotics algorithm for
protein loop closure. Protein Sci, 12, 963‚Äì972.
Cheadle, A. M., Harvey, W., Sadler, A. J., Schimpf, J., Shen, K., & Wallace, M. G. (2003).
ECLiPSe: An Introduction. Technical report IC-Parc 03‚Äì1, IC-Parc, Imperial College
London.
Chelvanayagam, G., Knecht, L., Jenny, T., Benner, S., & Gonnet, G. (1998). A Combinatorial Distance-Constraint Approach to Predicting Protein Tertiary Models from
Known Secondary Structure. Folding and Design, 3, 149‚Äì160.
Choco Team (2008). Choco: an Open Source Java Constraint Programming Library. In
Workshop on Open-Source Software for Integer and Constraint Programming. Available from http://www.emn.fr/z-info/choco-solver/.
Choi, Y., & Deane, C. M. (2010). FREAD Revisited: Accurate Loop Structure Prediction
Using a Database Search Algorithm. Proteins, 78 (6), 1431‚Äì40.
Clementi, C. (2008). Coarse-grained Models of Protein Folding: Toy Models or Predictive
Tools?. Curr Opin Struct Biol, 18, 10‚Äì15.
994

A Constraint Solver for Flexible Protein Models

Corblin, F., Trilling, L., & Fanchon, E. (2005). Constraint Logic Programming for Modeling
a Biological System Described by a Logical Network. In Workshop on ConstraintBased Methods for Bioinformatics.
Cortes, J., & Al-Bluwi, I. (2012). A Robotics Apporach to Enhance Conformational Sampling of Proteins. In International Design Engineering Technical Conferences and
Computers and Information in Engineering Conference, Vol. 4, pp. 1177‚Äì1186. ASME.
Crescenzi, P., Goldman, D., Papadimitriou, C., Piccolboni, A., & Yannakakis, M. (1998).
On the Complexity of Protein Folding. In Proceedings of the Thirtieth Annual ACM
Symposium on the Theory of Computing, pp. 597‚Äì603. ACM Press.
Dal PaluÃÄ, A., Dovier, A., Fogolari, F., & Pontelli, E. (2012a). Protein Structure Analysis
with Constraint Programming. In Cozzini, P., & Kellogg, G. (Eds.), Computational
Approaches to Nuclear Receptors, chap. 3, pp. 40‚Äì59. The Royal Society of Chemistry.
Dal PaluÃÄ, A., Spyrakis, F., & Cozzini, P. (2012b). A New Approach for Investigating Protein
Flexibility Based on Constraint Logic Programming: The First Application in the Case
of the Estrogen Receptor. European Journal of Medicinal Chemistry, 49, 127‚Äì140.
Dal PaluÃÄ, A., Dovier, A., & Fogolari, F. (2004). Constraint Logic Programming Approach
to Protein Structure Prediction. BMC Bioinformatics, 5, 186.
Dal PaluÃÄ, A., Dovier, A., Fogolari, F., & Pontelli, E. (2010). CLP-based protein fragment
assembly. Theory and Practice of Logic Programming, 10 (4-6), 709‚Äì724.
Dal PaluÃÄ, A., Dovier, A., Fogolari, F., & Pontelli, E. (2011). Exploring Protein Fragment
Assembly Using CLP. In Walsh, T. (Ed.), Proceedings of the International Joint
Conference on Artificial Intelligence, IJCAI, pp. 2590‚Äì2595. IJCAI/AAAI.
Dal PaluÃÄ, A., Dovier, A., & Pontelli, E. (2005). A New Constraint Solver for 3D Lattices and
Its Application to the Protein Folding Problem. In International Conference on Logic
for Programming Artificial Intelligence and Reasoning, pp. 48‚Äì63. Springer Verlag.
Dal PaluÃÄ, A., Dovier, A., & Pontelli, E. (2007). A Constraint Solver for Discrete Lattices,
its Parallelization, and Application to Protein Structure Prediction. Software Practice
and Experience, 37 (13), 1405‚Äì1449.
Dal PaluÃÄ, A., Dovier, A., & Pontelli, E. (2010). Computing Approximate Solutions of
the Protein Structure Determination Problem using Global Constraints on Discrete
Crystal Lattices. International Journal of Data Mining and Bioinformatics, 4 (1),
1‚Äì20.
Deane, C., & Blundell, T. (2001). CODA. A Combined Algorithm for Predicting the Structurally Variable Regions of Protein Models. Protein Sci, 10, 599‚Äì612.
Debartolo, J., Hocky, G., Wilde, M., Xu, J., Freed, K., & Sosnick, T. (2010). Protein
Structure Prediction Enhanced with Evolutionary Diversity: SPEED. Protein Science,
19 (3), 520‚Äì534.
DotuÃÅ, I., CebriaÃÅn, M., Van Hentenryck, P., & Clote, P. (2011). On Lattice Protein Structure
Prediction Revisited. IEEE/ACM Trans. Comput. Biology Bioinform, 8 (6), 1620‚Äì
1632.
995

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Dunbrack, R. (2002). Rotamer Libraries in the 21st Century. Curr. Opin. Struct. Biol.,
12 (4), 431‚Äì440.
Erdem, E. (2011). Applications of Answer Set Programming in Phylogenetic Systematics.
In Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning, pp.
415‚Äì431. Springer Verlag.
Erdem, E., & Ture, F. (2008). Efficient Haplotype Inference with Answer Set Programming.
In National Conference on Artificial Intelligence (AAAI), pp. 436‚Äì441. AAAI/MIT
Press.
Felts, A., Gallicchio, E., Chekmarev, D., Paris, K., Friesner, R., & Levy, R. (2008). Prediction of Protein Loop Conformations using AGBNP Implicit Solvent Model and
Torsion Angle Sampling. J Chem Theory Comput, 4, 855‚Äì868.
Fiser, A., Do, R., & Sali, A. (2000). Modeling of Loops in Protein Structures. Protein Sci,
9, 1753‚Äì1773.
Fogolari, F., Esposito, G., Viglino, P., & Cattarinussi, S. (1996). Modeling of Polypeptide
Chains as CŒ± Chains, CŒ± Chains with CŒ≤ , and CŒ± Chains with Ellipsoidal Lateral
Chains. Biophysical Journal, 70, 1183‚Äì1197.
Fogolari, F., Pieri, L., Dovier, A., Bortolussi, L., Giugliarelli, G., Corazza, A., Esposito, G.,
& Viglino, P. (2007). Scoring Predictive Models using a Reduced Representation of
Proteins: Model and Energy Definition. BMC Structural Biology, 7 (15), 1‚Äì17.
Fogolari, F., Corazza, A., Viglino, P., & Esposito, G. (2012). Fast Structure Similarity
Searches among Protein Models: Efficient Clustering of Protein Fragments. Algorithms
for Molecular Biology, 7, 16.
Fujitsuka, Y., Chikenji, G., & Takada, S. (2006). SimFold Energy Function for De Novo
Protein Structure Prediction: Consensus with Rosetta. Proteins, 62, 381‚Äì398.
Gay, S., Fages, F., Martinez, T., & Soliman, S. (2011). A Constraint Program for Subgraph
Epimorphisms with Application to Identifying Model Reductions in Systems Biology.
In Workshop on Constraint-Based Methods for Bioinformatics.
Gebser, M., Schaub, T., Thiele, S., & Veber, P. (2011). Detecting Inconsistencies in Large
Biological Networks with Answer Set Programming. Theory and Practice of Logic
Programming, 11 (2-3), 323‚Äì360.
Gecode Team (2013). Gecode: Generic Constraint Development Environment. Available
from http://www.gecode.org.
Go, N., & Scheraga, H. (1970). Ring Closure and Local Conformational Deformations of
Chain Molecules. Macromolecules, 3, 178‚Äì187.
Graca, A., Marques-Silva, J., Lynce, I., & Oliveira, A. (2011). Haplotype Inference with
Pseudo-Boolean Optimization. Annals of OR, 184 (1), 137‚Äì162.
Guns, T., Sun, H., Marchal, K., & Nijssen, S. (2010). Cis-regulatory Module Detection Using
Constraint Programming. In IEEE International Conference on Bioinformatics and
Biomedicine (BIBM), pp. 363‚Äì368.
996

A Constraint Solver for Flexible Protein Models

Handl, J., Knowles, J., Vernon, R., Baker, D., & Lovell, S. (2012). The Dual Role of
Fragments in Fragment-Assembly Methods for De Novo Protein Structure Prediction.
Proteins: Structure, Function and Bioinformatics, 80 (2), 490‚Äì504.
Hartenberg, R., & Denavit, J. (1995). A Kinematic Notation for Lower Pair Mechanisms
Based on Matrices. Journal of Applied Mechanics, 77, 215‚Äì221.
Hegler, J., LaÃàtzer, J., Shehu, A., Clementi, C., & Wolynes, P. (2009). Restriction Versus
Guidance in Protein Structure Prediction. Proc Natl Acad Sci U.S.A., 106 (36), 15302‚Äì
15307.
Jacobson, M., Pincus, D., Rapp, C., Day, T., Honig, B., Shaw, D., & Friesner, R. (2004). A
Hierarchical Approach to All-atom Protein Loop Prediction. Proteins, 55, 351‚Äì367.
JaCoP Team (2012). JaCoP web page, visited November 2012..
http://www.jacop.eu.

Available from

Jamroz, M., & Kolinski, A. (2010). Modeling of Loops in Proteins: a Multi-method Approach. BMC Struct. Biol., 10 (5).
Jauch, R., Yeo, H., Kolatkar, P. R., & Clarke, N. D. (2007). Assessment of CASP7 Structure
Predictions for Template Free Targets. Proteins, 69, 57‚Äì67.
Jones, D. (2006). Predicting Novel Protein Folds by using FRAGFOLD. Proteins, 45,
127‚Äì132.
Karplus, K., Karchin, R., Draper, J., Casper, J., Mandel-Gutfreund, Y., Diekhans, M.,
& Source., R. H. (2003). Combining local structure, fold-recognition, and new fold
methods for protein structure prediction. Proteins, 53 (6), 491‚Äì497.
Karplus, M., & Shakhnovich, E. (1992). Protein Folding: Theoretical Studies of Thermodynamics and Dynamics. In Protein Folding, pp. 127‚Äì195. WH Freeman.
Kim, D. E., Blum, B., Bradley, P., & Baker, D. (2009). Sampling Bottlenecks in De novo
Protein Structure Prediction. Journal of Molecular Biology, 393 (1), 249 ‚Äì 260.
Kinch, L., Yong Shi, S., Cong, Q., Cheng, H., Liao, Y., & Grishin, N. V. (2011). CASP9
assessment of free modeling target predictions. Proteins, 79, 59‚Äì73.
Kirillova, S., Cortes, J., Stefaniu, A., & Simeon, T. (2008). An NMA-Guided Path Planning Approach for Computing Large-Amplitude Conformational Changes in Proteins.
Proteins: Structure, Function, and Bioinformatics, 70 (1), 131‚Äì143.
Kolodny, R., Guibas, L., Levitt, M., & Koehl, P. (2005). Inverse Kinematics in Biology:
The Protein Loop Closure Problem. The International Journal of Robotics Research,
24 (2-3), 151‚Äì163.
Krippahl, L., & Barahona, P. (2002). Psico: Solving Protein Structures with Constraint
Programming and Optimization. Constraints, 7 (4-3), 317‚Äì331.
Krippahl, L., & Barahona, P. (2005). Applying Constraint Programming to Rigid Body
Protein Docking. In Principles and Practice of Constraint Programming, pp. 373‚Äì
387. Springer Verlag.
Krippahl, L., & Barahona, P. (1999). Applying Constraint Programming to Protein Structure Determination. In Principles and Practice of Constraint Programming, pp. 289‚Äì
302. Springer Verlag.
997

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Larhlimi, A., & Bockmayr, A. (2009). A New Constraint-Based Description of the SteadyState Flux Cone of Metabolic Networks. Discrete Applied Mathematics, 157 (10),
2257‚Äì2266.
LaValle, S. (2006). Planning Algorithms. Cambridge University Press.
Lazaridis, T., Archontis, G., & Karplus, M. (1995). Enthalpic Contribution to Protein
Stability: Atom-Based Calculations and Statistical Mechanics. Adv. Protein Chem.,
47, 231‚Äì306.
Lee, J., Kim, S., Joo, K., Kim, I., & Lee, J. (2004). Prediction of Protein Tertiary Structure
using Profesy, a Novel Method Based on Fragment Assembly and Conformational
Space Annealing. Proteins, 56 (4), 704‚Äì714.
Lee, J., Lee, D., Park, H., Coutsias, E., & Seok, C. (2010). Protein Loop Modeling by Using
Fragment Assembly and Analytical Loop Closure. Proteins, 78 (16), 3428‚Äì3436.
Liu, P., Zhu, F., Rassokhin, D., & Agrafiotis, D. (2009). A Self-organizing Algorithm for
Modeling Protein Loops. PLOS Comput Biol, 5 (8).
Lovell, S., Davis, I., Arendall, W., de Bakker, P., Word, J., Prisant, M., Richardson, J., &
Richardson, D. (2003). Structure Validation by CŒ± Geometry: œÜ, œà and CŒ≤ Deviation.
Proteins, 50, 437‚Äì450.
Mann, M., & Dal PaluÃÄ, A. (2010). Lattice Model Refinement of Protein Structures. In
Workshop on Constraint-Based Methods for Bioinformatics.
Micheletti, C., Seno, F., & Maritan, A. (2000). Recurrent oligomers in proteins: an optimal scheme reconciling accurate and concise backbone representations in automated
folding and design studies. proteins, 40 (4), 662‚Äì674.
Moll, M., Schwarz, D., & Kavraki, L. (2007). Roadmap Methods for Protein Folding. Humana Press.
Molloy, K., Saleh, S., & Shehu, A. (2013). Probabilistic Search and Energy Guidance for
Biased Decoy Sampling in Ab-Initio Protein Structure Prediction. IEEE/ACM Trans.
Comput. Biology Bioinform, PrePrint.
Neumaier, A. (1997). Molecular Modeling of Proteins and Mathematical Prediction of
Protein Structure. SIAM Review, 39, 407‚Äì460.
Noonan, K., O‚ÄôBrien, D., & Snoeyink, J. (2005). Protein Backbone Motion by Inverse
Kinematics. International Journal of Robotics Research, 24 (11), 971‚Äì982.
Olson, B. S., Molloy, K., & Shehu, A. (2011). In Search of the Protein Native State with
a Probabilistic Sampling Approach. J. Bioinformatics and Computational Biology,
9 (3), 383‚Äì398.
Raman, S., Vernon, R., Thompson, J., Tyka, M., Sadreyev, R., Pei, J., Kim, D., Kellogg, E.,
DiMaio, F., Lange, O., Kinch, L., Sheffler, W., Kim, B.-H., Das, R., Grishin, N. V.,
& Baker, D. (2009). Structure Prediction for CASP8 with All-atom Refinement using
Rosetta. Proteins, 77 (Suppl. 9), 89‚Äì99.
Rapp, C. S., & Friesner, R. A. (1999). Prediction of Loop Geometries using a Generalized
Born Model of Solvation Effects. Proteins, 35, 173‚Äì183.
998

A Constraint Solver for Flexible Protein Models

Ray, O., Soh, T., & Inoue, K. (2010). Analyzing Pathways Using ASP-Based Approaches. In
Algebraic and Numeric Biology, 4th International Conference, pp. 167‚Äì183. Springer
Verlag.
Rossi, F., van Beek, P., & Walsh, T. (2006). Handbook of Constraint Programming. Elsevier
Science Inc.
Rufino, S., Donate, L., Canard, L., & Blundell, T. (1997). Predicting the Conformational
Class of Short and Medium Size Loops Connecting Regular Secondary Structures:
Application to Comparative Modeling. J. Mol. Biol., 267, 352‚Äì367.
Shehu, A. (2009). An Ab-Initio Tree-Based Exploration to Enhance Sampling of Low-Energy
Protein Conformations. In Proceedings of Robotics: Science and Systems V.
Shehu, A. (2010). Conformational Search for the Protein Native State, pp. 431‚Äì452. John
Wiley & Sons. Inc.
Shehu, A., & Kavraki, L. (2012). Modeling Structures and Motions of Loops in Protein
Molecules. Entropy, 14, 252‚Äì290.
Shen, M., & Sali, A. (2006). Statistical Potential for Assessment and Prediction of Protein
Structures. Protein Sci, 15, 2507‚Äì2524.
Shih, E., & Hwang, M.-J. (2011). On the Use of Distance Constraints in Protein-Protein
Docking Computations. Proteins: Structure, Function, and Bioinformatics, 80 (1),
194‚Äì205.
Shmygelska, A., & Hoos, H. (2005). An Ant Colony Optimisation Algorithm for the 2D
and 3D Hydrophobic Polar Protein Folding Problem. BMC Bioinformatics, 6, 30‚Äì52.
Shmygelska, A., & Levitt, M. (2009). Generalized Ensemble Methods for De Novo Structure
Prediction. Proceedings of the National Academy of Science (USA), 106 (5), 1415‚Äì
1420.
Simoncini, D., Berenger, F., Shrestha, R., & Zhang, K. (2012). A Probabilistic FragmentBased Protein Structure Prediction Algorithm. PLOS One, 7 (7), e38799.
Simons, K., Kooperberg, C., Huang, E., & Baker, D. (1997). Assembly of Protein Tertiary
Structures from Fragments with Similar Local Sequences using Simulated Annealing
and Bayesian Scoring Functions. J. Mol. Biol., 268, 209‚Äì225.
Skolnick, J., Fetrow, J., & Kolinski, A. (2000). Structural Genomics and its Importance for
Gene Function Analysis. Nat. Biotechnology, 18 (3), 283‚Äì287.
Soto, C., Fasnacht, M., Zhu, J., Forrest, L., & Honig, B. (2008). Loop Modeling: Sampling,
Filtering, and Scoring. Proteins: Structure, Function, and Bioinformatics, 70, 834‚Äì
843.
Spassov, V., Flook, P., & Yan, L. (2008). LOOPER: A Molecular Mechanics-based Algorithm for Protein Loop Prediction. Protein Eng, 21, 91‚Äì100.
Stuckey, P. J., Becket, R., & Fischer, J. (2010). Philosophy of the MiniZinc Challenge.
Constraints, 15 (3), 307‚Äì316.
Sussmann, G., & Steele, G. (1980). CONSTRAINTS: A Language for Expressing AlmostHierarchical Descriptions. Artificial Intelligence, 14 (1), 1‚Äì39.
999

Campeotto, Dal PaluÃÄ, Dovier, Fioretto, & Pontelli

Sutherland, I. (1963). Sketchpad: A Man-Machine Graphical Communication System. Tech.
rep. 296, Lincoln Laboratory, MIT.
Swedish Institute for Computer Science (2012). SICStus Prolog Home Page. http://www.
sics.se/sicstus/.
Thebault, P., de Givry, S., Schiex, T., & Gaspin, C. (2005). Combining Constraint Processing and Pattern Matching to Describe and Locate Structured Motifs in Genomic
Sequences. In Fifth Workshop on Modeling and Solving Problems with Constraints,
pp. 53‚Äì60.
Tsai, Y., Huang, Y., Yu, C., & Lu, C. (2004). MuSiC: A Tool for Multiple Sequence
Alignment with Constraints. Bioinformatics, 20 (14), 2309‚Äì2311.
Xiang, Z., Soto, C., & Honig, B. (2002). Evaluating Conformal Energies: The Colony Energy
and its Application to the Problem of Loop Prediction. PNAS, 99, 7432‚Äì7437.
Xu, D., & Zhang, Y. (2012). Ab Initio Protein Structure Assembly Using Continuous
Structure Fragments and Optimized Knowledge-based Force Field. Proteins, 80 (7),
1715‚Äì1735.
Yang, R. (1998). Multiple Protein/DNA Sequence Alignment with Constraints. In International Conference on Practical Applications of Constraint Programming.
Yap, R. (2001). Parametric Sequence Alignment with Constraints. Constraints, 6, 157‚Äì172.
Yap, R., & Chuan, H. (1993). A Constraint Logic Programming Framework for Constructing
DNA Restriction Maps. Artificial Intelligence in Medicine, 5 (5), 447‚Äì464.
Yue, K., & Dill, K. (2000). Constraint Based Assembly of Tertiary Protein Structures from
Secondary Structure Elements. Proteins Science, 9 (10), 1935‚Äì1946.
Zhang, M., & Kavraki, L. (2002). A New Method for Fast and Accurate Derivation of
Molecular Conformations. Journal of Chemical Information and Computer Sciences,
42 (1), 64‚Äì70.
Zhang, Y., & Hauser, K. (2013). Unbiased, Scalable Sampling of Protein Loop Conformations from Probabilistic Priors. BMC Structural Biology, (to appear http:
// www. indiana. edu/ ~ motion/ slikmc/ papers/ BMC_ Zhang. pdf ).
Zhou, H., & Zhou, Y. (2002). Distance-scaled, Finite Ideal-gas Reference State Improves
Structure-derived Potentials of Mean Force for Structure Selection and Stability Prediction. Protein Sci, 11, 2714‚Äì2726.

1000

Journal of Artificial Intelligence Research 48 (2013) 841-883

Submitted 06/13; published 11/13

Scalable and Efficient Bayes-Adaptive Reinforcement
Learning Based on Monte-Carlo Tree Search
Arthur Guez

aguez@gatsby.ucl.ac.uk

Gatsby Computational Neuroscience Unit
University College London
London, WC1N 3AR, UK

David Silver

d.silver@cs.ucl.ac.uk

Dept. of Computer Science
University College London
London, WC1E 6BT, UK

Peter Dayan

dayan@gatsby.ucl.ac.uk

Gatsby Computational Neuroscience Unit
University College London
London, WC1N 3AR, UK

Abstract
Bayesian planning is a formally elegant approach to learning optimal behaviour under
model uncertainty, trading off exploration and exploitation in an ideal way. Unfortunately,
planning optimally in the face of uncertainty is notoriously taxing, since the search space
is enormous. In this paper we introduce a tractable, sample-based method for approximate
Bayes-optimal planning which exploits Monte-Carlo tree search. Our approach avoids expensive applications of Bayes rule within the search tree by sampling models from current
beliefs, and furthermore performs this sampling in a lazy manner. This enables it to outperform previous Bayesian model-based reinforcement learning algorithms by a significant
margin on several well-known benchmark problems. As we show, our approach can even
work in problems with an infinite state space that lie qualitatively out of reach of almost
all previous work in Bayesian exploration.

1. Introduction
A key challenge in sequential decision-making is to understand how agents can learn to
collect rewards ‚Äî and avoid costs ‚Äî through interactions with the world. A natural way
to characterize these interactions is by a Markov Decision Process (mdp). mdps consist of
a set of states, a set of possible actions, and a transition model that stochastically decides
a successor state from a given state and action. In addition, a cost or reward is associated
with each state and action. The problem for learning arises when some aspects of the
transition model are unknown to the agent, implying uncertainty about the best strategy
for gathering rewards and avoiding costs. Exploration is therefore necessary to reduce this
uncertainty and ensure appropriate exploitation of the environment. Weighing the benefits
of exploring, to identify potentially better actions, against the benefits of exploiting known
sources of rewards is generally referred to as the exploration-exploitation trade-off.
The trade-off can be formalized in various different ways. One possible objective is to
control the number of suboptimal actions the agent ever performs; algorithms that with high
¬©2013 AI Access Foundation. All rights reserved.

Guez, Silver, & Dayan

probability can bound the number of such suboptimal steps by a polynomial in the number
of states and actions are said to be pac-mdp (Strehl, Li, & Littman, 2009). Instead of
focusing on suboptimal actions, another objective is to minimize the so-called regret, which
is the expected loss relative to the optimal policy in the mdp (Jaksch, Ortner, & Auer,
2010). Lastly, Bayesian decision theory prescribes maximizing the expected discounted
sum of rewards in the light of a prior distribution over transition models; one way to
achieve this is by solving an augmented mdp, called the Bayes-Adaptive mdp (bamdp), in
which the corresponding augmented dynamics are known (Martin, 1967; Duff, 2002). The
augmentation is the posterior belief distribution over the dynamics, given the data so far
observed. The agent starts in the belief state corresponding to its prior and, by executing
the greedy policy in the bamdp whilst updating its posterior, acts optimally (with respect
to its beliefs) in the original mdp. The Bayes-optimal policy is the optimal policy of the
bamdp; it integrates exploration and exploitation in an ideal manner.
In general, these different objectives are not compatible ‚Äì see for example the work of
Kolter and Ng (2009) for the incompatibility between pac-mdp and the Bayes-optimal solution. pac-mdp and regret frameworks have gained considerable traction in recent years,
while Bayesian exploration has been comparatively ignored. However, the Bayesian framework is attractive because structured prior knowledge can be incorporated into the solution
in a principled manner, providing the means to tackle, at least in theory, large and complex
unknown environments. Methods tailored for objectives such as pac-mdp or regret minimization cannot so far easily be adapted to exploit such priors. With no other assumption
about the environment, they are thus forced to explore every state and action at least once,
which is hopeless in large environments.
Unfortunately, exact Bayesian reinforcement learning (RL) is computationally intractable.
Various algorithms have been devised to approximate optimal learning, but often at rather
large cost. This computational barrier has restricted Bayesian RL to small domains with
simple priors. In this paper, we present a tractable approach that exploits and extends
recent advances in Monte-Carlo tree search (mcts) (Kocsis & SzepesvaÃÅri, 2006), notably
to partially-observable mdps (Silver & Veness, 2010) of which the bamdp can be seen as a
special case. While mcts is capable of tackling large mdp problems when the dynamics are
known (Gelly, Kocsis, Schoenauer, Sebag, Silver, SzepesvaÃÅri, & Teytaud, 2012), we show
that a naive application of mcts to the bamdp is not tractable in general and we propose
a set of principled modifications to obtain a practical algorithm, which is called bamcp for
‚ÄòBayes-Adaptive Monte-Carlo Planner‚Äô.
At each iteration in bamcp, as in the pomcp algorithm (Silver & Veness, 2010), a single
mdp is sampled from the agent‚Äôs current beliefs. This mdp is used to simulate a single
episode whose outcome is used to update the value of each node of the search tree traversed
during the simulation. By integrating over many simulations, and therefore many sample
mdps, the optimal value of each future sequence is obtained with respect to the agent‚Äôs
beliefs. We prove that this process converges to the Bayes-optimal policy, given infinite
samples. Since many of the priors that are appropriate in the Bayesian RL setting require
some form of approximate inference, we extend the convergence proof to show that bamcp
also converges when combined with a Markov Chain Monte Carlo-based inference scheme.
Our algorithm is more efficient than previous sparse sampling methods for Bayes-adaptive
planning (Wang, Lizotte, Bowling, & Schuurmans, 2005; Castro, 2007; Asmuth & Littman,
842

Bayes-Adaptive Monte-Carlo Planning

2011), partly because it does not update the posterior belief state during the course of
each simulation. It thus avoids repeated applications of Bayes rule, which is expensive for
all but the simplest priors over the mdp. To increase computational efficiency further, we
introduce an additional innovation: a lazy sampling scheme that only samples the posterior
distribution for states traversed during the simulation.
We applied bamcp to a representative sample of benchmark problems and competitive algorithms from the literature. It consistently and significantly outperformed existing
Bayesian RL methods, and also recent non-Bayesian approaches, thus achieving state-ofthe-art performance.
Further, bamcp is particularly well suited to support planning in large domains in which
richly structured prior knowledge makes lazy sampling both possible and effective. This
offers the prospect of applying Bayesian RL at a realistically complex scale. We illustrate
this possibility by showing that bamcp can tackle a domain with an infinite number of
states and a structured prior over the dynamics, a challenging, if not radically intractable,
task for existing approaches. This example exploits bamcp‚Äôs ability to use Markov chain
Monte Carlo methods for inference associated with the posterior distribution over models.
The paper is organized as follows. First, we formally define the Bayesian model-based
RL problem and review existing methods; we then present our new algorithm in the context
of previous suggestions; and finally we report empirical results on existing domains and on
the new, infinite, task. Some of these results appeared in a short conference version of this
paper (Guez, Silver, & Dayan, 2012).

2. Model-Based Reinforcement Learning
We first briefly review model-based reinforcement learning and search algorithms in the
case that the model is known. We then introduce the formalism of Bayesian model-based
RL and provide a survey of existing approximation algorithms that motivate our approach.
2.1 Model-Based Reinforcement Learning with Known Model
An mdp is described as a 5-tuple M = hS, A, P, R, Œ≥i, where S is the discrete set of states,
A is the finite set of actions, P : S √ó A √ó S ‚Üí R is the state transition probability kernel,
R : S √ó A ‚Üí R is a bounded reward function, and Œ≥ is the discount factor (SzepesvaÃÅri,
2010). A deterministic stationary mdp policy œÄ is defined as a mapping œÄ : S ‚Üí A from
states to actions. The value function of a policy œÄ at state s ‚àà S is its expected return,
defined as:
"‚àû
#
X
œÄ
œÄ
t
V (s) ‚â° E
Œ≥ rt |s0 = s ,
(1)
t=0

where rt is the random reward obtained at time t when following policy œÄ from state s
‚Äî EœÄ denotes the expectation operator that averages over all possible paths that policy
œÄ implies. A related quantity is the action-value function of a policy œÄ for executing a
843

Guez, Silver, & Dayan

particular action a ‚àà A at state s ‚àà S before executing œÄ:
"‚àû
#
X
X
œÄ
0
œÄ
t‚àí1
0
Q (s, a) ‚â° R(s, a) + Œ≥
P(s, a, s )EM
Œ≥ rt |s1 = s
s0 ‚ààS

= R(s, a) + Œ≥

X

(2)

t=1

P(s, a, s0 )V œÄ (s0 ),

(3)

s0 ‚ààS

implying the relation V œÄ (s) = QœÄ (s, œÄ(s)). The optimal action-value function, denoted Q‚àó ,
provides the maximum expected return Q‚àó (s, a) that can be obtained after executing action
a in state s. The optimal value function, V ‚àó , is similarly defined and is related to Q‚àó as
V ‚àó (s) = maxa‚ààA Q‚àó (s, a), s ‚àà S. An optimal policy œÄ ‚àó achieves the maximum expected
return from all states, and can be obtained from Q‚àó as: œÄ ‚àó (s) = argmaxa‚ààA Q‚àó (s, a),
breaking ties arbitrarily.
When all the components of the mdp tuple are known ‚Äî including the model P ‚Äî
standard mdp planning algorithms can be used to estimate the optimal policy off-line,
such as Value Iteration or Policy Iteration (Bellman, 1954; Ross, 1983; Sutton & Barto,
1998; SzepesvaÃÅri, 2010). However, it is not always practical to find the optimal policy for
all states in large mdps in one fell swoop. Instead, there are methods that concentrate on
searching online for the best action at just the current state st . This is particularly common
for model-based Bayesian RL algorithms. We therefore introduce relevant existing online
search methods for mdps that are used as building blocks for Bayesian RL algorithms.
2.1.1 Online Search
Online search methods evaluate a tree of possible future sequences. The tree is rooted at
the current state and is composed of state and action nodes. Each state node, including the
root, has as its children all the actions that are legal from that state. In turn, each action
node has as its children all the successor states resulting from that action. The goal of the
forward search algorithm is recursively to estimate the value of each state and action node
in the tree. Ultimately, the value of each possible action from the root is used to select the
next action, and the process repeats using the new state at the root.
Online search methods may be categorised firstly by the backup method by which the
value of each node is updated, and secondly by the order in which the nodes of the tree are
traversed and backups are applied.
2.1.2 Full-Width Search
Classical online search methods are based on full-width backups, which consider all legal
actions and all possible successor states, for example using a Bellman backup,

V (s) ‚Üê max R(s, a) + Œ≥
a‚ààA

X

P(s, a, s0 )V (s0 )

(4)

s0 ‚ààS

Search efficiency is then largely determined by the order in which nodes are traversed.
One example is ‚Äôbest-first‚Äô, for which the current best is usually determined according to an
optimistic criterion. This leads to an algorithm resembling A‚àó (Hart, Nilsson, & Raphael,
844

Bayes-Adaptive Monte-Carlo Planning

1968), which applies in the deterministic case. The search tree may also be truncated,
using knowledge of the most extreme reward and the discount factor to ensure that this is
provably benign (Davies, Ng, & Moore, 1998). If one is prepared to give up guarantees on
optimality, an approximate value function (typically described in the online search literature
as a heuristic function or evaluation function) can be applied at leaf nodes to substitute for
the value of the truncated subtree.
2.1.3 Sample-Based Search
Rather than expanding every tree node completely, sample-based search methods overcome
the curse of dimensionality by just sampling successor states from the transition distribution.
These have the generic advantage over full-width search that they expend little effort on
unlikely paths in the tree.
Sparse Sampling
Sparse Sampling (Kearns, Mansour, & Ng, 1999) is a sample-based online search algorithm.
The key idea is to sample C successor nodes from each action node, and apply a Bellman
backup to these sampled transitions, so as to update the value of the parent state node
from the values of the child nodes:
C
Œ≥ X
Vd (s) = max R(s, a) +
Vd+1 (child(s, a, i)).
a‚ààA
C

(5)

i=1

The search tree is traversed in a depth-first manner, and an approximate value function
is employed at truncated leaf nodes, after some pre-defined depth D. Sparse Sampling
converges to a near-optimal policy given an appropriate choice of the parameters C and D.
FSSS
Although Sparse Sampling concentrates on likely transitions, it does not focus search on
nodes that have relatively high values or returns. In the work of Walsh, Goschin, and
Littman (2010), Forward Search Sparse Sampling (fsss) extends regular Sparse Sampling
by maintaining both lower and upper bounds on the value of each node:
Ld (s, a) = R(s, a) +
Ud (s, a) = R(s, a) +

Œ≥
C
Œ≥
C

X

Ld+1 (s0 )Count(s, a, s0 ),

(6)

Ud+1 (s0 )Count(s, a, s0 ),

(7)

s0 ‚ààChild(s,a)

X
s0 ‚ààChild(s,a)

Ld (s) = max Ld (s, a),

(8)

Ud (s) = max Ud (s, a),

(9)

a‚ààA

a‚ààA

where Child(s, a) is the set of successor states sampled from C draws of P(s, a, ¬∑), and
Count(s, a, s0 ) is the number of times each set element was sampled. Whenever a node
is created, the lower and upper bounds are initialized according to Ld (s, a) = Vmin and
845

Guez, Silver, & Dayan

Ud (s, a) = Vmax , i.e., the worst and best possible returns. The tree is traversed in a bestfirst manner according to these value bounds, starting from the root for each simulation
through the tree. At each state node, a promising action is selected by maximising the
upper bound on value. At each action (or chance) node, successor states are selected
from a sampled set of C candidates by maximising the uncertainty (upper minus lower
bound). This effectively prunes branches of the tree that have low upper bounds before
they are exhaustively explored, while still maintaining the theoretical guarantees of Sparse
Sampling.
Monte-Carlo Tree Search
Despite their theoretical guarantees, in practice, sparse sampling and fsss both suffer from
the fact that they truncate the search tree at a particular depth, and so experience bias
associated with the approximate value function they use at the leaves. Monte-Carlo Tree
Search (mcts) provides a way of reducing the bias by evaluating leaves exactly using the
model, but employing a sub-optimal, rollout policy. More formally, in mcts, states are
evaluated by averaging over many simulations. Each simulation starts from the root and
traverses the current tree until a leaf is reached, using a tree policy (e.g., greedy action
selection) based on information that has so far been gathered about nodes in the tree. This
results in a (locally) best-first tree traversal, where at each step the tree policy selects the
best child (best according to some exploration criterion) given the current values in the tree.
Rather than truncating the search and relying on a potentially biased value function at leaf
nodes, a different policy, called a rollout policy (e.g., uniform random) is employed from
the leaf node until termination or a search horizon. Each node traversed by the simulation
is then updated by a Monte-Carlo backup, which simply evaluates that node by the mean
outcome of all simulations that passed through that node. Specifically, the Monte-Carlo
backups update the value of each action node as follows:
Qd (s, a) ‚Üê Qd (s, a) + (R ‚àí Qd (s, a))/Nd (s, a),

(10)

where R is the sampled discounted return obtained from the traversed action node s, a at
depth d and Nd (s, a) is the visitation count for the action node s, a (i.e., the update computes
the mean of the sampled returns obtained from that action node over the simulations).
A particular tree policy for mcts that has received much attention, and indeed underlies
our algorithm, is the uct (Upper Confidence bounds applied to Trees) policy (Kocsis &
SzepesvaÃÅri, 2006). uct employs the ucbÔú± (Upper Confidence Bounds) algorithm (Auer,
Cesa-Bianchi, & Fischer, 2002), designed for multi-armed bandit problems, to select adaptively between actions at every state node according to:
p
argmax Qd (s, a) + c log(Nd (s))/Nd (s, a),
(11)
a‚ààA

where c is an exploration constant that needs to be set appropriately and Nd (s) is the
visitation count for the state node s. This tree policy treats the forward search as a metaexploration problem, preferring to exploit regions of the tree that currently appear better
than others, while continuing to explore unknown or less known parts of the tree. This leads
to good empirical results even for small numbers of simulations, because effort is expended
846

Bayes-Adaptive Monte-Carlo Planning

where search seems fruitful. Nevertheless all parts of the tree are eventually visited infinitely
often, and therefore the algorithm can be shown to converge to the optimal policy in the
very long run.
Despite some negative theoretical results showing that uct can be slow to find optimal
policies in carefully designed counterexample mdps (Coquelin & Munos, 2007), uct has
been successful in many large mdp domains (Gelly et al., 2012).
2.2 Model-Based Bayesian Reinforcement Learning
The methods we have so far discussed depend on the agent having a model of the world, i.e.,
the dynamics P. The key concern for Bayesian RL is acting when this model is not fully
known. We first describe the generic Bayesian formulation of optimal decision-making in an
unknown mdp, following Martin (1967) and Duff (2002), and then consider approximations
inspired by the intractability of the full problem.
2.2.1 The Formalism
Given that the dynamics P ‚àà P (coming from the set of all possible models) are only
incompletely known, Bayesian RL treats them as a latent random variable which follows a
prior distribution P (P). Observations about the dynamics contained in the history ht (at
time t) of actions and states: ht ‚â° s1 a1 s2 a2 . . . at‚àí1 st , duly lead to a posterior distribution
over P via a likelihood.
The history ht influences the posterior distribution. Thus policies œÄÃÉ that integrate
exploration and exploitation (called EE policies) for a Bayesian RL problem will generically
have to take this history into account, along with the current state, in order to specify what
action to take. That is, whereas when P is known, a policy œÄ can be defined as a mapping
œÄ : S √ó A ‚Üí [0, 1] from just the current state and actions to a probability (of execution), for
Bayesian RL, EE policies are defined as mappings from history, current state, and action
to a probability œÄÃÉ : S √ó H √ó A ‚Üí [0, 1], where H is the set of possible histories.1 We denote
by Œ†ÃÉ the set of all EE policies.
The objective for an EE policy under the Bayesian formulation is to maximize the
expected return (sum of discounted rewards), where the expectation is taken over the distribution of environments P (P) = P (P |‚àÖ), in addition to taking the usual expectation over
the stochasticity of the return induced by the dynamics. Formally, we define this expected
discounted return v starting from a state s after seeing history h when following an EE
policy œÄÃÉ as:
"‚àû
#
X
v(s, h, œÄÃÉ) = EœÄÃÉ
Œ≥ t rt |s0 = s, h0 = h
(12)
t=0

Z
=
P

=

"
dP P (P |h) EœÄÃÉM (P)

X
a0 ‚ààA

‚àû
X

#
Œ≥ t rt |s0 = s, h0 = h

(13)

t=0

R(s, a0 ) + Œ≥

X

œÄÃÉ(s, h, a0 )v(s0 , ha0 s0 , œÄÃÉ)PÃÑ(s, a0 , s0 , h),

(14)

s0 ‚ààS

1. The redundancy in the state-history notation throughout this paper, namely that the current state could
be extracted from the history, is only present to ensure clarity of exposition.

847

Guez, Silver, & Dayan

R
where PÃÑ(s, a, s0 , h) ‚â° P dP P (P |h) P(s, a, s0 ) denotes the probability of transitioning from
state s to s0 after executing a under a distribution of dynamics P (P |h), and M (P) denotes
the mdp associated with dynamics P.
Definition 1 Given S, A, R, Œ≥, and a prior distribution P (P) over the dynamics of the
mdp M , let
v ‚àó (s, ‚àÖ) = sup v(s, ‚àÖ, œÄÃÉ).

(15)

œÄÃÉ‚ààŒ†ÃÉ

Martin (1967, Thm. 3.2.1) shows that there exists a strategy œÄÃÉ ‚àó ‚àà Œ†ÃÉ that achieves that
expected return (i.e., v(s, ‚àÖ, œÄÃÉ ‚àó ) = v ‚àó (s, ‚àÖ)). Any such EE strategy œÄÃÉ ‚àó is called a Bayesoptimal policy.2
This formulation prescribes a natural recipe for computing the Bayes-optimal policy.
After observing history ht from the mdp, the posterior belief over P is updated using Bayes‚Äô
rule P (P|ht ) ‚àù P (ht |P)P (P) (or in recursive form P (P|ht ) ‚àù P(st‚àí1 , at‚àí1 , st )P (P|ht‚àí1 )).
Thus, the uncertainty about the dynamics of the model can be transformed into certainty
about the current state inside an augmented state space S + = S √ó H, where S is the state
space in the original problem and H is the set of possible histories. The dynamics associated
with this augmented state space are described by
Z
P + (hs, hi, a, hs0 , h0 i) = 1[h0 = has0 ]
P(s, a, s0 )P (P|h) dP,
(16)
P

and the reward function is simply the projected reward function in the original mdp:
R+ (hs, hi, a) = R(s, a).

(17)

Together, the 5-tuple M + = hS + , A, P + , R+ , Œ≥i forms the Bayes-Adaptive mdp (bamdp)
for the mdp problem M . Since the dynamics of the bamdp are known, it can in principle
be solved to obtain the optimal value function associated with each action:
"‚àû
#
X 0
‚àó
œÄÃÉ
t ‚àít
Q (hst , ht i, a) = max EM +
Œ≥
rt0 |at = a
(18)
œÄÃÉ

t0 =t

from which the optimal action for each state can be readily derived. Optimal actions in the
bamdp are executed greedily in the real mdp M and constitute the best course of action
for a Bayesian agent with respect to its prior belief over P:
Proposition 1 (Silver, 1963; Martin, 1967) The optimal policy of the bamdp is the
Bayes-optimal policy, as defined in Definition 1.
It is obvious that the expected performance of the bamdp policy in the mdp M is
bounded above by that of the optimal policy obtained with a fully-observable model, with
2. The proof by Martin (1967) only covers finite state spaces, but it can be extended to specific kinds of
infinite state spaces such as the one we consider in Section 4.2, see Appendix D for details.

848

Bayes-Adaptive Monte-Carlo Planning

equality occurring, for example, in the degenerate case in which the prior only has support
on the true model.
The Bayes-optimal policy is stationary as a function of the augmented state, but evolves
over time when observed in the context of the original mdp ‚Äî as a function of the state in
S only. Since the uncertainty about the dynamics is taken into account in the optimization
of the return, the Bayes-optimal policy integrates exploration and exploitation optimally.
It can be useful to observe that the bamdp is a particular form of Partially Observable
mdp (pomdp). The state space of this pomdp is S √ó P, where P is the set of all possible
models P. The second component of the state space is static and hidden, and partially
observed through experienced transitions. Planning can be conducted in the belief space,
or equivalently in the space of sufficient statistics of the belief distribution, allowing decisions
to be taken in the light of their likely outcomes in gathering exploitable information about
the hidden state. In the case of bamdp, such actions gather information about the hidden
model P. However, the pomdp is not a discrete pomdp since its state space is continuous
(with discrete observations). Therefore, as pointed out by Duff (2002), many classical
solutions to pomdps cannot be directly applied to the bamdp.
From a practical perspective, solving the bamdp exactly is computationally intractable,
even for small state spaces. First, the augmented state space contains all possible histories
and is therefore infinite. Second, the transitions of the bamdp, described in Equation 16,
require an integration of transition models over the posterior. Although this operation can
be trivial for some simple probabilistic models (e.g., independent Dirichlet-Multinomial), it
is intractable for most priors of interest (see Section 4.2 for an example). However, certain
special cases of the bamdp are known to be somewhat more tractable. For example, the
celebrated Gittins indices provide a shortcut solution for bandit problems (Gittins, Weber,
& Glazebrook, 1989), although calculating these indices remains a challenge in general.
Further, the optimal solution to at least some finite-horizon linear-Gaussian control problems can be computed exactly (Tonk & Kappen, 2010). Nevertheless, it appears unlikely
that there exists a tractable exact algorithm to solve general bamdps, justifying a search
for sound and efficient approximations.
2.2.2 Approximate Bayes-Adaptive Algorithms
Three coarse classes of approximation methods have been developed, which we now review.
Note that all of them have analogues in solution methods for pomdps.
First are offline methods that toil mightily to provide execution policies that can be used
for any observed augmented state. Second and third are two sets of online methods that
concentrate on just the current augmented state. One set of methods uses sparse sampling
in the full tree of future states and actions associated with the bamdp, starting from the
current augmented state. The other samples and solves one or more mdps from the current
posterior over P, possibly correcting for the bias towards exploitation to which this typically
leads.
After describing these classes, we highlight what they currently lack, and so establish
the basis for our new algorithm, bamcp.
849

Guez, Silver, & Dayan

Offline Methods
One idea is to solve the entire bamdp offline, for every state and belief (or history). This
obviates the need for anything other than a simple value/policy lookup during execution.
However, this avenue for approximation has not led to much practical success ‚Äî presumably
because of the difficulties associated with the size of the bamdp, including the fact that
gargantuan amounts of computation may be performed to find good policies in parts of the
space of histories that are actually not sampled in practice.
Existing approaches in this class include an actor-critic algorithm (Duff, 2003), which
does learning, and a point-based value iteration algorithm, called beetle (Bayesian Exploration Exploitation Tradeoff in LEarning) (Poupart, Vlassis, Hoey, & Regan, 2006).
beetle builds an approximate policy off-line by exploiting facets of the structure of the
value functions for bamdps, which they inherit from their broader, parent, class of pomdps.
More recently, Wang, Won, Hsu, and Lee (2012) propose to solve an offline pomdp by representing the latent dynamics as a discrete partially-observed state component, where the
value of this state component corresponds to one of K possible models sampled from the
prior. Their approach can fail if the true model is not well-represented in these K sampled
models.
Offline methods are particularly poorly suited to problems such as the infinite state task
we consider in section 4.2.
Online Methods: Sparse Sampling
Online methods reduce the dependency on the size of the bamdp by approximating the
bamdp solution around the current (augmented) state of the agent and running a planning
algorithm at each step.
One idea is to perform forms of forward search from the current state. Although these
methods concentrate on the current state, the search tree is still large and it can be expensive
to evaluate a given path in the tree. In partial alleviation of this problem, most approaches
rely on some form of sparse, non-uniform, tree exploration to minimize the search effort
(but see also Fonteneau, Busoniu, & Munos, 2013). While Section 2.1.3 described search
algorithms for mdps, here we present existing extensions to the bamdp setting. Analogous
methods for pomdps are reviewed by Ross, Pineau, Paquet, and Chaib-Draa (2008).
Wang et al. applied Sparse Sampling to search online in bamdps (Wang et al., 2005),
expanding the tree non-uniformly according to sampled trajectories. At each state node, a
promising action is selected via Thompson sampling (Thompson, 1933; Agrawal & Goyal,
2011) ‚Äî i.e., sampling an mdp from the belief-state, solving the mdp and taking the optimal
action. As in Sparse Sampling, this fails to exploit information about the values of nodes
in prioritizing the sampling process. At each chance (action) node, a successor belief-state
is sampled from the transition dynamics of the bamdp.
Castro et al. applied Sparse Sampling to define a relevant region of the bamdp for the
current decision step. This leads to an optimization problem that is solved using Linear
Programming (Castro & Precup, 2007).
Asmuth and Littman‚Äôs bfs3 algorithm (Asmuth & Littman, 2011) adapts Forward
Search Sparse Sampling (Walsh et al., 2010) to the bamdp (treated as a particular mdp).
Although bfs3 is described as Monte-Carlo tree search, it in fact uses a Bellman backup
850

Bayes-Adaptive Monte-Carlo Planning

rather than Monte-Carlo evaluation. As in fsss, each Bellman backup updates both lower
and upper bounds on the value of each node.
Online Methods: Dual Optimism
Instead of applying sparse sampling methods in the tree of future states and actions, an
alternative collection of methods derives one or more simpler mdps from the posterior at a
current augmented state, whose solution is often computationally straightforward. By itself,
this leads to over-exploitation: corrections are thus necessary to generate sufficient exploration. Exploration can be seen as coming from optimism in the face of uncertainty ‚Äì actions
that have yet to be tried sufficiently must look more attractive than their current mean.
Indeed, there are various heuristic forms of exploration bonus (Sutton, 1990; Schmidhuber,
1991; Dayan & Sejnowski, 1996; Kearns et al., 1999; Meuleau & Bourgine, 1999; Brafman
& Tennenholtz, 2003) that generalize the optimism inherent in optimal solutions such as
Gittins indices.
One such approximation was first derived in the work of Cozzolino, Gonzalez-Zubieta,
and Miller (1965), where the mean estimate of the transition probabilities (i.e., the mean of
the posterior) was employed as a certainty equivalence approximation. Solving the corresponding mean mdp induces some form of optimism, but it is not always sufficient to drive
exploration. This idea was revisited and linked to reinforcement learning formulations by
Dayan and Sejnowski (1996).
Another way to induce optimism is to exploit the variance in the posterior when sampling
mdps at an augmented state. One of these approaches is the Bayesian DP algorithm (Strens,
2000). At each step (or after every couple of steps), a single model is sampled from the
posterior distribution over transition models, and the action that is optimal in that model is
executed. Although a popular approach in practice, this algorithm does not have a known
theoretical guarantee relating it to the Bayes-optimal solution. In the Bandit case, this
reduces to Thompson Sampling. Optimism is generated because solving posterior samples
is likely to yield optimistic values in some unknown parts of the mdp (where posterior
entropy is large) and that will force the agent to visit these regions. The Best Of Sampled
Set (boss) algorithm generalizes this idea (Asmuth, Li, Littman, Nouri, & Wingate, 2009).
boss samples a number of models from the posterior and combines them optimistically. This
drives sufficient exploration to guarantee some finite-sample performance guarantees, but
these theoretical guarantees cannot be easily related to the Bayes-optimal solution. boss is
quite sensitive to its parameter that governs the sampling criterion, which is unfortunately
difficult to select. Castro and Precup proposed a variant, referred to as sboss, which
provides a more effective adaptive sampling criterion (Castro & Precup, 2010).
One can also see certain non-Bayesian methods in this light. For instance, Bayesian
Exploration Bonus (beb) solves the posterior mean mdp, but with an additional reward
bonus that depends on visitation counts (Kolter & Ng, 2009). This bonus is tailored such
that the method satisfies the so-called pac-bamdp property, which generalizes the pac-mdp
mentioned in the introduction, and implies limiting to a polynomial factor the number of
steps in which the EE policy is different than the Bayes-optimal policy. A more recent
approach is the bolt algorithm, which merges ideas from beb and boss, enforces optimism
in the transitions by (temporarily) adding fictitious evidence that currently poorly-known
851

Guez, Silver, & Dayan

actions lead to currently poorly-known states (Araya-LoÃÅpez, Buffet, & Thomas, 2012). bolt
also has the pac-bamdp property.
Discussion of Existing Methods
Despite the recent progress in approximation algorithms, tackling large domains with complex structured priors remains out of computational reach for existing Bayesian RL methods.
Unfortunately, it is exactly in these structured domains that Bayesian methods should shine,
since they have the statistical capacity to take advantage of the priors.
Methods that tackle the bamdp directly such as forward-search methods, suffer from
the repeated computation of the bamdp dynamics inside the search tree for most priors.
That is, to compute a single bamdp transition in Equation 16, one needs to apply Bayes‚Äô
rule and perform an integration over all possible models. This can be done cheaply for
simple priors, but can be rather expensive for arbitrary priors.
On the other hand, optimism-based methods are attractive because they appear more
tractable ‚Äî since they are dealing with smaller mdps. However, it turns out to be hard
to translate sophisticated prior knowledge into the form of a bonus ‚Äî existing methods
are only compatible with simple Dirichlet-Multinomial models. Moreover, the behavior in
the early steps of exploration can be very sensitive to the precise parameter inducing the
optimism.
We therefore developed an approximation algorithm for Bayesian RL that is compatible
with complex priors, while maintaining efficiency and (Bayesian) soundness, so that large
EE tasks can be approached in a principled way. Our approach adapts the pomcp MonteCarlo tree search algorithm (Silver & Veness, 2010), which avoids expensive applications
of Bayes rule by only sampling at the root of the tree. It also extends the approach by
introducing a novel scheme for lazy sampling. This makes it possible to search locally in
finite portions of large or even infinite domains.

3. The BAMCP Algorithm
To reiterate, the goal of a bamdp planning method is to find, for each decision point hs, hi
encountered, the action a that at least approximately maximizes the future expected return
(i.e., find an optimal EE policy œÄÃÉ ‚àó (s, h)). Our algorithm, Bayes-Adaptive Monte-Carlo
Planning (BAMCP), does this by performing a forward-search in the space of possible
future histories of the bamdp using a tailored Monte-Carlo tree search.
We employ the uct algorithm, as presented in Section 2.1.3, to allocate search effort to
promising branches of the state-action tree, and use sample-based rollouts to provide value
estimates at each node. For clarity, let us denote by Bayes-Adaptive uct (ba-uct) the
algorithm that applies vanilla uct to the bamdp (i.e., the particular mdp with dynamics
described in Equation 16).3 Sample-based search in the bamdp using ba-uct requires the
generation of samples from P + for every step of each simulation ‚Äî an expensive procedure
for all but the simplest generative models P (P). We avoid this cost by only sampling a
single transition model P i from the posterior at the root of the search tree at the start of
3. While using uct to solve bamdps is mentioned by Asmuth and Littman (2011), we are not aware of any
published work that evaluated the performance of ba-uct.

852

Bayes-Adaptive Monte-Carlo Planning

each simulation i, and using P i to generate all the necessary samples during this simulation.
Sample-based tree search then acts as a filter, ensuring that the correct distribution of state
successors is obtained at each of the tree nodes, as if it was sampled from P + . This root
sampling method was originally introduced in the pomcp algorithm (Silver & Veness, 2010),
developed to solve discrete-state pomdps.
Combining ba-uct with a version of root sampling forms the basis of the proposed
bamcp algorithm; this is detailed in Section 3.1. In addition, bamcp also takes advantage
of lazy sampling to reduce sampling complexity at the root, this is detailed in Section 3.2.
Finally, bamcp integrates rollout learning to improve the rollouts online, this is detailed in
Section 3.3. In Section 3.4, we show that bamcp converges to the Bayes-optimal solution.
Subsequent sections provide empirical results.
3.1 BA-UCT with Root Sampling
The root node of the search tree at a decision point represents the current state of the
bamdp. The tree is composed of state nodes representing belief states hs, hi and action
nodes representing the effect of particular actions from their parent state node. The visit
counts: N (hs, hi) for state nodes, and N (hs, hi, a) for action nodes, are initialized to 0 and
updated throughout search. A value, Q(hs, hi, a), which is initialized to 0, is also maintained
for each action node.
Each simulation traverses the tree without backtracking
by following the uct policy
p
at state nodes defined by argmaxa Q(hs, hi, a) + c log(N (hs, hi))/N (hs, hi, a), where c is an
exploration constant that needs to be set appropriately. Given an action, the transition
distribution P i corresponding to the current simulation i is used to sample the next state.
That is, at action node (hs, hi, a), s0 is sampled from P i (s, a, ¬∑), and the new state node is
set to hs0 , has0 i.
When a simulation reaches a leaf, the tree is expanded by attaching a new state node
with its connected action nodes, and a rollout policy œÄro is used to control the mdp defined
by the current P i . This policy is followed to some fixed total depth (determined using the
discount factor). The rollout provides an estimate of the value Q(hs, hi, a) from the leaf
action node. This estimate is then used to update the value of all action nodes traversed
during the simulation: if R is the sampled discounted return obtained from a traversed
action node (hs, hi, a) in a given simulation, then we update the value of each action node
to Q(hs, hi, a)+ (R ‚àí Q(hs, hi, a))/N (hs, hi, a) (i.e., the mean of the sampled returns obtained from
that action node over the simulations).
A detailed description of the bamcp algorithm is provided in Algorithm 1. A diagram
example of bamcp simulations is presented in Figure 1. In Section 3.4, we show bamcp
eventually converges to the Bayes-optimal policy.
Finally, note that the history of transitions h is generally not the most compact sufficient statistic of the belief in fully observable mdps. It can, for instance, be replaced with
unordered transition counts œà, considerably reducing the number of states of the bamdp
and, potentially the complexity of planning. bamcp can search in this reduced search space,
which takes the form of an expanding lattice rather than a tree. We found this version of
bamcp to offer only a marginal improvement. This is a common finding for mcts, stemming from its tendency to concentrate search effort on one of several equivalent paths (up
853

Guez, Silver, & Dayan

1.

2.
Past

Past

Planning

Planning

Tree policy

Tree policy

Rollout
policy

Rollout
policy

0

0

0

4.

3.

0

2

Past

Past

Planning

Planning

Tree policy

Tree policy

Rollout
policy

Rollout
policy

0

0

2

0

Figure 1: This diagram presents the first 4 simulations of bamcp in an mdp with 2 actions from state
hst , ht i. The rollout trajectories are represented with dotted lines (green for the current rollouts,
and greyed out for past rollouts). 1. The root node is expanded with two action nodes. Action
a1 is chosen at the root (random tie-breaking) and a rollout is executed in P 1 with a resulting
value estimate of 0. Counts N (hst , ht i) and N (hst , ht i, a1 ), and value Q(hst , ht i, a1 ) get updated.
2. Action a2 is chosen at the root and a rollout is executed with value estimate 0. Counts and
value get updated. 3. Action a1 is chosen (tie-breaking), then s0 is sampled from P 3 (st , a1 , ¬∑).
State node hs0 , ht a1 s0 i gets expanded and action a1 is selected, incurring a reward of 2, followed
by a rollout. 4. The UCB rule selects action a1 at the top, the successor state s0 is sampled from
P 4 (st , a1 , ¬∑). Action a2 is chosen from the internal node hs0 , ht a1 s0 i, followed by a rollout using
P 4 and œÄro . A reward of 2 is obtained after 2 steps from that tree node. Counts for the traversed
nodes are updated and the MC backup updates Q(hs0 , ht a1 s0 i, a1 ) to R = 0+Œ≥0+Œ≥ 2 2+Œ≥ 3 0+¬∑ ¬∑ ¬∑ =
2Œ≥ 2 and Q(hst , ht i, a1 ) to Œ≥ + 2Œ≥ 3 ‚àí Œ≥/3 = 32 (Œ≥ + Œ≥ 3 ).

854

Bayes-Adaptive Monte-Carlo Planning

Algorithm 1: BAMCP

procedure Search( hs, hi )
repeat
P ‚àº P (P|h)
Simulate(hs, hi, P, 0)
until Timeout()
return argmax Q(hs, hi, a)
a

end procedure

procedure Rollout(hs, hi, P, d )
if Œ≥ d Rmax <  then
return 0
end
a ‚àº œÄro (hs, hi, ¬∑)
s0 ‚àº P(s, a, ¬∑)
r ‚Üê R(s, a)
return
r+Œ≥Rollout(hs0 , has0 i, P, d+1)
end procedure

procedure Simulate( hs, hi, P, d)
if Œ≥ d Rmax <  then return 0
if N (hs, hi) = 0 then
for all a ‚àà A do
N (hs, hi, a) ‚Üê 0,
Q(hs, hi, a)) ‚Üê 0
end
a ‚àº œÄro (hs, hi, ¬∑)
s0 ‚àº P(s, a, ¬∑)
r ‚Üê R(s, a)
R ‚Üê r + Œ≥ Rollout(hs0 , has0 i, P, d)
N (hs, hi) ‚Üê 1, N (hs, hi, a) ‚Üê 1
Q(hs, hi, a) ‚Üê R
return R
end
q
(hs,hi))
a ‚Üê argmax Q(hs, hi, b) + c log(N
N (hs,hi,b)
b

s0 ‚àº P(s, a, ¬∑)
r ‚Üê R(s, a)
R ‚Üê r + Œ≥ Simulate(hs0 , has0 i, P, d+1)
N (hs, hi) ‚Üê N (hs, hi) + 1
N (hs, hi, a) ‚Üê N (hs, hi, a) + 1
Q(hs, hi, a) ‚Üê Q(hs, hi, a) +

R‚àíQ(hs,hi,a)
N (hs,hi,a)

return R
end procedure

to transposition), implying a limited effect on performance of reducing the number of those
paths.
Note that an algorithm very similar to ba-uct with root sampling also appeared in the
work of Vien and Ertel (2012), shortly after bamcp was originally published by Guez et al.
(2012).
3.1.1 Root Sampling at Work in a Simple Example
We illustrate the workings of bamcp, in particular root sampling, in a simulated example
that showcases a crucial component of Bayes-adaptivity.
Consider a simple prior distribution on two mdps (P 0 and P 1 ), illustrated in Figure 2,
where P (P = P 0 ) = P (P = P 1 ) = 21 . The mdps are episodic and stop at the leaves,
and an episode starts in s0 . From state s1 or s2 , any action has an expected reward of
0 under the prior distribution over mdps. Nevertheless, the outcome of a transition from
action a0 in state s0 carries information about the identity of the mdp, and allows a Bayesadaptive agent to take an informed decision in state s1 or s2 . Using Bayes-rule, we have
that P (P = P 0 |s0 a0 s1 ) ‚àù P (s0 a0 s1 | P = P 0 )P (P = P 0 ) = 0.8.
855

Guez, Silver, & Dayan

s0
a0

a1

s1 p = 0.8 s2 p = 0.2
a0

a1

s3 p = 1
+2

a0
s4 p = 1
‚àí2
(a)

s5 p = 1
0

a1

s4 p = 1
‚àí2

s3 p = 1
+2

P = P0
s0
a0

a1

s1 p = 0.2 s2 p = 0.8
a0

a1

s4 p = 1
‚àí2

a0
s3 p = 1
+2
(b)

s3 p = 1
+2

a1

s5 p = 1
0
s4 p = 1
‚àí2

P = P1

Figure 2: The two mdps of Section 3.1.1, with prior probability P (P = P 0 ) = P (P = P 1 ) =
1
2 . Differences between the two mdps are highlighted in blue.

We can therefore compute the optimal values:
(
2P (P = P 0 |h) ‚àí 2P (P = P 1 |h)
‚àó
V (h = s0 a0 s1 ) = max
2P (P = P 1 |h) ‚àí 2P (P = P 0 |h)

(19)

= 2 ¬∑ 0.8 ‚àí 2 ¬∑ 0.2 = 1.2 (= V ‚àó (h = s0 a0 s2 ))
V ‚àó (h = s0 ) = max{0, 1.2Œ≥} = 1.2Œ≥.
We now simulate bamcp on this simple example for the first decision in state s0 . With
root sampling, bamcp only samples either P 0 or P 1 with equal probability at the root of the
tree, and does not perform any explicit posterior update inside the tree. Yet, as suggested
by Lemma 1, we expect to find the correct distribution P (P = P 0 |s0 a0 s1 ) of samples of
P at the tree node hs0 a0 s1 i. Moreover, bamcp should converge to the optimal values V ‚àó
according to Theorem 1. This is what is observed empirically in Figure 3.
In the second row of Figure 3, we observe that QÃÇ(s0 a0 s1 , a1 ) is slower to converge
compared to other values. This is because time is ticking more slowly for this non-optimal
node (i.e., a small fraction of simulations reach this node) so the value stays put for many
simulations.
3.2 Lazy Sampling
In previous work on sample-based tree search, indeed including pomcp (Silver & Veness,
2010), a complete sample state is drawn from the posterior at the root of the search tree.
However, this can be computationally very costly. Instead, we sample P lazily, generating
856

Bayes-Adaptive Monte-Carlo Planning

2

2

1.5

1.5

Value

1

V
V
V
V

0.5
0
‚àí0.5
‚àí1

0

200

400

600

800

1000

1200

1400

( s 0a 0s 1)
‚àó
( s 0a 0s 1)
( s 0)
‚àó
( s 0)
1600

1800

1
0.5
0
‚àí0.5
2000

‚àí1

0

5

10
4

x 10
‚àí0.5

‚àí0.5

QÃÇ( s 0 a 0 s 1 , a 1 )
Q ‚àó( s 0a 0s 1, a 1)

Value

‚àí1

‚àí1.5

‚àí2

‚àí1

‚àí1.5

0

200

400

600

800

1000

1200

1400

1600

1800

2000

‚àí2

0

5

10
4

x 10
1

1

PÃÉ s 0 a 0 s(1 P = P 1 )
P ( P = P 1| s 0a 0s 1)

Probability

0.8
0.6

0.8
0.6

PÃÉ s 0 a 0 s(1 P = P 0 )
P ( P = P 0| s 0a 0s 1)

0.4

0.4

0.2
0

0.2
0

200

400

600

800

1000

1200

Number of simulations

1400

1600

1800

2000

0

0

5

10
4

x 10

Figure 3: Tracking of different internal variables of bamcp for the example of Section 3.1.1 with Œ≥ = 0.9.
bamcp is run at the starting state for a number of simulations (x-axis) and with c = 20. The
first two rows show the evolution of values at tree nodes corresponding to different histories,
along with target values as computed in Equation 20. The bottom row shows the evolution of
PÃÉs0 a1 s1 (P = P 0 ) = 1 ‚àí PÃÉs0 a1 s1 (P = P 1 ), the empirical distribution of mdps seen going through
PN (hs0 a1 s1 i)
1[P i = P 0 ]). (Left) The first 2000 simulations
tree node hs0 a1 s1 i (i.e., N (hs01a1 s1 i) i=0
(Right) Zoomed out view of 100,000 simulations, displaying empirical convergence to target
values.

857

Guez, Silver, & Dayan

only the particular transition probabilities that are required as the simulation traverses the
tree, and also during the rollout.
Consider P(s, a, ¬∑) to be parametrized by a latent variable Œ∏s,a for each state and action
pair. These may depend on each other, as well as on
R an additional set of latent variables œÜ.
The posterior over P can be written as P (Œò|h) = œÜ P (Œò|œÜ, h)P (œÜ|h), where Œò = {Œ∏s,a |s ‚àà
S, a ‚àà A}. Define Œòt = {Œ∏s1 ,a1 , ¬∑ ¬∑ ¬∑ , Œ∏st ,at } as the (random) set of Œ∏ parameters required
during the course of a bamcp simulation that starts at time 1 and ends at time t. Using
the chain rule, we can rewrite
P (Œò|œÜ, h) =P (Œ∏s1 ,a1 |œÜ, h)
P (Œ∏s2 ,a2 |Œò1 , œÜ, h)
..
.
P (Œ∏sT ,aT |ŒòT ‚àí1 , œÜ, h)
P (Œò \ ŒòT |ŒòT , œÜ, h)
where T is the length of the simulation and Œò \ ŒòT denotes the (random) set of parameters
that are not required for a simulation. For each simulation i, we sample P (œÜ|ht ) at the
root and then lazily sample the Œ∏st ,at parameters as required, conditioned on œÜ and all
Œòt‚àí1 parameters sampled for the current simulation. This process is stopped at the end of
the simulation, typically long before all Œ∏ parameters have been sampled. For example, if
the transition parameters for different states and actions are independent, we can simply
draw any necessary parameters individually for each state-action pair encountered during a
simulation. In general, transition parameters are not independent for different states, but
dependencies are likely to be structured. For example, the mdp dynamics could arise from a
mixture model where œÜ denotes the mixture component and P (œÜ|h) specifies the posterior
mixture proportion. Then, if the transition parameters Œ∏ are conditionally independent
given the mixture component, sampling œÜi at the root for simulation i allows us to sample
the required parameters Œ∏s,a independently from P (Œ∏s,a |œÜi , h) just when they are required
during the i-th simulation. This leads to substantial performance improvement, especially
in large mdps where a single simulation only requires a small subset of parameters (see for
example the domain in Section 4.2 for a concrete illustration). This lazy sampling scheme
is not limited to shallow latent variable models; in deeper models, we can also benefit from
conditional independencies to save on sampling operations for each simulation by sampling
only the necessary latent variables ‚Äî as opposed to sampling all of œÜ.
3.3 Rollout Policy Learning
The choice of rollout policy œÄro is important if simulations are few, especially if the domain
does not display substantial locality or if rewards require a carefully selected sequence of
actions to be obtained. Otherwise, a simple uniform random policy can be chosen to provide
noisy estimates. In this work, we learn Qro , the optimal Q-value in the real mdp, in a modelfree manner, using Q-learning, from samples (st , at , rt , st+1 ) obtained off-policy as a result
of the interaction of the bamcp agent with the mdp at time t. For each real transition
858

Bayes-Adaptive Monte-Carlo Planning

(st , at , rt , st+1 ) observed, we update
Qro (st , at ) ‚Üê Qro (st , at ) + Œ±(rt + Œ≥ max Qro (st+1 , a) ‚àí Qro (st , at )),
a

(20)

where Œ± is some learning rate parameter; this is the standard Q-learning rule (Watkins,
1989). Acting greedily according to Qro translates to pure exploitation of gathered knowledge. A rollout policy in bamcp following Qro could therefore over-exploit. Instead, similar
to the work of Gelly and Silver (2007), we select an -greedy policy with respect to Qro as
our rollout policy œÄro . In other words, after t steps in the mdp, we have updated Qro t
times and we use the following stochastic rollout policy for all mcts simulations at the t + 1
decision step:
(

1 ‚àí  + |A|
if a = argmaxa0 Qro (s, a0 )
œÄro (s, a) =
(21)

otherwise,
|A|
where œÄro (s, a) is the probability of selecting action a when in the mdp state s (i.e., history
is ignored) during a rollout. This biases rollouts towards observed regions of high rewards.
This method provides valuable direction for the rollout policy at negligible computational
cost. More complex rollout policies can be considered, for example rollout policies that
depend on the sampled model P i or on the history ht . However, these usually incur computational overhead, which may be less desired than running more simulations with worse
estimates.
3.4 Theoretical Properties
In this section, we show that bamcp converges to the Bayes-optimal policy. We first present
theoretical results in the case that exact posterior inference can be conducted to obtain
posterior samples of the dynamics (Section 3.4.1), we then extend the convergence guarantee
to the case where approximate inference (MCMC-based) is necessary to produce posterior
samples (Section 3.4.2).
The proof of Theorem 1 was present in the supplementary material by Guez et al. (2012).
Theorem 2 is a novel contribution of this paper.
3.4.1 Exact Inference Case
The main step is proving that root sampling does not alter the behavior of ba-uct. Our
proof is an adaptation of the pomcp proof by Silver and Veness (2010). We then provide
some intuition and some empirical evidence of convergence on simple Bandit problems ‚Äî
where the Bayes-optimal solution is known.
Consider the ba-uct algorithm: uct applied to the Bayes-Adaptive mdp (its dynamics
are described in Equation 16). Let DœÄ (hT ) be the rollout distribution of ba-uct: the
probability that history hT is generated when running the ba-uct search from hst , ht i, with
ht a prefix of hT , T ‚àí t the effective horizon in the search tree, and œÄ is an arbitrary EE
œÄ
policy. Similarly define the quantities DÃÉ (hT ): the probability that history hT is generated
when running the bamcp algorithm, and PÃÉh (P): the distribution of P at node h when
859

Guez, Silver, & Dayan

running bamcp. The following lemma shows that these rollout statistics are the same
under bamcp as ba-uct.4
Lemma 1 DœÄ (hT ) = DÀúœÄ (hT ) for all EE policies œÄ : H ‚Üí A.
Proof Let œÄ be arbitrary. We show by induction that for all suffix histories h of ht , (a)
DœÄ (h) = DÀúœÄ (h); and (b) P (P |h) = PÃÉh (P), where P (P |h) denotes (as before) the posterior
distribution over the dynamics given h.
Base case: At the root (h = ht , suffix history of size 0), it is clear that PÃÉht (P) = P (P |ht )
since we are sampling from the posterior at the root node and DœÄ (ht ) = DÀúœÄ (ht ) = 1 since
all simulations go through the root node.
Step case:
Assume proposition true for all suffices of size j. Consider any suffix has0 of size j + 1,
where a ‚àà A and s0 ‚àà S are arbitrary and h is an arbitrary suffix of size j ending in s. The
following relation holds:
Z
œÄ
0
œÄ
D (has ) = D (h)œÄ(h, a)
dP P (P |h) P(s, a, s0 )
(22)
ZP
œÄ
= DÃÉ (h)œÄ(h, a)
dP PÃÉh (P) P(s, a, s0 )
(23)
P

= DÀúœÄ (has0 ),

(24)

where the second line is obtained using the induction hypothesis, and the rest from the
definitions. In addition, we can match the distribution of the samples P at node has0 :
P (P |has0 ) = P (has0 | P)P (P)/P (has0 )

(25)

0

0

(26)

0

0

(27)

= P (h| P)P (P) P(s, a, s )/P (has )
= P (P |h)P (h) P(s, a, s )/P (has )
0

= ZP (P |h) P(s, a, s )
0

(28)

= Z PÃÉh (P) P(s, a, s )

(29)

0

= Z PÃÉha (P) P(s, a, s )

(30)

= PÃÉhas0 (P),

(31)

where Equation 29 is obtained from the induction hypothesis, Equation 30 is obtained from
the fact that the choice of action at each node is made independently of the samples P.
Finally, to obtain Equation 31 from Equation 30, consider the probability that a sample
P arrives at node has0 , it first needs to traverse node ha (this occurs with probability
PÃÉha (P)) and then, from node ha, the state s0 needs to be sampled (this occurs with probability P(s, a, s0 )); therefore, PÃÉhas0 (P) ‚àù PÃÉha (P) P(s, a, s0 ). Z is the normalization constant:
R
R
Z = 1/( P d P P(s, a, s0 )P (P |h)) = 1/( P d P P(s, a, s0 )PÃÉh (P)). This completes the induction.


4. For ease of notation, we refer to a node with its history only, as opposed to its state and history as in
the rest of the paper.

860

Bayes-Adaptive Monte-Carlo Planning

The proof of Lemma 1 does not make explicit the use of lazy sampling, since this method
for realizing the values of relevant random variables does not affect the rollout distribution
and so does not affect what is being computed, only how.
Define V (hs, hi) = max Q(hs, hi, a) ‚àÄhs, hi ‚àà S √ó H. We now show that bamcp cona‚ààA

verges to the Bayes-optimal solution.
Theorem 1 For all  > 0 (the numerical precision, see Algorithm 1) and a suitably chosen
max
c (e.g. c > R1‚àíŒ≥
), from state hst , ht i, bamcp constructs a value function at the root node
p

that converges in probability to an 0 -optimal value function, V (hst , ht i) ‚Üí V‚àó0 (hst , ht i),

. Moreover, for large enough N (hst , ht i), the bias of V (hst , ht i) decreases as
where 0 = 1‚àíŒ≥
O(log(N (hst , ht i))/N (hst , ht i)).
Proof The uct analysis by Kocsis and SzepesvaÃÅri (2006) applies to the ba-uct algorithm,
since it is vanilla uct applied to the bamdp (a particular mdp). It also applies for arbitrary rollout policies, including the one developed in Section 3.3. By Lemma 1, bamcp
simulations are equivalent in distribution to ba-uct simulations. The nodes in bamcp are
therefore evaluated exactly as in ba-uct, providing the result.

Lemma 1 provides some intuition for why belief updates are unnecessary in the search
tree: the search tree filters the samples from the root node so that the distribution of
samples at each node is equivalent to the distribution obtained when explicitly updating
the belief. In particular, the root sampling in pomcp (Silver & Veness, 2010) and bamcp is
different from evaluating the tree using the posterior mean. This is illustrated empirically
in Figures 4 and 5 in the case of simple Bandit problems.
3.4.2 Approximate Inference Case
In Theorem 1, we made the implicit assumption that bamcp is provided with true samples
drawn iid from the posterior. However, most sophisticated priors will require some form of
approximate sampling scheme (see, for example, the task in Section 4.2), such as Markov
Chain Monte Carlo (MCMC), which generally deliver correlated posterior samples after the
chain converges to the stationary distribution (Neal, 1993). Thus, it is necessary to extend
the proof of convergence of bamcp to deal with samples of this nature.
Theorem 2 When using an approximate sampling procedure based on a MCMC chain with
stationary distribution P (P |ht ) (e.g., Metropolis-Hastings or Gibbs sampling) to produce a
sample sequence P 1 , P 2 , . . . at the root node of bamcp, the value V (hst , ht i) found by
bamcp converges in probability to a (near-)optimal value function.
Proof Let  > 0 be the chosen numerical accuracy of the algorithm. We can choose a
finite depth T for the search tree as a function of , rmax , and Œ≥ that guarantees the sum
total return after depth T amountsPto less than . Now consider any leaf Q-node i of
that tree, with mean value ¬µin = n1 nm=1 rm after n simulations, where rm is the reward
obtained from this node at the m-th simulation going through that node. Since ucbÔú± is
used throughout the tree, exploration never ceases and this guarantees that n ‚Üí ‚àû (see for
example Kocsis & SzepesvaÃÅri, 2006, Thm. 3).
861

Guez, Silver, & Dayan

80

Discounted sum of rewards

Undiscounted sum of rewards

260

240

220

200

180

75

70

65

60
160
Bayes‚àíoptimal

BAMCP

Posterior Mean

(a)

55

Bayes‚àíoptimal

BAMCP

Posterior Mean

(b)

Figure 4: Performance comparison of bamcp (50000 simulations, 100 runs) against the posterior mean
decision on an 8-armed Bernoulli bandit with Œ≥ = 0.99 after 300 steps. The arms‚Äô success
probabilities are all 0.6 except for one arm which has success probability 0.9. The Bayes-optimal
result is obtained from 1000 runs with the Gittins indices (Gittins et al., 1989). a. Mean sum
of rewards after 300 steps. b. Mean sum of discounted rewards after 300 steps.

Root sampling filtering (Lemma 1) still holds despite the approximate sampling at the
root node; since it is a statement about the distribution of samples, not about the order in
which these samples arrive. Therefore, the distribution of dynamics at node i converges to
the right stationary distribution P (P |hi ), where hi is the history corresponding to node i.
Asymptotic results on Markov Chains (Law of large numbers for Markov Chains) guarantee
us that ¬µin ‚Üí ¬µi a.s., where ¬µi is the true expected reward at leaf node i.
Given convergence at the leaves, we can work our way up the tree by backward induction
to show that the values at each node converge to their (near-)optimal values. In particular
the value at the root converges to an ‚àíoptimal value.


3.5 Possible Misuse of Latent Variable Information: a Counter-Example
When planning in a bamdp using a sample-based forward-search algorithm such as bamcp,
it could be tempting to use the knowledge available in the sampler when producing samples
(such as the value of latent variables in the model) to take better planning decisions. For
example, when generating a sample P iR of the dynamics according to a posterior distribution P (P |h) which can be written as Œ∏ P (P |Œ∏)P (Œ∏|h), P i might have been generated by
sampling Œ∏i from P (Œ∏|h) before sampling P i from P (P |Œ∏i ). Since the value of Œ∏ is available
and contain high-level information, one natural question is to ask whether the search can
be informed by the value of Œ∏.
862

Bayes-Adaptive Monte-Carlo Planning

BAMCP ‚àí Number of simulations: 5000

BAMCP ‚àí Number of simulations: 250000

20

20

15

Œ≤

Œ≤

15

10

5

5

5

10

Œ±

15

20

5

BAMCP ‚àí Number of simulations: 2500000

20

15

Œ≤

Œ≤

15

Œ±

20

15

10

5

10

5

5

10

Œ±

15

20

5

10

15

Œ±

20

Posterior mean decision

Probability of correct decision

15

Œ≤

10

BAMCP ‚àí Number of simulations: 5000000

20

20

10

10

0

0.2

0.4

0.6

0.8

1

5

5

10

Œ±

15

20

Figure 5: Evaluation of bamcp against the Bayes-optimal policy, for the case Œ≥ = 0.95, when choosing
between a deterministic arm with reward 0.5 and a stochastic arm with reward 1 with posterior
probability p ‚àº Beta(Œ±, Œ≤). The result is tabulated for a range of values of Œ±, Œ≤, each cell value
corresponds to the probability of making the correct decision (computed over 50 runs) when
compared to the Gittins indices (Gittins et al., 1989) for the corresponding posterior. The first
four tables corresponds to different number of simulations for bamcp and the last table shows
the performance when acting according to the posterior mean. In this range of Œ±, Œ≤ values, the
Gittins indices for the stochastic arm are larger than 0.5 (i.e., selecting the stochastic arm is
optimal) for Œ≤ ‚â§ Œ± + 1 but also Œ≤ = Œ± + 2 for Œ± ‚â• 6. Acting according to the posterior mean is
different from the Bayes-optimal decision when Œ≤ >= Œ± and the Gittins index is larger than 0.5.
bamcp is guaranteed to converge to the Bayes-optimal decision in all cases, but convergence is
slow for the edge cases where the Gittins index is close to 0.5 (e.g., For Œ± = 17, Œ≤ = 19, the
Gittins index is 0.5044 which implies a value of at most 0.5044/(1‚àíŒ≥) = 10.088 for the stochastic
arm versus a value between 10 and 0.5 + Œ≥ √ó 10.088 = 10.0836 for the deterministic arm).

863

Guez, Silver, & Dayan

Here, we outline one incorrect way of using the latent variable value during search.
Suppose we would want to split our search tree on the value of Œ∏ (this would occur implicitly
if we were constructing history features based on the value of Œ∏), we provide below a simple
counter-example that shows that this is not a valid search approach.
Consider a simple prior distribution on two 5-state mdps, illustrated in Figure 6, where
P (Œ∏ = 0|h0 ) = P (Œ∏ = 1|h0 ) = 21 , and P (P |Œ∏) is a delta function on the illustrated mdp.
s0
a0

s0
a1

a0

s1 p = 1
a0

s2 p = 1
+1

s1 p = 1

a1

s3 p = 1
+2

a0
s4 p = 1
‚àí2
(a)

a1
s2 p = 1
+1

a1

s4 p = 1
‚àí2

Œ∏=0

s3 p = 1
+2
(b)

Œ∏=1

Figure 6: The two possible mdps corresponding to the two settings of Œ∏.

h0 = s0
a0

a1

s1

s2
+1

a0
1
2
s3

1
2

+2

a1
1
2
s4

1
2

‚àí2

Figure 7: bamdp, nodes correspond to belief(or history)-states.

There are 2 deterministic actions (a0 , a1 ) in each mdp, the episode length is 1 or 2 steps.
The only difference between the two mdps is the outcome of taking action a0 and a1 in state
s1 , as illustrated in Figure 6, so that a0 is rewarding when Œ∏ = 0 and costly when Œ∏ = 1,
and vice-versa for a1 . All the rewards are obtained from executing any action at any of the
terminal states (s2 , s3 , s4 ).
Observing the first transition is not informative, which implies that the posterior distribution is unchanged after the first transition: P (P |h0 ) = P (P |h0 a0 s1 ) = P (P |h0 a1 s2 ).
The bamdp corresponding to this problem is illustrated in Figure 7.
864

Bayes-Adaptive Monte-Carlo Planning

At history-state h0 = s0 , the Bayes-optimal Q values can easily be computed:
Q‚àó (h0 , a1 ) = Œ≥,

(32)

‚àó

Q (h0 a0 s1 , a0 ) = 0 + Œ≥ (2 ¬∑ P (s3 |h0 a0 s1 a0 ) ‚àí 2 ¬∑ P (s4 |h0 a0 s1 a0 ))
= Œ≥(1 ‚àí 1) = 0,

(33)
(34)

‚àó

Q (h0 a0 s1 , a1 ) = 0 + Œ≥ (2 ¬∑ P (s3 |h0 a0 s1 a0 ) ‚àí 2 ¬∑ P (s4 |h0 a0 s1 a0 ))

(35)

= Œ≥(1 ‚àí 1) = 0,

(36)

‚àó

(37)

‚àó

Q (h0 , a0 ) = 0 + Œ≥ max Q (h0 a0 s1 , a) = 0,
a

which implies that a1 = œÄ ‚àó (h0 ) for any Œ≥. [We used the fact that P (s3 |h0 a0 s1 a0 ) = P (Œ∏ =
0|h0 a0 s1 a0 ) ¬∑ P (s3 |Œ∏ = 0, s1 a0 ) + P (Œ∏ = 1|h0 a0 s1 a0 ) ¬∑ P (s3 |Œ∏ = 1, s1 a0 ) = 21 ¬∑ 1 + 12 ¬∑ 0 = 12 ,
and similarly for P (s4 |h0 a0 s1 a0 )].
Note that, since belief updates only occur at the terminal states, forward-search with
or without root sampling will be equivalent. They both would construct a search tree as in
Figure 7 and compute the right value and right decision.
The problem comes in if we decide to split our search tree at chance nodes based on
the value of Œ∏ in the generated samples going down the tree. For example, after taking
action a0 in state s0 , we would be using either an mdp for which Œ∏ = 0 w.p 0.5 or an mdp
for which Œ∏ = 1 w.p 0.5. Since multiple values of Œ∏ go through the node h0 a0 , we would
branch the tree as illustrated in Figure 8. This search tree is problematic because the value
computed for Q‚àó (h0 , a0 ) becomes 2 ¬∑ Œ≥ 2 , which is larger than Q‚àó (h0 , a1 ) = Œ≥ for any Œ≥ > 0.5.
Therefore, the policy that is computed at the root is no longer Bayes-optimal.

h0 = s0
a0
Œ∏ = 0, s1

a1
s2

Œ∏ = 1, s1

+1
a0
s3

a1

a0
s4

+2

a1

s3
‚àí2

s4
+2

‚àí2

Figure 8: A problematic search tree.

By branching on the latent variable value, we are creating spurious observations: we are
implying that the latent variable from the past will be observed in the future, which is not
the case.
To summarize, the Bayes-adaptive policy to be optimized must be a function of future
histories (i.e., things we‚Äôll actually observe in the future), and cannot be a function of future
unobserved latent variables. Ignoring this causes problems in simple domains such as the
one illustrated above, but similar scenarios would occur in more complex latent variable
models for the same reasons.
865

Guez, Silver, & Dayan

4. Experiments
We first present empirical results of bamcp on a set of standard problems with comparisons
to other popular algorithms. We then showcase bamcp‚Äôs advantages in a large scale task:
an infinite 2D grid with complex correlations between reward locations.
4.1 Standard Domains
The following algorithms were run on the standard domains: bamcp, sboss, beb, bfs3.
Details about their implementation and parametrization can be found in Appendix B. In
addition, we report results from the work of Strens (2000) for several other algorithms.
For all the following domains, we fix Œ≥ = 0.95.
‚Ä¢ The Double-loop domain is a 9-state deterministic mdp with 2 actions (Dearden,
Friedman, & Russell, 1998), 1000 steps are executed in this domain. It is illustrated
in Figure 9(a).
‚Ä¢ Grid5 is a 5 √ó 5 grid with a reset state in one corner, and a single reward state
diametrically opposite to the reset state. Actions with cardinal directions are executed
with small probability of failure (pfailure = 0.2) for 1000 steps.

These expectacan be approxias derived fairly

‚Ä¢ Grid10 is a 10 √ó 10 grid designed in the same way as Grid5. We collect 2000 steps
in this domain.
b,2
a,10
a,0

a,0

a,0

a,0

1 b,2 Maze
2
3
4
‚Ä¢ Dearden‚Äôs
is a 264-states
maze
with 5
3 flags to collect (Dearden et al., 1998).
b,2
A special state provides
reward
equivalent
to
the number of flags collected since the
b,2
b,2
last visit. 20000 steps are executed in this domain5 . It is illustrated in Figure 9(b).

ed two possible
The first, modate, but might
ture update, is
ation.

(a) Task 1 [11].
b,2

a,10
1

6
b,0

b,0
a,0

2

b,2
b,2
b,2a,0
b,2

5

a,0

a,0

3

b,0

a,0

1

4

a,b,0
5

2

a,0

a,0

a,0

0

a,b,0

Figure 1. The ‚ÄúChain‚Äù problem

algorithms conces to show that
es, and that the
is the case, then
-VPI strategies

nvergence proof
s tried infinitely
0

earning rate. If
shows that the
-values.
we use moment
ect mean.
finitely often in
updating, then
or every state

o prove that the

finitely often in

a,b,2
7
6.1 Problem
Descriptions

Figure

a,b,1

3

4 The arcs
Figure 1b,0
shows the 8
5-state ‚ÄúChain‚Äù problem.
a,b,0are
labeled with the actions that cause that state transition,
and the associated rewards.
However
the agent has only
Figure 3. The ‚Äú Maze‚Äù problem.
(b) Task
(a) 2 [14].
(b)
abstract actions {1,2} available. Usually abstract action 1
causes real-world action a to take place, and abstract
a direction perpendicular to that intended (with
2 causes real-world action b. With probability 0.2,
S standard
F domains
Geffect.
9: action
Two
of the
described
Section
4.1: a) The
Double-loop
domain,
b) Dearden‚Äôs
probability
0.1). There
are 33 reachable
locations
in the
the
agent
‚Äúslips‚Äù
and its action
has the
opposite in
maze (including the goal) and there are up to 8
maze.
Figures
from
work
of Strens
The
optimal
behavior
is tothe
always
choose
action 1(2000).
(even
combinations for status of the flags at any time. This
though this sometimes results in the transitions labeled
yields 264 discrete states. The agent was given limited
with b). Once state 5 is reached, a reward of 10 is usually
layout information (identifying the immediate successors
received several times before the agent slips, and starts
of each
in order tothe
reduce
the complexity
of the
again at the
state performance
1. This problemofrequires
quantify
each effective
algorithm,
westate)
measured
total
undiscounted
posterior distribution for the Bayesian DP approach.
exploration and accurate estimation of discounted reward.

To
reward over many steps. We chose this measure of performance to enable fair comparisons
Figure 2 shows the ‚ÄúLoop‚Äù problem which involves two
6.2 Results
to be drawn
with
prior
work.
In fact,
we Two
areFactions
optimising
a different criterion ‚Äì the discounted
loops
of length
5 joined
at a single
start state.
are available and transitions are deterministic. Taking

The experimental results show accumulated totals of

rewardDP
received
overStrens
learning(2000)
phases which
of
5. The result
reported
maze
with
theloop,
Bayesian
alg. by
is for consist
a different
action
a repeatedly
causes traversal
of the
right
F for Dearden‚Äôs
steps for Chain and Loop, and 20000 steps for
yielding
a reward
of 1the
for maze
every layout
5 actions
taken. to 1000
version of
the task
in which
is given
the agent.

Maze. Averages were taken over 256 runs for Chain and
Conversely,
taking actionproblem.
b repeatedly causesistraversal
of
(c) Task 3.
A navigation
the start
state.
The
Loop, and
16 runs for Maze. Table 1 summarizes
the left loop, yielding a reward of 2 for every 5 actions
comparative
performance after 1, 2, and 8 phases of
agent receives
a
reward
upon
reaching
based
on
the
number
taken. This problem requires a difficult compromise
866
learning. (Note that these results are pessimistic in that
between exploration and exploitation.
of flags collected.
they show the rewards actually received during learning
Figure 3 shows the ‚Äú Maze‚Äù problem. The agent can move

rather than the rewards which could be received with the

instantaneous greedy policy.) In the Bayesian DP method,
or down
by one square
in the
If it
Figureleft,
3: right,
Theupthree
domains
used
in maze.
our experiments.
a new hypothesis (for the MDP) was drawn each time the
attempts to move into a wall, its action has no effect. The
problem is to move from the start (top-left) to the goal
(top-right) collecting the flags on the way. When it

system entered the starting state. In Maze, a new
hypothesis was also obtained every 24 steps because there

Bayes-Adaptive Monte-Carlo Planning

reward from the start state ‚Äì and so we might expect this evaluation to be unfavourable to
our algorithm.
Although one major advantage of Bayesian RL is that one can specify priors about the
dynamics, for these domains, we used rather generic priors to enable comparisons with previous work. For the Double-loop domain, the Bayesian RL algorithms were run with a simple
1
Dirichlet-Multinomial model with symmetric Dirichlet parameter Œ± = |S|
. For the grids
and the maze domain, the algorithms were run with a sparse Dirichlet-Multinomial model,
as described by Friedman and Singer (1999). For both these models, efficient collapsed
sampling schemes are available; they are employed for the ba-uct and bfs3 algorithms in
our experiments to compress the posterior parameter sampling and the transition sampling
into a single transition sampling step. This considerably reduces the cost of belief updates
inside the search tree when using these simple probabilistic models. Unfortunately, efficient collapsed sampling schemes are not available in general (see for example the model in
Section 4.2).
Sum of Rewards after 1000 steps

90

90

BAMCP

80

80

70

70

60

60

50

50

40

40

30

30

20

20

10

‚àí3

10

‚àí2

‚àí1

10

90

10

0

10

10

80

70

70

60

60

50

50

40

40

30

30

20

20
‚àí3

10

‚àí2

10

‚àí3

10

‚àí2

10

90

SBOSS

80

10

BFS3

‚àí1

10

0

10

10

‚àí1

10

‚àí1

10

10

0

BEB

‚àí3

10

‚àí2

10

Average Time per Step (s)

10

0

Figure 10: Performance of each algorithm on the Grid5 domain as a function of planning time. Each
point corresponds to a single run of an algorithm with an associated setting of the parameters.
Increasing brightness inside the points codes for an increasing value of a parameter (bamcp
and bfs3: number of simulations, beb: bonus parameter Œ≤, sboss: number of samples K).
A second dimension of variation is coded as the size of the points (bfs3: branching factor C,
sboss: resampling parameter Œ¥). The range of parameters is specified in Appendix B.

A summary of the results is presented in Table 1. Figures 10 and 11 report the planning
time/performance trade-off for the different algorithms on the Grid5 and Maze domain.
867

Undiscounted sum of rewards after 20000 steps

Guez, Silver, & Dayan

1100
1000
900

BAMCP (BA‚àíUCT+RS+LS+RL)
BEB
BFS3
SBOSS

800
700
600
500
400
300
200
100
0

‚àí1

0

10

Average Time per Step (s)

10

Figure 11: Performance of each algorithm, as in Figure 10 but on Dearden‚Äôs Maze domain.

BAMCP
BFS3 (Asmuth & Littman, 2011)
SBOSS (Castro & Precup, 2010)
BEB (Kolter & Ng, 2009)
Bayesian DP* (Strens, 2000)
Bayes VPI+MIX* (Dearden et al., 1998)
IEQL+* (Meuleau & Bourgine, 1999)
QL Boltzmann*

Double-loop
387.6 ¬± 1.5
382.2 ¬± 1.5
371.5 ¬± 3
386 ¬± 0
377 ¬± 1
326 ¬± 31
264 ¬± 1
186 ¬± 1

Grid5
72.9 ¬± 3
66 ¬± 5
59.3 ¬± 4
67.5 ¬± 3
-

Grid10
32.7 ¬± 3
10.4 ¬± 2
21.8 ¬± 2
10 ¬± 1
-

Dearden‚Äôs Maze
965.2 ¬± 73
240.9 ¬± 46
671.3 ¬± 126
184.6 ¬± 35
817.6 ¬± 29
269.4 ¬± 1
195.2 ¬± 20

Table 1: Experiment results summary. For each algorithm, we report the mean sum of rewards and
confidence interval for the best performing parameter within a reasonable planning time limit
(0.25 s/step for Double-loop, 1 s/step for Grid5 and Grid10, 1.5 s/step for the Maze). For
bamcp, this simply corresponds to the number of simulations that achieve a planning time just
under the imposed limit. * Results by Strens (2000) reported without timing information.

On all the domains tested, bamcp performed best. Other algorithms came close on
some tasks, but only when their parameters were tuned to that specific domain. This is
particularly evident for beb, which required a different value of exploration bonus to achieve
maximum performance in each domain. bamcp‚Äôs performance is stable with respect to the
choice of its exploration constant (c = 3) and it did not require fine tuning to obtain the
results.
bamcp‚Äôs performance scaled well as a function of planning time, as is evident in Figures 10 and 11. In contrast, sboss follows the opposite trend. If more samples are employed
to build the merged model, sboss actually becomes too optimistic and over-explores, de868

(a)

Undiscounted sum of rewards after 20000 steps

Bayes-Adaptive Monte-Carlo Planning

1100
1000

BA‚àíUCT + RL
BA‚àíUCT

900
800
700
600
500
400
300
200
100
0

‚àí1

10

Average Time per Step (s)

0

10

1100

BA‚àíUCT + RS + RL
1000

BA‚àíUCT + RS

900
800
700
600

(b)

500
400
300
200
100
0
‚àí1

10

1100
1000

0

10

BA‚àíUCT + RS + LS + RL (BAMCP)
BA‚àíUCT + RS + LS

900
800
700
600

(c)

500
400
300
200
100
0

‚àí1

10

0

10

Figure 12: Evolution of performance from ba-uct to bamcp on Dearden‚Äôs Maze domain. bamcp is present
on all plots for comparison, as also displayed in Figure 11. a. Performance of vanilla ba-uct
with and without rollout policy learning (RL) presented in Section 3.3. b. Performance of
ba-uct with Root Sampling (RS), as presented in Section 3.1, and with and without rollout
learning. c. Performance of ba-uct with Root Sampling and Lazy Sampling (LS), as presented
in Section 3.2. In addition with rollout policy learning, this is the bamcp algorithm.

869

Guez, Silver, & Dayan

grading its performance. beb cannot take advantage of prolonged planning time at all. The
performance of bfs3 generally improves with more planning time, given an appropriate
choice of parameters, but it is not obvious how to trade-off the branching factor, depth, and
number of simulations in each domain. bamcp greatly benefited from our lazy sampling
scheme in the experiments, providing a 35√ó speed improvement over the naive approach in
the maze domain for example; this is illustrated in Figure 12.
Dearden‚Äôs maze aptly illustrates a major drawback of forward search sparse sampling
algorithms such as bfs3. Like many maze problems, all rewards are zero for at least k steps,
where k is the solution length. Without prior knowledge of the optimal solution length,
all upper bounds will be higher than the true optimal value until the tree has been fully
expanded up to depth k ‚Äì even if a simulation happens to solve the maze. In contrast, once
bamcp discovers a successful simulation, its Monte-Carlo evaluation will immediately bias
the search tree towards the successful trajectory.
Figure 12 confirms that, even on a moderate-sized domain with a simple prior (Independent Sparse Dirichlet-Multinomial), bamcp amply benefits from root sampling, lazy
sampling, and rollout learning. For more complex priors, as in the following section, ba-uct
becomes computationally intractable. Root sampling and lazy sampling are then mandatory
components.
4.2 Infinite 2D Grid Task
..
.

¬∑¬∑¬∑

¬∑¬∑¬∑

..
.
Figure 13: A portion of an infinite 2D grid task generated with Beta distribution parameters Œ±1 = 1, Œ≤1 = 2
(columns) and Œ±2 = 2, Œ≤2 = 1 (rows). Black squares at location (i,j) indicates a reward of 1,
the circles represent the corresponding parameters pi (blue) and qj (orange) for each row and
column (area of the circle is proportional to the parameter value). One way to interpret these
parameters is that following column i implies a collection of 2pi /3 reward on average (2/3 is
the mean of a Beta(2, 1) distribution) whereas following any row j implies a collection of qj /3
reward on average; but high values of parameters pi are less likely than high values parameters
qj . These parameters are employed for the results presented in Figure 14-c).

870

Bayes-Adaptive Monte-Carlo Planning

It is perhaps not unfair to characterize all the domains in the previous section as being
of very limited scale. Indeed, this can be seen as a correct reflection of the state of the
art of Bayesian RL. However, bamcp, because of its root-based lazy sampling, can be
applied to considerably larger and more challenging domains. We therefore designed a new
problem that is well beyond the capabilities of prior algorithms since it has an infinite and
combinatorially structured state space, and an even more challenging belief space. Although
still abstract, this new task illustrates something of bamcp‚Äôs power.
4.2.1 Problem Description
The new problem is a class of complex mdps over an infinite grid. In a draw of a particular
mdp, each column i has an associated latent parameter pi ‚àº Beta(Œ±1 , Œ≤1 ) and each row j
has an associated latent parameter qj ‚àº Beta(Œ±2 , Œ≤2 ). The probability of grid cell ij having
a reward of 1 is pi qj , otherwise the reward is 0. The agent knows it is on a grid and is
always free to move in any of the four cardinal directions. Rewards are consumed when
visited; returning to the same location subsequently results in a reward of 0. As opposed to
the independent Dirichlet priors employed in standard domains, here, dynamics are tightly
correlated across states (i.e., observing a state transition provides information about other
state transitions).
The domain is illustrated in Figure 13. Although the uncertainty appears to concern
the reward function of the mdp rather than the dynamics, it can be viewed formally as uncertainty in the dynamics when the state is augmented with a binary variable that indicates
whether a reward is present.6
Formally, since rewards disappear after one visit, the description of the state in the
mdp needs to include information about the state of all the rewards (for example in the
form of a set of grid locations previously visited) in addition to the position of the agent
on the infinite grid. A state s is therefore the combination of the current agent‚Äôs location
(i, j), the unordered set of previously visited locations V , and the binary variable R = rij .
The dynamics P then deterministically updates the position of the agent and the visited
locations based on the agent‚Äôs action, and updates R according to the reward map. The
known reward function is then simply R(s, a) = s(R) for all a (i.e., as described before, the
agent gets a reward in position ij if rij = 1).
4.2.2 Inference
Posterior inference (of the dynamics P) in this model requires approximation because of
the non-conjugate coupling of the variables. To see this, consider the posterior probability
of a particular grid cell kl having a reward of 1 (denote this event rkl = 1), then
Z
pk ql P (pk , ql |O) dpk dql ,

P (rkl = 1|O) =

(38)

pk ,ql

where O = {(i, j)} is the set of observed reward locations, each associated with an observed
reward rij ‚àà {0, 1}. Sampling rkl is straightforward given access to posterior samples of
6. In fact, the bamdp framework can be straightforwardly extended to deal with more general, partiallyobserved, reward functions (Duff, 2002).

871

Guez, Silver, & Dayan

pk and ql . However, the posterior distribution on pk and ql , P (pk , ql |O), cannot be easily
sampled from, it is given by:
P (pk , ql |O) ‚àù P (O|pk , ql )P (pk )P (ql )
Z
Y
Y
P (O|PO , QO )
P (p)
P (q)
=
PO \pk ,QO \ql

Z
=

p‚ààPO

Y

(40)

q‚ààQO

(pi qj )rij (1 ‚àí pi qj )1‚àírij

PO \pk ,QO \ql (i,j)‚ààO

(39)

Y

Beta(p; Œ±1 , Œ≤1 )

p‚ààPO

Y

Beta(q; Œ±2 , Œ≤2 ),

q‚ààQO

(41)
where PO denotes the set of parameters pi for all observed columns i (columns where at least
one observation exists) and similarly for QO with rows. This posterior suffers from nonconjugacy (because of the multiplicative interaction between the two Beta distribution) but
also from a complicated dependence structure (pk and ql depend on observations outside of
column k and row l). For these reasons, the inference is done approximately via MetropolisHastings (details in Appendix C).
4.2.3 Results
Planning algorithms that attempt to solve an mdp based on sample(s) (or the mean) of the
posterior (e.g., boss, beb, Bayesian DP) cannot directly handle this large combinatorial
state space. Previous forward-search methods (e.g., ba-uct, bfs3) can deal with the state
space, but not the complex belief space: at every node of the search tree they must solve
an approximate inference problem to estimate the posterior beliefs. By contrast, bamcp
limits the posterior inference to the root of the search tree and is not directly affected by
the size of the state space or belief space, which allows the algorithm to perform well even
with a limited planning time. Note that lazy sampling is required in this setup since a full
sample of the dynamics involves infinitely many parameters.
Figure 14 demonstrates the planning performance of bamcp in this complex domain.
Performance improves with additional planning time. The quality of the prior clearly affects
the agent‚Äôs performance, bamcp can take advantage of correct prior information to gain
more rewards. In addition, the behavior of the agent is qualitatively different depending on
the prior parameters employed.
For example, for the case of Figure 14-a, rewards are often found in relatively dense
blocks on the map and the agent exploits this fact when exploring; this explains the high
frequency of short dwell times. For Figure 14-b, good rewards rates can be obtained by
following the rare rows that have high qj parameters, but finding good rows can be expensive
for at least two reasons: 1) good rows can be far from the agent‚Äôs current position and 2) it
takes longer to decide the value of a row if most observations lack rewards; this is because the
entropy of the posterior is larger given observations of no rewards (which can be explained
by either rows or columns being poor, or both at the same time) than given observations
of rewards (which can be explained with high probability by both rows and columns being
good, since rij ‚àº Bernoulli(pi qj )). Hence, the agent might settle on sub-optimal rows for
large periods of time, for example until it gains enough confidence that a better row is likely
to be found nearby (as in Bandit problems where the Bayes-optimal agent might settle on
872

60

50

30

‚àí1

10

0

10

Planning time (s)

45

40

35

30

25

20

15

‚àí1

10

0

10

Planning time (s)

8

6
5
4
‚àí2
10

70

60

50

40

30

20

‚àí1

10

0

10

Planning time (s)

1

10

‚àí1

10

0

10

Planning time (s)

1

10

7

0.05

0

50

100

150

200

50

100

150

200

50

100

150

200

Dwell Time (Horizontal)

0.05

6.5
6
5.5
5
4.5
4

0

3.5
3
2.5
2
‚àí2
10

1

80

0

7

10

90

10
‚àí2
10

9

1

50

10
‚àí2
10

10

10

Discounted sum of rewards after 200 steps

Undiscounted sum of rewards after 200 steps

20
‚àí2
10

Undiscounted sum of rewards after 200 steps

BAMCP
BAMCP Wrong prior
Random

11

Frequency

70

BAMCP
BAMCP Wrong prior

12

Frequency

80

0.05

13

‚àí1

10

0

10

Planning time (s)

1

10

13

0.05

0

Dwell Time (Horizontal)

0.05

12
11
10

Frequency

90

40

14

Discounted sum of rewards after 200 steps

100

Discounted sum of rewards after 200 steps

Undiscounted sum of rewards after 200 steps

Bayes-Adaptive Monte-Carlo Planning

9
8
7

0

6
5
4
3
‚àí2
10

‚àí1

10

0

10

Planning time (s)

1

10

0.05

0

Dwell Time (Horizontal)

Figure 14: Performance of bamcp as a function of planning time on the Infinite 2D grid task, for Œ≥ = 0.97,
where each row corresponds to a different set of parameters generating the grid. The performance during the first 200 steps in the environment is averaged over 50 sampled environments
(5 runs for each sample) and is reported both in terms of undiscounted (left) and discounted
(center) sum of rewards. bamcp is run either with the correct generative model as prior (solid
green) or with an incorrect prior (dotted green). The performance of a uniform random policy
is also reported (blue). A small sample portion of a grid generated with these parameters is
displayed on each row, presented as in Figure 13. The frequency histogram of dwell times ‚Äî the
number of consecutive steps the agent stays on a row before switching ‚Äî is reported for each
scenario. The grids are generated with Beta parameters a) Œ±1 =0.5, Œ≤1 =0.5, Œ±2 =0.5, Œ≤2 =0.5,
b) Œ±1 =0.5, Œ≤1 =0.5, Œ±2 =1, Œ≤2 =3, and c) Œ±1 =2, Œ≤1 =1, Œ±2 =1, Œ≤2 =2. For the case of wrong priors (dot-dashed lines), bamcp is given the parameters a) Œ±1 =4, Œ≤1 =1, Œ±2 =0.5, Œ≤2 =0.5, b)
Œ±1 =1, Œ≤1 =3, Œ±2 =0.5, Œ≤2 =0.5, and c) Œ±1 =1, Œ≤1 =2, Œ±2 =2, Œ≤2 =1.

873

Guez, Silver, & Dayan

a sub-optimal arm if it believes it likely is the best arm given past data). The heavier-tail
distribution of dwell times for this scenario, in Figure 14-b, reflects this behavior.
The case of Figure 14-c consists of a mixture of rich and poor rows. The agent can
determine moderately quickly if a row is not good enough, given what it expects to find,
and then switches to a nearby row. Once a good enough row is found, the agent can stick
to it for large periods of time. This is reflected in the bimodal nature of the distribution of
dwell times in Figure 14-c. In many cases, the agent is satisfied with one of the first rows
he visits, since it is likely that the agent starts on a good row. He then decides to stay on
it for the entire duration of the episode, which explains the peak towards 200.
When bamcp‚Äôs prior belief about the dynamics is not the same as the generative model‚Äôs
distribution (Wrong prior dot-dashed lines in Figure 14), then maladaptive behavior can be
observed. For instance, in Figure 14-a, the deluded agent expects most columns to be rich,
and some rows to be rich and others to be poor. Hence, a good strategy given this prior
belief is to find one of the good rows and exploit it by travelling horizontally. However,
since a lot of columns are actually poor in this generative model, the agent never encounters
the continuous sequence of rewards it expects to find on good rows. Given its wrong prior,
even if on what is actually a good row, it explains the observation by the row being poor
‚Äî rather than the column ‚Äî and switches to a different row. This behavior is reflected in
the shorter horizontal dwell times plotted in Figure 14-a. Similar effects can be observed in
the Wrong prior cases of Figure 14-b,c.
It should be pointed out that the actual Bayes-optimal strategy in this domain is not
known ‚Äî the behavior of bamcp for finite planning time might not qualitatively match the
Bayes-optimal strategy. Nevertheless, we speculate that some of the behavior we observe
with bamcp, including the apparently maladaptive behaviors, would also be found in the
Bayes-optimal solution.

5. Discussion
Bayesian model-based reinforcement learning addresses the problem of optimizing the discounted return of an agent when the dynamics are uncertain. By solving an augmented
mdp called the bamdp, the agent can optimally trade-off exploration and exploitation and
maximize its expected discounted return according to its prior beliefs. While formally attractive, this framework suffers from a major drawback: it is computationally intractable
to solve the bamdp exactly. While we are not aware of any formal complexity analysis
for solving bamdps, bamdps can be mapped to continuous-state pomdps with discrete observations (Duff, 2002). In general, solving discrete pomdps is known to be challenging
(Mundhenk, Goldsmith, Lusena, & Allender, 2000; Madani, Hanks, & Condon, 2003).
To approximate the Bayes-optimal solution efficiently, we suggested a sample-based
algorithm for Bayesian RL called bamcp that significantly surpassed the performance of
existing algorithms on several standard tasks. We showed that bamcp can tackle larger
and more complex tasks generated from a structured prior, where existing approaches scale
poorly. In addition, bamcp provably converges to the Bayes-optimal solution, even when
MCMC-based posterior sampling is employed.
The main idea is to employ Monte-Carlo tree search to explore the augmented Bayesadaptive search space efficiently. The naive implementation of that idea is an algorithm
874

Bayes-Adaptive Monte-Carlo Planning

that we called ba-uct. However, ba-uct cannot cope with most priors because it employs
expensive belief updates inside the search tree. We therefore introduced three modifications
to obtain a computationally tractable sampled-based algorithm: root sampling, which only
requires beliefs to be sampled at the start of each simulation (as in Silver & Veness, 2010);
a model-free RL algorithm that learns a rollout policy; and a lazy sampling scheme which
enables the posterior beliefs to be sampled cheaply.
5.1 Future Work: Algorithms
Despite its excellent empirical performance in many domains (Gelly et al., 2012), the uct
algorithm is known to suffer several drawbacks. First, there is no finite-time regret bound.
It is possible to construct malicious environments, for example in which the optimal policy
is hidden in a generally low reward region of the tree, where uct can be misled for long
periods (Coquelin & Munos, 2007). Of course, in our setting, appropriate prior distributions
might help structure search more effectively. But, the issue of convergence of the MCMC
chain in approximate inference settings may hinder any effort to get finite-time guarantees.
Second, the uct algorithm treats every action node as a multi-armed bandit problem.
However, there is no actual benefit to accruing reward during planning, and so it is in
theory more appropriate to use pure exploration bandits (Bubeck, Munos, & Stoltz, 2009).
We focused on learning the dynamics (and implicitly the rewards in the infinite grid
task) of a fully observable mdp. If the states are not observed directly, then bamcp could be
extended to maintain beliefs over both the dynamics and the state. Both state and dynamics
would then be sampled from the posterior distribution, at the start of each simulation. This
setting is known as a Bayes-Adaptive Partially Observable mdp (bapomdp) (Ross, Pineau,
Chaib-draa, & Kreitmann, 2011).
In this work, we limited ourselves to the case of discrete-state mdps, since they already
present significant challenges for Bayesian exploration. bamcp cannot be straightforwardly
converted to deal with continuous-state mdps, but it remains to see whether the ingredients that make bamcp successful in the discrete setting could be reassembled into a
continuous-state solution, for example using some form of value function approximation
during simulation-based search (Silver, Sutton, & MuÃàller, 2008).
5.2 Future Work: Priors
bamcp is able to exploit prior knowledge about the dynamics in a principled manner. It is
possible to encode many aspects of domain knowledge into the prior distribution, and so an
important avenue for future work is to explore rich, structured priors about the dynamics
of the mdp. As we showed, if this prior knowledge matches the class of environments that
the agent will encounter, then exploration can be significantly accelerated. It is therefore
important to understand how to select or learn appropriate priors so that large real-world
tasks can be tackled with Bayesian RL. One promising category of rich priors in this context
are non-parametric priors. For example, Doshi-Velez, Wingate, Roy, and Tenenbaum (2010)
and Wingate, Goodman, Roy, Kaelbling, and Tenenbaum (2011) have investigated this
direction, but as yet only in combination with myopic planning algorithms, rather than
Bayes-Adaptive planning.
875

Guez, Silver, & Dayan

5.3 Evaluation of Bayesian RL Algorithms
Bayesian RL algorithms have traditionally been tested on small, hand-crafted, domains.
Even though these domains can contain substantial structure, the priors given to the agent
are usually independent Dirichlet distributions that only generate unstructured random
worlds. This mismatch between the prior distribution and the domains is problematic to
evaluate, since a perfect Bayesian RL algorithm is not guaranteed to perform well given
incorrect priors. Since it is not tractable to compute the Bayes-optimal solution exactly, it
becomes impossible to decide whether an algorithm that obtains a low return compared to
other algorithms in some hand-crafted domain is a better or a worse approximation to the
Bayes-optimal solution.
For the purpose of algorithmic evaluation, the obvious solution is to design priors that
actually generate the tasks that we solve. When a Bayesian RL algorithm is given this
generative model as prior and is also tested on many of these generated tasks, then the
Bayes-optimal solution is guaranteed to obtain the best discounted return on average. In
this case, a higher mean return becomes synonymous with a better approximation ‚Äî given
the goal of matching the Bayes-optimal solution‚Äôs performance. We employed this method
of averaging across generated domains in Section 4.2 to evaluate the bamcp algorithm on
the Infinite Grid task. To understand the exploration performance of proposed algorithmic solutions truly, future comparisons between algorithms would likely benefit from such
evaluation schemes.
5.4 Conclusion
Bayes-adaptive planning is conceptually appealing but computationally very challenging.
The enormous computation required by prior approaches is largely due to the fact that
root values are computed from expectations and/or maximisations over the complete tree
of possible actions and states that follows on from the current history. In addition, these
values must integrate over the distribution of transition and potentially reward models at
each state in the search tree. As a result, computation typically grows exponentially with
search depth, at a rate determined by the action space, successor state space, and model
space.
Our new algorithm, bamcp, builds on previous work (Kearns et al., 1999; Kocsis &
SzepesvaÃÅri, 2006; Silver & Veness, 2010) that solves these problems systematically by sampling these expectations, and notably on the pomcp algorithm of Silver and Veness (2010).
Only a tiny fraction of the future tree is actually explored, chosen by sampled actions according to their likely worth; and by sampling transitions from the dynamics. Additionally,
bamcp also solves the requirement of integrating over models: by sampling models from
the belief distribution; but only only at the root node, so as to avoid the need to compute
posteriors throughout the tree; and by lazily avoiding realizing random choices until the
last possible moment.
The result is an efficient algorithm that outperforms previous Bayesian model-based
reinforcement learning algorithms by a significant margin on several well-known benchmark
problems, and that can scale to problems with an infinite state space and a complex prior
structure.
876

Bayes-Adaptive Monte-Carlo Planning

Acknowledgments
We acknowledge support for this project from the Gatsby Charitable Foundation (AG, PD),
the Natural Sciences and Engineering Research Council of Canada (AG), the Royal Society
(DS), and from the European Community‚Äôs Seventh Framework Programme (FP7/20072013) under grant agreement n‚ó¶ 270327 (DS).

Appendix A: List of Acronyms
BAMCP
BAMDP
BA-UCT
BEB
BEETLE
BFS3
BOLT
BOSS
FSSS
IEQL
MCMC
MCTS
MDP
PAC
POMCP
POMDP
RL
SBOSS
UCB1
UCT

Bayes-Adaptive Monte-Carlo Planner (Algorithm name)
Bayes-Adaptive Markov Decision Process
Bayes-Adaptive UCT (Algorithm name)
Bayesian Exploration Bonus (Algorithm name)
Bayesian Exploration Exploitation Tradeoff in LEarning (Algorithm name)
Bayesian Forward Search Sparse Sampling (Algorithm name)
Bayesian Optimistic Local Transitions (Algorithm name)
Best Of Sampled Set (Algorithm name)
Forward Search Sparse Sampling (Algorithm name)
Interval Estimation Q-learning (Algorithm name)
Monte-Carlo Markov Chain
Monte-Carlo Tree Search (Algorithm name)
Markov Decision Process
Probably Approximately Correct
Partially-Observable Monte-Carlo Planner (Algorithm name)
Partially Observable Markov Decision Process
Reinforcement Learning
Smarter Best Of Sampled Set (Algorithm name)
Upper Confidence Bound 1 (Algorithm name)
Upper Confidence bounds applied to Trees (Algorithm name)

Appendix B: Algorithms‚Äô Implementation
All algorithms below were implemented in C++ (code components were shared across algorithms as much as possible):
‚Ä¢ BAMCP - The algorithm presented in Section 3, implemented with root sampling,
lazy sampling, and rollout learning. The algorithm was run for different number of
simulations (10 to 10000) to span different planning times. In all experiments, we
set œÄro to be an -greedy policy with  = 0.5. The uct exploration constant was
left unchanged for all experiments (c = 3), we experimented with other values of
c ‚àà {0.5, 1, 5} with similar results.
‚Ä¢ SBOSS (Castro & Precup, 2010): for each domain, we varied the number of samples
K ‚àà {2, 4, 8, 16, 32} and the resampling threshold parameter Œ¥ ‚àà {3, 5, 7}.
‚Ä¢ BEB (Kolter & Ng, 2009): for each domain, we varied the bonus parameter Œ≤ ‚àà
{0.5, 1, 1.5, 2, 2.5, 3, 5, 10, 15, 20}.
877

Guez, Silver, & Dayan

‚Ä¢ BFS3 (Asmuth & Littman, 2011) for each domain, we varied the branching factor
C ‚àà {2, 5, 10, 15} and the number of simulations (10 to 2000). The depth of search
was set to 15 in all domains except for the larger grid and maze domain where it was
set to 50. We also tuned the Vmax parameter for each domain ‚Äî Vmin was always set
to 0.
Code for this paper can be found online on the first author‚Äôs website, or directly by
following this GitHub link https://github.com/acguez/bamcp.

Appendix C: Inference Details for the Infinite 2D Grid Task
We construct a Markov Chain using the Metropolis-Hastings algorithm to sample from the
posterior distribution of row and column parameters given observed transitions, following
the notation introduced in Section 4.2. Let O = {(i, j)} be the set of observed reward
locations, each associated with an observed reward rij ‚àà {0, 1}. The proposal distribution
chooses a row-column pair (ip , jp ) from O uniformly at random,
Pand samples pÃÉip ‚àº Beta(Œ±1 +
m1 , Œ≤1 + n1 ) and qÃÉjp ‚àº Beta(Œ±2 + m2 , Œ≤2 + n2 ), where m1 = (i,j)‚ààO
P 1i=ip rij (i.e., the sum
Œ≤
2
of rewards observed on that column) and n1 = (1 ‚àí /2(Œ±2 + Œ≤2 )) (i,j)‚ààO 1i=ip (1 ‚àí rij ), and
similarly for m2 , n2 (mutatis mutandis). The n1 term for the proposed column parameter
pÃÉi has this rough correction term, based on the prior mean failure of the row parameters,
to account for observed 0 rewards on the column due to potentially low row parameters.
Since the proposal is biased with respect to the true conditional distribution (from which we
cannot sample), we also prevent the proposal distribution from getting too peaked. Better
proposals (e.g., taking into account the sampled row parameters) could be devised, but
they would likely introduce additional computational cost and the proposal above generated
large enough acceptance probabilities (generally above 0.5 for our experiments). All other
parameters pi , qj such that i or j is present in O are kept from the last accepted samples
(i.e., pÃÉi = pi and qÃÉj = pj for these is and js), and all parameters pi , qj that are not linked to
observations are (lazily) resampled from the prior ‚Äî they do not influence the acceptance
probability. We denote by Q(p, q ‚Üí pÃÉ, qÃÉ) the probability of proposing the set of parameters
pÃÉ and qÃÉ from the last accepted sample of column/row parameters p and q. The acceptance
probability A can then be computed as A = min(1, A0 ) where:
P (pÃÉ, qÃÉ |h)Q(pÃÉ, qÃÉ ‚Üí p, q)
P (p, q |h)Q(p, q ‚Üí pÃÉ, qÃÉ)
P (pÃÉ, qÃÉ)Q(pÃÉ, qÃÉ ‚Üí p, q)P (h| pÃÉ, qÃÉ)
=
P (p, q)Q(p, q ‚Üí pÃÉ, qÃÉ)P (h| p, q)
Q
n1 m2
n2
rij
1‚àírij
1
pm
(i,j)‚ààO 1[i = ip or j = jp ](pÃÉi qÃÉj ) (1 ‚àí pÃÉi qÃÉj )
ip (1 ‚àí pip ) qjp (1 ‚àí qjp )
Q
= m1
2
rij
1‚àírij .
n2
pÃÉip (1 ‚àí pÃÉip )n1 qÃÉm
(i,j)‚ààO 1[i = ip or j = jp ](pi qj ) (1 ‚àí pi qj )
jp (1 ‚àí qÃÉjp )

A0 =

The last accepted sampled is employed whenever a sample is rejected. Finally, reward values
Rij are resampled lazily based on the last accepted sample of the parameters pi , qj , when
they have not been observed already. We omit the implicit deterministic mapping to obtain
the dynamics P from these parameters.
878

Bayes-Adaptive Monte-Carlo Planning

Appendix D: On the Existence of the Bayes-Optimal Policy
As described in Definition 1, Martin (1967) proves the following statement for mdps with
finite state spaces.
Theorem 3 (Martin, 1967, Thm. 3.2.1) Let v(s, h, œÄÃÉ) be the expected discounted return
in an mdp (with |S| and |A| finite) when the process starts from the augmented state hs, hi
and the EE policy œÄÃÉ is used. Let
v ‚àó (s, h) = sup v(s, h, œÄÃÉ).

(42)

œÄÃÉ‚ààŒ†ÃÉ

Then there is a policy œÄÃÉ ‚àó ‚àà Œ†ÃÉ such that v ‚àó (s, h) = v(s, h, œÄÃÉ ‚àó ).
The proof of Theorem 3 consists in proving that the set of EE policies Œ†ÃÉ can be mapped
into the a compact subset of the real line, and that the mapping of the function v(s, h, ¬∑)
is continuous on this set. The proof requires an ordering of histories that relies on the
finiteness of the state space. Let N = |S|, then the history ordering employed by Martin
(1967) is:
t0
X
st N ‚àít+1 ,
(43)
z(ht0 ) ‚â°
t=1

where z(h) is the number corresponding to history h in the order. In general |S| is not
finite, but in some scenarios we may bound by Nt the number of states the agent can be
in at time t (for example in the Infinite Grid scenario). For these scenarios we consider the
following ordering of histories:
0

w(ht0 ) ‚â°

t
X

st

t=1

t
Y

Nk‚àí1 ,

(44)

k=0

which reduces to w(h) = z(h) if Nt = N ‚àÄt. With this ordering, the proof of Theorem 3
can then be carried out as by Martin (1967) (with minimal modifications) to prove the
statement for these more general mdps - their state space is infinite but the possible states
of the agent grows in a controlled manner over time.
Although it is reassuring to know that the Bayes-optimal policy exists for these additional cases, in practice we are satisfied with  approximation to the Bayes-optimal policy
and the existence of -Bayes-optimal policies is likely to be guaranteed in even more general
scenarios.

879

Guez, Silver, & Dayan

References
Agrawal, S., & Goyal, N. (2011). Analysis of Thompson sampling for the multi-armed
bandit problem. Arxiv preprint.
Araya-LoÃÅpez, M., Buffet, O., & Thomas, V. (2012). Near-optimal BRL using optimistic
local transitions. In Proceedings of the 29th International Conference on Machine
Learning.
Asmuth, J., Li, L., Littman, M., Nouri, A., & Wingate, D. (2009). A Bayesian sampling
approach to exploration in reinforcement learning. In Proceedings of the Twenty-Fifth
Conference on Uncertainty in Artificial Intelligence, pp. 19‚Äì26.
Asmuth, J., & Littman, M. (2011). Approaching Bayes-optimality using Monte-Carlo tree
search. In Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence,
pp. 19‚Äì26.
Auer, P., Cesa-Bianchi, N., & Fischer, P. (2002). Finite-time analysis of the multiarmed
bandit problem. Machine learning, 47 (2), 235‚Äì256.
Bellman, R. (1954). The theory of dynamic programming. Bull. Amer. Math. Soc, 60 (6),
503‚Äì515.
Brafman, R., & Tennenholtz, M. (2003). R-max-a general polynomial time algorithm for
near-optimal reinforcement learning. The Journal of Machine Learning Research, 3,
213‚Äì231.
Bubeck, S., Munos, R., & Stoltz, G. (2009). Pure exploration in multi-armed bandits
problems. In Proceedings of the 20th international conference on Algorithmic learning
theory, pp. 23‚Äì37. Springer-Verlag.
Castro, P., & Precup, D. (2010). Smarter sampling in model-based Bayesian reinforcement
learning. In Machine Learning and Knowledge Discovery in Databases, pp. 200‚Äì214.
Springer.
Castro, P. (2007). Bayesian exploration in Markov decision processes. Ph.D. thesis, McGill
University.
Castro, P., & Precup, D. (2007). Using linear programming for Bayesian exploration in
Markov decision processes. In Proceedings of the 20th International Joint Conference
on Artificial Intelligence, pp. 2437‚Äì2442.
Coquelin, P., & Munos, R. (2007). Bandit algorithms for tree search. In Proceedings of the
23rd Conference on Uncertainty in Artificial Intelligence, pp. 67‚Äì74.
Cozzolino, J., Gonzalez-Zubieta, R., & Miller, R. (1965). Markov decision processes with
uncertain transition probabilities. Tech. rep., 11, Operations Research Center, MIT.
Davies, S., Ng, A., & Moore, A. (1998). Applying online search techniques to reinforcement
learning. In Proceedings of the National Conference on Artificial Intelligence, pp.
753‚Äì760.
Dayan, P., & Sejnowski, T. (1996). Exploration bonuses and dual control. Machine Learning,
25 (1), 5‚Äì22.
880

Bayes-Adaptive Monte-Carlo Planning

Dearden, R., Friedman, N., & Russell, S. (1998). Bayesian Q-learning. In Proceedings of
the National Conference on Artificial Intelligence, pp. 761‚Äì768.
Doshi-Velez, F., Wingate, D., Roy, N., & Tenenbaum, J. (2010). Nonparametric bayesian
policy priors for reinforcement learning. In Advances in Neural Information Processing
Systems (NIPS).
Duff, M. (2003). Design for an optimal probe. In Proceedings of the 20th International
Conference on Machine Learning, pp. 131‚Äì138.
Duff, M. (2002). Optimal Learning: Computational Procedures For Bayes-Adaptive Markov
Decision Processes. Ph.D. thesis, University of Massachusetts Amherst.
Fonteneau, R., Busoniu, L., & Munos, R. (2013). Optimistic planning for belief-augmented
Markov decision processes. In IEEE International Symposium on Adaptive Dynamic
Programming and reinforcement Learning (ADPRL 2013).
Friedman, N., & Singer, Y. (1999). Efficient Bayesian parameter estimation in large discrete
domains. Advances in Neural Information Processing Systems (NIPS), 1 (1), 417‚Äì423.
Gelly, S., Kocsis, L., Schoenauer, M., Sebag, M., Silver, D., SzepesvaÃÅri, C., & Teytaud, O.
(2012). The grand challenge of computer Go: Monte Carlo tree search and extensions.
Communications of the ACM, 55 (3), 106‚Äì113.
Gelly, S., & Silver, D. (2007). Combining online and offline knowledge in UCT. In Proceedings of the 24th International Conference on Machine learning, pp. 273‚Äì280.
Gittins, J., Weber, R., & Glazebrook, K. (1989). Multi-armed bandit allocation indices.
Wiley Online Library.
Guez, A., Silver, D., & Dayan, P. (2012). Efficient Bayes-adaptive reinforcement learning
using sample-based search. In Advances in Neural Information Processing Systems
(NIPS), pp. 1034‚Äì1042.
Hart, P., Nilsson, N., & Raphael, B. (1968). A formal basis for the heuristic determination
of minimum cost paths. Systems Science and Cybernetics, IEEE Transactions on,
4 (2), 100‚Äì107.
Jaksch, T., Ortner, R., & Auer, P. (2010). Near-optimal regret bounds for reinforcement
learning. The Journal of Machine Learning Research, 99, 1563‚Äì1600.
Kearns, M., Mansour, Y., & Ng, A. (1999). A sparse sampling algorithm for near-optimal
planning in large Markov decision processes. In Proceedings of the 16th international
joint conference on Artificial intelligence-Volume 2, pp. 1324‚Äì1331.
Kocsis, L., & SzepesvaÃÅri, C. (2006). Bandit based Monte-Carlo planning. In Machine
Learning: ECML, pp. 282‚Äì293. Springer.
Kolter, J., & Ng, A. (2009). Near-Bayesian exploration in polynomial time. In Proceedings
of the 26th Annual International Conference on Machine Learning, pp. 513‚Äì520.
Madani, O., Hanks, S., & Condon, A. (2003). On the undecidability of probabilistic planning
and related stochastic optimization problems. Artificial Intelligence, 147 (1), 5‚Äì34.
Martin, J. (1967). Bayesian decision problems and Markov chains. Wiley.
881

Guez, Silver, & Dayan

Meuleau, N., & Bourgine, P. (1999). Exploration of multi-state environments: Local measures and back-propagation of uncertainty. Machine Learning, 35 (2), 117‚Äì154.
Mundhenk, M., Goldsmith, J., Lusena, C., & Allender, E. (2000). Complexity of finitehorizon markov decision process problems. Journal of the ACM (JACM), 47 (4),
681‚Äì720.
Neal, R. M. (1993). Probabilistic inference using markov chain monte carlo methods. Tech.
rep., University of Toronto.
Poupart, P., Vlassis, N., Hoey, J., & Regan, K. (2006). An analytic solution to discrete
Bayesian reinforcement learning. In Proceedings of the 23rd international conference
on Machine learning, pp. 697‚Äì704. ACM.
Ross, S., Pineau, J., Chaib-draa, B., & Kreitmann, P. (2011). A Bayesian approach for
learning and planning in Partially Observable Markov Decision Processes. Journal of
Machine Learning Research, 12, 1729‚Äì1770.
Ross, S., Pineau, J., Paquet, S., & Chaib-Draa, B. (2008). Online planning algorithms for
POMDPs. Journal of Artificial Intelligence Research, 32 (1), 663‚Äì704.
Ross, S. (1983). Introduction to stochastic dynamic programming: Probability and mathematical. Academic Press, Inc.
Schmidhuber, J. (1991). Curious model-building control systems. In IEEE International
Joint Conference on Neural Networks, pp. 1458‚Äì1463.
Silver, D., & Veness, J. (2010). Monte-Carlo planning in large POMDPs. In Advances in
Neural Information Processing Systems (NIPS), pp. 2164‚Äì2172.
Silver, D., Sutton, R. S., & MuÃàller, M. (2008). Sample-based learning and search with
permanent and transient memories. In Proceedings of the 25th international conference
on Machine learning, pp. 968‚Äì975. ACM.
Silver, E. (1963). Markovian decision processes with uncertain transition probabilities or
rewards. Tech. rep., DTIC Document.
Strehl, A., Li, L., & Littman, M. (2009). Reinforcement learning in finite MDPs: PAC
analysis. The Journal of Machine Learning Research, 10, 2413‚Äì2444.
Strens, M. (2000). A Bayesian framework for reinforcement learning. In Proceedings of the
17th International Conference on Machine Learning, pp. 943‚Äì950.
Sutton, R. (1990). Integrated architectures for learning, planning, and reacting based on
approximating dynamic programming. In Proceedings of the Seventh International
Conference on Machine Learning, Vol. 216, p. 224. Citeseer.
Sutton, R., & Barto, A. (1998). Reinforcement learning. MIT Press.
SzepesvaÃÅri, C. (2010). Algorithms for reinforcement learning. Synthesis Lectures on Artificial Intelligence and Machine Learning. Morgan & Claypool Publishers.
Thompson, W. (1933). On the likelihood that one unknown probability exceeds another in
view of the evidence of two samples. Biometrika, 25 (3/4), 285‚Äì294.
Tonk, S., & Kappen, H. (2010). Optimal exploration as a symmetry breaking phenomenon.
Tech. rep., Radboud University Nijmegen.
882

Bayes-Adaptive Monte-Carlo Planning

Vien, N. A., & Ertel, W. (2012). Monte carlo tree search for bayesian reinforcement learning.
In Machine Learning and Applications (ICMLA), 2012 11th International Conference
on, Vol. 1, pp. 138‚Äì143. IEEE.
Walsh, T., Goschin, S., & Littman, M. (2010). Integrating sample-based planning and
model-based reinforcement learning. In Proceedings of the 24th Conference on Artificial Intelligence (AAAI).
Wang, T., Lizotte, D., Bowling, M., & Schuurmans, D. (2005). Bayesian sparse sampling
for on-line reward optimization. In Proceedings of the 22nd International Conference
on Machine learning, pp. 956‚Äì963.
Wang, Y., Won, K., Hsu, D., & Lee, W. (2012). Monte Carlo Bayesian reinforcement
learning. In Proceedings of the 29th International Conference on Machine Learning.
Watkins, C. (1989). Learning from delayed rewards. Ph.D. thesis, Cambridge.
Wingate, D., Goodman, N., Roy, D., Kaelbling, L., & Tenenbaum, J. (2011). Bayesian policy
search with policy priors. In Proceedings of the International Joint Conferences on
Artificial Intelligence.

883

Journal of ArtiÔ¨Åcial Intelligence Research 48 (2013) 783-812

Submitted 08/13; published 11/13

The Complexity of Optimal Monotonic Planning:
The Bad, The Good, and The Causal Graph
Carmel Domshlak
Anton Nazarenko

dcarmel@ie.technion.ac.il
anton.nazarenko@gmail.com

Faculty of Industrial Engineering & Management,
Technion - Israel Institute of Technology,
Haifa, Israel

Abstract
For almost two decades, monotonic, or ‚Äúdelete free,‚Äù relaxation has been one of the
key auxiliary tools in the practice of domain-independent deterministic planning. In the
particular contexts of both satisÔ¨Åcing and optimal planning, it underlies most state-of-theart heuristic functions. While satisÔ¨Åcing planning for monotonic tasks is polynomial-time,
optimal planning for monotonic tasks is NP-equivalent. Here we establish both negative and
positive results on the complexity of some wide fragments of optimal monotonic planning,
with the fragments being deÔ¨Åned around the causal graph topology. Our results shed some
light on the link between the complexity of general optimal planning and the complexity
of optimal planning for the respective monotonic relaxations.

1. Introduction
In domain-independent deterministic (or ‚Äúclassical‚Äù) planning, the world states are represented by complete assignments to a set of variables, the operators allow for deterministic
modiÔ¨Åcations of these assignments, and the objective is to Ô¨Ånd a sequence of operators that
sequentially modiÔ¨Åes a given initial assignment to an assignment that satisÔ¨Åes a certain
predeÔ¨Åned goal property. In the last two decades, solvers for this problem have made spectacular advances in their empirical eÔ¨Éciency, and this especially in the context of state-space
heuristic search planning techniques. This eÔ¨Éciency has been made possible largely by the
ability to exploit monotonic, or ‚Äúdelete-free,‚Äù relaxations of the planning tasks (McDermott,
1999; Bonet & GeÔ¨Äner, 2001; HoÔ¨Ämann & Nebel, 2001).
At a high level, monotonic relaxation replaces the regular value switching semantics of
planning operators with the value accumulating semantics. That is, if an operator switches
the value of a variable v from x to y, then the relaxed version of that operator ‚Äúextends‚Äù
the value of v from {x} to {x, y}. The key point here is that applying operators under value
accumulating semantics does not reduce the applicability of operators in the future. Two
properties of monotonic relaxation make it especially valuable to automated planning. First,
while deterministic planning is PSPACE-complete even for rather conservative propositional
formalisms, planning for monotonic tasks is polynomial-time (Bylander, 1994), and thus can
be exploited for deriving heuristic estimates. Second, in numerous problems of practical
interest, plans for monotonic relaxations are not that distant from the true plans for these
problems (HoÔ¨Ämann, 2005; Helmert & MattmuÃàller, 2007; Helmert & Domshlak, 2009; Bonet
& Helmert, 2010). Hence, starting from the seminal HSP (Bonet & GeÔ¨Äner, 2001) and
FF (HoÔ¨Ämann & Nebel, 2001) planning systems, exploiting, and in particular, explicitly
c
‚Éù2013
AI Access Foundation. All rights reserved.

Domshlak & Nazarenko

planning for, monotonic relaxations became an important ingredient of most systems for
domain-independent deterministic planning. (For a comprehensive survey, see, e.g., Betz &
Helmert, 2009.)
Ideally, a planner reasoning about the cost of the plans for monotonic relaxations should
reason about the cost of optimal plans for monotonic relaxations. Unfortunately, while
regular planning for monotonic tasks is polynomial-time, optimal planning for these tasks
is NP-equivalent (Bylander, 1994), and constant-factor approximations for this problem are
provably hard as well (Betz & Helmert, 2009). Still, admissible heuristic estimates can in
principle exploit tractable fragments of optimal planning for monotonic relaxations (Katz
& Domshlak, 2010). However, to the best of our knowledge, no substantial fragments of
tractability have been revealed for monotonic optimal planning to date.
Identifying signiÔ¨Åcant fragments of tractability for optimal monotonic planning is precisely our focus here. Our special interest is in establishing connections between the complexity of optimal planning and that of optimal planning for the monotonic relaxations of
the respective planning tasks. This interest is motivated by the new and important role
of methods that combine tractable fragments of regular deterministic planning with monotonic relaxation heuristics (Helmert, 2004; Keyder & GeÔ¨Äner, 2008a; Katz & Domshlak,
2010; Katz, HoÔ¨Ämann, & Domshlak, 2013a, 2013b; Katz & HoÔ¨Ämann, 2013). In turn, this
comparative perspective has brought us to consider planning tasks in terms of Ô¨Ånite-domain
representations that go beyond the standard propositional representation formalisms such
as STRIPS (Fikes & Nilsson, 1971) and ADL (Pednault, 1989). Some explanation, and
possibly even justiÔ¨Åcation, for this choice of analysis are in place here.
Due to their close relationship to Ô¨Årst-order and propositional logics, propositional representations have dominated the area of automated planning since the early days of AI research. For instance, the propositional PDDL language is still a de facto standard problem
description language in the planning community (Fox & Long, 2003). However, propositional languages blur a lot of important structure that is present in typical planning tasks of
interest. As we discuss later on, Ô¨Ånite-domain representations (FDR) that go beyond propositional state variables (BaÃàckstroÃàm & Klein, 1991; BaÃàckstroÃàm & Nebel, 1995; Helmert,
2009) allowed for much deeper and much more discriminative analysis of automated planning complexity. In turn, some of these formal developments have already been translated
into practical advances in planning, allowing for the introduction of eÔ¨Äective enhancements
of monotonic relaxation heuristics (Fox & Long, 2001; Helmert, 2004; Helmert & GeÔ¨Äner,
2008; Keyder & GeÔ¨Äner, 2008a; Cai, HoÔ¨Ämann, & Helmert, 2013; Katz et al., 2013a,
2013b), abstraction heuristics (Edelkamp, 2001; Helmert, Haslum, & HoÔ¨Ämann, 2007; Katz
& Domshlak, 2010), decomposition-based planning (Nissim, Brafman, & Domshlak, 2010;
Nissim & Brafman, 2012), search-topology analysis (HoÔ¨Ämann, 2011), and many others.
Nonetheless, under the value accumulating semantics of monotonic relaxation, FDR no
longer maintains its key advantage over propositional representations, because there no
longer seems to be any reason to prefer explicit representation of certain mutual exclusion
relationships between the propositions. Therefore, in principle, the results presented in
what follows can be phrased, and sometimes even extended, in the context of propositional
representations such as STRIPS. Why, then, have we chosen to view the complexity of
optimal relaxed planning through the lens of FDR? The primary reason is our interest in
comparative complexity analysis of optimal planning and optimal planning for the respective
784

The Complexity of Optimal Monotonic Planning

monotonic relaxations. Departing from previously discovered fragments of tractability for
both satisÔ¨Åcing and optimal planning, we approach the following two high-level questions:
1. For what fragments of deterministic planning, if any, is optimal planning hard but
optimal (monotonically) relaxed planning easy?
2. For what fragments of deterministic planning, if any, is optimal planning easy yet
optimal (monotonically) relaxed planning hard?
For regular planning, the best classiÔ¨Åcation we have these days for its worst-case time
complexity exploits the properties of some graphical structures induced by the planning
tasks, together with various properties of the FDR state variables such as the size of their
domains. Hence, discussing optimal relaxed planning for FDR tasks keeps us in direct
relation to that well-explored complexity map of regular deterministic planning. Moreover,
we show that some known links between the planning complexity and graph-topological
properties of the FDR tasks are even stronger in the case of optimal relaxed planning.
The second reason for our choice is that recent work has already revealed interesting
interplays between (either complete or partial) monotonic relaxation of Ô¨Ånite-domain variables and graphical structures induced by the FDR tasks. The respective results are in the
context of computational complexity of non-optimal planning (Katz et al., 2013b), heuristic estimates (Keyder & GeÔ¨Äner, 2008b; Katz et al., 2013a; Katz & HoÔ¨Ämann, 2013), and
search-topology analysis (HoÔ¨Ämann, 2011). For instance, HoÔ¨Ämann (2011) showed that, if
the causal graph of the FDR task is acyclic, and every variable transition is invertible, then
the h+ heuristic induced by optimal relaxed plans from the evaluated states has no local
minima. This result in particular testiÔ¨Åes that examining monotonic relaxations through
the lens of FDR can lead to some crisp and concisely formulated results. The same can
be found in our work here: While we show how some of our results can be easily reformulated, and sometimes even generalized, in terms of STRIPS, some of our other results do
not conform so easily to STRIPS reformulation.
Finally, while the immediate value of our results in this work is mostly theoretical, we
would like to see them as a step towards exploiting optimal relaxed planning to devise
heuristic functions for deterministic planning. Some of our results, such as Theorem 4, can
in fact be directly used within the framework of implicit abstractions (Katz & Domshlak,
2010), while some other results can possibly be exploited within various frameworks of
partial monotonic relaxation such as, e.g., the recent red-black planning framework of Katz
et al. (2013b, 2013a). To what extent this will actually happen remains, of course, to
be seen. However, the very focus of both implicit abstractions and red-black planning on
Ô¨Ånite-domain task representations should make it much easier to assess the relevance of our
results to these frameworks.

2. Formalism, Background, and Related Results
We use the notation [n] to refer to the set {1, . . . , n}. In directed graphs, the edge from x
to y is denoted by (x, y), and in undirected graphs, the edge between x and y is denoted by
{x, y}. By ||x|| we refer to the representation size of object x, not to be confused with |x|,
which denotes the number of elements in set x.
785

Domshlak & Nazarenko

2.1 FDR, MFDR, and Monotonic Relaxation
Here we adopt the terminology and notation of Katz et al. (2013b). A planning task
in Ô¨Ånite-domain representation (FDR) is given by a quintuple Œ† = ‚ü®V, A, I, G, cost‚ü©,
where:
‚Ä¢ V is a set of state variables, with each v ‚àà V being associated with a Ô¨Ånite domain
D(v). A partial variable assignment p is a function on a variable subset V(p) ‚äÜ V that
assigns each v ‚àà V(p) a value p[v] ‚àà D(v) of its domain. A partial variable assignment
s is called a state if V(s) = V .
‚Ä¢ I is an initial state. The goal G is a partial variable assignment to V .
‚Ä¢ A is a Ô¨Ånite set of actions. Each action a is a pair ‚ü®pre(a), eÔ¨Ä(a)‚ü© of partial variable
assignments to V called precondition and eÔ¨Äect, respectively.
‚Ä¢ cost : A ‚Üí R0+ is a real-valued, nonnegative action cost function.
Auxiliary notation:
‚Äî For a partial assignment p and a variable subset V ‚Ä≤ ‚äÜ V(p), by p[V ‚Ä≤ ] we denote the
assignment provided by p to V ‚Ä≤ . For ease of presentation, we sometimes also specify
partial assignments as sets of constructs v ‚Üê d, in which v ‚àà V and d ‚àà D(v).
‚Äî For a variable v ‚àà V , by Av ‚äÜ A we denote the actions aÔ¨Äecting the value of v, that
is, Av = {a | v ‚àà V(eÔ¨Ä(a))}. For a sequence of actions œÅ and a state variable v ‚àà V ,
by œÅ‚Üìv we denote the restriction of œÅ to the actions in Av .
The semantics of FDR tasks is as follows. An action a is applicable in a state s iÔ¨Ä
s[v] = pre(a)[v] for all v ‚àà V(pre(a)). Applying a in state s changes the value of every v ‚àà
V(eÔ¨Ä(a)) to eÔ¨Ä(a)[v]; the resulting state is denoted by sJaK. By sJ‚ü®a1 , . . . , ak ‚ü©K we denote the
state obtained from sequential application of the (respectively applicable) actions a1 , . . . , ak
starting at state s. Such an action sequence is an s-plan if sJ‚ü®a1 , . . . , ak ‚ü©K[V(G)] = G,
and it is an optimal s-plan if the sum of its action costs is minimal among all s-plans. The
computational task of (optimal) planning is Ô¨Ånding an (optimal) I-plan. In what follows,
(optimal) I-plans are often referred simply as (optimal) plans for Œ†.
A monotonic Ô¨Ånite-domain representation (MFDR) planning task is given by a
quintuple Œ† = ‚ü®V, A, I, G, cost‚ü© exactly as for FDR tasks, but the semantics is diÔ¨Äerent.1
Informally, in MFDR tasks the state variables accumulate their values, rather than switching
between them. More speciÔ¨Åcally, an MFDR state s is a function that assigns each v ‚àà V a
non-empty subset s[v] ‚äÜ D(v) of its domain. An MFDR action a is applicable in state s iÔ¨Ä
pre(a)[v] ‚àà s[v] for all v ‚àà V(pre(a)). Applying an MFDR action a in state s changes the
value of v ‚àà V(eÔ¨Ä(a)) from s[v] to s[v] ‚à™ {eÔ¨Ä(a)[v]}. Respectively, an MFDR action sequence
‚ü®a1 , . . . , ak ‚ü© applicable in state s is an s-plan if G[v] ‚àà sJ‚ü®a1 , . . . , ak ‚ü©K[v] for all v ‚àà V(G).
In all other respects, MFDR and FDR semantics are identical.
1. It is not entirely clear to whom the original formulation of monotonic relaxation for multi-valued variable
domains should be attributed, but it can be traced back at least to the work of Helmert (2006) on the
Fast Downward planning system.

786

The Complexity of Optimal Monotonic Planning

While FDR planning is PSPACE-complete even for propositional state variables, planning for MFDR tasks is polynomial time (Bylander, 1994). Starting with the HSP (Bonet
& GeÔ¨Äner, 2001) and FF (HoÔ¨Ämann & Nebel, 2001) planning systems, exploiting this attractive property of MFDR for deriving heuristic estimates via the notion of monotonic
relaxation became a key ingredient of many planning systems. Given an FDR planning task
Œ† = ‚ü®V, A, I, G‚ü©, the monotonic relaxation of Œ† is the MFDR task Œ†+ = Œ†. For any
state s of Œ†, the optimal relaxation heuristic h+ (s) is deÔ¨Åned to be the cost of the optimal
plan for the MFDR task ‚ü®V, A, s, G‚ü©, and by (optimal) relaxed planning for Œ† we refer
to (optimal) planning for Œ†+ . If œÅ+ is a plan for Œ†+ , then œÅ+ is referred to as a relaxed
plan for Œ†.
Finally, for both FDR and MFDR, we sometimes distinguish between planning tasks in
terms of a pair of standard graphical structures induced by the description of these tasks.
‚Ä¢ The causal graph CGŒ† of Œ† is a digraph over nodes V . An arc (v, v ‚Ä≤ ) is in CGŒ† iÔ¨Ä v Ã∏=
v ‚Ä≤ and there exists an action a ‚àà A such that (v, v ‚Ä≤ ) ‚àà V(eÔ¨Ä(a))‚à™V(pre(a))√óV(eÔ¨Ä(a)).
In this case, we say that (v, v ‚Ä≤ ) is induced by a. By succ(v) and pred(v) we respectively
denote the sets of immediate successors and predecessors of v in CGŒ† .
‚Ä¢ The domain transition graph DTG(v, Œ†) of a variable v ‚àà V is an arc-labeled
digraph over the nodes D(v) such that an arc (d, d‚Ä≤ ) labeled with pre(a)[V \ {v}]
and cost(a) belongs to the graph iÔ¨Ä both eÔ¨Ä(a)[v] = d‚Ä≤ , and either pre(a)[v] = d or
v Ã∏‚àà V(pre(a)).
2.2 Causal Graph Treewidth and Planning Complexity
Introduced by Halin (1976), tree-width went unnoticed until it was independently rediscovered by Robertson and Seymour (1984) and Arnborg, Cornell, and Proskurowski (1987). It
has since received widespread attention due to its numerous graph-theoretic and algorithmic
applications. Informally, the tree-width of a graph is a measure of how close the structure
of the graph is to a tree. For example, the tree-width of a tree is 1, regardless of its size,
whereas the tree-width of a complete graph over n nodes is n ‚àí 1. Formally, the tree-width
of a graph is deÔ¨Åned via the notion of tree decomposition as follows.
A tree decomposition of a connected undirected graph G = (V, E) is a pair ‚ü®T, Œ±‚ü©, where
T = (V T , E T ) is a tree, i.e., a connected acyclic graph, and Œ± : V T 7‚Üí 2V such that:
1. For every v ‚àà V , the set {t ‚àà V T | v ‚àà Œ±(t)} in T is non-empty and connected.
2. For every (v, u) ‚àà E there is a t ‚àà V T such that {v, u} ‚äÜ Œ±(t).
The width of a tree decomposition ‚ü®T, Œ±‚ü© of G is max{|Œ±(t)| | t ‚àà V T } ‚àí 1, and the treewidth of G, tw(G), is the minimum width over all tree decompositions of G. Following
what appears to be standard terminology, by tree-width of a digraph G we refer to the
tree-width of the undirected graph induced by G (Berwanger, Dawar, Hunter, Kreutzer, &
ObdzraÃÅlek, 2012).
With the development of parametrized complexity analysis (Downey & Fellows, 1999;
Flum & Grohe, 2006), it has been shown that many NP-hard problems can be solved in
polynomial time when restricted to induce certain problem-speciÔ¨Åc graphical structures
of a Ô¨Åxed tree-width. In particular, constraint satisfaction and constraint optimization
787

Domshlak & Nazarenko

problems over Ô¨Ånite-domain variables can be solved in time polynomial in the size of the
explicit description of these problems, and exponential only in the tree-width of the induced
constraint graph (Dechter, 2003). Since the causal graph captures a high-level structure
of the planning problems, one would expect its tree-width to play a similar role in the
worst-case time complexity of both satisÔ¨Åcing and optimal FDR planning. Unfortunately,
the results in this direction have mostly been negative.
‚Ä¢ Under a standard assumption on parametric complexity hierarchy that W[1] Ã∏‚äÜ nu-FPT
(Flum & Grohe, 2006), Chen and Gimenez (2010) proved that, for any family of
digraphs C, FDR planning for tasks inducing causal graphs in C is polynomial-time if
and only if the size of connected components in C is bounded by a constant. As the
family of all digraphs with tree-width of 1 trivially fails to satisfy the latter condition,
the immediate corollary of this result is that even satisÔ¨Åcing FDR planning restricted
to causal graphs with the tree-width of 1 is not polynomial.
‚Ä¢ While the construction in the proof of Chen and Gimenez (2010) uses FDR tasks
with variable domains of parametric size, the work of Gimenez and Jonsson (2009b)
shows that the negative result for causal graphs with the tree-width of 1 holds even if
restricted to such planning tasks with Ô¨Åxed variable domains. SpeciÔ¨Åcally, Gimenez
and Jonsson show that FDR planning over chain causal graphs is NP-hard even if
restricted to variables with domains of size 5.
These negative results on the role of the causal graph‚Äôs tree-width in computational
tractability of FDR planning are strong, but apparently tell only part of the story. As
shown by Brafman and Domshlak (2006, 2013), the causal graph‚Äôs tree-width does play
a role in the worst-case time complexity of FDR planning, but in a tight interplay with
another parameter called the task‚Äôs local depth. Informally, local depth of an FDR task Œ†
captures a minmax amount of work required on a single variable in order to solve Œ†. Since
later we refer to this result of Brafman and Domshlak, a precise speciÔ¨Åcation of local depth
is warranted here: denoting by P lans(Œ†) the (possibly inÔ¨Ånite) set of all plans for an FDR
task Œ†, the local depth of Œ† is
Œ¥Œ† =

min

max {|œÅ‚Üìv |},

œÅ‚ààP lans(Œ†) v‚ààV

that is, Œ¥Œ† is the maximal number of value changes of a single state variable, along a plan that
minimizes that quantity among the plans for Œ†. By Theorem 6 of Brafman and Domshlak
(2013), FDR tasks Œ† can be solved in time polynomial in ||Œ†|| and exponential only in
O(tw(CGŒ† ) ¬∑ Œ¥Œ† ). Up to some possible stratiÔ¨Åcations based on succinct representation of
internal variable domain dynamics, such as those suggested by Fabre, Jezequel, Haslum,
and ThieÃÅbaux (2010), this appears to be the strongest link discovered so far between the
complexity of general FDR planning and the graph-topological properties of the causal
graphs. Note also that this positive result applies only to satisÔ¨Åcing planning; it is applicable
to optimal planning only in very limited settings (Fabre et al., 2010; Brafman & Domshlak,
2013).
788

The Complexity of Optimal Monotonic Planning

3. Negative Results: The Bottleneck of Variable Domains
Our focus here is on connections between the worst-case time complexity of optimal relaxed
planning and the structure of the problems‚Äô causal graphs. Note that the causal graphs
of FDR tasks are trivially invariant under monotonic relaxation: since Œ†+ = Œ†, we have
CGŒ†+ = CGŒ† . As we just mentioned, previous works have already revealed certain connections between the structure of the causal graphs, and in particular its tree-width, and
the complexity of FDR planning. In what follows, we show that this link is even stronger
and somewhat more intriguing in the case of optimal relaxed planning. Having said that,
we begin with a set of negative results which, at least at Ô¨Årst glance, suggest that no such
link is actually likely.
DeÔ¨Ånition 1 A connected digraph G = (N, E) is a fork if it contains exactly one node
r ‚àà N with non-zero out-degree, that is, E = {(r, n) | n ‚àà N \ {r}}. Similarly, G is
an inverted fork if it contains exactly one node r ‚àà N with non-zero in-degree, that is,
E = {(n, r) | n ‚àà N \ {r}}. The respective special nodes r in fork and inverted-fork graphs
are called the roots of the graphs.
Considering FDR planning tasks with fork and inverted fork causal graphs, the Ô¨Årst
impression might be that these FDR fragments are restricted enough to allow for polynomialtime planning. This, however, is not the case: even non-optimal planning for FDR tasks
with such simple causal graphs is hard, and this even if all variables but the roots are further
restricted to be binary-valued (Domshlak & Dinitz, 2001). On the other hand, especially
since non-optimal relaxed planning for FDR is polynomial-time, these results have no direct
inÔ¨Çuence on the complexity of optimal relaxed planning for the respective FDR fragments.
Nonetheless, surprisingly or not, this problem is hard.
Theorem 1 Optimal relaxed planning is NP-equivalent even if restricted to FDR tasks
with fork and inverted-fork structured causal graphs. Moreover, the result holds even if all
state variables but the roots are restricted to binary domains.
Proof: The proof is by polynomial reductions from the NP-equivalent problems of (minimum) Directed Steiner Tree and (minimum) Set Cover (Karp, 1972).
Directed Steiner Tree: Given a digraph G = (N, E) with arc weights w : E ‚Üí R0+ , a
set of terminals Z ‚äÇ N , and a root vertex nr , Ô¨Ånd a minimum weight arborescence
(directed tree) T rooted in nr ‚àà N such that all terminals Z are included in T .
Set Cover: Given a collection C of subsets of a Ô¨Ånite set S, Ô¨Ånd a minimum cardinality
subset C ‚Ä≤ ‚äÜ C such that every element of S belongs to at least one member of C ‚Ä≤ .
Fragment I: Given a Directed Steiner Tree problem ‚ü®G = (N, E), w, Z, nr ‚ü©, the corresponding fork-structured FDR task Œ† = ‚ü®V, A, I, G, cost‚ü© is constructed as follows. The
variable set V contains a variable per terminal node in G, plus an extra variable r, that
is, V = {r} ‚à™ VZ where VZ = {vz | z ‚àà Z}. The domain of r, D(r) = N , corresponds
to the nodes of G, and all other variables are binary-valued, with D(vz ) = {0, 1}. In the
initial state, I[r] = nr and I[v] = 0 for all v ‚àà VZ . The goal is to achieve value 1 for all
v ‚àà VZ . For each arc e = (x, y) ‚àà E, the action set A contains a root-changing action
789

Domshlak & Nazarenko

ae with pre(ae ) = {r ‚Üê x}, eÔ¨Ä(ae ) = {r ‚Üê y}, and cost(ae ) = w(e). Likewise, for each
terminal z ‚àà Z, A contains a vz -changing action az with pre(az ) = {r ‚Üê z, vz ‚Üê 0},
eÔ¨Ä(az ) = {vz ‚Üê 1}, and cost(az ) = 0. This construction is clearly polynomial, the causal
graph of Œ† forms a fork rooted at r, and the variable domains in Œ† are as required by the
theorem. It also holds that:
(i) For any relaxed plan œÅ for Œ†, the set of arcs {e | ae ‚àà œÅ‚Üìr } in G induces a connected
sub-graph G ‚Ä≤ containing nr such that all terminals Z are included in G ‚Ä≤ (or otherwise
at least one of the leaf variables could not have been changed by œÅ to its goal value).
Likewise, there is a directed path in G ‚Ä≤ from nr to every other node n in G ‚Ä≤ (or
otherwise the respective value n of the root variable r could not have been achieved
along œÅ). Hence, in particular, G ‚Ä≤ contains an arborescence rooted in nr that includes
all terminals Z.
(ii) Vice versa, let T be an arborescence of G rooted in nr that includes all terminals
Z = {z1 , . . . , zm }, and let {e1 , . . . , ek } be a topological ordering of the arcs of T . Then
‚ü®ae1 , . . . , aek , az1 , . . . , azm ‚ü© is a relaxed plan for Œ†, and the cost of œÅ is precisely the
weight of T .
Hence, optimal relaxed plans for Œ† induce minimum directed Steiner trees for ‚ü®G = (N, E), w, Z, nr ‚ü©,
and vice versa.
Fragment II: Given a Set Cover problem ‚ü®S, C‚ü© with S = {1, 2, . . . , m} and |C| = n,
the corresponding inverted-fork structured FDR task Œ† = ‚ü®V, A, I, G, cost‚ü© is constructed as
follows. The variable set V contains a variable per member of C, plus an extra variable r,
that is, V = {r}‚à™{vc | c ‚àà C}. The domain of r is D(r) = {0}‚à™S, and all other variables are
binary-valued, with D(vc ) = {0, 1}. In the initial state, I[v] = 0 for all v ‚àà V . The goal is to
achieve value m for the special variable r. For i ‚àà S, and each subset c ‚àà C such that i ‚àà c,
the action set A contains a root-changing action ai;c with pre(ai;c ) = {r ‚Üê (i ‚àí 1), vc ‚Üê 1},
eÔ¨Ä(ai;c ) = {r ‚Üê i}, and cost(ai;c ) = 0. Likewise, for each c ‚àà C, A contains a vc -changing
action ac with pre(ac ) = {vc ‚Üê 0}, eÔ¨Ä(ac ) = {vc ‚Üê 1}, and cost(ac ) = 1. The construction
is polynomial, the causal graph of Œ† forms an inverted fork rooted at r, and the variable
domains in Œ† are as required by the theorem. Note that, due to the chain-like structure of
the domain transition graphs in Œ†, there is no diÔ¨Äerence between the plans for Œ† and for
Œ†+ , and it is easy to verify that any plan for Œ† induces a cover of S of the same cost, and
vice versa. Hence, optimal relaxed plans for Œ† induce minimum set covers for ‚ü®S, C‚ü©, and
vice versa.

Corollary 1 Optimal relaxed planning is NP-equivalent even if restricted to FDR tasks
with the causal-graph tree-width of 1.
This corollary is immediate from Theorem 1 as the undirected graphs induced by both
forks and inverted forks are a special case of trees and thus have tree-width of 1. At Ô¨Årst
glance, the message of Corollary 1 is discouraging with respect to our agenda: the structure
of the causal graphs does not seem to play a major role in the complexity of optimal
relaxed planning for FDR. Our next result, however, seems to be even more discouraging
with respect to the prospects of tractability of optimal relaxed planning for FDR.
790

The Complexity of Optimal Monotonic Planning

Theorem 2 Optimal relaxed planning is NP-equivalent even if restricted to FDR tasks
with two state variables.
Proof: The proof is by a polynomial reduction from the (minimum) directed Steiner tree
problem, and in fact, the proof is very similar to that of the fork case of Theorem 1. Given
a Directed Steiner Tree problem ‚ü®G = (N, E), w, Z, nr ‚ü© with Z = {z1 , . . . , zm }, we compile
it to an FDR task Œ† = ‚ü®{v1 , v2 }, A, I, G, cost‚ü© as follows. The domain of v1 corresponds
to the nodes of G, and the domain of v2 corresponds to the terminal nodes and the root
node, that is, D(v1 ) = N and D(v2 ) = Z ‚à™ {nr }. In the initial state, both I[v1 ] = nr and
I[v2 ] = nr , and the goal is to achieve value zm for v2 . For each arc e = (x, y) ‚àà E, the
action set A contains a v1 -changing action ae with pre(ae ) = {v1 ‚Üê x}, eÔ¨Ä(ae ) = {v1 ‚Üê y},
and cost(ae ) = w(e). Likewise, denoting nr by z0 , for 1 ‚â§ i ‚â§ m, A contains a v2 -changing
action azi with pre(azi ) = {v1 ‚Üê zi , v2 ‚Üê zi‚àí1 }, eÔ¨Ä(azi ) = {v2 ‚Üê zi }, and cost(azi ) = 0.
The construction is polynomial, and its correctness stems from analysis identical to that of
the proof of Theorem 1.

Theorem 2 shows that even the dimensionality of the FDR state spaces plays a secondary
role, if any, in the complexity of optimal relaxed planning. By that, however, it answers
one of the two macro-questions on our agenda:
Corollary 2 There exist fragments of FDR for which optimal planning is polynomial-time,
while optimal relaxed planning is NP-equivalent.
This corollary is immediate from Theorem 2 and polynomial-time solvability of optimal
planning for FDR tasks with a Ô¨Åxed number of state variables.

4. Positive Results I: State Variables with Fixed-Size Domains
Depending on the reader‚Äôs background and intuitions, Theorem 2 can either surprise or seem
somewhat predictable. In any case, it was Theorem 2 that led us to consider a diÔ¨Äerent
(and this time fruitful) fragmentation of optimal relaxed planning.
A closer look at Theorem 1 and Lemma 2 reveals that the size of the FDR variable
domains might be crucial in the complexity of optimal relaxed planning: While the proofs
of these two claims rely heavily on the parametric domain size of some of the state variables,
these proofs also imply that optimal relaxed planning is hard even if only a single FDR
variable comes with a parametric domain size. Departing from this observation, we now
show that, after all, the topology of the causal graph does play an interesting role in worstcase time complexity classiÔ¨Åcation of optimal relaxed planning for FDR tasks. In particular,
it turns out that bounding the tree-width of the causal graph by a constant is all it takes
to achieve polynomial-time optimal relaxed planning for FDR tasks with Ô¨Åxed-size variable
domains.
Theorem 3 For any family of directed graphs C, if the tree-width in C is bounded by a
constant, then optimal relaxed planning for FDR tasks with Ô¨Åxed-size variable domains and
causal graphs in C is polynomial-time.
791

Domshlak & Nazarenko

Proof: The proof of Theorem 3 is inspired by and closely resembles the approach of Brafman
and Domshlak (2013) discussed in Section 2.2. Given an FDR task Œ† = ‚ü®V, A, I, G, cost‚ü©,
we compile it into a constraint optimization problem COPŒ†+ = (X , Œ¶) over Ô¨Ånite-domain
variables X , functions Œ¶, and the global objective to minimize Œ£œÜ‚ààŒ¶ œÜ(X ). If Œ†+ is unsolvable, then all the assignments to X evaluate the objective function to ‚àû. Otherwise, the
optimum of the objective is obtained on and only on the assignments to X that correspond
to optimal plans for Œ†+ , that is, to optimal relaxed plans for Œ†.
Let |V | = n, ‚àÜ = maxv‚ààV |D(v)|, and recall that pred(v) for state variable v ‚àà V denotes
the set of v‚Äôs immediate predecessors in the causal graph.
‚Ä¢ For each state variable v ‚àà V , X contains a variable xv that represents the choice of a
subset of actions from Av to participate in the plan we are looking for. These possible
choices form the domain D(xv ) of xv , and each such choice is represented by a set of
size smaller or equal to ‚àÜ, with each element of that set being a quadruple
(d, id, a, t),
with d ‚àà D(v), id ‚àà {v} ‚à™ pred(v), t ‚àà {1, . . . , n‚àÜ}, and, if id = v, then a ‚àà {a‚Ä≤ ‚àà
Av | eÔ¨Ä(a‚Ä≤ )[v] = d} and otherwise a =‚ä•. At a high level, if we view state variables as
active decision makers, then d is a value that the relaxed variable v aims to achieve
and accumulate at time point t, either by itself using action a, or by delegating this
task to another variable id. As we show later on, no variable should accumulate more
than ‚àÜ values, and since the accumulated values are never lost, optimal plans for Œ†+
cannot be longer than n‚àÜ actions.
‚Ä¢ For each state variable v ‚àà V , Œ¶ contains a non-negative, extended real-valued function œÜv from D(xv ). Likewise, for each pair of state variables {v, w} such that the
causal graph CGŒ† contains either arc (v, w) or arc (w, v), Œ¶ contains an indicator
function œÜv,w : D(xv ) √ó D(xw ) ‚Üí {0, ‚àû}. To simplify the speciÔ¨Åcation of œÜv,w , we
deÔ¨Åne a set of auxiliary constraints as follows.
(S1) [Precondition Constraint] An assignment ‚ü®Œ∏v1 , . . . , Œ∏vn ‚ü© to X satisÔ¨Åes S1 iÔ¨Ä, for all
v ‚àà V , (d, v, a, t) ‚àà Œ∏v implies that, for each w ‚àà V(pre(a)),
pre(a)[w] ‚àà {I[w]} ‚à™ {d‚Ä≤ | (d‚Ä≤ , ¬∑, ¬∑, t‚Ä≤ ) ‚àà Œ∏w , t‚Ä≤ < t}.

(1)

(S2) [Delegation Constraint] An assignment ‚ü®Œ∏v1 , . . . , Œ∏vn ‚ü© to X satisÔ¨Åes S2 iÔ¨Ä, for all v ‚àà V ,
(d, w, ‚ä•, t) ‚àà Œ∏v implies that, for some a ‚àà Av ‚à© Aw with d ‚àà eÔ¨Ä(a)[v], (¬∑, w, a, t) ‚àà Œ∏w .
(S3) [Goal Achievement Constraint] An assignment ‚ü®Œ∏v1 , . . . , Œ∏vn ‚ü© to X satisÔ¨Åes S3 iÔ¨Ä, for
all v ‚àà V(G),
G[v] ‚àà {I[v]} ‚à™ {d | (d, ¬∑, ¬∑, ¬∑) ‚àà Œ∏v }.
(2)
Constraint S1 ensures that preconditions of actions to which a variable is committed
are provided on time. Constraint S2 ensures that the ‚Äúoutsourced‚Äù value achievements are
fulÔ¨Ålled at the required time points. Finally, constraint S3 simply veriÔ¨Åes that the value of
v induced by Œ∏v is a goal value. Importantly, S3 corresponds to a set of n unary constraints,
792

The Complexity of Optimal Monotonic Planning

and S1 and S2 can both be represented as a set of binary constraints over X . Given that,
functions Œ¶ are speciÔ¨Åed as
‚àë
œÜv (Œ∏v ) =
cost(a),
(¬∑,v,a,¬∑)‚ààŒ∏v

{
0, {Œ∏v , Œ∏w } satisÔ¨Åes S1(xv , xw ), S2(xv , xw ), S3(xv ) and S3(xw )
œÜv,w (Œ∏v , Œ∏w ) =
,
‚àû, otherwise

(3)

where S1(xv , xw ), S2(xv , xw ), and S3(xv ) correspond to the binary and unary constraints
induced respectively by S1, S2, and S3 on the COP variables xv and xw .
Let us now take a closer look at COPŒ†+ constructed as above for the problems in the
scope of Theorem 3.
(1) The constraint network of COPŒ†+ corresponds to the undirected graph induced by the
causal graph CGŒ†+ (= CGŒ† ). Hence, since the tree-width of the latter is bounded by
a constant by the scope of the theorem, so is the tree-width of the constraint network
of COPŒ†+ . While Ô¨Ånding an optimal tree decomposition of a graph G is NP-hard,
a tree decomposition of G with width c ¬∑ tw(G) for a low constant c can be found
in time polynomial in the size of G (Robertson & Seymour, 1991; Becker & Geiger,
1996; Amir, 2010). Hence, COPŒ†+ can be solved in time polynomial in the size of its
representation using the standard message-passing algorithm for constraint optimization
over trees (Dechter, 2003).
(2) Recall that the values of the COP variable xv are sets of quadruples (d, id, a, t) of size
‚â§ ‚àÜ. Then, the size of the xv ‚Äôs domain D(xv ) is upper-bounded by
(|D(v)| ¬∑ |{z}
n ¬∑ (|Av | + 1) ¬∑ (n‚àÜ))‚àÜ ,
| {z }
| {z } | {z }
d

id

a

(4)

t

and since ‚àÜ = O(1), we have |D(xv )| = O(poly(||Œ†||)). Together with (1), that implies
that COPŒ†+ can be solved in time O(poly(||Œ†||)).
We now prove the correctness of this compilation by showing that, if Œ†+ is unsolvable,
then all the assignments to X evaluate the objective function Œ£œÜ‚ààŒ¶ œÜ(X ) to ‚àû, and otherwise, the objective is minimized on and only on the assignments to X that correspond to
optimal plans for Œ†+ .
First, given an assignment Œ∏ = ‚ü®Œ∏v1 , . . . , Œ∏vn ‚ü© to X such that Œ£œÜ‚ààŒ¶ œÜ(Œ∏) < ‚àû, we show
that Œ∏ induces a valid plan œÅŒ∏ for Œ†+ of cost Œ£œÜ‚ààŒ¶ œÜ(Œ∏). Note that, since Œ£œÜ‚ààŒ¶ œÜ(Œ∏) < ‚àû,
by Eq. 3 we have Œ∏ satisfying constraints
S1-S3.
‚à™
Consider the multi-set Z = v‚ààV {(a, t) | (¬∑, v, a, t) ‚àà Œ∏v } induced by Œ∏, and let
Z = {(a1 , t1 ), . . . , (am , tm )}, m = |Z|,
be an arbitrary ordering of Z such that, for 1 ‚â§ j < i ‚â§ m, it holds that tj ‚â§ ti . For
1 ‚â§ i ‚â§ m, let v be the variable ‚Äúin charge of performing the action ai ‚Äù in Œ∏, that is,
(eÔ¨Ä(ai )[v], v, ai , ti ) ‚àà Œ∏v . For each w ‚àà V(pre(ai )), Eq. 1 in constraint S1 implies that either
pre(ai )[w] = I[w] or there is some (pre(ai )[w], id, a, t) ‚àà Œ∏w with t < ti . In the latter case,
793

Domshlak & Nazarenko

if id = w, then by the construction of œÅŒ∏ , a = aj for some j < i, and by the deÔ¨Ånition
of D(xw ), pre(ai )[w] = eÔ¨Ä(aj )[w]. Otherwise, if id = w‚Ä≤ for some w‚Ä≤ Ã∏= w, then by the
deÔ¨Ånition of S2, pre(ai )[w] = eÔ¨Ä(a‚Ä≤ )[w] for some (¬∑, w‚Ä≤ , a‚Ä≤ , t) ‚àà Œ∏w‚Ä≤ . Thus, a‚Ä≤ = aj for some
j < i, and pre(ai )[w] = eÔ¨Ä(aj )[w]. Therefore, the action sequence
œÅŒ∏ = ‚ü®a1 , . . . , am ‚ü©
is applicable in the initial state I of Œ†+ , and given that, Œ∏ satisfying S3 implies that œÅŒ∏
is a plan for Œ†+ . Finally, it is immediate from the construction of œÅŒ∏ and Eq. 3 that
cost(œÅŒ∏ ) = Œ£œÜ‚ààŒ¶ œÜ(Œ∏).
We now show that any optimal plan œÅ = ‚ü®a1 , . . . , am ‚ü© for Œ†+ induces an assignment
Œ∏œÅ = ‚ü®Œ∏v1 , . . . , Œ∏vn ‚ü© to X such that Œ£œÜ‚ààŒ¶ œÜ(Œ∏œÅ ) = cost(œÅ). By the deÔ¨Ånition of MFDR,
for 1 ‚â§ i ‚â§ m and for each state variable v ‚àà V , IJa1 , . . . , ai‚àí1 K[v] ‚äÜ IJa1 , . . . , ai K[v].
By optimality of œÅ, for 1 ‚â§ i ‚â§ m, there exists at least one variable v ‚àà V for which
IJa1 , . . . , ai‚àí1 K[v] ‚äÇ IJa1 , . . . , ai K[v]. In particular, that implies that actions {a1 , . . . , am }
are all diÔ¨Äerent, and for each variable v ‚àà V , if
‚ñ≥

œÅ/v = {ai | IJa1 , . . . , ai‚àí1 K[v] ‚äÇ IJa1 , . . . , ai K[v]},
then2 |œÅ/v| ‚â§ ‚àÜ.
Adopting an arbitrary ordering {v1 , . . . , vn } of the state variables V , for 1 ‚â§ j ‚â§ n, let
œÅ/vj = {aj1 , . . . , ajmj }. In turn, for 1 ‚â§ l ‚â§ mj , let djl ‚àà D(vj ) be the value achieved and
accumulated for vj by the action ajl , i.e., IJa1 , . . . , ajl K[vj ] \ IJa1 , . . . , ajl ‚àí1 K[vj ] = {djl }. For
‚à™
1 ‚â§ l ‚â§ mj , if ajl Ã∏‚àà j‚àí1
k=1 œÅ/vk , then Œ∏vj is set to contain (djl , vj , ajl , jl ), and otherwise, Œ∏vj
is set to contain (djl , vk , ‚ä•, jl ) for k = min {k ‚Ä≤ | ajl ‚àà œÅ/vk‚Ä≤ }.
By the construction of Œ∏œÅ , each action a from œÅ is present in the value of exactly one
variable xv , and by Eq. 3, œÜv (Œ∏v ) sums up the cost of a exactly once. Hence, if Œ∏œÅ satisÔ¨Åes
the constraints S1-S3 that are enforced by the step functions œÜv,w , we have Œ£œÜ‚ààŒ¶ œÜ(Œ∏œÅ ) =
cost(œÅ). The former also directly follows from the construction of Œ∏œÅ . For 1 ‚â§ j ‚â§ n,
mj
let Œ∏vj = {(djl , idjl , ajl , tjl )}l=1
. By the deÔ¨Ånition of the values djl as above, the set of
values {dj1 , . . . , djmj } is exactly the set of values of vj that gets accumulated by the relaxed
plan œÅ from I, and thus satisfaction of S3 follows from œÅ being a plan for Œ†+ . Again, by
the construction of Œ∏œÅ , the sequence of time points {tj1 , . . . , tjmj } corresponds to the time
points of the Ô¨Årst achievements of {dj1 , . . . , djmj }, respectively, along œÅ, and for each such
Ô¨Årst achiever ajl along œÅ, it is captured and properly scheduled either by Œ∏vi or by a neighbor
of vi in the causal graph. Hence, the constraints S1 and S2 are all satisÔ¨Åed as well. This
Ô¨Ånalizes the proof for the compilation correctness, and thus of Theorem 3.

Note that Theorem 3 in particular answers the second macro-question on our agenda:
Corollary 3 There exist fragments of FDR for which (even satisÔ¨Åcing) planning is NPequivalent, while optimal relaxed planning is polynomial-time.
2. That corresponds
to the well-known fact that, under our notation, optimal plans in MFDR cannot be
‚àë
longer than v‚ààV |D(v)| ‚â§ n‚àÜ.

794

The Complexity of Optimal Monotonic Planning

This corollary is immediate from Theorem 3 and the discovery of Gimenez and Jonsson
(2009b) that FDR planning over chain causal graphs is NP-hard even if restricted to variables
with domains of size 5.
Following our ‚ÄúSTRIPS vs. FDR‚Äù discussion in the introduction, Theorem 3 trivially
implies that optimal relaxed planning for STRIPS tasks Œ† can be done in time polynomial
in ||Œ†|| and exponential only in the tree-width of the causal graph. This is actually an
example of a tractability fragment for which one can only beneÔ¨Åt from switching to a
propositional representation: While the formulation of the result remains the same, the
coverage of the result grows because, if the size of the FDR variable domains is bounded by
‚àÜ = O(1), then the tree-width of the causal graph under STRIPS representation is at most
‚àÜ times larger than this under FDR. However, it can also be smaller, down to identical.
Later, however, we present some results that directly beneÔ¨Åt from the Ô¨Ånite-domain input
representation of the planning tasks.
Our discussion in the remainder of this section addresses the readers familiar with the
work of Brafman and Domshlak (2013) in detail. This discussion can be skipped without
any loss of continuity.
At Ô¨Årst view, the compilation in the proof of Theorem 3 brings to mind the compilation in the algorithm
v1
v2
vn
behind the proof of Theorem 6 of Brafman and Domshlak (2013). One might thus naturally ask whether that
algorithm cannot be used directly for the proof of our
Theorem 3. As it stands, however, the algorithm of
vn+1
Brafman and Domshlak does not yield polynomialtime complexity on those tasks with which Theorem 3
is concerned. To see why, consider an FDR task Œ† = ‚ü®V, A, I, G, cost‚ü© with V = {v1 , . . . , vn+1 },
where, for all vi , D(vi ) = {0, 1}, I[vi ] = 0, and G[vi ] = 1, and A = {a1 , . . . , an } with
V(pre(ai )) = ‚àÖ, V(eÔ¨Ä(ai )) = {vi , vn+1 }, and eÔ¨Ä(ai )[vi ] = eÔ¨Ä(ai )[vn+1 ] = 1. The causal graph
of Œ†, depicted above, has tree-width of 1. However, for any plan œÅ for Œ†+ , maxv‚ààV {|œÅ‚Üìv |} ‚â•
n, and the local depth Œ¥Œ†+ is n. This is because Œ†+ cannot be solved without applying each
of the n actions A at least once, and each of these actions aÔ¨Äects the value of the variable
vn+1 . Hence, Ô¨Ånding even a non-optimal plan for Œ†+ using the algorithm of Brafman and
Domshlak (2013) will take time exponential in ||Œ†||.
As a Ô¨Ånal note, it actually can be shown that the algorithm of Brafman and Domshlak
(2013) is optimal and polynomial-time on a sub-class of MFDR tasks like those in Theorem 3
but also restricted to single-eÔ¨Äect operators. It is multiple-eÔ¨Äect actions that complicate
matters, and require a diÔ¨Äerent algorithmic approach to guarantee planning tractability.

5. Positive Results II: M-unfoldable State Variables
Despite the discouraging results in Section 3, we now return to consider FDR tasks with
parametric-size domains. Recall that, while the variable values of monotonic relaxation Œ†+
correspond to sets of values of the respective variables in Œ†, these large variable domains in
Œ†+ are given implicitly, via the variable domains D(v1 ), . . . , D(vn ) of Œ†. This conciseness of
representation, however, hides many aspects of the problem structure in Œ†+ that otherwise
might have be exploited for planning eÔ¨Éciency. In particular, reasoning about the domain
795

Domshlak & Nazarenko

transition graphs induced by the FDR tasks has been successfully exploited in complexity
analysis of FDR (Jonsson & BaÃàckstroÃàm, 1998; Domshlak & Dinitz, 2001; Katz & Domshlak,
2008; Gimenez & Jonsson, 2009a). In contrast, in monotonic relaxations, the true domain
transition graphs of Œ†+ , denoted henceforth as DTG(v, Œ†+ ), cannot always be represented
explicitly because the number of nodes in these graphs is exponential in ||Œ†||. However,
this is not always, or does not always have to be, the case, and below we focus on planning
with such ‚Äúaccessible‚Äù monotonic variables.
DeÔ¨Ånition 2 Given an FDR planning task Œ† = ‚ü®V, A, I, G, cost‚ü©, the eÔ¨Äective domain
D‚äï (v) of v ‚àà V in Œ†+ consists of all value subsets œë ‚àà D+ (v) = 2D(v) \ ‚àÖ that are reachable
from {I[v]} in DTG(v, Œ†+ ). That is, œë ‚àà D‚äï (v) iÔ¨Ä
(i) I[v] ‚àà œë, and
(ii) for each value d ‚àà œë, there is a directed path from I[v] to d in the unlabeled digraph
induced by DTG(v, Œ†) such that all the values along that path belong to œë.
The elements of D‚äï (v) are called the eÔ¨Äective values of v in Œ†+ .
DeÔ¨Ånition 3 Let Œ† be an inÔ¨Ånite set of FDR tasks, and Œì be a property of state variables
that, for each task Œ† ‚àà Œ†, partitions the state variables of Œ† into those that satisfy Œì
(referred as Œì-variables), and those that do not satisfy Œì. We say that Œì-variables in Œ† are
monotonically unfoldable (M-unfoldable) if there exists an integer k ‚àà N such that,
for every task Œ† ‚àà Œ† and every Œì-variable v of Œ†, |D‚äï (v)| = O(||Œ†||k ).
Œì in DeÔ¨Ånition 3 can be any property of FDR state variables, and in particular, any
property deÔ¨Åned with respect to the tasks‚Äô causal graphs, such as ‚Äúroot,‚Äù ‚Äúsink,‚Äù ‚Äúnodes
whose causal graph in-degrees are larger than their causal graph out-degrees,‚Äù etc. Informally, Œì-variables of a set of FDR tasks Œ† are M-unfoldable if, for every task Œ† ‚àà Œ† and
every Œì-variable v of Œ†, the ‚Äúrelevant subgraph‚Äù of DTG(v, Œ†+ ) can be described explicitly
in space polynomial in the representation size of Œ†. For instance, v is trivially M-unfoldable
if the size of its domain in Œ† is bounded by a constant, or even by O(log(||Œ†||)). More generally, let DTG‚Ä† (v, Œ†) be the digraph obtained from the (labels ignored) domain transition
graph DTG(v, Œ†) by unifying parallel edges. It is not hard to verify from DeÔ¨Ånitions 2 and 3
that v is M-unfoldable if and only if the number of arborescence subgraphs of DTG‚Ä† (v, Œ†)
rooted in I[v], and covering G[v] if v ‚àà V(G), is O(poly(||Œ†||)).
We now return to consider fork-structured FDR tasks. While in Theorem 1 we considered
fork-structured FDR tasks with only root variables being unrestricted, we now consider an
‚Äúinverse‚Äù fragment, corresponding to fork-structured FDR tasks with only root variables
being restricted. Optimal FDR planning for such tasks is polynomial-time for |D(r)| =
2 (Katz & Domshlak, 2010), but it is NP-equivalent for |D(r)| > 2 (Katz & Keyder, 2012).
In contrast, Theorem 4 below shows that optimal relaxed planning for fork-structured FDR
tasks is polynomial-time for a much wider class of root variables. Moreover, a simple
observation behind the construction in the proof of Theorem 4 is later generalized to capture
a much richer fragment of causal graphs.
Theorem 4 Optimal relaxed planning is polynomial time for any set of FDR tasks Œ†
with fork-structured causal graphs and M-unfoldable root variables.
796

The Complexity of Optimal Monotonic Planning

Proof: Let Œ† = ‚ü®V, A, I, G, cost‚ü© be a fork-structured FDR task with root r and Vleafs =
V \ {r} = {v1 , . . . , vn }. We assume that goal values are speciÔ¨Åed for all variables in Vleafs ;
this is because none of the leaves in Vleafs \ V(G) need to change their value at all, and thus
they can be schematically removed from the problem. Given such a FDR task Œ†, an optimal
plan for its relaxation Œ†+ can be constructed as follows.
‚Ä¢ All the eÔ¨Äective values œë ‚àà D‚äï (r) consistent with the goal (that is, G[r] ‚àà œë if
r ‚àà V(G)) are processed one by one, independently. For each such eÔ¨Äective value œë,
we extract the following information.
(1) For the root variable r, we determine a cheapest path from I[r] to œë in DTG(r, Œ†+ ),
with œÄ(œë) denoting the action sequence inducing that path.
(2) For each leaf variable v ‚àà Vleafs , we
(a) schematically remove from the domain transition graph DTG(v, Œ†) all the
arcs labeled with actions a that are ‚Äúnot supported by œë‚Äù, that is, actions a
with r ‚àà V(pre(a)) and pre(a)[r] Ã∏‚àà œë, and then
(b) determine a cheapest path from I[v] to G[v] in that arc-reduced domain
transition graph, with œÄœë (G[v]) denoting the action sequence inducing that
path.
‚Ä¢ Return the concatenation of action sequences œÄ(œë‚àó ) ¬∑ œÄœë‚àó (G[v1 ]) ¬∑ . . . ¬∑ œÄœë‚àó (G[vn ]) where
[
]
n
‚àë
‚àó
cost(œÄœë (G[vi ])) ,
œë = argmin cost(œÄ(œë)) +
œë‚ààD‚äï (r)

i=1

and cost(œÄ) for an action sequence œÄ is the sum of the costs of actions along œÄ.
The algorithm is polynomial-time given an explicit description of the eÔ¨Äective part of
DTG(r, Œ†+ ), and thus it is polynomial-time if r is M-unfoldable. Recall that, since the
causal graph is acyclic, no action aÔ¨Äects more than one variable. The correctness of the
algorithm stems from a simple observation that, for any relaxed plan œÅ for a fork-structured
FDR task Œ†, œÅ‚Ä≤ = œÅ‚Üìr ¬∑ œÅ‚Üìv1 ¬∑ . . . ¬∑ œÅ‚Üìvn is also a relaxed plan for Œ†, and (trivially) of identical
cost. Hence, while searching for an optimal relaxed plan for Œ†, we can restrict ourselves to
plans of the latter form, and it is immediate from the description of the algorithm that it
Ô¨Ånds the cheapest such plan.

As an aside, following our ‚ÄúSTRIPS vs. FDR‚Äù discussion, note that Theorem 4 provides
an example for exploiting ‚Äúvalue grouping‚Äù induced by the FDR representation of the planning tasks. The simple algorithm in the proof exploits the fact that only the actions that
change the value of a leaf variable depend on its value, and this prevents restrictions from
being placed on either the size of the leaf domains, or on the structure of their domain
transition graphs. Of course, Theorem 4 can also be reformulated in terms of STRIPS, yet
this would require the respective partition of the propositions to be given/discovered, which
is essentially equivalent to starting with something like FDR input in the Ô¨Årst place.
While the scope of the tractability result in Theorem 4 is fairly limited in terms of
the causal graph structure, the nice property of the sets of optimal relaxed plans for forkstructured FDR tasks, exploited in the proof of Theorem 4, can be generalized to a much
797

Domshlak & Nazarenko

wider fragment of causal graphs. In turn, this generalization allows us to provide our next
tractability result for a wide fragment of optimal relaxed planning for FDR.
Lemma 1 Let Œ† = ‚ü®V, A, I, G, cost‚ü© be an FDR task with a directed acyclic causal graph,
and let {v1 , . . . , vn } be an arbitrary topological ordering of V with respect to CGŒ† . Then,
for any plan œÅ for Œ†+ , œÅ‚Ä≤ = œÅ‚Üìv1 ¬∑ . . . ¬∑ œÅ‚Üìvn is also a plan for Œ†+ .
Proof: Directed acyclicity of the causal graph in particular implies that no action aÔ¨Äects
more than one variable. The proof of the lemma stems from combining this property with
(i) the fact that œÅ‚Ä≤ preserves the order of the actions œÅ‚Üìvi as in œÅ, and (ii) the core property
of monotonic relaxations Œ†+ that, for any variable v, any value d ‚àà D(v), and any state s
of the relaxed task Œ†+ , if d ‚àà s[v], then d ‚àà s‚Ä≤ [v] for any s‚Ä≤ reachable from s in Œ†+ .
Since CGŒ† forms a DAG and the state variables are ordered according to a topological
ordering of CGŒ† , V(pre(a)[v1 ]) ‚äÜ {v1 } for all actions a ‚àà œÅ‚Üìv1 . Thus, order preservation of
œÅ‚Üìv1 along œÅ‚Ä≤ with respect to œÅ implies that œÅ‚Üìv1 is applicable in I, with IJœÅ‚Üìv1 K[v1 ] = IJœÅK[v1 ],
and IJœÅ‚Üìv1 K[vi ] = I[vi ] for i > 1. Assume now that, for i ‚â• 1, œÅ‚Üìv1 ¬∑ . . . ¬∑ œÅ‚Üìvi is applicable in
I, and
{
IJœÅK[vj ], j ‚â§ i
IJœÅ‚Üìv1 ¬∑ . . . ¬∑ œÅ‚Üìvi K[vj ] =
.
(5)
I[vj ],
j>i
Together with the topological ordering of V and order preservation of œÅ‚Üìvi +1 along œÅ‚Ä≤ with
respect to œÅ, Eq. 5 implies that œÅ‚Üìvi+1 is applicable in IJœÅ‚Üìv1 ¬∑ . . . ¬∑ œÅ‚Üìvi K, and
IJœÅ‚Üìv1

{
IJœÅK[vj ],
j =i+1
.
¬∑ . . . ¬∑ œÅ‚Üìvi KJœÅ‚Üìvi+1 K[vj ] =
IJœÅ‚Üìv1 ¬∑ . . . ¬∑ œÅ‚Üìvi K[vj ], otherwise

(6)

Putting Eqs. 5 and 6 together then proves the induction hypothesis, and for i = n, Eq. 5
boils down to
IJœÅ‚Ä≤ K = IJœÅ‚Üìv1 ¬∑ . . . ¬∑ œÅ‚Üìvn K = IJœÅK.

DeÔ¨Ånition 4 Let Œ† be an inÔ¨Ånite set of FDR tasks. We say that the tasks in Œ† are Munfoldable if all state variables in Œ† are M-unfoldable.
Theorem 5 Let Œ† be an inÔ¨Ånite set of M-unfoldable FDR tasks with directed acyclic causal
graphs. If both the tree-width and node in-degree of the causal graphs in Œ† are bounded by
a constant, then optimal relaxed planning for Œ† is polynomial-time.
Proof: Similarly to the proof of Theorem 3, the proof of Theorem 5 is based on a planningto-COP compilation. Given an FDR task Œ† = ‚ü®V, A, I, G, cost‚ü©, we compile its monotonic
relaxation Œ†+ into a constraint optimization problem COPŒ†+ = (X , Œ¶) over variables X ,
functions Œ¶, and the global objective to minimize Œ£œÜ‚ààŒ¶ œÜ(X ) such that, if Œ†+ is unsolvable,
then all the assignments to X evaluate the objective function to ‚àû, and otherwise, the
optimum of the objective is obtained on and only on the assignments to X that correspond
to optimal plans for Œ†+ . The speciÔ¨Åc construction of COPs here relies on the property of
monotonic relaxations of DAG-structured FDR tasks expressed by Lemma 1.
798

The Complexity of Optimal Monotonic Planning

Given an FDR task Œ† = ‚ü®V, A, I, G, cost‚ü© as in the theorem, COPŒ†+ = (X , Œ¶) is speciÔ¨Åed
as follows. For each state variable v ‚àà V ,
‚Ä¢ X contains a variable xv with domain D(xv ) = D‚äï (v), that is, the eÔ¨Äective domain
of v in Œ†+ , and
‚Ä¢ Œ¶ contains a non-negative, extended real-valued function œÜv over v and its immediate
ancestors in the causal graph, that is, over {xv } ‚à™ {xw | w ‚àà pred(v)}.
Assuming an arbitrary Ô¨Åxed ordering {w1 , . . . , wk } of v‚Äôs immediate ancestors pred(v), for
each œëpred ‚àà D‚äï (pred(v)) = D‚äï (w1 ) √ó ¬∑ ¬∑ ¬∑ √ó D‚äï (wk ), let DTG(v, Œ†+ |œëpred ) denote the
restriction of DTG(v, Œ†+ ) to only edges ‚Äúsupported by œëpred ‚Äù: an edge marked with an
action a remains in DTG(v, Œ†+ |œëpred ) if and only if, for each w ‚àà V(pre(a))\{v}, pre(a)[w] ‚àà
œëpred [w]. Given that, for each eÔ¨Äective value œë ‚àà D‚äï (v) and each œëpred ‚àà D‚äï (pred(v)),
œÜv (œë, œëpred ) = ‚àû if œë is not reachable from I[v] in DTG(v, Œ†+ |œëpred ), or if G[v] is speciÔ¨Åed
yet G[v] Ã∏‚àà œë. Otherwise, œÜv (œë, œëpred ) equals the cost of a cheapest path from I[v] to œë
in DTG(v, Œ†+ |œëpred ). In what follows, the action sequence inducing that cheapest path is
denoted by œÄ(œë|œëpred ).
The properties of COPŒ†+ constructed as above for the problems in the scope of Theorem 5 are as follows.
(1) The constraint network of COPŒ†+ corresponds to (the undirected graph induced by)
the moral graph of the causal graph CGŒ† . Since both in-degree and tree-width of CGŒ†
are bounded by a constant, then so is the tree-width œâCOP of the constraint network. As
we mentioned before, given a graph G, a tree decomposition of a graph G with width
c ¬∑ tw(G) for a low constant c can be found in time polynomial in the size of G and
exponential only in tw(G). Hence, since œâCOP = O(1), COPŒ†+ can be solved in time
polynomial in the size of its explicit representation.
(2) Since Œ† is M-unfoldable, the domain size of each COP variable is O(poly(||Œ†||)). Together with (1), that implies that COPŒ†+ can be solved in time O(poly(||Œ†||)).
(3) By the deÔ¨Ånitions of monotonic relaxation and of domain transition graphs, explicit
description of all DTG(v, Œ†+ ) for an M-unfoldable FDR task Œ† is polynomial in ||Œ†||.
Hence, the construction of functional components Œ¶, and thus of the entire COPŒ†+ , can
be done in time O(poly(||Œ†||)).
(4) By the construction of COPŒ†+ and Lemma 1, for any topological ordering {v1 , . . . , vn }
of V , every complete assignment Œ∏ to the COP variables X such that
‚àë
œÜv (Œ∏[v], Œ∏[pred(v)]) = Œ± Ã∏= ‚àû
v‚ààV

induces a relaxed plan
œÄ(Œ∏[v1 ]|Œ∏[pred(v1 )]) ¬∑ . . . ¬∑ œÄ(Œ∏[vn ]|Œ∏[pred(vn )])
of cost Œ± for Œ†, and vice versa. Thus, if Œ†+ is solvable, then, given an assignment Œ∏ ‚àó
to X on which the minimization objective of COPŒ†+ is obtained, we can derive from it
(in O(poly(||Œ†||)) time) an optimal relaxed plan for Œ†. Otherwise, if Œ†+ is unsolvable,
then all the assignments to X evaluate the objective function to ‚àû.
799

Domshlak & Nazarenko

ONML
HIJK
v1


HIJK
ONML
v2


HIJK
ONML
v3

/ d1,2

d1,1
d1,1

d2,1

d1,2
d1,3

d2,2
d2,3

ONML
HIJK
HIJK
HIJK
/ ONML
/ ONML
o
d1,1 Qo Q
d1,3
d
BB QQQ | 1,2 BB
mm|
m
m
BB Q|Q|Q
B
|
m
m
BB|| QQQmmmmBBB|||
|B
mmQQQQ ||BB
|| BBmmm
Q| B
 }|||mmmmm BB!  }||| QQQQQBB! 
mv
(
HIJK
ONML
HIJK
HIJK
/ ONML
o
/ ONML
d2,1 Qo Q
d
d2,3
m
BB QQQ | 2,2 BB
m
m
|
m
BB Q|Q|Q
B
|
m
m
BB|| QQQmmmmBBB|||
|B
mmQQQQ ||BB
|| BBmmm
Q| B
 }|||mmmmm BB!  }||| QQQQQBB! 
mv
(
HIJK
ONML
HIJK
HIJK
/ ONML
/ ONML
d3,1 o
d3,2 o
d3,3

d1,1

#

/ d2,2
;

d2,1

d3,1

/ d1,3

d1,2
d1,3

#
/ d2,3
;

d2,1

#

/ d3,2
;

d2,2
d2,3

#
/ d3,3
;

(a)

(b)

Figure 1: Illustration for the example used in the discussion of Theorem 5.
This Ô¨Ånalizes the proof of Theorem 5, and Corollary 4 below generalizes it to digraphs that
are ‚Äúalmost DAGs.‚Äù

Note that Theorem 5 provides yet another example of exploiting ‚Äúvalue grouping‚Äù induced by the FDR representation of the planning tasks. Consider a planning task family
Œ†(n) = ‚ü®V, A, I, G, cost‚ü© in which V = {v1 , . . . , vn }; for 1 ‚â§ i ‚â§ n, D(vi ) = {di,1 , . . . , di,n };
I[vi ] = di,1 ; G[vi ] = di,n ; and actions
‚à™
A=
{ai,k,j = ‚ü®{vi ‚Üê di,k , vi‚àí1 ‚Üê di‚àí1,j }, {vi ‚Üê di,k+1 }‚ü©}.
|
{z
} |
{z
}
1‚â§i,j‚â§n
1‚â§k‚â§n‚àí1

pre

eÔ¨Ä

Figure 1a illustrates the causal graph and the domain transition graphs for the task Œ†(3) .
The causal graphs in Œ†(n) form directed chains, and thus both the tree-width and node
in-degree of the causal graphs in Œ†(n) equal 1. Likewise, the eÔ¨Äective domain D‚äï (vi ) of
each vi in Œ†+
(n) is of size n, and thus the tractability of optimal relaxed planning for Œ†(n)
is directly covered by Theorem 5. In contrast, if each variable value di,j is represented by
a separate propositional variable, inducing the causal graph as in Figure 1b, then both the
tree-width and node in-degree in the family of the induced causal graphs are of the order
of n, and in fact, the causal graph is not even acyclic. Therefore, Theorem 5 is no longer
directly applicable.
Corollary 4 Let Œ† be an inÔ¨Ånite set of M-unfoldable FDR tasks. If the size of the strongly
connected components, the tree-width, and the node in-degree of the causal graphs in Œ† are
all bounded by a constant, then optimal relaxed planning for Œ† is polynomial-time.
Proof: Any FDR task Œ† with a causal graph whose strongly connected components (SCCs)
are of size at most k can be compiled into an equivalent FDR task Œ†m with a directed acyclic
causal graph by merging the variables of each SCC into a single variable (Seipp & Helmert,
2011). This compilation can be done in time polynomial in ||Œ†|| and exponential only in k.
The causal graph CGŒ†m is obtained from the causal graph CGŒ† by contracting all nodes of
each SCC. Since node contraction can only decrease the tree-width, we have tw(CGŒ†m ) ‚â§
800

The Complexity of Optimal Monotonic Planning

tw(CGŒ† ), and thus tw(CGŒ†m ) = O(1). Likewise, if the maximal node in-degree in CGŒ†
is c, then the maximal node in-degree in CGŒ†m is ck, and thus it is also O(1). Finally,
the domain of a variable u in Œ†m that is obtained by merging some Œ†‚Äôs SCC {v1u , . . . , vku‚Ä≤ },
k ‚Ä≤ ‚â§ k, corresponds to the cross-product of the domains of these SCC‚Äôs variables. It is
easy to verify from DeÔ¨Ånition 2 that D‚äï (u) ‚äÜ D‚äï (v1u ) √ó ¬∑ ¬∑ ¬∑ √ó D‚äï (vku‚Ä≤ ), and thus, together
with k = O(1), M-unfoldability of all v1u , . . . , vku‚Ä≤ implies |D‚äï (u)| = O(poly(||Œ†||)), Ô¨Åtting3
DeÔ¨Ånition 3.

Returning now to the statement of Theorem 5, a few comments on its extensions beyond
Corollary 4 are in place. First, note that Theorem 5 as it is does not generalize Theorem 4 for
fork-structured FDR tasks because the latter allows for general, and not only M-unfoldable,
leaf variables. However, it is easy to see that Theorem 5 can be stratiÔ¨Åed to allow for
such generalization. Since no other variable depends on a leaf v, all we care about in v is
achieving G[v]. Thus, for any optimal relaxed plan œÅ, œÅ‚Üìv induces a simple path, and not a
general arborescence, in DTG(v, Œ†). Hence, using binary-valued (‚ÄúG[v] achieved: yes/no‚Äù)
COP variables xv for the DAG leaf v, and specifying the respective functions œÜv using the
procedure in the proof of Theorem 4, the scope of Theorem 5 is extended to generalize
Theorem 4.
Second, in the case of DAG-structured causal graphs, DeÔ¨Ånition 2 of eÔ¨Äective domains,
on which the notion of M-unfoldability is based, is overly conservative. Instead of deriving
the eÔ¨Äective domains for the variables in isolation, we can derive them in a topological order
of the causal graph, given the already derived eÔ¨Äective domains of the immediate ancestors.
In speciÔ¨Åc domains, this can substantially extend the scope of M-unfoldability for FDR tasks
with DAG causal graphs.
Finally, Theorem 5 requires not only the tree-width, but also the in-degree of the causal
graph to be bounded by a constant. As such an extra condition, the latter is suÔ¨Écient,
but not necessary. Below, under the notion of prevail decomposability, we list two local
properties of state variables that guarantee polynomial-time optimal relaxed planning on
arbitrary acyclic causal graphs with a Ô¨Åxed tree-width. It is very likely that other such
helpful properties exist, and thus the boundaries of prevail decomposability can be further
extended. Nicely, optimal relaxed planning will remain polynomial-time even if diÔ¨Äerent
state variables satisfy diÔ¨Äerent such properties, and even if some state variables are not
prevail decomposable, but have Ô¨Åxed in-degree.
DeÔ¨Ånition 5 Let Œ† be an inÔ¨Ånite set of FDR tasks, and Œì be a property of state variables
that, for each task Œ† ‚àà Œ†, partitions the state variables of Œ† into those that satisfy Œì
(referred as Œì-variables), and those that do not satisfy Œì. We say that Œì-variables in Œ† are
prevail decomposable if, for every task Œ† ‚àà Œ† and every Œì-variable v of Œ†, either
(i) the set PRv = {pre(a)[pred(v)] | a ‚àà Av } of preconditions of actions Av on variables
other than v is of size O(log(||Œ†||)), or
3. Note that it is possible that D‚äï (u) ‚äÇ D‚äï (v1u )√ó¬∑ ¬∑ ¬∑√óD ‚äï (vku‚Ä≤ ). For instance, if V = {x, y}, D(x) = D(y) =
{0, 1}, I = {x ‚Üê 0, y ‚Üê 0}, G = {x ‚Üê 1, y ‚Üê 1}, and A = {‚ü®{x ‚Üê 0, y ‚Üê 1}, {x ‚Üê 1}‚ü©, ‚ü®{y ‚Üê 0, x ‚Üê
1}, {y ‚Üê 1}‚ü©}, then D‚äï (x) = {{0}, {0, 1}}, D‚äï (y) = {{0}, {0, 1}}, but D‚äï (xy) = {{x ‚Üê 0, y ‚Üê 0}}. In
fact, this example can be easily extended so that the ‚Äúmerged‚Äù variable xy is M-unfoldable, while both
x and y are not.

801

Domshlak & Nazarenko

(ii) the set ARBv of arborescence subgraphs of DTG(v, Œ†) rooted in I[v], and covering G[v]
if v ‚àà V(G), is of size O(log(||Œ†||)).
We say that the tasks in Œ† are prevail decomposable if all state variables in Œ† are
prevail decomposable.
Note that prevail decomposability of type (i) is tangential to the notion of M-unfoldability:
neither does the former imply the latter, nor the other way around. In contrast, prevail
decomposability of type (ii) is a direct stratiÔ¨Åcation of M-unfoldability because the latter
considers a compacted version DTG‚Ä† (v, Œ†) of DTG(v, Œ†), and furthermore, allows for a
polynomial (rather than logarithmic) bound on the number of arborescence subgraphs.
Theorem 6 Let Œ† be an inÔ¨Ånite set of M-unfoldable, prevail decomposable FDR tasks with
directed acyclic causal graphs. If the tree-width of the causal graphs in Œ† is bounded by a
constant, then optimal relaxed planning for Œ† is polynomial-time.
Proof: Here as well, our proof of Theorem 6 follows the planning-to-COP compilation
methodology. However, the compilation under prevail decomposability must diÔ¨Äer from the
one in the proof of Theorem 5 since we can no longer rely on Ô¨Åxed in-degree of the causal
graphs to derive the Ô¨Åxed tree-width of the constraint networks from the Ô¨Åxed tree-width
of the causal graphs. For ease of presentation, we Ô¨Årst specify the compilation assuming
all the state variables satisfy the speciÔ¨Åc condition (i) of DeÔ¨Ånition 5. We then extend the
speciÔ¨Åcation to cover the alternative condition (ii) of DeÔ¨Ånition 5 as well.
For our construction we need to establish a certain graph-theoretic formalism and a
respective notation. Let G = (V, E) be a graph, and let N : V ‚Üí 2V be the node neighborhood function of G, that is, N (v) = {u | {v, u} ‚àà E}. The splitting of v ‚àà V with
the support S ‚äÜ N (v) transforms G by adding new vertex v ‚Ä≤ and edge {v, v ‚Ä≤ }, and, for all
u ‚àà S, removing edge {v, u} and adding edge {v ‚Ä≤ , u}. Informally, splitting can be seen as
a (non-unique) reverse process to edge contraction, and the nodes added to G by splittings
are called stretch nodes. For example, Figure 2b depicts the graph obtained from the graph
in Figure 2a by splitting the node v with the support of {x, y, u} ‚äÇ N (v) = {x, y, u, w},
adding a stretch node v(1) .
A graph G ‚àó is an expansion of G if G can be transformed to G ‚àó by a sequence of splittings.
For example, Figure 2c depicts the graph obtained from the graph in Figure 2a by Ô¨Årst
splitting the node v with the support of {x, y} ‚äÇ N (v) = {x, y, u, w}, and then splitting v
with the support of {u, w} ‚äÇ N (v) = {v(1) , u, w}. More speciÔ¨Åcally, G ‚àó = (V ‚àó , E ‚àó ) is an
expansion of G = (V, E) if and only iÔ¨Ä there exist functions f : V ‚àó ‚Üí V and g : E ‚Üí E ‚àó
such that
(a) For v ‚àà V , the subgraph of G ‚àó induced by f ‚àí1 (v) = {v ‚Ä≤ ‚àà V ‚àó | f (v ‚Ä≤ ) = v} is a tree, and
(b) For {v, u} ‚àà E, if g({v, u}) = {v ‚Ä≤ , u‚Ä≤ } then f (v ‚Ä≤ ) = v and f (u‚Ä≤ ) = u.
The tree subgraph T ‚àó (v) of G ‚àó induced by f ‚àí1 (v) is called the stretch tree of v. There is a
bijective correspondence between the leaves of T ‚àó (v) and the neighbors N (v) of v via the
function g: for each {v, u} ‚àà E, there is exactly one edge in E ‚àó , g({v, u}), that directly
connects between T ‚àó (v) and T ‚àó (u). In other words, f induces a partition of V ‚àó , with each
part being the stretch tree T ‚àó (v) for some v ‚àà V , and g maps the edges of G to those edges
802

The Complexity of Optimal Monotonic Planning

x-

y

-
-- 
- 
v/
  ///
//



u

w

(a)

x






v(1)

y

y

x ==

==

v(1)
v

x(1)

v

w

u(1)

@@
@

u

(b)

v(1)

y(1)

v

v(2)
u

y

x

w

(c)

v(2)

u

w(1)
w

(d)

Figure 2: Node splitting and graph expansions.
of G ‚àó that connect between the parts of this partition. Finally, if the node degree in G ‚àó
is bounded by 3, then G ‚àó is called sub-cubic. For example, the expansion in Figure 2c is
sub-cubic, while the expansion in Figure 2b is not.
The above terminology is mostly adopted from Markov and Shi (2011). In addition, we
call an expansion G ‚àó of G fully separating if the stretch trees in G ‚àó are connected only at
the stretch nodes, and not at the original nodes, of G. That is, G ‚àó = (V ‚àó , E ‚àó ) is a fully
separating expansion of G = (V, E) if there exists a function œÑ : V ‚Üí V ‚àó such that, for each
v ‚àà V , it holds that œÑ (v) ‚àà f ‚àí1 (v) and, for each edge {œÑ (v), v ‚Ä≤ } ‚àà E ‚àó , v ‚Ä≤ ‚àà f ‚àí1 (v). For
example, the expansion in Figure 2c is not fully separating, while the expansion in Figure 2d
is.4
Given the above notion of graph expansion, if we now have a problem to be solved on a
graph G, and eÔ¨Éciency of solving this problem depends badly, possibly exponentially, on the
node degree in G, then we can try to reformulate this problem over a sub-cubic expansion
G ‚àó of G. However, if the eÔ¨Éciency of the problem in question also depends badly on the
graph‚Äôs tree-width, then the tree-width of G ‚àó should be as close as possible to that of G.
(The tree-width of G ‚àó cannot be smaller than the tree-width of G because G ‚àó has G as a
minor.) While there are numerous eÔ¨Écient schemes for sub-cubic graph expansion, most
of them can create expansions of arbitrarily larger tree-width than that of their expandees.
Recently, however, Markov and Shi (2011) showed that this negative side-eÔ¨Äect can always
be eliminated, and sometimes even eÔ¨Éciently.
Theorem 3.1 of Markov and Shi (2011) states their main result: there is a polynomialtime algorithm that, given a graph G and its tree decomposition of width w, computes a
sub-cubic expansion G ‚àó of G with tw(G ‚àó ) ‚â§ w + 1. In particular, this result implies that
any graph G admits a sub-cubic expansion whose tree-width is no more than tw(G) + 1, and
that this expansion can be constructed eÔ¨Éciently for arbitrary graph families with a Ô¨Åxed
4. Without any eÔ¨Äective loss of generality, one can assume that œÑ (v) = v, that is, the nodes in V are never
mapped to stretch nodes, but only to their ‚Äúmirrors‚Äù in V ‚àó . However, here we decided to stick to the
explicit use of the œÑ function to avoid confusion between the nodes V and the identically named nodes
in V ‚àó .

803

Domshlak & Nazarenko

tree-width.5 Moreover, it is straightforward to verify that any expansion can be transformed
in linear time into a fully separating expansion, without increasing the tree-width and node
degrees. Therefore, Theorem 3.1 of Markov and Shi (2011) holds even if we request fully
separating sub-cubic expansions.6
Our COP compilation exploits such ‚Äútree-width friendly‚Äù expansions of causal graphs.
Since our focus in Theorem 5 is on digraph families C with the tree-width in C being
bounded by a constant, by Theorem 3.1 of Markov and Shi (2011), any digraph G ‚àà C
can be eÔ¨Éciently associated with a fully separating sub-cubic expansion G ‚àó with tree-width
‚â§ tw(G) + 1. Note, however, that the construction of G ‚àó ignores the orientation of the arcs
in G: while G is a digraph, G ‚àó is an undirected graph, and its construction is based on a
tree decomposition of the undirected graph induced by G. Since our COP compilation does
depend on the direction of the arcs in the causal graph, we will have to restore in G ‚àó the
relevant bits of this information about G.
But Ô¨Årst we give some auxiliary notation.
‚Ä¢ Given a fully separating expansion G ‚àó of (the undirected graph induced by) a digraph
G = (V, E), we consider stretch trees T ‚àó (v) as if rooted in the respective nodes œÑ (v),
and by Tv‚àó‚Ä≤ (v) we denote the subtree of T ‚àó (v) rooted at v ‚Ä≤ ‚àà T ‚àó (v).
‚Ä¢ Recalling that the graphs G of our interest here are DAGs, and that the leaves of T ‚àó (v)
are bijectively associated with the neighbors N (v) of v in G, let N in (v), N out (v) ‚äÜ
N (v) be the partition of v‚Äôs neighbors in G into immediate ancestors and immediate
descendants of v, respectively.
out (v) we denote the respective neighbors of
‚Ä¢ By Nvin‚Ä≤ (v) ‚äÜ N in (v) and Nvout
‚Ä≤ (v) ‚äÜ N
v that are associated with the leaves of the stretch subtree Tv‚àó‚Ä≤ (v). That is, we have
‚Ä≤‚Ä≤ of T ‚àó (v) and some u‚Ä≤‚Ä≤ ‚àà T ‚àó (u),
u ‚àà Nvin‚Ä≤ (v) ‚à™ Nvout
‚Ä≤ (v) if and only if, for some leaf v
v‚Ä≤
‚àó
‚Ä≤‚Ä≤
‚Ä≤‚Ä≤
‚Ä≤‚Ä≤
‚Ä≤‚Ä≤
G contains edge {v , u } (i.e., g({v, u}) = {v , u }).

We now proceed with specifying our COP compilation for the FDR tasks as in Theorem 6.
Given such a task Œ† = ‚ü®V, A, I, G, cost‚ü©, let G ‚àó = (V ‚àó , E ‚àó ) be a fully separating, sub-cubic
expansion G ‚àó of the causal graph CGŒ† with tree-width ‚â§ tw(CGŒ† ) + 1. The respective
constraint optimization problem COPŒ†+ = (X , Œ¶) is speciÔ¨Åed as follows.
For each v ‚àà V , X contains a variable xv that is schematically associated with the root
œÑ (v) of T ‚àó (v), and a variable xv‚Ä≤ /v for each stretch-tree node v ‚Ä≤ ‚àà T ‚àó (v) \ {œÑ (v)}. The
domain of the variable xv is
{
{œë | œë ‚àà D‚äï (v), G[v] ‚àà œë}, v ‚àà V(G)
D(xv ) =
.
(7)
D‚äï (v),
otherwise
The domain of each variable xv‚Ä≤ /v is
D(xv‚Ä≤ /v ) = {0, 1}mv √ó D(xv ),

(8)

5. While determining optimal tree decomposition of a graph is NP-hard, it can be done in polynomial time
for graph families having Ô¨Åxed tree-width (Bodlaender, 1996).
6. Requiring the expansions to be fully separating is more of a luxury than a need: relying on this property
simpliÔ¨Åes the compilation scheme described next, but that scheme can also be modiÔ¨Åed so to not require
full separation.

804

The Complexity of Optimal Monotonic Planning

where mv = |PRv |. That is, D(xv‚Ä≤ /v ) is a set of some pairs ‚ü®Œ¥, œë‚ü©, with Œ¥ ‚àà {0, 1}mv and œë ‚àà
D‚äï (v). For each Œ¥ ‚àà {0, 1}mv , by DTG(v, Œ†+ |Œ¥) we denote the restriction of DTG(v, Œ†+ )
to edges ‚Äúsupported by Œ¥‚Äù: Assuming an arbitrarily Ô¨Åxed numbering of the elements of
PRv = {pr1 , . . . , prmv }, an edge marked with an action a such that pre(a)[pred(v)] = pri ‚àà
PRv remains in DTG(v, Œ†+ |Œ¥) if and only if Œ¥[i] = 1. For œë ‚àà D‚äï (v), by c(œë|Œ¥) we denote
the cost of a cheapest path from I[v] to œë in DTG(v, Œ†+ |Œ¥); in case of unreachability,
c(œë|Œ¥) = ‚àû.
Similarly to the way each node of the causal graph‚Äôs expansion G ‚àó is associated with a
COP variable, it is also associated with a non-negative, extended real-valued function. For
each state variable v ‚àà V :
(I) The stretch tree root œÑ (v) is associated with a function œÜv . The scope of œÜv is
Q(œÜv ) = {xv } ‚à™ {xv‚Ä≤ /v | v ‚Ä≤ ‚àà N ‚àó (œÑ (v))},
‚àó

where N ‚àó : V ‚àó ‚Üí 2V is the node neighborhood function in G ‚àó . Note that |N ‚àó (œÑ (v))| ‚â§
3 because G ‚àó is sub-cubic. For each œë ‚àà D(xv ) and each assignment Œ∏ = {‚ü®Œ¥v‚Ä≤ , œëv‚Ä≤ ‚ü©}v‚Ä≤ ‚ààN ‚àó (œÑ (v))
to Q(œÜv ) \ {xv },
{
c(œë|Œ¥H(Œ∏) ), ‚àÄv ‚Ä≤ ‚àà N ‚àó (œÑ (v)) : œëv‚Ä≤ = œë
œÜv (œë, Œ∏) =
,
(9)
‚àû,
otherwise
where Œ¥H(Œ∏) is the Hadamard, or entrywise, product of all the indicator vectors
{Œ¥v‚Ä≤ }v‚Ä≤ ‚ààN ‚àó (œÑ (v)) in Œ∏.
(II) Each leaf stretch node v ‚Ä≤ ‚àà T ‚àó (v) is associated with a 0/‚àû indicator function œÜv‚Ä≤ /v ,
the scope of which is
Q(œÜv‚Ä≤ /v ) = {xv‚Ä≤ /v , xu‚Ä≤ /u },
where u‚Ä≤ is the leaf node of T ‚àó (u) such that g({v, u}) = {v ‚Ä≤ , u‚Ä≤ }. Here the orientation
of the arcs within the causal graph CGŒ† matters. SpeciÔ¨Åcally, if {v, u} represents a
causal graph arc from u to v , then œÜv‚Ä≤ /v zeroes on the assignments (‚ü®Œ¥v‚Ä≤ , ¬∑‚ü©, ‚ü®Œ¥u‚Ä≤ , œëu‚Ä≤ ‚ü©)
such that
‚Ä¢ the vector Œ¥v‚Ä≤ enables all and only all the preconditions in PRv that are, passively
or actively, supported by the value œëu‚Ä≤ of u, and
‚Ä¢ the vector Œ¥u‚Ä≤ enables all the preconditions PRu , since v does not condition the
u-changing actions in our DAG-structured planning task Œ†.
That is, for each ‚ü®Œ¥v‚Ä≤ , œëv‚Ä≤ ‚ü© ‚àà D(xv‚Ä≤ /v ) and each ‚ü®Œ¥u‚Ä≤ , œëu‚Ä≤ ‚ü© ‚àà D(xu‚Ä≤ /u ),
Ô£±
Ô£¥
Ô£≤0,

Œ¥u‚Ä≤ = 1 ‚àß
œÜv‚Ä≤ /v (‚ü®Œ¥v‚Ä≤ , œëv‚Ä≤ ‚ü©, ‚ü®Œ¥u‚Ä≤ , œëu‚Ä≤ ‚ü©) =
‚àÄ1 ‚â§ i ‚â§ mv : (Œ¥v‚Ä≤ [i] = 0) ‚Üî (u ‚àà V(pri ) ‚àß pri [u] Ã∏‚àà œëu‚Ä≤ ) .
Ô£¥
Ô£≥
‚àû, otherwise
(10)
Note that the value of œÜv‚Ä≤ /v is independent of the œëv‚Ä≤ component of ‚ü®Œ¥v‚Ä≤ , œëv‚Ä≤ ‚ü©, ‚ü®Œ¥u‚Ä≤ , œëu‚Ä≤ ‚ü©.
805

Domshlak & Nazarenko

Otherwise, if {v, u} represents a causal graph arc7 from v to u, then conversely,
Ô£±
Ô£¥
Ô£≤0, Œ¥v‚Ä≤ = 1 ‚àß
‚Ä≤
‚Ä≤
‚Ä≤
‚Ä≤
œÜv‚Ä≤ /v (‚ü®Œ¥v , œëv ‚ü©, ‚ü®Œ¥u , œëu ‚ü©) =
‚àÄ1 ‚â§ i ‚â§ mu : (Œ¥u‚Ä≤ [i] = 0) ‚Üî (v ‚àà V(pri ) ‚àß pri [v] Ã∏‚àà œëv‚Ä≤ ) .
Ô£¥
Ô£≥
‚àû, otherwise
(11)
(III) Each internal stretch node v ‚Ä≤ ‚àà T ‚àó (v) is also associated with a 0/‚àû indicator function
œÜv‚Ä≤ /v , but its scope comprises the variable xv‚Ä≤ /v , together with all the variables xv‚Ä≤‚Ä≤ /v
that correspond to the immediate descendants of v ‚Ä≤ in Tv‚àó‚Ä≤ (v). That is,
Q(œÜv‚Ä≤ /v ) = {xv‚Ä≤ /v } ‚à™ {xv‚Ä≤‚Ä≤ /v | v ‚Ä≤‚Ä≤ ‚àà N ‚àó (v ‚Ä≤ ) ‚à© Tv‚àó‚Ä≤ (v)}.
For each ‚ü®Œ¥v‚Ä≤ , œëv‚Ä≤ ‚ü© ‚àà D(xv‚Ä≤ /v ) and each assignment Œ∏ = {‚ü®Œ¥v‚Ä≤‚Ä≤ , œëv‚Ä≤‚Ä≤ ‚ü©} to Q(œÜv‚Ä≤ /v ) \
{xv‚Ä≤ /v }, œÜv‚Ä≤ /v zeroes on (‚ü®Œ¥v‚Ä≤ , œëv‚Ä≤ ‚ü©, Œ∏) if and only if the vector Œ¥v‚Ä≤ enables all and
only all the preconditions in PRv that are (passively or actively) supported by all the
immediate ancestors u ‚àà Nvin‚Ä≤ (v) via the values these ancestors ‚Äúcommit to‚Äù at the
respective stretch-tree root COP variables xu . That is,
{
0, Œ¥v‚Ä≤ = Œ¥H(Œ∏) ‚àß ‚àÄv ‚Ä≤‚Ä≤ ‚àà N ‚àó (v ‚Ä≤ ) ‚à© Tv‚àó‚Ä≤ (v) : œëv‚Ä≤‚Ä≤ = œëv‚Ä≤
œÜv‚Ä≤ /v (‚ü®Œ¥v‚Ä≤ , œëv‚Ä≤ ‚ü©, Œ∏) =
. (12)
‚àû, otherwise
In other words, starting with Eqs. 10 and 11, the support provided by Nvin‚Ä≤ (v) to v is
communicated to v by the indicator vectors Œ¥v‚Ä≤‚Ä≤ in Œ∏, and it is aggregated/summarized
in Eq. 12 by the Hadamard vector product Œ¥H(Œ∏) .
Complexity-wise, the properties of the COPŒ†+ constructed as above are as follows.
(1) The constraint network of COPŒ†+ is obtained from the expansion G ‚àó by replacing each
‚àó be a graph
subgraph of G ‚àó induced by nodes Q(œÜŒ± ) with a clique over Q(œÜŒ± ). Let GQ
with nodes Q(œÜŒ± ), xŒ± ‚àà X , and edges {Q(œÜŒ± ), Q(œÜŒ≤ )} for (only) all pairs Œ±, Œ≤ such that
‚àó is isomorphic to
Q(œÜŒ± ) ‚à© Q(œÜŒ≤ ) Ã∏= ‚àÖ. By the construction of the COP functions Œ¶, GQ
‚àó
G . Likewise, since |Q(œÜŒ± ) ‚à© Q(œÜŒ≤ )| ‚â§ 1 for all pairs of functions œÜŒ± , œÜŒ≤ , the tree-width
‚àó ) ¬∑ max |Q(œÜ )|. Together that implies
œâCOP of the constraint network is ‚â§ tw(GQ
Œ±
Œ±
‚àó
œâCOP ‚â§ tw(GQ
)¬∑max |Q(œÜŒ± )| = tw(G ‚àó )¬∑max |Q(œÜŒ± )| ‚â§ 4¬∑tw(G ‚àó ) ‚â§ 4¬∑(tw(CGŒ† )+1) = O(1).
Œ±

Œ±

Hence, since Ô¨Ånding a constant-factor approximation to the graph‚Äôs tree-width is polynomial in the size of the graph and exponential only in its tree-width, COPŒ†+ can be
solved in time polynomial in the size of its representation.
(2) By M-unfoldability of Œ† and Eq. 7, for v ‚àà V , the domain size of each COP variable xv
is O(poly(||Œ†||)). The domain of each stretch node variable xv‚Ä≤ /v is a cross-product of
two sets. The size of the second set in Eq. 8 is O(poly(||Œ†||)) because so is the domain
size of the respective variable xv . The size of the Ô¨Årst set in Eq. 8 is 2|PRv | and, by
DeÔ¨Ånition 5, 2|PRv | = 2O(log(||Œ†||)) = O(poly(||Œ†||)). Together with (1), this implies that
COPŒ†+ can be solved in time O(poly(||Œ†||)).
7. Since Theorem 6 is devoted to directed acyclic causal graphs, we do not address here the case in which
CGŒ† contains both (v, u) and (u, v).

806

The Complexity of Optimal Monotonic Planning

(3) By the deÔ¨Ånition of monotonic relaxation and the deÔ¨Ånition of domain transition graphs,
explicit description of all DTG(v, Œ†+ ) for an M-unfoldable FDR task Œ† is polynomial
in ||Œ†||. Hence, the construction of functional components Œ¶ as in Eqs. 9-12, and thus
of the entire COPŒ†+ , can be done in time O(poly(||Œ†||)).

We now proceed to prove the correctness of COPŒ†+ = (X , Œ¶). That is, we will prove
that if Œ†+ is unsolvable, then all the assignments to X evaluate the objective function
Œ£œÜ‚ààŒ¶ œÜ(X ) to ‚àû, and otherwise, the objective is minimized on and only on the assignments
to X that correspond to optimal plans for Œ†+ .
First, given an assignment Œ∏ to X such that Œ£œÜ‚ààŒ¶ œÜ(Œ∏) < ‚àû, we show that Œ∏ induces
a valid plan œÅŒ∏ for Œ†+ of cost Œ£œÜ‚ààŒ¶ œÜ(Œ∏). By Eqs. 9 and 12, Œ£œÜ‚ààŒ¶ œÜ(Œ∏) < ‚àû implies that,
for each v ‚àà V and each xv‚Ä≤ /v in the stretch tree T ‚àó (v), Œ∏[xv‚Ä≤ /v ] ‚àà {‚ü®¬∑, Œ∏[xv ]‚ü©}. That is,
the relaxation value of v assigned by Œ∏ to xv is consistently propagated to all the nodes of
T ‚àó (v), and in particular, to its leaves.
Let a leaf node xv‚Ä≤ /v in T ‚àó (v) connect T ‚àó (v) with T ‚àó (u) for some causal graph neighbor
u ‚àà N (v), and let Œ∏[xv‚Ä≤ /v ] = ‚ü®Œ¥v‚Ä≤ , Œ∏[xv ]‚ü©. If u ‚àà N in (v), then by Eq. 10, œÜv‚Ä≤ /v (Œ∏) Ã∏= ‚àû
implies that Œ¥v‚Ä≤ encodes all and only all preconditions in PRv that are not disabled by the
relaxation value Œ∏[xu ] of u. Otherwise, if u ‚àà N out (v), then, by the DAG structure of CGŒ† ,
u has nothing to do with preconditions of actions aÔ¨Äecting v + , and by Eq. 11, œÜv‚Ä≤ /v (Œ∏) Ã∏= ‚àû
implies that Œ¥v‚Ä≤ = 1 trivially enables all the preconditions in PRv .
Given that, for each (leaf or internal) stretch node in T ‚àó (v), let Œ∏[xv‚Ä≤ /v ] = ‚ü®Œ¥v‚Ä≤ , Œ∏[xv ]‚ü©.
By the conjunctive structure of the preconditions in FDR and the Hadamard vector product
in Eq. 12, œÜv‚Ä≤ /v (Œ∏) Ã∏= ‚àû implies that Œ¥v‚Ä≤ encodes all and only all the preconditions in PRv
that are not‚à™disabled by the values Œ∏[xu ] of all u ‚àà Nvin‚Ä≤ (v). Finally, by the deÔ¨Ånition of graph
expansion, v‚Ä≤ ‚ààN ‚àó (œÑ (v)) Nvin‚Ä≤ (v) = N in (v). Thus, by Eq. 11, œÜv (Œ∏) Ã∏= ‚àû implies that Œ∏[xv ] is
reachable from I[v] in the properly restricted domain transition graph DTG(v, Œ†+ |Œ∏[Xv ])
where Xv = {xu | u ‚àà pred(v)}, and that œÜv (Œ∏) equals the cost of the cheapest such
path. The rest follows from the DAG structure of CGŒ† and Lemma 1. The proof of the
opposite direction is straightforward from the construction of COPŒ†+ and the ‚Äúserialization‚Äù
Lemma 1.


In our Ô¨Ånal note we return to the deÔ¨Ånition of prevail decomposability, and speciÔ¨Åcally, to
its second suÔ¨Écient condition that, for all state variables v ‚àà V , the set ARBv of arborescence
sugraphs of DTG(v, Œ†) rooted in I[v], and covering G[v] if v ‚àà V(G), is of size O(log(||Œ†||)).
While this condition was not addressed in our COP construction so far, switching from
the Ô¨Årst to the second suÔ¨Écient condition of prevail decomposability requires only that
the semantics of the indicator vectors Œ¥ be changed: Instead of encoding the support that
pred(v) provide to individual preconditions of actions in Av , they should encode the support
that pred(v) provide to the entire arborescences ARBv in DTG(v, Œ†). Since the condition
requires |ARBv | = O(log(||Œ†||)), this support can be encoded and reasoned about eÔ¨Éciently.
Note that the choice between the two conditions can be made on a variable-by-variable basis,
and thus the two conditions are not mutually exclusive but complementary.
807

Domshlak & Nazarenko

Œ†
causal graph
extra condition
Ô¨Åxed size
œâ = O(1)
|D(v)| = O(1)
œâ = O(1) & DAG |D(v)| = O(1)
œâ = O(1) & DAG in-degree = O(1)
œâ = O(1) & DAG

FDR
in P?
Yes
No
No
No
No

MFDR
in P?
No
Yes
Yes
Yes, if M-unfoldable
Yes, if M-unfoldable and
prevail decomposable

Th.
Th.
Th.
Th.
Th.

2
3
3
5
6

Table 1: A summary of our main results for optimal MFDR planning, contrasted with the
previously established complexity of the corresponding fragments of optimal FDR
planning. In the table, Œ† is a fragment of FDR/MFDR planning, characterized
in terms of the causal graph tree-width œâ, causal graph in-degree, and upper
bound |D(v)| on the size of the variable domains. M-unfoldability and prevail
decomposability are two properties of MFDR tasks that have been introduced and
exploited in this work.

6. Summary and Future Work
We took a step towards a Ô¨Åne-grained classiÔ¨Åcation of worst-case time complexity of optimal
monotonic planning, with a focus on ‚Äúwhat gets harder‚Äù and ‚Äúwhat gets easier‚Äù when
switching from optimal planning to optimal relaxed planning, in the context of Ô¨Ånite-domain
planning task representations. Along the way, we established both negative and positive
results on the complexity of some wide fragments of this problem, with the negative results
emphasizing the role of the structure of state variable domains, and the positive results
emphasizing the role of the causal graph topology. Table 1 lists our main results for optimal
monotonic planning, contrasted with the complexity of the corresponding fragments of
optimal FDR planning. The key conclusions are as follows.
1. Optimal planning for monotonic relaxations is hard even if restricted to very simple
causal graph structures, but the complexity there stems from the size of the state
variable domains.
2. Restricted to planning tasks with constant-bounded state variable domains, the problem becomes solvable in time exponential only in the tree-width of the causal graph,
while it is known to be very much not so even for non-optimal regular planning.
3. While the tree-width of digraphs is independent of the edge directions, exploiting
the directed structure of the causal graph together with its tree-width allows the
computational tractability to be expanded beyond Ô¨Åxed-size state variable domains.
The latter conclusion opens an interesting venue for further investigation. While we
addressed only directed acyclic causal graphs, the scope of tractability can perhaps be expanded by exploiting some existing ‚Äúdirected‚Äù notions of graph width (Johnson, Robertson,
Seymour, & Thomas, 2001; Hunter & Kreutzer, 2008; Berwanger et al., 2012). This might
808

The Complexity of Optimal Monotonic Planning

be especially appealing because the tree-width of most standard planning benchmarks under their natural FDR encodings does not appear to be Ô¨Åxed across the respective families
of the tasks.
Another interesting direction would be to examine the results and techniques introduced here in a wider context: that of the recently introduced framework of red-black
relaxations (Katz et al., 2013b). In red-black (RB) planning, the variables are partitioned
into two sets: the ‚Äúblack‚Äù set adopts the regular, value switching semantics of FDR, while
the ‚Äúred‚Äù set adopts the monotonic, value accumulating semantics of MFDR. In the context
of satisÔ¨Åcing planning, complexity analysis of RB planning complexity through the lens of
causal graph topology has already led to some advances in the practice of heuristic-search
planning (Katz et al., 2013a; Katz & HoÔ¨Ämann, 2013). To take a similar step in optimal
planning, admissible heuristics that are based on RB relaxations must be devised. That, in
turn, calls for identifying tractable fragments of optimal RB planning. We are cautiously
optimistic that some of the results and techniques presented in this paper will be found valuable in the context of RB planning as well. For instance, the positive result in Theorem 4
for fork-structured MFDR tasks can be straightforwardly extended to RB tasks with only
root variables taking the monotonic semantics and all the leaves keeping their regular, FDR
semantics. Similarly, the positive result in Theorem 5 for DAG-structured MFDR tasks can
be straightforwardly extended to RB tasks with black-painted leaf variables. An interesting
question in that respect is whether computational tractability of optimal RB planning can
be extended to causal graphs in which some internal nodes get to keep their original FDR
semantics.

Acknowledgments
The work was partly supported by the Israel Science Foundation (ISF) grant 1045/12, and
the EOARD grant FA8655-12-1-2096.

References
Amir, E. (2010). Approximation algorithms for treewidth. Algorithmica, 56 (4), 448‚Äì479.
Arnborg, S., Cornell, D. G., & Proskurowski, A. (1987). Complexity of Ô¨Ånding embeddings
in a k-tree. SIAM Journal of Algebraic Discrete Methods, 8, 277‚Äì284.
BaÃàckstroÃàm, C., & Klein, I. (1991). Planning in polynomial time: The SAS-PUBS class.
Computational Intelligence, 7 (3), 181‚Äì197.
BaÃàckstroÃàm, C., & Nebel, B. (1995). Complexity results for SAS+ planning. Computational
Intelligence, 11 (4), 625‚Äì655.
Becker, A., & Geiger, D. (1996). A suÔ¨Éciently fast algorithm for Ô¨Ånding close to optimal
junction trees. In Proceedings of the 12th Conference on Uncertainty in ArtiÔ¨Åcial
Intelligence (UAI), pp. 81‚Äì89.
Berwanger, D., Dawar, A., Hunter, P., Kreutzer, S., & ObdzraÃÅlek, J. (2012). The DAG-width
of directed graphs. Journal of Combinatorial Theory, Series B, 102 (4), 900‚Äì923.
Betz, C., & Helmert, M. (2009). Planning with h+ in theory and practice. In Proceedings
of the 32nd Annual German Conference on ArtiÔ¨Åcial Intelligence (KI), pp. 9‚Äì16.
809

Domshlak & Nazarenko

Bodlaender, H. L. (1996). A linear-time algorithm for Ô¨Ånding tree-decompositions of small
treewidth. SIAM Journal of Computing, 25 (6), 1305‚Äì1317.
Bonet, B., & GeÔ¨Äner, H. (2001). Planning as heuristic search. ArtiÔ¨Åcial Intelligence, 129 (1‚Äì
2), 5‚Äì33.
Bonet, B., & Helmert, M. (2010). Strengthening landmark heuristics via hitting sets. In
Proceedings of the 19th European Conference on ArtiÔ¨Åcial Intelligence, pp. 329‚Äì334,
Lisbon, Portugal.
Brafman, R. I., & Domshlak, C. (2006). Factored planning: How, when, and when not.
In Proceedings of the 18th National Conference on ArtiÔ¨Åcial Intelligence (AAAI), pp.
809‚Äì814, Boston, MA.
Brafman, R. I., & Domshlak, C. (2013). On the complexity of planning for agent teams and
its implications for single agent planning. ArtiÔ¨Åcial Intelligence, 198, 52‚Äì71.
Bylander, T. (1994). The computational complexity of propositional STRIPS planning.
ArtiÔ¨Åcial Intelligence, 69 (1-2), 165‚Äì204.
Cai, D., HoÔ¨Ämann, J., & Helmert, M. (2013). Enhancing the context-enhanced additive
heuristic with precedence constraints. In Proceedings of the 19th International Conference on Automated Planning and Scheduling (ICAPS), pp. 50‚Äì57.
Chen, H., & Gimenez, O. (2010). Causal graphs and structurally restricted planning. Journal of Computer and System Sciences, 76 (7), 579‚Äì592.
Dechter, R. (2003). Constraint Processing. Morgan Kaufmann.
Domshlak, C., & Dinitz, Y. (2001). Multi-agent oÔ¨Ä-line coordination: Structure and complexity. In Proceedings of Sixth European Conference on Planning (ECP), pp. 277‚Äì288.
Downey, R. G., & Fellows, M. R. (1999). Parameterized Complexity. Springer-Verlag, New
York.
Edelkamp, S. (2001). Planning with pattern databases. In Proceedings of the European
Conference on Planning (ECP), pp. 13‚Äì24.
Fabre, E., Jezequel, L., Haslum, P., & ThieÃÅbaux, S. (2010). Cost-optimal factored planning:
Promises and pitfalls. In Proceedings of the International Conference on Automated
Planning and Scheduling (ICAPS), pp. 65‚Äì72.
Fikes, R. E., & Nilsson, N. (1971). STRIPS: A new approach to the application of theorem
proving to problem solving. ArtiÔ¨Åcial Intelligence, 2, 189‚Äì208.
Flum, J., & Grohe, M. (2006). Parameterized Complexity Theory. Springer-Verlag.
Fox, M., & Long, D. (2001). Stan4: A hybrid planning strategy based on subproblem
abstraction. AI Magazine, 22 (3), 81‚Äì84.
Fox, M., & Long, D. (2003). PDDL2.1: An extension to PDDL for expressing temporal
planning problems. Journal of ArtiÔ¨Åcial Intelligence Research, 20, 61‚Äì124.
Gimenez, O., & Jonsson, A. (2009a). The inÔ¨Çuence of k-dependence on the complexity of
planning. In Proceedings of the 19th International Conference on Automated Planning
and Scheduling (ICAPS), pp. 138‚Äì145.
810

The Complexity of Optimal Monotonic Planning

Gimenez, O., & Jonsson, A. (2009b). Planning over chain causal graphs for variables with
domains of size 5 is NP-hard. Journal of ArtiÔ¨Åcial Intelligence Research, 34, 675‚Äì706.
Halin, R. (1976). s-functions for graphs. Journal of Geometry, 8, 171‚Äì186.
Helmert, M. (2004). A planning heuristic based on causal graph analysis. In Proceedings
of the Fourteenth International Conference on Automated Planning and Scheduling
(ICAPS), pp. 161‚Äì170.
Helmert, M. (2006). The Fast Downward planning system. Journal of ArtiÔ¨Åcial Intelligence
Research, 26, 191‚Äì246.
Helmert, M. (2009). Concise Ô¨Ånite-domain representations for PDDL planning tasks. ArtiÔ¨Åcial Intelligence, 173, 503‚Äì535.
Helmert, M., & Domshlak, C. (2009). Landmarks, critical paths and abstractions: What‚Äôs
the diÔ¨Äerence anyway?. In Proceedings of the 19th International Conference on Automated Planning and Scheduling (ICAPS), pp. 162‚Äì169.
Helmert, M., & GeÔ¨Äner, H. (2008). Unifying the causal graph and additive heuristics. In Proceedings of the 18th International Conference on Automated Planning and Scheduling
(ICAPS), pp. 140‚Äì147.
Helmert, M., Haslum, P., & HoÔ¨Ämann, J. (2007). Flexible abstraction heuristics for optimal
sequential planning. In Proceedings of the 17th International Conference on Automated
Planning and Scheduling (ICAPS), pp. 200‚Äì207.
Helmert, M., & MattmuÃàller, R. (2007). Accuracy of admissible heuristic functions in selected planning domains. In Proceedings of the 23rd AAAI Conference on ArtiÔ¨Åcial
Intelligence, pp. 938‚Äì943.
HoÔ¨Ämann, J. (2005). When ‚Äôignoring delete lists‚Äô works: Local search topology in planning
benchmarks. Journal of ArtiÔ¨Åcial Intelligence Research, 24, 685‚Äì758.
HoÔ¨Ämann, J. (2011). Analyzing search topology without running any search: On the connection between causal graphs and h+ . Journal of ArtiÔ¨Åcial Intelligence Research, 41,
155‚Äì229.
HoÔ¨Ämann, J., & Nebel, B. (2001). The FF planning system: Fast plan generation through
heuristic search. Journal of ArtiÔ¨Åcial Intelligence Research, 14, 253‚Äì302.
Hunter, P., & Kreutzer, S. (2008). Digraph measures: Kelly decompositions, games, and
orderings. Theoretical Computer Science, 399 (3), 206‚Äì219.
Johnson, T., Robertson, N., Seymour, P. D., & Thomas, R. (2001). Directed tree-width.
Journal of Combinatorial Theory, Series B, 82 (1), 138‚Äì154.
Jonsson, P., & BaÃàckstroÃàm, C. (1998). State-variable planning under structural restrictions:
Algorithms and complexity. ArtiÔ¨Åcial Intelligence, 100 (1‚Äì2), 125‚Äì176.
Karp, R. (1972). Reducibility among combinatorial problems. In Complexity of Computer
Computations, pp. 85‚Äì103. Plenum Press, New York.
Katz, M., & Domshlak, C. (2008). New islands of tractability of cost-optimal planning.
Journal of ArtiÔ¨Åcial Intelligence Research, 32, 203‚Äì288.
811

Domshlak & Nazarenko

Katz, M., & Domshlak, C. (2010). Implicit abstraction heuristics. Journal of ArtiÔ¨Åcial
Intelligence Research, 39, 51‚Äì126.
Katz, M., & HoÔ¨Ämann, J. (2013). Red-black relaxed plan heuristics reloaded. In Proceedings
of the 6th Annual Symposium on Combinatorial Search (SOCS), pp. 105‚Äì113.
Katz, M., HoÔ¨Ämann, J., & Domshlak, C. (2013a). Red-black relaxed plan heuristics. In
Proceedings of the 27th AAAI Conference on ArtiÔ¨Åcial Intelligence (AAAI), pp. 489‚Äì
495.
Katz, M., HoÔ¨Ämann, J., & Domshlak, C. (2013b). Who said we need to relax all variables?. In Proceedings of the 23rd International Conference on Automated Planning
and Scheduling (ICAPS), pp. 126‚Äì134.
Katz, M., & Keyder, E. (2012). Structural patterns beyond forks: Extending the complexity
boundaries of classical planning. In Proceedings of the 26th AAAI Conference on
ArtiÔ¨Åcial Intelligence (AAAI), pp. 1779‚Äì1785.
Keyder, E., & GeÔ¨Äner, H. (2008a). Heuristics for planning with action costs revisited. In
Proceedings of the 18th European Conference on ArtiÔ¨Åcial Intelligence (ECAI), pp.
588‚Äì592.
Keyder, E., & GeÔ¨Äner, H. (2008b). Heuristics for planning with action costs revisited. In
Proceedings of the 18th European Conference on ArtiÔ¨Åcial Intelligence, pp. 588‚Äì592.
Markov, I. L., & Shi, Y. (2011). Constant-degree graph expansions that preserve treewidth.
Algorithmica, 59, 461‚Äì470.
McDermott, D. V. (1999). Using regression-match graphs to control search in planning.
ArtiÔ¨Åcial Intelligence, 109 (1-2), 111‚Äì159.
Nissim, R., & Brafman, R. I. (2012). Multi-agent A‚àó for parallel and distributed systems.
In Proceedings of the 11th International Conference on Autonomous Agents and Multiagent Systems (AAMAS), pp. 1265‚Äì1266.
Nissim, R., Brafman, R. I., & Domshlak, C. (2010). A general, fully distributed multiagent planning algorithm. In Proceedings of the 9th International Conference on
Autonomous Agents and Multiagent Systems (AAMAS), pp. 1323‚Äì1330.
Pednault, E. (1989). ADL: Exploring the middle ground between STRIPS and the situation calculus. In Proceedings of the 1st International Conference on Principles of
Knowledge Representation and Reasoning, pp. 324‚Äì331.
Robertson, N., & Seymour, P. D. (1984). Graph minors III: Planar tree-width. Journal of
Combinatorial Theory, 36, 49‚Äì63.
Robertson, N., & Seymour, P. D. (1991). Graph minors X: Obstructions to tree decomposition. Journal of Combinatorial Theory, Series B, 52 (2), 153‚Äì190.
Seipp, J., & Helmert, M. (2011). Fluent merging for classical planning problems. In Proceedings of the ICAPS-2011 Workshop on Knowledge Engineering for Planning and
Scheduling (KEPS), pp. 47‚Äì53.

812

Journal of Artificial Intelligence Research 48 (2013) 923-951

Submitted 7/13; published 12/13

A Smooth Transition from Powerlessness to Absolute Power
Elchanan Mossel

mossel@stat.berkeley.edu

University of California, Berkeley
Berkeley, CA 94720 USA
Weizmann Institute of Science
Rehovot, Israel

Ariel D. Procaccia

arielpro@cs.cmu.edu

Carnegie Mellon University
Pittsburgh, PA 15213 USA

MikloÃÅs Z. RaÃÅcz

racz@stat.berkeley.edu

University of California, Berkeley
Berkeley, CA 94720 USA

Abstract
We study the phase transition of the coalitional manipulation problem for generalized
scoring rules. Previously it has been shown that,
‚àö under some conditions on the distribution
of votes, if the number of manipulators is o ( n), where n is the number of voters, then
the probability that a random profile is manipulable by the coalition goes to zero
‚àö as the
number of voters goes to infinity, whereas if the number of manipulators is œâ ( n), then
the probability that a random profile is manipulable
goes to one. Here we consider the
‚àö
critical window, where a coalition has size c n, and we show that as c goes from zero to
infinity, the limiting probability that a random profile is manipulable goes from zero to
one in a smooth fashion, i.e., there is a smooth phase transition between the two regimes.
This result analytically validates recent empirical results, and suggests that deciding the
coalitional manipulation problem may be of limited computational hardness in practice.

1. Introduction
Finding ‚Äúgood‚Äù voting systems which satisfy some natural requirements is one of the main
goals in social choice theory. This problem is increasingly relevant in the area of artificial intelligence and in computer science more broadly, where virtual elections are now an
established tool for preference aggregation (see, e.g., Caragiannis & Procaccia, 2011).
A naturally desirable property of a voting system is strategyproofness (a.k.a. nonmanipulability): no voter should benefit from voting strategically, i.e., voting not according to
her true preferences. However, Gibbard (1973) and Satterthwaite (1975) showed that no
reasonable voting system can be strategyproof. Before stating their result, let us specify
the problem more formally.
We consider n voters electing a single winner among m candidates. The voters specify
their opinion by ranking the candidates, and the winner is determined according to some
n ‚Üí [m] of all the voters‚Äô rankings, where S
predefined social choice function (SCF) f : Sm
m
denotes the set of all possible total orderings of the m candidates. We call a collection of
rankings by the voters a ranking profile. We say that a SCF is manipulable if there exists a
c
2013
AI Access Foundation. All rights reserved.

Mossel, Procaccia, & RaÃÅcz

ranking profile where a voter can achieve a more desirable outcome of the election according
to her true preferences by voting in a way that does not reflect her true preferences.
The Gibbard-Satterthwaite theorem states that any SCF which is not a dictatorship
(i.e., not a function of a single voter), and which allows at least three candidates to be
elected, is manipulable. This has contributed to the realization that it is unlikely to expect
truthfulness in voting. Consequently, there have been many branches of research devoted
to understanding the extent of the manipulability of voting systems, and to finding ways of
circumventing the negative results.
One approach, introduced by Bartholdi, Tovey, and Trick (1989), suggests computational
complexity as a barrier against manipulation: a SCF may not be manipulable in practice if it
is hard for a voter to compute a manipulative vote. A significant body of work focuses on the
worst-case complexity of manipulation (see the survey by Faliszewski and Procaccia, 2010).
Here we are interested specifically in the coalitional manipulation problem, where a group
of voters can change their votes in unison, with the goal of making a given candidate
win. Various variations of this problem are known to be N P-hard under many of the
common SCFs (Conitzer, Sandholm, & Lang, 2007; Xia, Zuckerman, Procaccia, Conitzer,
& Rosenschein, 2009; Betzler, Niedermeier, & Woeginger, 2011).
Crucially, this line of work focuses on worst-case complexity. While worst-case hardness
of manipulation is a desirable property for a SCF to have, it does not tell us much about
typical instances of the problem‚Äîis it usually easy or hard to manipulate? A recent line
of research on average-case manipulability has been questioning the validity of such worstcase complexity results. The goal of this alternative line of work is to show that there
are no ‚Äúreasonable‚Äù voting rules that are computationally hard to manipulate on average.
Specifically, the goal is to rule out the following informal statement: there are ‚Äúgood‚Äù voting
rules that are hard to manipulate on average under any ‚Äúsufficiently rich‚Äù distribution over
votes.
Taking this point of view, showing easiness of manipulation under a restricted class of
distributions‚Äîsuch as i.i.d. votes or even uniform votes (the impartial culture assumption)‚Äî
is interesting, even if these do not necessarily capture all possible real-world elections.
Specifically, if we show that manipulation is easy under such distributions, then any averagecase hardness result would necessarily have to make some unnatural technical assumptions
to avoid these distributions. Studying such restricted distributions over votes is indeed
exactly what some recent papers have done.
For the coalitional manipulation problem, Procaccia and Rosenschein (2007a) first suggested that it is trivial to determine whether manipulation is possible for most coalitional
manipulation instances, from a typical-case computational point of view; one can make a
highly informed guess purely based on the number of manipulators. Specifically, they studied a setting where there is a distribution over votes (which satisfies some conditions), and
concentrated on a family of SCFs known as positional scoring rules. They showed that if the
‚àö
size of the coalition is o ( n), then with probability converging to 1 as n ‚Üí ‚àû, the coalition
is powerless, i.e., it cannot change the outcome of the election. In contrast, if the size of the
‚àö
coalition is œâ ( n) (and o (n)), then with probability converging to 1 as n ‚Üí ‚àû, the coalition is all-powerful, i.e., it can elect any candidate. Later Xia and Conitzer (2008b) proved
an analogous result for so-called generalized scoring rules, a family that contains almost
all common voting rules. See also related work by Peleg (1979), Slinko (2004), Pritchard
924

A Smooth Transition from Powerlessness to Absolute Power

and Slinko (2006), and Pritchard and Wilson (2009). We discuss additional related work in
Section 1.2.
Our primary interest in this paper is to understand the critical window that these papers
‚àö
leave open, when the size of the coalition is Œò ( n). Specifically, we are interested in the
phase transition in the probability of coalitional manipulation, when the size of the coalition
‚àö
is c n and c varies from zero to infinity, i.e., the transition from powerlessness to absolute
power.
In the past few decades there has been much research on the connection between phase
transitions and computationally hard problems (see, e.g., Fu & Anderson, 1986; Cheeseman,
Kanefsky, & Taylor, 1991; Achlioptas, Naor, & Peres, 2005). In particular, it is often
the case that the computationally hardest problems can be found at critical values of a
sharp phase transition (see, e.g., Gomes & Walsh, 2006, for an overview). On the other
hand, smooth phase transitions are often found in connection with computationally easy
(polynomial) problems, such as 2-coloring (Achlioptas, 1999) and 1-in-2 SAT (Walsh, 2002).
Thus understanding the phase transition in this critical window may shed light on where
the computationally hardest problems lie.
Recently, Walsh (2011) empirically analyzed two well-known voting rules‚Äîveto and
single transferable vote (STV)‚Äîand found that there is a smooth phase transition between
the two regimes. Specifically, Walsh studied coalitional manipulation with unweighted votes
for STV and weighted votes for veto, and sampled from a number of distributions in his
experiments, including i.i.d. distributions, correlated distributions, and votes sampled from
real-world elections. Our main result complements and improves upon Walsh‚Äôs analysis
in two ways; while Walsh‚Äôs results show how the phase transition looks like concretely for
veto and STV, we analytically show that the phase transition is indeed smooth for any
generalized scoring rule (including veto and STV) when the votes are i.i.d. This suggests
that deciding the coalitional manipulation problem may not be computationally hard in
practice.
1.1 Our Results
We now present our results, but first let us formally specify the setup of the problem.
n , and for a candidate a, define
We denote a ranking profile by œÉ = (œÉ1 , . . . , œÉn ) ‚àà Sm
n | f (œÉ) = a}, the set of ranking profiles where the outcome of f is a. Our
Wa = {œÉ ‚àà Sm
setup and assumptions are the following.
Assumption 1. We assume that the number of candidates, m, is constant.
Assumption 2. We assume that the SCF f is anonymous, i.e., it treats each voter equally.
Assumption 3. We assume that the votes of voters are i.i.d., according to some distribution
p on Sm . Furthermore, we assume that there exists Œ¥ > 0 such that for every œÄ ‚àà Sm ,
p (œÄ) ‚â• Œ¥ (necessarily Œ¥ ‚â§ 1/m!).
If we were to assume only these, then our setup would include uninteresting cases, such
as when f is a constant‚Äîi.e., no matter what the votes are, a specific candidate wins.
Another less interesting case is when the probability of a given candidate winning vanishes
as n ‚Üí ‚àû‚Äîwe can then essentially forget about this candidate for large n (in the sense
925

Mossel, Procaccia, & RaÃÅcz

that a coalition of size ‚Ñ¶ (n) would be necessary to make this candidate win). To exclude
these and focus on the interesting cases, we make an additional assumption which concerns
both the SCF and the distribution of votes.
Assumption 4. We assume that there exists Œµ > 0 such that for every n and for every
candidate a ‚àà [m], the probability of a being elected is at least Œµ > 0, i.e., P (Wa ) ‚â• Œµ
(necessarily Œµ ‚â§ 1/m).
All four assumptions are satisfied when the distribution is uniform (i.e., under the impartial culture assumption) and the SCF is close to being neutral (i.e., neutral up to some
tie-breaking rules); in particular, they hold for all commonly used SCFs. The assumptions
are somewhat more general than this, although the i.i.d. assumption remains a restrictive
one. However, as discussed earlier, even showing easiness of manipulation under such a
restricted class of distributions is interesting.
‚àö
As mentioned before, we are interested in the case when the coalition has size c n for
some constant c. Define the probabilities

‚àö
q n (c) := P some coalition of size c n can elect any candidate ,

‚àö
q n (c) := P some coalition of size c n can change the outcome of the election ,

‚àö
rn (c) := P a specific coalition of size c n can elect any candidate ,

‚àö
rn (c) := P a specific coalition of size c n can change the outcome of the election ,
and let
q (c) := lim q n (c) ,
n‚Üí‚àû

q (c) := lim q n (c) ,
n‚Üí‚àû

r (c) := lim rn (c) ,
n‚Üí‚àû

r (c) := lim rn (c) ,
n‚Üí‚àû

provided these limits exist. Clearly q n (c) ‚â§ q n (c), rn (c) ‚â§ rn (c), rn (c) ‚â§ q n (c), and
rn (c) ‚â§ q n (c).
Before we describe our results, which deal with these quantities, we first explain how
these relate to the various variants of the coalitional manipulation problem. In the coalitional manipulation problem the coalition is fixed, and thus the relevant quantities are rn (c)
and rn (c). Closely related is the problem of determining the margin of victory, which is the
minimum number of voters who need to change their votes to change the outcome of the
election. Also related is the problem of bribery, the minimum number of voters who need
to change their votes to make a given candidate win. The main difference between these
problems is that in coalitional manipulation the coalition is fixed, whereas in the latter two
problems the coalition is not fixed. Hence the relevant quantities for studying the latter
two are q n (c) and q n (c). Our tools also allow us to deal with other related quantities (such
as microbribery, Faliszewski, Hemaspaandra, Hemaspaandra, & Rothe, 2009), but we focus
our attention on the four quantities described above.
‚àö
Our first result analyzes the case when the size of the coalition is c n for large c. We
‚àö
show that if c is large enough, then with probability close to 1, a specific coalition of size c n
can elect any candidate. This holds for any SCF that satisfies the above (mild) restrictions.
Theorem 1.1. Assume that Assumptions 1, 2, 3, and 4 hold. For any Œ∑ > 0 there exists a
constant c = c (Œ∑, Œ¥, Œµ, m) such that rn (c) ‚â• 1 ‚àí Œ∑ for every n. In particular, we can choose
hp
i
p
c = (4/Œ¥) log (2m!/Œ∑)
log (2m/Œ∑) + log (2/Œµ) .
926

A Smooth Transition from Powerlessness to Absolute Power

It follows that
lim lim inf rn (c) = 1.

c‚Üí‚àû

n

This result extends previous theorems of Procaccia and Rosenschein (2007a), and Xia
and Conitzer (2008b), from scoring rules and generalized scoring rules, respectively, to
anonymous SCFs.
‚àö
Our second result deals with the case when the size of the coalition is c n for small
c, and the transition as c goes from 0 to ‚àû. Here we assume additionally that f is a
generalized scoring rule (to be defined in Section 3.1.1); this is needed because there exist
(pathological) anonymous SCFs for which the result below does not hold (see the beginning
of Section 3 for an example).
Theorem 1.2. Assume that Assumptions 1, 2, 3, and 4 hold, and furthermore that f is a
generalized scoring rule. Then:
(1) The limits q (c), q (c), r (c) and r (c) exist.
(2) There exists a constant K = K (f, Œ¥) < ‚àû such that q (c) ‚â§ Kc; in particular,
limc‚Üí0 q (c) = 0.
(3) For all 0 < c < ‚àû, 0 < q (c) ‚â§ q (c) < 1 and 0 < r (c) ‚â§ r (c) < 1, and furthermore
q (c), q (c), r (c) and r (c) are all continuously differentiable in c with bounded derivative.
In words, Part 2 means that if c is small enough then with probability close to 1 no
‚àö
coalition of size c n can change the outcome of the election, and the statements about
r and r in Part 3 mean that the coalitional manipulation problem has a smooth phase
transition: as the number of manipulators increases, the probabilities that a coalition has
some power, and that it has absolute power, increase smoothly. Parts 1 and 2 of the theorem
simply make a result of Xia and Conitzer (2008b) more precise, by extending the analysis
‚àö
to the Œò( n) regime. More importantly, in the proofs of these statements we introduce the
machinery needed to establish Part 3, which is our main result.
Since the coalitional manipulation problem does not have a sharp phase transition, Theorem 1.2 can be interpreted as suggesting that realistic distributions over votes are likely
to yield coalitional manipulation instances that are tractable in practice, even if the size
‚àö
of the coalition concentrates on the previously elusive Œò( n) regime; this is true for any
generalized scoring rule, and in particular for almost all common social choice functions (an
exception is Dodgson‚Äôs rule). This interpretation has a negative flavor in further strengthening the conclusion that worst-case complexity is a poor barrier to manipulation.
However, the complexity glass is in fact only half empty. The probability that the margin
‚àö
of victory is at most c n is captured by the quantity q n , hence Part 3 of Theorem 1.2 also
implies that the margin of victory problem has a smooth phase transition. As recently
pointed out by Xia (2012a), efficiently solving the margin of victory problem could help
in post-election audits‚Äîused to determine whether electronic elections have resulted in an
incorrect outcome due to software or hardware bugs‚Äîand its tractability is in fact desirable.
The methods we use are flexible, and can be extended to various setups of interest that do
not directly satisfy our assumptions above, for instance single-peaked preferences. Consider
a one-dimensional political spectrum represented by the interval [0, 1], and fix the location
927

Mossel, Procaccia, & RaÃÅcz

of the candidates. Assume voters are uniformly distributed on the interval, independently
of each other. For technical reasons, this distribution does not satisfy our assumptions,
since there will be rankings œÄ ‚àà Sm such that p (œÄ) = 0; however, our tools allow us
to
setting
as well. For instance, if the locations of the m candidates are
 1deal3 with this
	
2m‚àí1
, then our results hold (with appropriate quantitative modifications).
2m , 2m , . . . , 2m
Similarly, if the locations were something else, then there would exist a subset of candidates
who have an asymptotically nonvanishing probability of winning, and the same results hold
restricted to this subset of candidates.
Finally, we discuss the role of tie-breaking in our setup, since this is often an important
issue when studying manipulation. However, since we consider manipulation by coalitions
‚àö
of size c n, ties where there exist a constant number of voters such that if their votes are
changed appropriately there is no longer a tie, are not relevant. Indeed, our tools allow us
to extend the results of Theorem 1.2 to a class of SCFs slightly beyond generalized scoring
rules, and, in particular, these allow for arbitrary tie-breaking rules (see Section 3.2.1 for
details).
1.2 Additional Related Work
A recent line of research with an average-case algorithmic flavor also suggests that manipulation is indeed typically easy; see, e.g., the work of Kelly (1993), Conitzer and Sandholm (2006), Procaccia and Rosenschein (2007b), and Zuckerman et al. (2009) for results
on certain restricted classes of SCFs. A different approach, initiated by Friedgut, Kalai,
Keller and Nisan (2008, 2011), who studied the fraction of ranking profiles that are manipulable, also suggests that manipulation is easy on average; see further the work of Xia and
Conitzer (2008a), Dobzinski and Procaccia (2008), Isaksson, Kindler and Mossel (2012),
and Mossel and RaÃÅcz (2012). We refer to the survey by Faliszewski and Procaccia (2010)
for a detailed history of the surrounding literature. See also related literature in economics,
e.g., the work of Good and Mayer (1975), Chamberlain and Rothschild (1981), and Myatt
(2007).
Recent work by Xia (2012a) is independent from, and closely related to, our work.
As mentioned above, Xia‚Äôs paper is concerned with computing the margin of victory in
elections. He focuses on computational complexity questions and approximation algorithms,
but one of his results is similar to Parts 1 and 2 of Theorem 1.2. However, our analysis is
completely different; our approach facilitates the proof of Part 3 of the theorem, which is our
main contribution. An even more recent (and also independent) manuscript by Xia (2012b)
considers similar questions for generalized scoring rules and captures additional types of
strategic behavior (such as control), but again, crucially, this work does not attempt to
understand the phase transition (nor does it subsume our Theorem 1.1).

2. Large Coalitions
Without further ado, we prove Theorem 1.1. The main idea is to observe that for i.i.d. distributions, the Hamming distance of a random ranking profile from a fixed subset of ranking
profiles concentrates around its mean. The theorem follows from standard concentration
inequalities.
928

A Smooth Transition from Powerlessness to Absolute Power

n , define
Proof of Theorem 1.1. For œÉ, œÉ 0 ‚àà Sm

d œÉ, œÉ

0




1X 
=
1 œÉi 6= œÉi0 ,
n
n

i=1

i.e., d (œÉ, œÉ 0 ) is 1/n times the Hamming distance of œÉ and œÉ 0 . If U is a subset of ranking
profiles and œÉ is a specific ranking profile then define dU (œÉ) = minœÉ0 ‚ààU d (œÉ, œÉ 0 ). The
function dU is Lipschitz with constant 1/n, and therefore by McDiarmid‚Äôs inequality we
have the following concentration inequality:

P (|dU (œÉ) ‚àí EdU | ‚â• c) ‚â§ 2 exp ‚àí2c2 n
(1)
n . Suppose U ‚äÜ S n has measure at least Œµ, i.e., U is such that
for any c > 0 and U ‚äÜ Sm
m
p

‚àö
P (œÉ ‚àà U ) ‚â• Œµ, and take Œ≥ such that 2 exp ‚àí2Œ≥ 2 n < Œµ, e.g., let Œ≥ = log (2/Œµ)/ n. Then
(1) implies that there exists œÉ ‚àà U such that |dU (œÉ) ‚àí EdU | ‚â§ Œ≥, but since dU (œÉ) = 0, this
means that EdU ‚â§ Œ≥. So for such a set U , we have

P (dU (œÉ) > Œ≥ + c) ‚â§ exp ‚àí2c2 n
p
‚àö
for any c > 0. Choosing c = B/ n and defining B 0 = B + log (2/Œµ) we get that

‚àö 
(2)
P dU (œÉ) > B 0 / n ‚â§ exp ‚àí2B 2 .

In the language of the usual Hamming distance, this means that the probability that the
0 ‚àön coordinates to be in U is at most
ranking profile
needs
to
be
changed
in
at
least
B

exp ‚àí2B 2 , which can be made arbitrarily small by choosing B large enough.
By our assumption, P (œÉ ‚àà Wa ) ‚â• Œµ for every a, and therefore by (2) and a union bound
we get

‚àö 
P ‚àÉa : dWa (œÉ) > B 0 / n ‚â§ m exp ‚àí2B 2 .
p
By choosing B = log (2m/Œ∑), this probability is at most Œ∑/2.
‚àö
Consider a specific coalition of size DB 0 n, where D = D (Œ¥, m) will be chosen later.
Using Chernoff‚Äôs bound and a union bound, with probability close to one, for every possible
‚àö
ranking œÄ the coalition has at least B 0 n voters with the ranking œÄ:

‚àö
‚àö
P ‚àÉœÄ ‚àà Sm : coalition of size DB 0 n has less than B 0 n voters with ranking œÄ



‚àö
‚àö 
‚àö
‚â§ m!P Bin DB 0 n, Œ¥ < B 0 n ‚â§ m! exp ‚àí (1 ‚àí 1/DŒ¥)2 DB 0 nŒ¥/2


‚â§ m! exp ‚àí (1 ‚àí 1/DŒ¥)2 DŒ¥/2 ,
‚àö
‚àö
where Bin (DB 0 n, Œ¥) denotes a binomial random variable with parameters DB 0 n and Œ¥,
and where we used our assumption that for every voter the probability for every ranking is
at least Œ¥ > 0. Choosing D = (4/Œ¥) log (2m!/Œ∑), this probability is at most Œ∑/2.
By the anonymity of f , the outcome only depends on the number of voters voting
according to each ranking. Consequently, if œÉ is such that it is at a distance of at most
‚àö
‚àö
B 0 / n away from each Wa , and where for each ranking œÄ there are at least B 0 n voters in
the coalition with ranking œÄ, then the coalition is able to achieve any outcome. Using the
above and a union bound this happens with probability at least 1 ‚àí Œ∑.
929

Mossel, Procaccia, & RaÃÅcz

3. Small Coalitions and the Phase Transition
This section is almost entirely devoted to the proof of Theorem 1.2, but it also includes
some helpful definitions, examples, and intuitions.
Consider the following example of a SCF. For a ‚àà [m] let na (œÉ) denote the number
of votersPwho ranked candidate a on top in the ranking profile œÉ. Define the SCF f by
f (œÉ) = m
a=1 ana (œÉ) mod m. This SCF is clearly anonymous (since it only depends on
the number of voters voting according to specific rankings), and moreover it is easy to see
that any single voter can always elect any candidate.
This example shows that, in general, we cannot have a matching lower bound for the
‚àö
size of the manipulating coalition on the order of n. However, this is an artificial example
(one would not consider such a voting system in real life), and we expect that a matching
lower bound holds for most reasonable SCFs.
Xia and Conitzer (2008b) introduced a large class of SCFs called generalized scoring
rules, which include most commonly occurring SCFs. In the following we introduce this
class of SCFs, provide an alternative way of looking at them (as so-called ‚Äúhyperplane
‚àö
rules‚Äù), and show that for this class of SCFs if the coalition has size c n for small enough
c, then the probability of being able to change the outcome of the election can be arbitrarily
close to zero. At the end of the section we then prove the smooth transition as stated in
Part 3 of Theorem 1.2.
3.1 Generalized Scoring Rules, Hyperplane Rules, and their Equivalence
In this section we introduce generalized scoring rules and hyperplane rules and show their
equivalence.
3.1.1 Generalized Scoring Rules
We now define generalized scoring rules.
Definition 1. For any y, z ‚àà Rk , we say that y and z are equivalent, denoted by y ‚àº z, if
for every i, j ‚àà [k], yi ‚â• yj if and only if zi ‚â• zj .
Definition 2. A function g : Rk ‚Üí [m] is compatible if for any y ‚àº z, g (y) = g (z).
That is, for any function g that is compatible, g (y) is completely determined by the
total preorder of {y1 , . . . , yk } (a total preorder is an ordering in which ties are allowed).
Definition 3 (Generalized scoring rules). Let k ‚àà N, f : Sm ‚Üí Rk (called a generalized
scoring function), and g : Rk ‚Üí [m] where g is compatible (g is called a decision function).
The functions f and g determine the generalized scoring rule GS (f, g) as follows: for
n , let
œÉ ‚àà Sm
!
n
X
GS (f, g) (œÉ) := g
f (œÉi ) .
i=1

From the definition it is clear that every generalized scoring rule (GSR) is anonymous.
930

A Smooth Transition from Powerlessness to Absolute Power

3.1.2 Hyperplane Rules
Preliminaries and notation. In the following, for a SCF let us write f ‚â° fn , i.e., let us
explicitly note that f is a function on n voters; also let us write œÉ ‚â° œÉ n . Since the SCF
fn is anonymous, the outcome only depends on the numbers of voters who vote according
to particular rankings. Let Dn denote the set of points in the probability simplex ‚àÜm! for
which all coordinates are integer multiples of 1/n. Let us denote a typical element of the
probability simplex ‚àÜm! by x = {xœÄ }œÄ‚ààSm . For a ranking profile œÉ n , let us denote the
corresponding element of the probability simplex by x (œÉ n ), i.e., for all œÄ ‚àà Sm ,
1X
1 [œÉi = œÄ] .
n
n

x (œÉ n )œÄ =

i=1

By our assumptions the outcome of fn only depends on x (œÉ n ), so by abuse of notation we
may write that fn : ‚àÜm! |Dn ‚Üí [m] with fn (œÉ n ) = fn (x (œÉ n )).
We are now ready to define hyperplane rules.
Definition 4 (Hyperplane rules). Fix a finite set of affine hyperplanes of the simplex ‚àÜm! :
H1 , . . . , H` . Each affine hyperplane partitions the simplex into three parts: the affine hyperplane itself and two open halfspaces on either side of the affine hyperplane. Thus the affine
hyperplanes H1 , . . . , H` partition the simplex into finitely many (at most 3` ) regions. Let
F : ‚àÜm! ‚Üí [m] be a function which is constant on each such region. Then the sequence of
n ‚Üí [m], defined by
SCFs {fn }n‚â•1 , fn : Sm
fn (œÉ n ) = F (x (œÉ n ))
is called a hyperplane rule induced by the affine hyperplanes H1 , . . . , H` and the function F .
A function F : ‚àÜm! ‚Üí [m] naturally partitions the simplex ‚àÜm! into m parts based on
the outcome of F . (For hyperplane rules this partition is coarser than the partition of ‚àÜm!
induced by the affine hyperplanes H1 , . . . , H` .) We abuse notation and denote these parts
by {Wa }a‚àà[m] . The following definition will be useful for us.
Definition 5 (Interior and boundaries of a partition induced by F ). We say that x ‚àà ‚àÜm!
is an interior point of the partition {Wa }a‚àà[m] induced by F if there exists Œ± > 0 such that
for all y ‚àà ‚àÜm! for which |x ‚àí y| ‚â§ Œ±, we have F (x) = F (y). Otherwise, we say that
x ‚àà ‚àÜm! is on the boundary of the partition, which we denote by B.
For a hyperplane rule the boundary B is contained in the union of the corresponding
affine hyperplanes. Conversely, suppose F : ‚àÜm! ‚Üí [m] is an arbitrary function and the
n ‚Üí [m] is defined by f (œÉ n ) = F (x (œÉ n )).
sequence of (anonymous) SCFs {fn }n‚â•1 , fn : Sm
n
If the boundary B of F is contained in the union of finitely many affine hyperplanes of
‚àÜm! , then F is not necessarily a hyperplane rule, but there exists a hyperplane rule FÃÇ such
that F and FÃÇ agree everywhere except perhaps on the union of the finitely many affine
hyperplanes.
931

Mossel, Procaccia, & RaÃÅcz

3.1.3 Equivalence
Xia and Conitzer (2009) gave a characterization of generalized scoring rules: a SCF is a
generalized scoring rule if and only if it is anonymous and finitely locally consistent (see Xia
& Conitzer, 2009, Definition 5). This characterization is related to saying that generalized
scoring rules are the same as hyperplane rules, yet we believe that spelling this out explicitly
is important, because the geometric viewpoint of hyperplane rules is somewhat different,
and in this probabilistic context it is also more flexible.
Lemma 3.1. The class of generalized scoring rules coincides with the class of hyperplane
rules.
Proof. First let us show that every hyperplane rule is a generalized scoring rule. Let us
consider the hyperplane rule induced by affine hyperplanes H1 , . . . , H` of the simplex ‚àÜm! ,
and the function F : ‚àÜm! ‚Üí [m]. The affine hyperplanes of ‚àÜm! can be thought of as
hyperplanes of Rm! that go through the origin‚Äîabusing notation we also denote these by
H1 , . . . , H` . Let u1 , . . . , u` denote unit normal vectors of these hyperplanes.
n,
We need to define functions f and g such that for every ranking profile œÉ n ‚àà Sm
`+1
`+1
n
n
GS (f, g) (œÉ ) = F (x (œÉ )). We will have f : Sm ‚Üí R
and g : R
‚Üí [m]. Coordinates
1, . . . , ` of f correspond to hyperplanes H1 , . . . , H` , while the last coordinate of f will always
be 0 (this is a technical necessity to make sure that the function g is compatible). Let us
look at the coordinate corresponding to hyperplane Hj with normal vector uj . For œÄ ‚àà Sm
define
(f (œÄ))j ‚â° (f (œÄ))Hj ‚â° (f (œÄ))uj := (uj )œÄ ,
where the coordinates of Rm! are indexed by elements of Sm . Then
n

(f (œÉ ))j :=

n
X
i=1

(f (œÉi ))j =

n
X

(uj )œÉi = n (uj ¬∑ x (œÉ n )) .

i=1

The sign of (f (œÉ n ))j thus tells us which side of the hyperplane Hj the point x (œÉ n ) lies
on. We define g (y) for all y ‚àà R`+1 such that y`+1 = 0; then the requirement that g be
compatible defines g for all y ‚àà R`+1 . For x ‚àà R, define sgn (x) to be 1 if x > 0, ‚àí1 if x < 0,
and 0 if x = 0.
To define g (y1 , . . . , y` , 0), look at the vector (sgn (y1 ) , . . . , sgn (y` )). This vector determines a region in ‚àÜm! in the following way: if sgn (yj ) = 1, then the region lies in the
same open halfspace as uj , if sgn (yj ) = ‚àí1 then the region lies in the open halfspace
which does not contain uj , and finally if yj = 0, then the region lies in the hyperplane
Hj . Now we define g (y1 , . . . , y` , 0) to be the value of F on the region of ‚àÜm! defined by
(sgn (y1 ) , . . . , sgn (y` )). The value of g (y1 , . . . , y` , 0) is well-defined since F is constant in
each such region. Moreover, if we take y ‚àº z with y`+1 = z`+1 = 0, then necessarily
(sgn (y1 ) , . . . , sgn (y` )) = (sgn (z1 ) , . . . , sgn (z` )), and thus g (y) = g (z): so g is compatible
(this is where we used the extra coordinate).
Now let us show that every generalized scoring rule is a hyperplane rule. Suppose a
generalized scoring rule is given by P
functions f : Sm P
‚Üí Rk and g : Rk ‚Üí [m]. For a ranking
n
n
n
n
profile œÉ ‚àà Sm , define f (œÉ ) := i=1 f (œÉi ) = n œÄ‚ààSm f (œÄ) (x (œÉ n ))œÄ ; in this way we
k
can view f as a function mapping Nm!
‚â•0 \ {0} to R (and hence can also view GS (f, g) as a
932

A Smooth Transition from Powerlessness to Absolute Power

function mapping Nm!
‚â•0 \ {0} to [m]). Since this mapping is homogeneous, we may extend
the domain of f (and hence that of GS (f, g)) to Qm!
‚â•0 \ {0} in the natural way.

	
m!
For a total preorder O, let RO = x ‚àà Q‚â•0 \ {0} : f (x) ‚àº O . By definition, if x, y ‚àà RO
then g (f (x)) = g (f (y)), i.e., GS (f, g) is constant in each region RO . Each region RO is
a Q-convex cone, i.e. if x, y ‚àà RO and Œª ‚àà Q ‚à© [0, 1], then Œªx + (1 ‚àí Œª) y ‚àà RO , and
furthermore if ¬µ ‚àà Q>0 , then ¬µx ‚àà RO (both of these properties follow immediately from
Definition 1). Thus we can write Qm!
‚â•0 \ {0} as the disjoint union of the Q-convex cones
{RO }O . The only way to do this is by taking finitely many hyperplanes of Rm! and cutting
Qm!
‚â•0 \ {0} using these hyperplanes; a precise statement of this can be found in Appendix A.
This essentially follows from a result by Kemperman (1986, Thm. 2)‚Äîto keep the paper selfcontained we reproduce in Appendix A his results and proof, and show how the statement
above follows from his results. Since our function is homogeneous, we need only look at
m!
the values
 of GSm!(f,
	 g) on the simplex ‚àÜ . Bym!the above, the simplex is divided into
regions RO ‚à© ‚àÜ
via affine hyperplanes of ‚àÜ , and the function GS (f, g) is constant
O
m!
on RO ‚à© ‚àÜ for each total preorder O, so GS (f, g) is indeed a hyperplane rule.
3.1.4 Examples
Most commonly used SCFs are generalized scoring rules / hyperplane rules, including
all positional scoring rules, instant-runoff voting, Coombs‚Äô method, contingent vote, the
KemeÃÅny-Young method, Bucklin voting, Nanson‚Äôs method, Baldwin‚Äôs method, Copeland‚Äôs
method, maximin, and ranked pairs. Some of these examples were already shown by Xia
and Conitzer (2008b, 2009), but nevertheless in Appendix B we detail explanations of many
of these examples. The main reason for this is that the perspective of a hyperplane rule
arguably makes these explanations simpler and clearer. A rule that does not fit into this
framework is Dodgson‚Äôs rule, which is not homogeneous (see, e.g., Brandt, 2009), and therefore it is not a hyperplane rule.
3.2 Small Coalitions for Generalized Scoring Rules
‚àö
We now show that for generalized scoring rules, a coalition of size c n for small enough
c can only change the outcome of the election with small probability. By the equivalence
above, we can work in the framework of hyperplane rules.
We consider two metrics on ‚àÜm! : the L1 metric, denoted by d1 or k¬∑k1 , and the L2
metric, denoted by d2 or k¬∑k2 . The L1 metric is important in this setting, since changing
the votes of voters corresponds to moving in the L1 metric on ‚àÜm! ; this connection is
formalized in the following lemma.
n . Then d (x (œÉ n ) , x (œÑ n )) ‚â§ 2 d (œÉ n , œÑ n ), where d
Lemma 3.2. Let œÉ n , œÑ n ‚àà Sm
1
H denotes
n H
P
Hamming distance, i.e., dH (œÉ n , œÑ n ) = ni=1 1 [œÉi 6= œÑi ]. Furthermore, if y ‚àà Dn , then there
n such that x (œÑÃÇ n ) = y and d (x (œÉ n ) , y) = 2 d (œÉ n , œÑÃÇ n ).
exists œÑÃÇ n ‚àà Sm
1
n H

Proof. Let œÄ 0 = œÉ n , and for i = 1, . . . , n, define the ranking profile œÄ i as
œÄ i = (œÑ1 , . . . , œÑi , œÉi+1 , . . . , œÉn ) .
933

Mossel, Procaccia, & RaÃÅcz

By definition, œÄ n = œÑ n . The desired inequality then follows from the triangle inequality:
n
 X



d1 (x (œÉ n ) , x (œÑ n )) = d1 x œÄ 0 , x (œÄ n ) ‚â§
d1 x œÄ i‚àí1 , x œÄ i
i=1
n
X
2
2
1 [œÉi 6= œÑi ] = dH (œÉ n , œÑ n ) .
=
n
n
i=1

For the second part of the lemma, construct œÑÃÇ n as follows. For each œÄ ‚àà Sm , let IœÄ :=
{i ‚àà [n] : œÉi = œÄ}. If x (œÉ n )œÄ ‚â§ yœÄ , then for every i ‚àà IœÄ , let œÑÃÇi = œÄ. If x (œÉ n )œÄ > yœÄ , then
choose a subset of indices IœÄ0 ‚äÇ IœÄ of size |IœÄ0 | = nyœÄ , and for every i ‚àà IœÄ0 , let œÑÃÇi = œÄ. Finally,
define the rest of the coordinates of œÑÃÇ n so that x (œÑÃÇ n ) = y. The construction guarantees
that then d1 (x (œÉ n ) , y) = n2 dH (œÉ n , œÑÃÇ n ).
It is therefore natural to define distances from the boundary B using the L1 metric:
Definition 6 (Blowup of boundary). For Œ± > 0, we define the blowup of the boundary B
by Œ± to be
n
o
B +Œ± = y ‚àà ‚àÜm! : ‚àÉx ‚àà B such that kx ‚àí yk1 ‚â§ Œ± .
In order for some coalition to be able to change the outcome of the election at a given
ranking profile, the point on the simplex corresponding to this ranking profile needs to be
sufficiently close to the boundary B; this is formulated in the following lemma.
Lemma 3.3. Suppose we have n voters, a coalition of size k, and the ranking profile is
n , which corresponds to the point x (œÉ n ) ‚àà ‚àÜm! on the probability simplex. A
œÉ n ‚àà Sm
necessary condition for the coalition to be able to change the outcome of the election from
this position is that x (œÉ n ) ‚àà B +2k/n . Conversely, if x (œÉ n ) ‚àà B +(2k‚àím!)/n , then there exists
a coalition of size k that can change the outcome of the election.
Proof. For any ranking profile œÑ n that the coalition can reach, we have dH (œÉ n , œÑ n ) ‚â§ k,
n / B +2k/n , then for every
and so by Lemma 3.2 we have d1 (x (œÉ n ) , x (œÑ n )) ‚â§ 2k
n . If x (œÉ ) ‚àà
ranking profile œÑ n which the coalition can reach, x (œÉ n ) and x (œÑ n ) are in the same region
determined by the hyperplanes, and so F (x (œÑ n )) = F (x (œÉ n )), i.e., the coalition cannot
change the outcome of the election.
Now suppose that x (œÉ n ) ‚àà B +(2k‚àím!)/n . Then by definition there exists y ‚àà B such
m!
that d1 (x (œÉ n ) , y) ‚â§ 2k‚àím!
n . Since y ‚àà B, there exists yÃÇ ‚àà Dn such that d1 (y, yÃÇ) ‚â§ n and
F (yÃÇ) 6= F (x (œÉ n )). By the triangle inequality, d1 (x (œÉ n ) , yÃÇ) ‚â§ 2k
n , and then by the second
n such that x (œÑÃÇ n ) = yÃÇ and d (œÉ n , œÑÃÇ n ) ‚â§ k. The
part of Lemma 3.2 there exists œÑÃÇ n ‚àà Sm
H
coalition consisting of voters with indices in I := {i ‚àà [n] : œÉi 6= œÑÃÇi } can thus change the
outcome of the election.
Corollary 3.4. If we have n voters, the probability that some coalition of size k can change
the outcome of the election is bounded from below by P x (œÉ n ) ‚àà B +(2k‚àím!)/n and from

above by P x (œÉ n ) ‚àà B +2k/n , where œÉ n is drawn according to the probability distribution
satisfying the conditions of the setup.
934

A Smooth Transition from Powerlessness to Absolute Power

Gaussian limit. Due to the i.i.d.-ness of the votes, the multinomial random variable x (œÉ n )
concentrates around its expectation, and the rescaled random variable
xÃÉ (œÉ n ) :=

‚àö

n (x (œÉ n ) ‚àí E (x (œÉ n )))

converges to a normal distribution, with zero mean and specific covariance structure. For
our analysis it is better to use this Gaussian picture, and thus we will reformulate the
preliminaries above in this limiting setting. First, let us determine the limiting distribution.
Lemma 3.5. We have xÃÉ (œÉ n ) ‚áín N (0, Œ£), where the covariance structure is given by
Œ£ = diag (p) ‚àí ppT , where recall that p is the distribution of a vote.
Proof. It is clear P
that E (xÃÉ (œÉ n )) = 0. Computing the
 covariance structure, we first have
1
2
that E xœÄ = n2 ni,j=1 P (œÉi = œÄ, œÉj = œÄ) = 1 ‚àí n1 p (œÄ)2 + n1 p (œÄ), from which we have


Var (xœÄ ) = n1 p (œÄ) ‚àí p (œÄ)2 and thus Var (xÃÉœÄ ) = p (œÄ) ‚àí p (œÄ)2 . Then similarly for œÄ 6= œÄ 0
we have


n



1 X
1 X
1
0
0
E (xœÄ xœÄ0 ) = 2
p (œÄ) p œÄ 0 ,
P œÉi = œÄ, œÉj = œÄ = 2
p (œÄ) p œÄ = 1 ‚àí
n
n
n
i,j=1

i6=j

from which we have that Cov (xœÄ , xœÄ0 ) = ‚àí n1 p (œÄ) p (œÄ 0 ) and thus

Cov (xÃÉœÄ , xÃÉœÄ0 ) = ‚àíp (œÄ) p œÄ 0 .
Note: because of the concentration of x (œÉ n ) around its mean, and our assumption that
for every n and for every candidate a ‚àà [m], P (f (œÉ n ) = a) ‚â• Œµ, it is necessary that for every
Œ± > 0 and for every candidate a ‚àà [m] there exists y ‚àà ‚àÜm! such that ky ‚àí E (x (œÉ1 ))k1 ‚â§ Œ±
and F (y) = a.
Denote by ¬µ the distribution of N (0, Œ£) and let XÃÉ denote a random variable distributed
according to ¬µ. Note that ¬µ is a degenerate multivariate normal distribution, as the support
of ¬µ concentrates on the hyperplane H0 where the coordinates sum to zero. (This is because
P
n
œÄ‚ààSm xÃÉ (œÉ )œÄ = 0.)
The underlying function F : ‚àÜm! ‚Üí [m] corresponds to a function FÃÉ : Rm! |H0 ‚Üí [m]
in the Gaussian limit, and this functionnFÃÉ partitions
Rm! |H0 into m parts based on the
o
outcome of FÃÉ . We denote these parts by WÃÉa
. We will need the following definitions
a‚àà[m]

and properties of boundaries, analogous to those above.
Definition 7 (Interior and boundaries
of a partition). We say that xÃÉ ‚àà Rm! |H0 is an
n o
interior point of the partition WÃÉa
induced by FÃÉ if there exists Œ± > 0 such that for
a‚àà[m]

all yÃÉ ‚àà R |H0 for which kxÃÉ ‚àí yÃÉk1 ‚â§ Œ±, we have FÃÉ (xÃÉ) = FÃÉ (yÃÉ). Otherwise, we say that
xÃÉ ‚àà Rm! |H0 is on the boundary of the partition, which we denote by BÃÉ.
m!

Lemma 3.6. If the boundary B comes from a hyperplane rule, i.e., B is contained in the
union of ` affine hyperplanes in ‚àÜm! , then BÃÉ is contained in the union of `Àú hyperplanes of
Rm! |H0 , where `Àú ‚â§ `.
935

Mossel, Procaccia, & RaÃÅcz

Proof. Two things can happen to an affine hyperplane H of ‚àÜm! when we take the Gaussian
limit: (1) if E (x (œÄ)) ‚àà H, then translation by E (x (œÄ)) takes H into a hyperplane HÃÉ of
‚àö
Rm! |H0 , and since HÃÉ goes through the origin, scaling (in particular by n) does not move
this hyperplane; (2) if E (x (œÄ)) ‚àà
/ H, then translation by E (x (œÄ)) takes H into an affine
‚àö
m!
hyperplane HÃÉ of R |H0 that does not go through the origin, and then scaling by n moves
HÃÉ to an affine hyperplane of Rm! |H0 whose L2 distance from the origin is proportional to
‚àö
n, so in the n ‚Üí ‚àû limit this affine hyperplane ‚Äúvanishes‚Äù.
Definition 8 (Blowup of boundary). For Œ± > 0, we define the blowup of the boundary BÃÉ
by Œ± to be
n
o
BÃÉ +Œ± = yÃÉ ‚àà Rm! |H0 : ‚àÉxÃÉ ‚àà BÃÉ such that kxÃÉ ‚àí yÃÉk1 ‚â§ Œ± .
‚àö
Let us focus specifically on a coalition of size c n for some (small) constant c. Corollary 3.4 implies the following.
Corollary 3.7. For hyperplane rules the limit of the probability that in an election
with n

‚àö
voters some coalition of size c n can change the outcome of the election is ¬µ XÃÉ ‚àà BÃÉ +2c .
The following claim, together with Corollary 3.7, tells us that for hyperplane rules a
‚àö
coalition of size c n can change the outcome of the election with only small probability,
given that c is sufficiently small, proving Part 2 of Theorem 1.2.
n oM
Claim 3.8. Suppose our SCF is a hyperplane rule, and in particular let HÃÉi
be a
i=1
S
collection of hyperplanes in Rm! |H0 such that BÃÉ ‚äÜ M
i=1 HÃÉi . Then

 r 2 Mc
+c
‚àö .
¬µ XÃÉ ‚àà BÃÉ
‚â§
œÄ Œ¥
Proof. By our condition and a union bound we have
M

 X


+c
¬µ XÃÉ ‚àà BÃÉ
‚â§
¬µ XÃÉ ‚àà HÃÉi+c .
i=1

For a hyperplane HÃÉ in Rm! |H0 , denote (one of) the corresponding unit normal vector(s) (in
the hyperplane H0 ) by u. Then
n
o
HÃÉ = xÃÉ ‚àà Rm! |H0 : u ¬∑ xÃÉ = 0
and since L1 distance is always greater than L2 distance, we have
n
o n
o
HÃÉ +c ‚äÜ xÃÉ ‚àà Rm! |H0 : ‚àÉyÃÉ ‚àà HÃÉ such that kxÃÉ ‚àí yÃÉk2 ‚â§ c = xÃÉ ‚àà Rm! |H0 : |u ¬∑ xÃÉ| ‚â§ c .
Since XÃÉ is a multidimensional Gaussian r.v., u ¬∑ XÃÉ is a one-dimensional Gaussian r.v. (which
is centered). Therefore




2c
¬µ XÃÉ ‚àà HÃÉ +c ‚â§ ¬µ u ¬∑ XÃÉ ‚àà [‚àíc, c] ‚â§ r

.
2œÄ Var u ¬∑ XÃÉ
936

A Smooth Transition from Powerlessness to Absolute Power

We have that




2


Var u ¬∑ XÃÉ = E u ¬∑ XÃÉ = E uT XÃÉ XÃÉ T u = uT Œ£u,

and so all that remains to show is that
min
u:kuk=1,u‚ä•1

uT Œ£u ‚â• Œ¥,

where 1 is the m!-dimensional vector having 1 in every coordinate.
Let Œª1 (Œ£) ‚â• Œª2 (Œ£) ‚â• ¬∑ ¬∑ ¬∑ ‚â• Œªm! (Œ£) denote the eigenvalues of Œ£. Since Œ£ is positive
semidefinite, all eigenvalues are nonnegative. We know that 0 is an eigenvalue of Œ£ (the
corresponding eigenvector is 1), so Œªm! (Œ£) = 0. By the variational characterization of
eigenvalues we have
min
uT Œ£u = Œªm!‚àí1 (Œ£) ,
u:kuk=1,u‚ä•1

and so we need to show that Œªm!‚àí1 (Œ£) ‚â• Œ¥. To do this we use Weyl‚Äôs inequalities.
Lemma 3.9 (Weyl‚Äôs inequalities). For an n √ó n matrix M let Œª1 (M ) ‚â• Œª2 (M ) ‚â• ¬∑ ¬∑ ¬∑ ‚â•
Œªn (M ) denote its eigenvalues. If A and C are n √ó n symmetric matrices then
Œªj (A + C) ‚â§ Œªi (A) + Œªj‚àíi+1 (C)

if i ‚â§ j,

Œªj (A + C) ‚â• Œªi (A) + Œªj‚àíi+n (C)

if i ‚â• j.

We use Weyl‚Äôs inequality for A = diag (p) and C = ‚àíppT . The eigenvalues of A are
{p (œÄ)}œÄ‚ààSm , all of which are no less than Œ¥. Since C has rank 1, all its eigenvalues but one are
zero, and the single nonzero eigenvalue is Œªm! (C) = ‚àípT p. Since Œ£ = diag (p)‚àíppT = A+C,
Weyl‚Äôs inequality tells us that

Œªm!‚àí1 (Œ£) ‚â• Œªm! (diag (p)) + Œªm!‚àí1 ‚àíppT ‚â• Œ¥ + 0 = Œ¥.
‚àö
This implies that we have a lower bound of ‚Ñ¶ ( n) for the size of the coalition needed in
order to change the outcome of the election for hyperplane rules. As mentioned before, most
commonly occurring SCFs are in this class of rules: see Appendix B for many examples.
3.2.1 ‚ÄúAlmost‚Äù Hyperplane Rules
Furthermore, the Gaussian limiting setting above is not sensitive to small changes to the
voting rule for finite n. Consequently, for SCFs that are ‚Äúalmost‚Äù hyperplane rules (in a
‚àö
sense we make precise below), the same conclusion holds: a coalition of size ‚Ñ¶ ( n) is needed
in order to be able to change the outcome of the election with non-negligible probability.
In particular, the same result holds for SCFs with arbitrary tie-breaking rules for ranking
profiles which lie on one of the hyperplanes (e.g., the tie-breaking rule can depend on the
number of voters n).
Definition 9 (‚ÄúAlmost‚Äù hyperplane rules). Fix a finite set of affine hyperplanes of the
simplex ‚àÜm! : H1 , . . . , H` . These partition the simplex into finitely many regions. Let F :
‚àÜm! ‚Üí [m] be a function which is constant on each such region, and let B denote the
937

Mossel, Procaccia, & RaÃÅcz

n ‚Üí [m], is called an
induced boundary. Then the sequence of SCFs {fn }n‚â•1 , fn : Sm
‚àö
‚Äúalmost‚Äù hyperplane rule if for every œÉ n such that x (œÉ n ) ‚àà
/ B +o(1/ n) , we have

fn (œÉ n ) = F (x (œÉ n )) .
This SCF is called an ‚Äúalmost‚Äù hyperplane rule induced by the affine hyperplanes H1 , . . . , H`
and the function F .
n ‚Üí [m], is an ‚Äúalmost‚Äù
Lemma 3.10. Suppose the sequence of SCFs {fn }n‚â•1 , fn : Sm
hyperplane rule defined by ` hyperplanes. Then in the Gaussian limiting setting the boundary
BÃÉ is contained in the union of `Àú hyperplanes of Rm! |H0 , where `Àú ‚â§ `.
‚àö

Proof. For finite n, the induced boundary of fn in the simplex ‚àÜm! is contained in B +o(1/ n) ,
‚àö
‚àö
by definition. Since in the Gaussian limit we scale by n, the blowup by o (1/ n) of the
boundary B disappears in the limit, and hence we are back to the situation of Lemma 3.6.
Consequently, the affine hyperplanes corresponding to our ‚Äúalmost‚Äù hyperplane rule either
‚Äúdisappear to infinity‚Äù or become hyperplanes of Rm! |H0 .
Corollary 3.11. Corollary 3.7 and Claim 3.8 hold for ‚Äúalmost‚Äù hyperplane rules as well.
3.3 Smoothness of the Phase Transition
In this final subsection our goal is to show Parts 1 and 3 of Theorem 1.2. The existence
of the limits in Part 1 follows immediately from the Gaussian limit described above; we do
not detail this, but rather give formulas for these limiting probabilities. These then imply
the properties described in Part 3 of the theorem.
In the following let the hyperplane rule be given by affine hyperplanes H1 , . . . , H` of
‚àÜm! and the function F : ‚àÜm! ‚Üí [m]; in the limiting setting denote by HÃÉ1 , . . . , HÃÉ`Àú the
corresponding hyperplanes of Rm! |H0 and denote by FÃÉ : Rm! |H0 ‚Üí [m] the corresponding
function.
3.3.1 The Quantities q and q
For xÃÉ ‚àà Rm! |H0 define
Œ± (xÃÉ) :=

inf

d1 (xÃÉ, yÃÉ) ,

Œ≤ (xÃÉ) := max

inf

a‚àà[m] yÃÉ:FÃÉ (yÃÉ)=a

yÃÉ:FÃÉ (yÃÉ)6=FÃÉ (xÃÉ)

d1 (xÃÉ, yÃÉ) .

From the previous subsection it is then immediate that we can write

 

q (c) = ¬µ XÃÉ : Œ± XÃÉ ‚â§ 2c ,

 

q (c) = ¬µ XÃÉ : Œ≤ XÃÉ ‚â§ 2c .
It is important to note that the boundary BÃÉ is contained in the union of finitely many
hyperplanes, HÃÉ1 , . . . , HÃÉ`Àú, and thus the regions where FÃÉ is constant are convex cones which
are the intersection of finitely many halfspaces.

Consequently Œ± (xÃÉ) is either d1 (xÃÉ,0), where

m!
Àú where d1 xÃÉ, HÃÉj =
0 denotes the origin of R , or it is d1 xÃÉ, HÃÉj for some 1 ‚â§ j ‚â§ `,
938

A Smooth Transition from Powerlessness to Absolute Power

inf yÃÉ‚ààHÃÉj d1 (xÃÉ, yÃÉ). If we scale xÃÉ by some positive constant Œª, then the distance from the origin


and from every hyperplane scales as well (i.e., d1 (ŒªxÃÉ, 0) = Œªd1 (xÃÉ, 0) and d1 ŒªxÃÉ, HÃÉj =


Œªd1 xÃÉ, HÃÉj ), and thus for every Œª > 0, we have Œ± (ŒªxÃÉ) = ŒªŒ± (xÃÉ). Consequently, if we
write xÃÉ = kxÃÉk2 sÃÉ, where sÃÉ ‚àà S m!‚àí1 , and S m!‚àí1 denotes the (m! ‚àí 1)-sphere (not to be
n , the set of ranking profiles on n voters and m candidates), then we have
confused with Sm
Œ± (xÃÉ) = kxÃÉk2 Œ± (sÃÉ).
The same scaling property holds for Œ≤ as well, and hence we have
   


 
(3)
q (c) = ¬µ XÃÉ : XÃÉ  Œ± SÃÉ ‚â§ 2c ,
 2  


 
q (c) = ¬µ XÃÉ : XÃÉ  Œ≤ SÃÉ ‚â§ 2c .
(4)
2

Recall that our condition that for every a ‚àà [m], P (f (œÉ) = a) ‚â• Œµ, implies that for every
Œ∑ > 0 and for every a ‚àà [m] there exists xÃÉ ‚àà Rm! |H0 such that kxÃÉk2 ‚â§ Œ∑ and FÃÉ (xÃÉ) = a.
Consequently for every xÃÉ ‚àà Rm! |H0 we must‚àö
have Œ± (xÃÉ) ‚â§ d1‚àö(xÃÉ, 0) and Œ≤ (xÃÉ) ‚â§ d1 (xÃÉ, 0).
‚àö In
m!‚àí1
particular, for sÃÉ ‚àà S
we have d1 (sÃÉ, 0) ‚â§ m!d2 (sÃÉ, 0) = m! and so Œ± (sÃÉ) , Œ≤ (sÃÉ) ‚â§ m!.
This immediately implies that for every c > 0 we have


 
2c
 
q (c) ‚â• ¬µ XÃÉ : XÃÉ  ‚â§ ‚àö
> 0.
2
m!
To show that q (c) < 1, note that since the boundary is contained in the union of finitely
many hyperplanes, there exists sÃÉ‚àó ‚àà S m!‚àí1 such that Œ± (sÃÉ‚àó ) > 0. By continuity of Œ±, there
exists a neighborhood U ‚äÜ S m!‚àí1 of sÃÉ‚àó such that for every sÃÉ ‚àà U , Œ± (sÃÉ) ‚â• Œ± (sÃÉ‚àó ) /2. For
4c
any xÃÉ such that xÃÉ/ kxÃÉk2 ‚àà U and kxÃÉk2 > Œ±(sÃÉ
‚àó ) , we have
Œ± (xÃÉ) = kxÃÉk2 Œ± (xÃÉ/ kxÃÉk2 ) >

4c Œ± (sÃÉ‚àó )
= 2c.
Œ± (sÃÉ‚àó ) 2

So consequently


 
 
 
 
q (c) ‚â§ 1 ‚àí ¬µ XÃÉ : XÃÉ/ XÃÉ  ‚àà U, XÃÉ  >
2

2

4c
Œ± (sÃÉ‚àó )


< 1.

Finally, the fact that q (c) and q (c) are continuously differentiable follows from the
formulas (3) and (4), since q (c) and q (c) are both written as the Gaussian volume of a
subset of Rm! |H0 , and in both cases this subset grows continuously as c increases. The
derivative of both q (c) and q (c) is bounded at zero (by Corollary 3.7 and Claim 3.8), while
as c ‚Üí ‚àû the derivative approaches zero, and since the derivative is continuous, it must be
bounded by a constant for the whole half-line.
3.3.2 The Quantities r and r

‚àö
In the previous setup when the coalition of size c n was not specified, the ranking profile
‚àö
could be changed arbitrarily within a Hamming ball of radius c n. On the probability
‚àö
simplex ‚àÜm! this corresponded to an L1 ball of radius 2c/ n, and in the rescaled limiting
939

Mossel, Procaccia, & RaÃÅcz

setting it corresponded to an L1 ball in Rm! |H0 of radius 2c. When the coalition of size
‚àö
c n is specified, things are slightly different. In particular, when we look at the probability
distribution on the probability simplex ‚àÜm! induced by the distribution on ranking profiles
(or, in the limiting setting, the Gaussian distribution on Rm! |H0 ), then we have lost track of
the votes of any specific coalition. Nonetheless, the Gaussian limiting setting still provides
formulas for the limiting probabilities r (c) and r (c).
‚àö
We can first
‚àö draw a random ranking profile for the other n ‚àí c n voters not in the
coalition, œÉ n‚àíc n , and then the voters in the coalition can set their votes arbitrarily. The
question is, how can the coalition affect the outcome of the vote? In particular, (a) can
they change the outcome of the election, and (b) can they
 candidate?
 elect‚àö any
‚àö
The ranking profile œÉ n‚àíc n corresponds to a point x œÉ n‚àíc n on the probability simplex ‚àÜm! , and by setting their votes
can move this point on the probability
 the‚àöcoalition

n‚àíc
n
simplex in some neighborhood of x œÉ
. We omit the calculation for finite n and only
present the result in the limiting setting.
Suppose the limiting ranking profile of the voters other than the coalition corresponds
to the point xÃÉ ‚àà Rm! |H0 . Then the set of points the coalition can reach is the following:
n
o
Rc (xÃÉ) := yÃÉ ‚àà Rm! |H0 : ‚àÄœÄ ‚àà Sm : yÃÉœÄ ‚àí xÃÉœÄ + cp (œÄ) ‚â• 0 .
We can then define

n
o
œï (xÃÉ) := inf Œ≥ : ‚àÉyÃÉ ‚àà RŒ≥ (xÃÉ) such that FÃÉ (yÃÉ) 6= FÃÉ (xÃÉ) ,
n
o
œà (xÃÉ) := inf Œ≥ : ‚àÄa ‚àà [m] ‚àÉyÃÉ ‚àà RŒ≥ (xÃÉ) such that FÃÉ (yÃÉ) = a ,

and it follows immediately that we can then write

 

r (c) = ¬µ XÃÉ : œï XÃÉ ‚â§ c ,

 

r (c) = ¬µ XÃÉ : œà XÃÉ ‚â§ c .
In the same way as in Section 3.3.1 one can argue that œï and œà scale: if Œª > 0 then
œï (ŒªxÃÉ) = Œªœï (xÃÉ) and œà (ŒªxÃÉ) = Œªœà (xÃÉ). Hence we have
   


 
r (c) = ¬µ XÃÉ : XÃÉ  œï SÃÉ ‚â§ c ,
(5)
 2  


 
r (c) = ¬µ XÃÉ : XÃÉ  œà SÃÉ ‚â§ c .
(6)
2

For every 0 < c < ‚àû we have r (c) ‚â§ q (c) < 1 (using Section 3.3.1). Let us now show that
also r (c) > 0. We claim that for all sÃÉ ‚àà S m!‚àí1 |H0 , œà (sÃÉ) ‚â§ 2Œ¥ . This follows from the fact
that if sÃÉ ‚àà S m!‚àí1 |H0 then S m!‚àí1 |H0 ‚äÜ R 2 (sÃÉ), which is true because if yÃÉ ‚àà S m!‚àí1 |H0 then
Œ¥

for all œÄ ‚àà Sm , yÃÉœÄ ‚àí sÃÉœÄ + 2Œ¥ p (œÄ) ‚â• ‚àí1 ‚àí 1 + 2Œ¥ Œ¥ = 0. Thus we have


 
cŒ¥
 
r (c) ‚â• ¬µ XÃÉ : XÃÉ  ‚â§
>0
2
2
as claimed.
940

A Smooth Transition from Powerlessness to Absolute Power

Finally, the fact that r (c) and r (c) are continuously differentiable follows from the
formulas (5) and (6) using an argument given above: r (c) and r (c) are written as the
Gaussian volume of subsets of Rm! |H0 , and these subsets grow continuously as c increases.
The derivative of both r (c) and r (c) is bounded at zero (by Corollary 3.7 and Claim 3.8),
while as c ‚Üí ‚àû the derivative approaches zero, and since the derivative is continuous, it
must be bounded by a constant for the whole half-line.

Acknowledgments
We thank anonymous referees for helpful comments. E.M. is supported by NSF (DMS
1106999) and by DOD ONR grant N000141110140, and M.Z.R. is supported by a UC
Berkeley Graduate Fellowship and by NSF (DMS 0548249).

Appendix A. Decomposing Rd as the Disjoint Union of Finitely Many
Convex Cones: Only Via Hyperplanes
In order for the paper to be self-contained, we reproduce here the main definitions and
results of Kemperman (1986) that make precise the claim used in the proof of Lemma 3.1
that the only way to decompose Qd‚â•0 \ {0} into the disjoint union of finitely many Q-convex
cones is via hyperplanes. Kemperman‚Äôs paper deals with convex sets in general, but here
we summarize the results about convex cones that are relevant to us. Kemperman‚Äôs results
pertain to finite dimensional linear spaces and we will state them in this form; in the end
we show how results for Rd‚â•0 follow immediately from these, and as a consequence we also
obtain the claim used in the proof of Lemma 3.1.
Let us start with the main definitions. In the following, all linear spaces are over the
reals and are finite dimensional. Let X be a linear space. A convex cone is a subset K ‚äÜ X
such that x, y ‚àà K and Œª > 0 imply x + y ‚àà K and Œªx ‚àà K. (We do not require that
0 ‚àà K.) For a set A ‚äÜ X, denote its affine hull by aff (A), its convex hull by cvx (A), and
its closure by cl (A). Note that if K ‚äÜ X is a convex cone, then aff (K) is a linear subspace
of X.
We define two special types of convex cones: basic convex cones and elementary convex
cones.
Definition 10 (Basic convex cone). Let K be a convex cone in a finite dimensional linear
space X. We say that K is a basic convex cone (in X) if K is a member K = K0 of some
partition
Àô 1 ‚à™Àô . . . ‚à™K
Àô r
X = K0 ‚à™K
of X into finitely many disjoint convex cones {Ki }ri=0 .
Note that any linear subspace Y of X is a basic convex cone, from which it immediately
follows that K is a basic convex cone in X if and only if it is a basic convex cone in aff (K).
In order to define elementary convex cones, we need a few more definitions.
Definition 11 (Open polyhedral convex cone). Let K be a convex cone in a finite dimensional linear space X. We say that K is an open polyhedral convex cone relative to X if K
941

Mossel, Procaccia, & RaÃÅcz

can be expressed as the intersection of finitely many open halfspaces H1 , . . . , H` of X, each
of which has the origin on its boundary. The whole linear space X is an open polyhedral
convex cone with ` = 0.
Definition 12 (Relatively open polyhedral convex cone). Let K be a convex cone in a
finite dimensional linear space X. Then K is a relatively open polyhedral convex cone if
either K = ‚àÖ or K is an open polyhedral convex cone relative to aff (K).
Definition 13 (Elementary convex cone). Let K be a convex cone in a finite dimensional
linear space X. We say that K is an elementary convex cone if K can be represented as a
disjoint union of finitely many relatively open polyhedral convex cones.
The main result of Kemperman concerning convex cones is the following (Kemperman,
1986, Thm. 2).
Theorem A.1. Let K be a convex cone in Rd . Then K is a basic convex cone if and only
if it is an elementary convex cone.
In Lemma 3.1 we only use the ‚Äúonly if‚Äù direction, and we thus leave the proof of the
‚Äúif‚Äù direction as an exercise for the reader.
Proof of ‚Äúonly if ‚Äù direction. Let X be a finite dimensional linear space and let K be a basic
convex cone in X of dimension d = dim (K) = dim (Y ), where Y = aff (K). We prove by
induction on d the following:
(i) The relative interior of K, denoted by K 0 , is a relatively open polyhedral convex cone.
(ii) If K 0 6= Y , then denote by F1 , . . . , F` the (d ‚àí 1)-dimensional hyperplanes
 in Y cor0
responding to the finitely many faces of the polyhedron cl (K) = cl K . Then the
convex cones Fi ‚à© K, i = 1, . . . , `, are elementary convex cones of dimension at most
d ‚àí 1 (but they need not be disjoint).
(iii) The convex cone K is also an elementary convex cone.
If K = ‚àÖ, then properties (i) - (iii) hold. If d = 0, then necessarily K = {0}, since K is
a convex cone, and again K satisfies properties (i) - (iii) above.
So we may assume that d ‚â• 1 and that each basic convex cone of dimension at most
d ‚àí 1 satisfies properties (i) - (iii) above. Since K is a basic convex cone, there exists a
partition
Àô 1 ‚à™Àô . . . ‚à™K
Àô r
Y = K0 ‚à™K
(7)
of Y into finitely many disjoint convex cones {Kj }rj=0 , with K0 = K. We may assume that
r ‚â• 0 is minimal, and hence the Kj are non-empty. Note that K 0 is also non-empty since
dim (K) = dim (Y ).
If r = 0 then K = K0 = Y and the properties (i) - (iii) above are immediately satisfied,
so we may assume that r ‚â• 1. For j = 1, . . . , r, let Hj be a hyperplane in Y which separates
the convex cone K = K0 with non-empty interior K 0 from the non-empty convex cone Kj .
(Such hyperplanes exist by the hyperplane separation theorem, and, moreover, each such
hyperplane goes through the origin, because each Kj contains at least one point from every
942

A Smooth Transition from Powerlessness to Absolute Power

open ball around the origin, since each Kj is a cone.) Let Hj0 be the associated open half
space in Y which contains the interior K 0 of K. Let
L0 = H10 ‚à© ¬∑ ¬∑ ¬∑ ‚à© Hr0 .
Then L0 is a polyhedral convex cone, which is open relative to Y , and contains the interior
K 0 of K.
We claim that L0 = K 0 . It is enough to show that L0 ‚äÜ K, because then L0 ‚äÜ K 0
follows from the definition of K 0 . Suppose on the contrary that there exists x ‚àà L0 such
that x ‚àà
/ K. Then from the partition (7) there must exist an index 1 ‚â§ j ‚â§ r with x ‚àà Kj .
/ L0 , which is a contradiction. This proves (i).
This implies that x ‚àà
/ Hj0 and thus x ‚àà
Now let us show (ii). By (7), we can write the linear space Fi as the disjoint union of
the convex cones Fi ‚à© Kj , j = 0, . . . , r, and thus Fi ‚à© K is a basic convex cone and hence,
by induction, an elementary convex cone.
Finally, let us show that K is an elementary convex cone. Since K 0 is a polyhedral
convex cone which is open relative to Y , it only remains to show that K \ K 0 can be written
as a finite disjoint union of relatively open polyhedral convex cones. By (ii), we can write
K \ K 0 as the finite union of elementary convex cones:
K \ K 0 = ‚à™`i=1 (Fi ‚à© K) ,
so what remains is to show that we can write this as a finite disjoint union of relatively
open polyhedral convex cones. We may assume w.l.o.g. that Fi ‚à© K 6= ‚àÖ for all i and that
(Fi ‚à© K) * (Fj ‚à© K) for all i 6= j (otherwise we can leave out Fi ‚à© K from the union).
We claim that then for every i,
[
(Fj ‚à© Fi ‚à© K) ,
(8)
rel int (Fi ‚à© K) ‚äÜ (Fi ‚à© K) \
j6=i

from which it immediately follows that rel int (Fi ‚à© K) ‚à© rel int (Fj ‚à© K) = ‚àÖ for i 6= j. To
show (8), let the two open halfspaces on either side of the hyperplane Fj be denoted by
Fj+ and Fj‚àí . W.l.o.g. assume that K ‚à© Fj‚àí = ‚àÖ. Since (Fi ‚à© K) * (Fj ‚à© K), we must have
(Fi ‚à© K) ‚à© Fj+ 6= ‚àÖ. Let x ‚àà (Fi ‚à© K) ‚à© Fj+ and let y ‚àà Fj ‚à© Fi ‚à© K. Since Fi ‚à© K is convex,
the interval from x to y is contained in Fi ‚à© K, but because (Fi ‚à© K) ‚à© Fj‚àí = ‚àÖ, no points
on this line past the point y can be in Fi ‚à© K; hence y ‚àà
/ rel int (Fi ‚à© K).
Since Fi ‚à© K is a basic convex cone, rel int (Fi ‚à© K) is a relatively open polyhedral
convex cone by induction. If Fi ‚à© K = aff (Fi ‚à© K) then rel int (Fi ‚à© K) = Fi ‚à© K. If not,
then denote by Fi,1 , . . . , Fi,`i the hyperplanes in aff (Fi ‚à© K) corresponding to the finitely
many faces of the polyhedron cl (Fi ‚à© K). By induction, the convex cones Fi,j ‚à© Fi ‚à© K,
j = 1, . . . , `i , are elementary convex cones, and we can write

[

Àô  `
`
i
K \ K 0 = ‚à™Àô i=1 rel int (Fi ‚à© K)
‚à™i=1 ‚à™`j=1
(Fi,j ‚à© Fi ‚à© K) .
i
What remains to be shown is that ‚à™`i=1 ‚à™`j=1
(Fi,j ‚à© Fi ‚à© K) can be written as a finite disjoint
union of relatively open polyhedral convex cones; this follows by iterating the previous
argument.

943

Mossel, Procaccia, & RaÃÅcz

Let us now show that Rd‚â•0 is a basic convex cone in Rd . For i = 1, . . . , d, define the

	

	
closed halfspace Hi‚â•0 = x ‚àà Rd : xi ‚â• 0 and its complement Hi<0 = x ‚àà Rd : xi < 0 ,
and from these define the convex cones
‚â•0
Ki = H1‚â•0 ‚à© ¬∑ ¬∑ ¬∑ ‚à© Hi‚àí1
‚à© Hi<0 ,

i = 1, . . . , d.

Then we can write Rd as the disjoint union of the convex cones Rd‚â•0 and K1 , . . . , Kd , showing
that indeed Rd‚â•0 is a basic convex cone. This implies that if we can write Rd‚â•0 as the disjoint
union of the convex cones C1 , . . . , Cr , then each Ci is a basic convex cone, and hence, by
Theorem A.1, an elementary convex cone.
Now let us turn to the claim in the proof of Lemma 3.1. In Lemma 3.1, we write Qm!
‚â•0 \ {0}
m!
Àô 1 ‚à™Àô . . . ‚à™C
Àô r . For
as the disjoint union of finitely many Q-convex cones: Q‚â•0 \ {0} = C0 ‚à™C
m!
i = 0, . . . , r, let CÃÉi = cvx (Ci ). It is known (see, e.g., Young, 1975) that Ci = Q ‚à©CÃÉi . The
CÃÉi are therefore disjoint convex cones which satisfy

and

CÃÉ0 ‚à™Àô CÃÉ1 ‚à™Àô . . . ‚à™Àô CÃÉr ‚äÜ Rm!
‚â•0

(9)

 
 
 
cl CÃÉ0 ‚à™ cl CÃÉ1 ‚à™ ¬∑ ¬∑ ¬∑ ‚à™ cl CÃÉr = Rm!
‚â•0 .

(10)

Our goal is to show that each CÃÉi is an elementary convex cone. Conditions (10) and (9)
are very similar to the definition of a basic convex cone; in this spirit let us introduce the
following definition.
Definition 14 (Basic convex cone up to closure). Let K0 be a convex cone in a finite
dimensional linear space X. We say that K0 is a basic convex cone up to closure (in X) if
there exist disjoint convex cones K1 , . . . , Kr such that
Àô 1 ‚à™Àô . . . ‚à™K
Àô r‚äÜX
K0 ‚à™K
and
cl (K0 ) ‚à™ cl (K1 ) ‚à™ ¬∑ ¬∑ ¬∑ ‚à™ cl (Kr ) = X.
Since Rd‚â•0 is a basic convex cone, the CÃÉi above are basic convex cones up to closure.
In fact, every basic convex cone up to closure is an elementary convex cone; the proof is
exactly the same as the one shown above for the ‚Äúonly if‚Äù direction of Theorem A.1, one just
needs to replace ‚Äúbasic convex cone‚Äù with ‚Äúbasic convex cone up to closure‚Äù everywhere in
the proof, and make the appropriate changes. Moreover, the other direction of Theorem A.1
implies that actually every basic convex cone up to closure is a basic convex cone.
Hence the CÃÉi are elementary convex cones, which is what we need in Lemma 3.1.

Appendix B. Most Voting Rules are Hyperplane Rules: Examples
In the following we show that all positional scoring rules, instant-runoff voting, Coombs‚Äô
method, contingent vote, the KemeÃÅny-Young method, Bucklin voting, Nanson‚Äôs method,
Baldwin‚Äôs method, and Copeland‚Äôs method are all hyperplane rules.
944

A Smooth Transition from Powerlessness to Absolute Power

‚Ä¢ Positional scoring rules. Let w ‚àà Rm be a weight vector. Given
a ranking profile
P
vector œÉ, the (normalized) score of candidate a ‚àà [m] is sa = n1 ni=1 w œÉi‚àí1 (a) . The
positional scoring rule associated to the weight vector w elects the candidate who has
the highest score. (In case of a tie, there is some tie-breaking rule, but we do not
care about this here.) We denote such a SCF on n voters by fnw . Examples include
plurality (with weight vector w = (1, 0, 0, . . . , 0)), Borda count (with weight vector
w = (m ‚àí 1, m ‚àí 2, . . . , 0)) and veto (with weight vector w = (1, 1, . . . , 1, 0)).
To a sequence of SCFs {fnw }n‚â•1 we can associate a function F w : ‚àÜm! ‚Üí [m] in the
followingP
way. For a candidate
a ‚àà [m] and x ‚àà ‚àÜm! , define the (normalized) score

sa (x) = œÄ‚ààSm xœÄ w œÄ ‚àí1 (a) , and let
F w (x) := arg max sa (x) ,
a‚àà[m]

if this arg max is unique, and if it is not unique, then there is some tie-breaking rule.
This construction guarantees that fnw = F w |Dn . For candidates a 6= b, define
n
o
Ha,b := x ‚àà ‚àÜm! : sa (x) = sb (x) ,
which is an affine hyperplane of the
probability simplex ‚àÜm! . Clearly the boundary

m
B w is contained in the union of 2 such affine hyperplanes:
[
Bw ‚äÜ
Ha,b .
a6=b‚àà[m]

‚Ä¢ Instant-runoff voting. If a candidate receives absolute majority of first preference
votes, then that candidate wins. If no candidate receives an absolute majority, then
the candidate with fewest top votes is eliminated. In the next round the votes are
counted again, with each ballot counted as one vote for the advancing candidate who
is ranked highest on that ballot. This is repeated until the winning candidate receives
a majority of the vote against the remaining candidates.
The boundary corresponds to two kinds of situations: either (1) there is a tie at the
top at the end, when only two candidates remain; or (2) there is a tie for eliminating a
candidate at the end of one of the rounds. Technically situation (1) is also contained
in situation (2), since at the very end one can view choosing a winner as eliminating
the second placed candidate. One can see that if candidates a and b are tied for
elimination after candidates C ‚äÜ [m] \ {a, b} (where C = ‚àÖ is allowed) have been
eliminated, then necessarily
X
X
X
X
xœÄ =
xœÄ .
(11)
C 0 ‚äÜC {œÄ(1),...,œÄ(|C 0 |)}=C 0 ,
œÄ(|C 0 |+1)=a

C 0 ‚äÜC {œÄ(1),...,œÄ(|C 0 |)}=C 0 ,
œÄ(|C 0 |+1)=b

Consequently, denoting by sa,C (x) the quantity on the left hand side of (11), the
boundary B is contained in the union of at most m2 2m affine hyperplanes:
n
o
[
[
B‚äÜ
x ‚àà ‚àÜm! : sa,C (x) = sb,C (x) .
a6=b C‚äÜ[m]\{a,b}

945

Mossel, Procaccia, & RaÃÅcz

‚Ä¢ Coombs‚Äô method. This is similar to IRV, but the elimination rule is different. If
a candidate receives absolute majority of first preference votes, then that candidate
wins. If no candidate receives an absolute majority, then the candidate who is ranked
last by the most voters is eliminated. In the next round the votes are counted again,
with each ballot counted as one vote for the advancing candidate who is ranked highest
on that ballot. This is repeated until the winning candidate receives a majority of the
vote against the remaining candidates.
The boundary corresponds to two kinds of situations: either (1) there is a tie at the
top at the end, when only two candidates remain; or (2) there is a tie for eliminating a
candidate at the end of one of the rounds. Technically situation (1) is also contained
in situation (2), since at the very end one can view choosing a winner as eliminating
the second placed candidate. One can see that if candidates a and b are tied for
elimination after candidates C ‚äÜ [m] \ {a, b} (where C = ‚àÖ is allowed) have been
eliminated, then necessarily
X
X
X
X
xœÄ =
xœÄ .
(12)
C 0 ‚äÜC {œÄ(m),...,œÄ(m‚àí|C 0 |+1)}=C 0 ,
œÄ(m‚àí|C 0 |)=a

C 0 ‚äÜC {œÄ(m),...,œÄ(m‚àí|C 0 |+1)}=C 0 ,
œÄ(m‚àí|C 0 |)=b

Consequently, denoting by sa,C (x) the quantity on the left hand side of (12), the
boundary B is contained in the union of at most m2 2m affine hyperplanes:
B‚äÜ

[

[



	
x ‚àà ‚àÜm! : sa,C (x) = sb,C (x) .

a6=b C‚äÜ[m]\{a,b}

‚Ä¢ Contingent vote. This is also similar to IRV, except here all but two candidates
get eliminated after the first round. If a candidate receives absolute majority of first
preference votes, then he/she wins. If no candidate receives an absolute majority, then
all but the top two leading candidates are eliminated and there is a second count, where
the votes of those who supported an eliminated candidate are redistributed among
the two remaining candidates. The candidate who then achieves absolute majority
wins.
Here the boundary B corresponds to two kinds of situations: either (1) there are
two distinct top candidates, and when the votes of the voters who voted for other
candidates are redistributed, then the two top candidates are in a dead heat; or (2)
there are two or more candidates who receive an equal number of votes in the first
round. Both of these situations can be described as subsets of affine hyperplanes, and
so B is contained in the union of at most m (m ‚àí 1) affine hyperplanes:
Ô£±
Ô£º
Ô£¥
Ô£¥
Ô£≤
Ô£Ω
[
X
X
X
X
m!
B‚äÜ
x‚àà‚àÜ :
xœÄ +
xœÄ =
xœÄ +
xœÄ
Ô£¥
Ô£¥
Ô£æ
œÄ
œÄ
a6=b Ô£≥
œÄ:œÄ(1)=a
œÄ:œÄ(1)=b
œÄ:œÄ(1)‚àà{a,b},a
/
>b
œÄ:œÄ(1)‚àà{a,b},b
/
>a
Ô£±
Ô£º
Ô£Ω
[Ô£≤
X
X
‚à™
x ‚àà ‚àÜm! :
xœÄ =
xœÄ .
Ô£≥
Ô£æ
a6=b

œÄ:œÄ(1)=a

œÄ:œÄ(1)=b

946

A Smooth Transition from Powerlessness to Absolute Power

‚Ä¢ KemeÃÅny-Young method. Denote by K the Kendall tau distance, which is a metric
on permutations which counts the number of pairwise disagreements between the two
permutations, i.e.,
X
K (œÑ1 , œÑ2 ) =
1 [a and b are in the opposite order in œÑ1 and œÑ2 ] ,
{a,b}

where the sum is over all unordered pairs of distinct candidates. Given a ranking
profile œÉ n , the KemeÃÅny-Young method selects the ranking which minimizes the sum
of Kendall tau distances from the votes:
œÑ = arg min

n
X

K (œÉi , œÑ ) ,

i=1

and then the winner of the election is declared to be œÑ (1). For us it will be convenient
to write œÑ as
X
œÑ = arg min
xœÄ (œÉ n ) K (œÄ, œÑ ) .
œÄ

Here if we are on the boundary
B then there
P
P must exist two rankings œÑ1 and œÑ2 such
that œÑ1 (1) 6= œÑ2 (1) and œÄ xœÄ K (œÄ, œÑ1 ) = œÄ xœÄ K (œÄ, œÑ2 ). Thus B is contained in the
union of at most (m!)2 affine hyperplanes:
(
)
X
X
[
m!
x‚àà‚àÜ :
xœÄ K (œÄ, œÑ1 ) =
xœÄ K (œÄ, œÑ2 ) .
B‚äÜ
œÑ1 6=œÑ2

œÄ

œÄ

‚Ä¢ Bucklin voting. First every candidate gets a point from all the voters who ranked
them at the top. If there is a candidate who has a majority (i.e., more than n/2
points), then that candidate wins. If not, then every candidate gets a point from
all the voters who ranked them second. If there is a candidate who has more than
n/2 points after this, then the candidate with the most points wins (there might be
multiple candidates with more than n/2 points after a given round). This process is
iterated until there is a candidate with more than n/2 points.
Here a point on the boundary B corresponds to a situation where some pair of candidates have the same number of points after some number of rounds. Therefore B is
contained in the union of at most m2 (m ‚àí 1) /2 affine hyperplanes:
Ô£±
Ô£º
m Ô£≤
k
k
Ô£Ω
[ [
X
X
X
X
B‚äÜ
x ‚àà ‚àÜm! :
xœÄ =
xœÄ .
Ô£≥
Ô£æ
a6=b k=1

i=1 œÄ:œÄ(i)=a

i=1 œÄ:œÄ(i)=b

‚Ä¢ Nanson‚Äôs method. This is Borda count combined with a variation of the instantrunoff voting procedure. First, the Borda scores of all candidates are computed, and
then those candidates with Borda score no greater than the average Borda score are
eliminated. Then the Borda scores of each remaining candidate are recomputed, as
if the eliminated candidates were not on the ballot. This is repeated until there is a
final candidate left.
947

Mossel, Procaccia, & RaÃÅcz

The boundary corresponds to situations when a candidate‚Äôs Borda score exactly equals
the average score after some candidates have been eliminated. For C ‚äÜ [m], denote by
sa,C (x) the score of candidate a after exactly the candidates in C have been eliminated
(sa,C (x) is a linear function of {xœÄ }œÄ‚ààSm ), and denote by sÃÑC (x) the average score of
remaining candidates after exactly the candidates in C have been eliminated. The
boundary B is contained in the union of at most m2m affine hyperplanes:
n
o
[
[
B‚äÜ
x ‚àà ‚àÜm! : sa,C (x) = sÃÑC (x) .
a‚àà[m] C‚äÜ[m]\{a}

‚Ä¢ Baldwin‚Äôs method. This is essentially Borda count combined with the instantrunoff voting procedure. First, the Borda scores of all candidates are computed, and
then the candidate with the lowest score is eliminated. Then the Borda scores of each
remaining candidate are recomputed, as if the eliminated candidate were not on the
ballot. This is repeated until there is a final candidate left.
The boundary corresponds to ties for eliminating a candidate at the end of one of the
rounds. Borrow the notation sa,C (x) from the previous example. The boundary B is
thus contained in the union of at most m2 2m affine hyperplanes:
n
o
[
[
B‚äÜ
x ‚àà ‚àÜm! : sa,C (x) = sb,C (x) .
a6=b C‚äÜ[m]\{a,b}

‚Ä¢ Copeland‚Äôs method. This is a pairwise aggregation method: every candidate gets
1 point for each other candidate it beats in a pairwise majority election, and 1/2 a
point for each candidate it ties with in a pairwise majority election. The winner is
the candidate who receives the most points. This method
corresponds to cutting the

simplex ‚àÜm! up into finitely many regions via m
affine
hyperplanes, and in each
2
region the winner is the candidate with the most points.
While in the previous examples tie-breaking rules were not an issue, here it does
become important. We do not care about tie-breaking rules when we are on an
affine hyperplane where two candidates tie each other in a pairwise majority election.
However, there are open regions in the intersection of halfspaces defined by the affine
hyperplanes where candidates are tied at the top with having the same scores. In
this case, in order for Copeland to be a hyperplane rule, we need to break ties in
favor of the same candidate for the whole region. (This is also how ties are broken for
Copeland‚Äôs method in Xia & Conitzer, 2008b.)
Using this tie-breaking rule Copeland‚Äôs method is indeed a hyperplane rule, since the
boundary is contained in the union of at most m
2 affine hyperplanes:
Ô£±
Ô£º
Ô£Ω
[Ô£≤
X
X
B‚äÜ
x ‚àà ‚àÜm! :
xœÄ =
xœÄ .
Ô£≥
Ô£æ
œÄ
œÄ
a6=b

œÄ:a>b

948

œÄ:b>a

A Smooth Transition from Powerlessness to Absolute Power

References
Achlioptas, D. (1999). Threshold phenomena in random graph colouring and satisfiability.
Ph.D. thesis, Department of Computer Science, University of Toronto.
Achlioptas, D., Naor, A., & Peres, Y. (2005). Rigorous location of phase transitions in hard
optimization problems. Nature, 435 (7043), 759‚Äì764.
Bartholdi III, J., Tovey, C., & Trick, M. (1989). The Computational Difficulty of Manipulating an Election. Social Choice and Welfare, 6 (3), 227‚Äì241.
Betzler, N., Niedermeier, R., & Woeginger, G. J. (2011). Unweighted coalitional manipulation under the Borda rule is NP-hard. In Proceedings of the 22nd International Joint
Conference on Artificial Intelligence (IJCAI), pp. 55‚Äì60.
Brandt, F. (2009). Some remarks on Dodgson‚Äôs voting rule. Mathematical Logic Quarterly,
55 (4), 460‚Äì463.
Caragiannis, I., & Procaccia, A. D. (2011). Voting almost maximizes social welfare despite
limited communication. Artificial Intelligence, 175 (9‚Äì10), 1655‚Äì1671.
Chamberlain, G., & Rothschild, M. (1981). A note on the probability of casting a decisive
vote. Journal of Economic Theory, 25 (1), 152‚Äì162.
Cheeseman, P., Kanefsky, B., & Taylor, W. (1991). Where the really hard problems are.
In Proceedings of the 12th International Joint Conference on Artificial Intelligence
(IJCAI), pp. 331‚Äì337.
Conitzer, V., & Sandholm, T. (2006). Nonexistence of Voting Rules That Are Usually
Hard to Manipulate. In Proceedings of the 21st National Conference on Artificial
Intelligence, Vol. 21, pp. 627‚Äì634.
Conitzer, V., Sandholm, T., & Lang, J. (2007). When are elections with few candidates
hard to manipulate?. Journal of the ACM, 54 (3), 1‚Äì33.
Dobzinski, S., & Procaccia, A. (2008). Frequent Manipulability of Elections: The Case
of Two Voters. In Proceedings of the 4th International Workshop on Internet and
Network Economics, pp. 653‚Äì664. Springer.
Faliszewski, P., Hemaspaandra, E., Hemaspaandra, L., & Rothe, J. (2009). Llull and
Copeland Voting Computationally Resist Bribery and Constructive Control. Journal of Artificial Intelligence Research, 35, 275‚Äì341.
Faliszewski, P., & Procaccia, A. (2010). AI‚Äôs War on Manipulation: Are We Winning?. AI
Magazine, 31 (4), 53‚Äì64.
Friedgut, E., Kalai, G., Keller, N., & Nisan, N. (2011). A Quantitative Version of the
Gibbard-Satterthwaite Theorem for Three Alternatives. SIAM J. Comput., 40 (3),
934‚Äì952.
Friedgut, E., Kalai, G., & Nisan, N. (2008). Elections can be manipulated often. In Proceedings of the 49th Annual Symposium on Foundations of Computer Science, pp.
243‚Äì249. IEEE.
949

Mossel, Procaccia, & RaÃÅcz

Fu, Y., & Anderson, P. (1986). Application of statistical mechanics to NP-complete problems
in combinatorial optimisation. Journal of Physics A: Mathematical and General, 19,
1605‚Äì1620.
Gibbard, A. (1973). Manipulation of Voting Schemes: A General Result. Econometrica:
Journal of the Econometric Society, 587‚Äì601.
Gomes, C., & Walsh, T. (2006). Randomness and Structure. In Rossi, F., van Beek, P.,
& Walsh, T. (Eds.), Handbook of Constraint Programming, Foundations of Artificial
Intelligence, pp. 639‚Äì664. Elsevier.
Good, I., & Mayer, L. (1975). Estimating the efficacy of a vote. Behavioral Science, 20 (1),
25‚Äì33.
Isaksson, M., Kindler, G., & Mossel, E. (2012). The Geometry of Manipulation: A Quantitative Proof of the Gibbard-Satterthwaite Theorem. Combinatorica, 32 (2), 221‚Äì250.
Kelly, J. (1993). Almost all social choice rules are highly manipulable, but a few aren‚Äôt.
Social Choice and Welfare, 10 (2), 161‚Äì175.
Kemperman, J. (1986). Decomposing Rd into finitely many semigroups. In Indagationes
Mathematicae (Proceedings), Vol. 89, pp. 71‚Äì78. Elsevier.
Mossel, E., & RaÃÅcz, M. (2012). A quantitative Gibbard-Satterthwaite theorem without
neutrality. In Proceedings of the 44th ACM Symposium on Theory of Computing
(STOC), pp. 1041‚Äì1060. ACM. Full version to appear in Combinatorica, available as
arXiv preprint at arXiv:1110.5888.
Myatt, D. (2007). On the theory of strategic voting. The Review of Economic Studies,
74 (1), 255‚Äì281.
Peleg, B. (1979). A note on manipulability of large voting schemes. Theory and Decision,
11 (4), 401‚Äì412.
Pritchard, G., & Slinko, A. (2006). On the average minimum size of a manipulating coalition.
Social Choice and Welfare, 27 (2), 263‚Äì277.
Pritchard, G., & Wilson, M. (2009). Asymptotics of the minimum manipulating coalition
size for positional voting rules under impartial culture behaviour. Mathematical Social
Sciences, 58 (1), 35‚Äì57.
Procaccia, A., & Rosenschein, J. (2007a). Average-case tractability of manipulation in voting via the fraction of manipulators. In Proceedings of the 6th International Conference
on Autonomous Agents and Multi-Agent Systems (AAMAS), pp. 718‚Äì720.
Procaccia, A., & Rosenschein, J. (2007b). Junta Distributions and the Average-case Complexity of Manipulating Elections. Journal of Artificial Intelligence Research, 28,
157‚Äì181.
Satterthwaite, M. (1975). Strategy-proofness and Arrow‚Äôs Conditions: Existence and Correspondence Theorems for Voting Procedures and Social Welfare Functions. Journal
of Economic Theory, 10 (2), 187‚Äì217.
Slinko, A. (2004). How large should a coalition be to manipulate an election?. Mathematical
Social Sciences, 47 (3), 289‚Äì293.
950

A Smooth Transition from Powerlessness to Absolute Power

Walsh, T. (2002). The Interface between P and NP: COL, XOR, NAE, 1-in-k, and Horn
SAT. In Proceedings of the 17th National Conference on AI (AAAI 2002), pp. 695‚Äì
700.
Walsh, T. (2011). Where Are the Hard Manipulation Problems?. Journal of Artifical
Intelligence Research, 42, 1‚Äì29.
Xia, L. (2012a). Computing the margin of victory for various voting rules. In Proceedings
of the 13th ACM Conference on Electronic Commerce (EC), pp. 982‚Äì999. ACM.
Xia, L. (2012b). How Many Vote Operations Are Needed to Manipulate A Voting System?.
Arxiv preprint arXiv:1204.1231.
Xia, L., & Conitzer, V. (2008a). A Sufficient Condition for Voting Rules to be Frequently
Manipulable. In Proceedings of the 9th ACM Conference on Electronic Commerce
(EC), pp. 99‚Äì108. ACM.
Xia, L., & Conitzer, V. (2008b). Generalized Scoring Rules and the Frequency of Coalitional
Manipulability. In Proceedings of the 9th ACM Conference on Electronic Commerce
(EC), pp. 109‚Äì118. ACM.
Xia, L., & Conitzer, V. (2009). Finite Local Consistency Characterizes Generalized Scoring
Rules. In Proceedings of the 9th International Joint Conference on Artificial Intelligence (IJCAI), pp. 336‚Äì341.
Xia, L., Zuckerman, M., Procaccia, A. D., Conitzer, V., & Rosenschein, J. S. (2009). Complexity of unweighted coalitional manipulation under some common voting rules. In
Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI), pp. 348‚Äì353.
Young, H. (1975). Social choice scoring functions. SIAM Journal on Applied Mathematics,
824‚Äì838.
Zuckerman, M., Procaccia, A. D., & Rosenschein, J. S. (2009). Algorithms for the coalitional
manipulation problem. Artificial Intelligence, 173 (2), 392‚Äì412.

951

Journal of Artificial Intelligence Research 48 (2013)

Submitted 5/2013; published 12/2013

Exact Query Reformulation over Databases
with First-order and Description Logics Ontologies
Enrico Franconi
Volha Kerhet
Nhung Ngo

franconi@inf.unibz.it
kerhet@inf.unibz.it
ngo@inf.unibz.it

Free University of Bozen-Bolzano, Italy

Abstract
We study a general framework for query rewriting in the presence of an arbitrary
first-order logic ontology over a database signature. The framework supports deciding the
existence of a safe-range first-order equivalent reformulation of a query in terms of the
database signature, and if so, it provides an effective approach to construct the reformulation based on interpolation using standard theorem proving techniques (e.g., tableau).
Since the reformulation is a safe-range formula, it is effectively executable as an SQL query.
At the end, we present a non-trivial application of the framework with ontologies in the
very expressive ALCHOIQ description logic, by providing effective means to compute
safe-range first-order exact reformulations of queries.

1. Introduction
We address the problem of query reformulation with expressive ontologies over databases.
An ontology provides a conceptual view of the database and it is composed by constraints
on a vocabulary extending the basic vocabulary of the data. Querying a database using
the terms in such a richer ontology allows for more flexibility than using only the basic
vocabulary of the relational database directly.
In this paper we study and develop a query rewriting framework applicable to knowledge
representation systems where data is stored in a classical finite relational database, in a way
that in the literature has been called the locally-closed world assumption (Etzioni, Golden,
& Weld, 1997), exact views (Marx, 2007; Nash, Segoufin, & Vianu, 2010; Fan, Geerts,
& Zheng, 2012), or DBox (Seylan, Franconi, & de Bruijn, 2009; Franconi, Ibanez-Garcia,
& Seylan, 2011). A DBox is a set of ground atoms which semantically behaves like a
database, i.e., the interpretation of the database predicates in the DBox is exactly equal
to the database relations. The DBox predicates are closed, i.e., their extensions are the
same in every interpretation, whereas the other predicates in the ontology are open, i.e.,
their extensions may vary among different interpretations. We do not consider here the
open interpretation for the database predicates (also called ABox or sound views). In an
ABox, the interpretation of database predicates contains the database relations and possibly
more. This notion is less faithful in the representation of a database semantics since it would
allow for spurious interpretations of database predicates with additional unwanted tuples
not present in the original database.
In our general framework an ontology is a set of first-order formulas, and queries are
(possibly open) first-order formulas. Within this setting, the framework provides precise
semantic conditions to decide the existence of a safe-range first-order equivalent reformulac
2013
AI Access Foundation. All rights reserved.

Franconi, Kerhet, & Ngo

tion of a query in terms of the database signature. It also provides an effective approach to
construct the reformulation with sufficient conditions. We are interested in safe-range reformulations of queries because their range-restricted syntax is needed to reduce the original
query answering problem to a relational algebra evaluation (e.g., via SQL) over the original
database (Abiteboul, Hull, & Vianu, 1995). Our framework points out several conditions on
the ontologies and the queries to guarantee the existence of a safe-range reformulation. We
show that these conditions are feasible in practice and we also provide an efficient method
to ensure their validation. Standard theorem proving techniques can be used to compute
the reformulation.
In order to be complete, our framework is applicable to ontologies and queries expressed
in any fragment of first-order logic enjoying finitely controllable determinacy (Nash et al.,
2010), a stronger property than the finite model property of the logic. If the employed logic
does not enjoy finitely controllable determinacy our approach would become sound but
incomplete, but still effectively implementable using standard theorem proving techniques.
We have explored non-trivial applications where the framework is complete; in this paper,
the application with ALCHOIQ ontologies and concept queries is discussed. We show how
(i) to check whether the answers to a given query with an ontology are solely determined
by the extension of the DBox predicates and, if so, (ii) to find an equivalent rewriting of the
query in terms of the DBox predicates to allow the use of standard database technology for
answering the query. This means we benefit from the low computational complexity in the
size of the data for answering queries on relational databases. In addition, it is possible to
reuse standard techniques of description logics reasoning to find rewritings, such as in the
paper by Seylan et al. (2009).
The query reformulation problem has received strong interest in classical relational
database research as well as modern knowledge representation studies. Differently from
the mainstream research on query reformulation (Halevy, 2001), which is mostly based
on perfect or maximally contained rewritings with sound views under relatively inexpressive constraints (see, e.g., the DL-Lite approach in Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009), we focus here on exact rewritings with exact views, since it characterises
precisely the query answering problem with ontologies and databases, in the case when the
exact semantics of the database must be preserved. As an example, consider a ground negative query over a given standard relational database; by adding an ontology on top of it, its
answer is not supposed to change‚Äîsince the query uses only the signature of the database
and additional constraints are not supposed to change the meaning of the query‚Äîwhereas
if the database were treated as an ABox (sound views) the answer may change in presence
of an ontology. This may be important from the application perspective: a DBox preserves
the behaviour of the legacy application queries over a relational database. Moreover, by
focussing on exact reformulations of definable queries (as opposed to considering the certain
answer semantics to arbitrary queries, such as in DL-Lite), we guarantee that answers to
queries can be subsequently composed in an arbitrary way: this may be important to legacy
database applications.
This work extends the works on exact rewritings with exact views by Marx (2007) and
Nash et al. (2010) by focussing on safe-range reformulations and on the conditions ensuring
their existence, and by considering general first-order ontologies extending the database
signature, rather than just local as view constraints over the database predicates (Halevy,
886

Exact Query Reformulation over DBs with FO and DL Ontologies

2001). This paper extends the papers by Franconi, Kerhet, and Ngo (2012a, 2012b) by
providing a precise semantic characterisation for the existence of an exact reformulation
(Theorem 4) as opposed to just sufficient conditions, by considering the much more expressive description logic ALCHOIQ, and by providing all the proofs.
The paper is organised as follows: section 2 provides the necessary formal background
and definitions; section 3 introduces the notion of a query determined by a database; section 4 introduces a characterisation of the query reformulation problem; in sections 5 and 6
the conditions allowing for an effective reformulation are analysed, and a sound and complete algorithm to compute the reformulation is introduced. Finally, we present the case of
ALCHOIQ ontologies. All the proofs are presented in details in the Appendix.

2. Preliminaries
Let FOL(C, P) be a classical function-free first-order language with equality over a signature
Œ£ = (C, P), where C is a finite set of constants and P is a set of predicates with associated
arities. In the rest of this paper we will refer to an arbitrary fragment of FOL(C, P), which
will be called L.
We denote with P{œï1 ,...,œïn } the set of all predicates occurring in the formulas œï1 , . . . , œïn ,
with C{œï1 ,...,œïn } the set of all constants occurring in the formulas œï1 , . . . , œïn ; for the sake of
brevity, instead of P{œï} (resp. C{œï} ) we write Pœï (resp. Cœï ). We denote with œÉ(œï1 , . . . , œïn )
the signature of the formulas œï1 , . . . , œïn , namely the union of P{œï1 ,...,œïn } and C{œï1 ,...,œïn } .
We denote the arity of a predicate P as ar(P ). Given a formula œï, we denote the set of
all variables appearing in œï as var(œï), and the set of the free variables appearing in œï as
free(œï); we may use for œï the notation œï[X] , where X = free(œï) is the (possibly empty)
set of free variables of the formula.
A database (instance) DB is a finite set of ground atoms of the form P (c1 , . . . , cn ), where
P ‚àà P, n-ary predicate, and ci ‚àà C (1 ‚â§ i ‚â§ n). The set of all predicates appearing in a
database DB is denoted as PDB , and the set of all constants appearing in DB is called the
active domain of DB, and is denoted as CDB . A (possibly empty) finite set KB of closed
formulas will be called an ontology.
As usual, an interpretation I = h‚àÜI , ¬∑I i includes a non-empty set‚Äîthe domain ‚àÜI ‚Äîand
an interpretation function ¬∑I defined over constants and predicates of the signature. We say
that interpretations I = h‚àÜI , ¬∑I i and J = h‚àÜJ , ¬∑J i are equal, written I = J , if ‚àÜI = ‚àÜJ
and ¬∑I = ¬∑J . An interpretation I embeds a database DB, if it holds that aI = a for every
database constant a ‚àà CDB (the standard name assumption (SNA), customary in databases,
see Abiteboul et al., 1995) and that (c1 , . . . , cn ) ‚àà P I if and only if P (c1 , . . . , cn ) ‚àà DB. We
denote the set of all interpretations embedding a database DB as E(DB).
In other words, in every interpretation embedding a DB the interpretation of any
database predicate is always the same and it is given exactly by its content in the database;
this is, in general, not the case for the interpretation of the non-database predicates. We
say that all the database predicates are closed, while all the other predicates are open and
may be interpreted differently in different interpretations. We do not consider here the open
world assumption (the ABox ) for embedding a database in an interpretation. In an open
world, an interpretation I soundly embeds a database if it holds that (c1 , . . . , cn ) ‚àà P I if
(but not only if) P (c1 , . . . , cn ) ‚àà DB.
887

Franconi, Kerhet, & Ngo

In order to allow for an arbitrary database to be embedded, we generalise the standard
name assumption to all the constants in C; this implies that the domain of any interpretation
necessarily includes the set of all the constants C. The finiteness of C corresponds to the
finite ability of a database system to represent distinct constant symbols; C is meant to be
unknown in advance, since different database systems may have different limits. We will
see that the framework introduced here will not depend on the choice of C.
Given an interpretation I = h‚àÜI , ¬∑I i, we denote as I|S the interpretation restricted to
the smaller signature S ‚äÜ P ‚à™ C, i.e., the interpretation with the same domain ‚àÜI and the
same interpretation function ¬∑I defined only for the constants and predicates from the set
S. The semantic active domain of a signature œÉ 0 ‚äÜ P ‚à™ C in an interpretation I, denoted
adom(œÉ 0 , I), is the set of all elements of the domain ‚àÜI occurring in interpretations of
predicates and constants from œÉ 0 in I:
adom(œÉ 0 , I) :=

[

[

P ‚ààœÉ 0 (a1 ,...,an )‚ààP I

{a1 , . . . , an } ‚à™

[

{cI }.

c‚ààœÉ 0

If œÉ 0 ‚äÜ PDB ‚à™ C, then for any interpretations I and J embedding DB we have:
adom(œÉ 0 , I) = adom(œÉ 0 , J ); so, for such a case we introduce the notation adom(œÉ 0 , DB) :=
adom(œÉ 0 , I), where I is any interpretation embedding the database DB. Intuitively
adom(œÉ 0 , DB) includes the constants from œÉ 0 and from DB appearing in the relations corresponding to the predicates from œÉ 0 .
Let X be a set of variable symbols and S a set; a substitution is a total function Œò : X 7‚Üí S
assigning an element in S to each variable in X, including the empty substitution  when
X = ‚àÖ. Domain and image (range) of a substitution Œò are written as dom(Œò) and rng(Œò)
respectively. Given a subset of the set of constants C0 ‚äÜ C, we write that a formula œï[X]
is true in an interpretation I with its free variables substituted according to a substitution
Œò : X 7‚Üí C0 as (I |= œï[X/Œò] ). Given an interpretation I = h‚àÜI , ¬∑I i and a subset of
its domain ‚àÜ ‚äÜ ‚àÜI , we write that a formula œï[X] is true in I with its free variables
interpreted according to a substitution Œò : X 7‚Üí ‚àÜ as (I, Œò |= œï). The extension domain of
aSformula œï[X] with respect to the interpretation I is defined as the set of domain elements
{rng(Œò) | dom(Œò) = X, rng(Œò) ‚äÜ ‚àÜ, I, Œò |= œï[X] }.
As usual, an interpretation in which a closed formula is true is called a model for
the formula; the set of all models of a formula œï (resp. KB) is denoted as M (œï) (resp.
M (KB)). A database DB is legal for an ontology KB if there exists a model of KB embedding
DB. In the following, we will consider only consistent non-tautological ontologies and legal
databases.
2.1 Queries
A query is a (possibly closed) formula. Given a query Q[X] , we define its certain answer
over KB and DB as follows:
Definition 1 (Certain Answer). The (certain) answer of a query Q[X] to a database DB
under the ontology KB is the set of substitutions with constants:
{Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà M (KB) ‚à© E(DB) : I |= Q[X/Œò] }.
888

Exact Query Reformulation over DBs with FO and DL Ontologies

Query answering is defined as an entailment problem, and as such it is going to have the
same (high) complexity as entailment.
Note, that if a query Q is closed (i.e., a Boolean query), then the certain answer is {} if
Q is true in all the models of the ontology embedding the database, and ‚àÖ otherwise. In the
following, we assume that the closed formula Q[X/Œò] is neither valid nor inconsistent under
the ontology KB, given a substitution Œò : X 7‚Üí C assigning to variables distinct constants
not appearing in Q, nor in KB, nor in CDB : this would lead to trivial reformulations.
We now show that we can weaken the standard name assumption for the constants by
just assuming unique names, without changing the certain answers. As we said before, an
interpretation I satisfies the standard name assumption if cI = c for any c ‚àà C. Alternatively, an interpretation I satisfies the unique name assumption (UNA) if aI 6= bI for
any different a, b ‚àà C. We denote the set of all interpretations satisfying standard name
assumption as I(SNA). We denote the set of all interpretations satisfying unique name
assumption as I(UNA). The following proposition allows us to freely interchange the standard name and the unique name assumptions with interpretations embedding databases.
This is of practical advantage, since we can encode the unique name assumption in classical
first-order logic reasoners, and many description logics reasoners do support natively the
unique name assumption as an extension to OWL.
Proposition 1 (SNA vs UNA). For any query Q[X] , ontology KB and database DB,
{Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà I(SNA) ‚à© M (KB) ‚à© E(DB) : I |= Q[X/Œò] } =
{Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà I(UNA) ‚à© M (KB) ‚à© E(DB) : I |= Q[X/Œò] }.
Since a query can be an arbitrary first-order formula, its answer may depend on the
domain, which we do not know in advance. For example, the query Q(x) = ¬¨Student(x)
over the database Student(a), Student(b), with domain {a, b, c} has the answer {x = c},
while with domain {a, b, c, d} has the answer {x = c, x = d}. Therefore, the notion of
domain independent queries has been introduced in relational databases. Here we adapt
the classical definitions (Avron, 2008; Abiteboul et al., 1995) to our framework: we need
a more general version of domain independence, namely domain independence w.r.t an
ontology, i.e., restricted to the models of an ontology.
Definition 2 (Domain Independence). A formula Q[X] is domain independent with
respect to an ontology KB iff for every two models I and J of KB (i.e., I = h‚àÜI , ¬∑I i
and J = h‚àÜJ , ¬∑J i) which agree on the interpretation of the predicates and constants (i.e.
¬∑I = ¬∑J ), and for every substitution Œò : X 7‚Üí ‚àÜI ‚à™ ‚àÜJ we have:
rng(Œò) ‚äÜ ‚àÜI and I, Œò |= Q[X] iff
rng(Œò) ‚äÜ ‚àÜJ and J , Œò |= Q[X] .
The above definition reduces to the classical definition of domain independence whenever
the ontology is empty.
A weaker version of domain independence‚Äîwhich is relevant for open formulas‚Äîis the
following.
Definition 3 (Ground Domain Independence). A formula Q[X] is ground domain independent iff Q[X/Œò] is domain independent for every substitution Œò : X 7‚Üí C.
889

Franconi, Kerhet, & Ngo

For example, the formula ¬¨P (x) is ground domain independent, but it is not domain independent.
The problem of checking whether a FOL formula is domain independent is undecidable
(Abiteboul et al., 1995). The well known safe-range syntactic fragment of FOL introduced
by Codd is an equally expressive language; indeed any safe-range formula is domain independent, and any domain independent formula can be easily transformed into a logically
equivalent safe-range formula. Intuitively, a formula is safe-range if and only if its variables
are bounded by positive predicates or equalities (for full details see Appendix A.3). For
example, the formula ¬¨A(x) ‚àß B(x) is safe-range, while queries ¬¨A(x) and ‚àÄx. A(x) are
not. To check whether a formula is safe-range, the formula is transformed into a logically
equivalent safe-range normal form and its range restriction is computed according to a set
of syntax based rules; the range restriction of a formula is a subset of its free variables, and
if this coincides with the free variables then the formula is said to be safe-range (Abiteboul
et al., 1995). Similar to domain independence, a formula is ground safe-range if any grounding of this formula is safe-range. An ontology KB is safe-range (domain independent), if
every formula in KB is safe-range (domain independent).
The safe-range fragment of first-order logic with the standard name assumption is
equally expressive to the relational algebra, which is the core of SQL (Abiteboul et al.,
1995).

3. Determinacy
The certain answer to a query includes all the substitutions which make the query true in
all the models of the ontology embedding the database: so, if a substitution would make the
query true only in some model, then it would be discarded from the certain answer. In other
words, it may be the case that the answer to the query is not necessarily the same among
all the models of the ontology embedding the database. In this case, the query is not fully
determined by the given source data; indeed, there is some answer which is possible, but
not certain. Due to the indeterminacy of the query with respect to the data, the complexity
to compute the certain answer in general increases up to the complexity of entailment in
the logic. In this paper we focus on the case when a query has the same answer over all the
models of the ontology embedding the database, namely, when the information requested
by the query is fully available from the source data without ambiguity. In this way, the
indeterminacy disappears, and the complexity of the process may decrease (see section 4).
The determinacy of a query w.r.t. a source database (Nash et al., 2010; Marx, 2007; Fan
et al., 2012) has been called implicit definability of a formula (the query) from a set of
predicates (the database predicates) by Beth (1953).
Definition 4 (Finite Determinacy or Implicit Definability). A query Q[X] is (finitely)
determined by (or implicitly definable from) the database predicates PDB under KB iff for
any two models I and J of the ontology KB‚Äîboth with a finite interpretation to the
database predicates PDB ‚Äîwhenever I|PDB ‚à™C = J |PDB ‚à™C then for every substitution
Œò : X 7‚Üí ‚àÜI we have: I, Œò |= Q[X] iff J , Œò |= Q[X] .
Intuitively, the answer of an implicitly definable query does not depend on the interpretation of non-database predicates. Once the database and a domain are fixed, it is never
890

Exact Query Reformulation over DBs with FO and DL Ontologies

the case that a substitution would make the query true in some model of the ontology
and false in others, since the truth value of an implicitly defined query depends only on
the interpretation of the database predicates and constants and on the domain (which are
fixed). In practice, by focussing on finite determinacy of queries we guarantee that the user
can always interpret the answers as being not only certain, but also exact‚Äînamely that
whatever is not in the answer can never be part of the answer in any possible world.
In the following we focus on ontologies and queries in those fragments of FOL(C, P) for
which determinacy under models with a finite interpretation of database predicates (finite
determinacy) and determinacy under models with an unrestricted interpretation of database
predicates (unrestricted determinacy) coincide. We say that these fragments have finitely
controllable determinacy: we require that whenever a query is finitely determined then it is
also determined in unrestricted models (the reverse is trivially true). Indeed, the results in
this paper would fail if finite determinacy and unrestricted determinacy do not coincide: it
can be shown (Gurevich, 1984) that Theorem 1 below fails if we consider only models with
a finite interpretation of database predicates.
Example 1 (Example from database theory). Let P = {P, R, A}, PDB = {P, R},
KB = {‚àÄx, y, z. R(x, y) ‚àß R(x, z) ‚Üí y = z,
‚àÄx, y. R(x, y) ‚Üí ‚àÉz. R(z, x),
(‚àÄx, y. R(x, y) ‚Üí ‚àÉz. R(y, z)) ‚Üí (‚àÄx. A(x) ‚Üî P (x))}.
The formula ‚àÄx, y. R(x, y) ‚Üí ‚àÉz. R(y, z) is entailed from the first two formulas only over
finite interpretations of R. The query Q = A(x) is finitely determined by P (it is equivalent
to P (x) under the models with a finite interpretation of R), but it is not determined by any
database predicate under models with an unrestricted interpretation of R. This knowledge
base does not enjoy finitely controllable determinacy.
The exact reformulation of a query (Nash et al., 2010) (also called explicit definition by
Beth, 1953) is a formula logically equivalent to the query which makes use only of database
predicates and constants.
Definition 5 (Exact Reformulation or Explicit Definability). A query Q[X] is explicitly definable from the database predicates PDB under the ontology KB iff there is some
b[X] in FOL(C, P), such that KB |= ‚àÄX.Q[X] ‚Üî Q
b[X] and œÉ(Q)
b ‚äÜ PDB . We call
formula Q
b[X] an exact reformulation of Q[X] under KB over PDB .
this formula Q
Determinacy of a query is completely characterised by the existence of an exact reformulation of the query: it is well known that a first-order query is determined by database
predicates if and only if there exists a first-order exact reformulation.
Theorem 1 (Projective Beth definability, Beth, 1953). A query Q is implicitly definable from the database predicates PDB under an ontology KB, iff it is explicitly definable as
b in FOL(C, P) over PDB under KB.
a formula Q
e the formula obtained from it by uniformly replacing
Let Q be any formula in L and Q
every occurrence of each non-database predicate P with a new predicate Pe. We extend this
renaming operator e¬∑ to any set of formulas in a natural way. One can check whether a query
is implicitly definable by using the following theorem.
Theorem 2 (Testing Determinacy, Beth, 1953). A query Q[X] is implicitly definable
g |= ‚àÄX.Q[X] ‚Üî Q
e[X] .
from the database predicates PDB under the ontology KB iff KB ‚à™ KB

891

Franconi, Kerhet, & Ngo

4. Exact Safe-Range Query Reformulation
In this section we analyse the conditions under which the original query answering problem
corresponding to an entailment problem can be reduced systematically to a model checking
problem of a safe-range formula over the database (e.g., using a database system with
SQL). Given a database signature PDB , an ontology KB, and a query Q[X] expressed in L
and determined by the database predicates, our goal is to find a safe-range reformulation
b[X] of Q[X] in FOL(C, P), that when evaluated as a relational algebra expression over a
Q
legal database instance, gives the same answer as the certain answer of Q[X] to the database
under KB. This can be reformulated as the following problem:
Problem 1 (Exact safe-range Query Reformulation). Find an exact reformulation
b[X] of Q[X] under KB as a safe-range query in FOL(C, P) over PDB .
Q
Since an exact reformulation is equivalent under the ontology to the original query, the
certain answer of the original query and of the reformulated query are identical. More
precisely, the following proposition holds.
Proposition 2. Given a database DB, let Q[X] be implicitly definable from PDB under KB
b[X] be an exact reformulation of Q[X] under KB over PDB , then:
and let Q
{Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà M (KB) ‚à© E(DB) : I |= Q[X/Œò] } =
b[X/Œò] }.
{Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà M (KB) ‚à© E(DB) : I |= Q
From the above equation it is clear that in order to answer an exactly reformulated query,
one may still need to consider all the models of the ontology embedding the database, i.e.,
we still have an entailment problem to solve. The following theorem states the condition
to reduce the original query answering problem‚Äîbased on entailment‚Äîto the problem of
checking the validity of the exact reformulation over a single model: the condition is that
the reformulation should be domain independent. Indeed there is only one interpretation
(with a particular domain) embedding the database with the signature restricted to the
database predicates.
Theorem 3 (Adequacy of Exact safe-range Query Reformulation). Let DB be
b[X] is an exact domain
a database which is legal for KB, and let Q[X] be a query. If Q
independent (or safe-range) reformulation of Q[X] under KB over PDB , then:
{Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà M (KB) ‚à© E(DB) : I |= Q[X/Œò] } =
b DB), ‚àÄI = hC, ¬∑I i ‚àà E(DB) : I|P
{Œò | dom(Œò) = X, rng(Œò) ‚äÜ adom(œÉ(Q),

DB ‚à™C

b[X/Œò] }.
|= Q

A safe-range reformulation is necessary to transform a first-order query to a relational
algebra query which can then be evaluated by using SQL techniques. The theorem above
shows in addition that being safe-range is also a sufficient property for an exact reformulation to be correctly evaluated as an SQL query. Let us now see an example in which we
cannot reduce the problem of answering an exact reformulation to model checking over a
database, if the exact reformulation is not safe-range.
Example 2. Let P = {P, A}, PDB = {P }, C = {a},
DB = {P (a, a)}, KB = {‚àÄy. P (a, y) ‚à® A(y)},
b[X] = ‚àÄy. P (x, y) (i.e., X = {x}).
Q[X] = Q
892

Exact Query Reformulation over DBs with FO and DL Ontologies

‚Ä¢ C includes the active domain CDB (it is actually equal).
‚Ä¢ DB is legal for KB because there is I = h{a}, ¬∑I i such that P I = {(a, a)}, AI = ‚àÖ
and obviously, I ‚àà M (KB).
‚Ä¢ {Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà M (KB) ‚à© E(DB) : I |= Q[X/Œò] } = ‚àÖ because
one can take I = h{a, b}, ¬∑I i such that P I = {(a, a)}, AI = {b}; then I ‚àà M (KB) ‚à©
E(DB), but for the only possible substitution {x ‚Üí a} we have: I 6|= ‚àÄy P (a, y).
‚Ä¢ However,
b DB), ‚àÄI = hC, ¬∑I i ‚àà E(DB) : I|P ‚à™C |= Q
b[X/Œò] } =
{Œò | dom(Œò) = X, rng(Œò) ‚äÜ adom(œÉ(Q),
DB

{x ‚Üí a}
As we have seen, answers to a query for which a reformulation exists will contain only
constants from the active domain of the database and the query; therefore, ground statements in the ontology involving non-database predicates and non-active domain constants
(for example, as ABox statements) will not play any role in the final evaluation of the
reformulated query over the database.

5. Conditions for an Exact Safe-Range Reformulation
We have just seen the importance of getting an exact safe-range query reformulation. In
this section we are going to study the conditions under which an exact safe-range query
reformulation exists.
First of all, we will focus on the semantic notion of safe-range namely domain independence. While implicit definability is‚Äîas we already know‚Äîa sufficient condition for the
existence of an exact reformulation, it does not guarantee alone the existence of a domain
independent reformulation.
Example 3. Let P = {A, B}, PDB = {A}, KB = {‚àÄx.B(x) ‚Üî A(x)}, Q = ¬¨B(x).
Then Q is implicitly definable from PDB under KB, and every exact reformulation of Q over
PDB under KB is logically equivalent to ¬¨A(x) and not domain independent.
By looking at the example, it seems that the reason for the non domain independent
reformulation lies in the fact that the ontology, which is domain independent, cannot guarantee existence of an exact domain independent reformulation of the non domain independent
query. However, let us consider the following example:
Example 4. Let PDB = {A, C}, KB = {¬¨A(a),
‚àÉy ¬¨B(y) ‚àß C(x). It is easy to see that KB is
is implicitly definable from PDB under KB, and
independent reformulation of Q.

‚àÄx. A(x) ‚Üî B(x)} and let a query Q =
domain independent and Q is not. Q
b = ¬¨A(a) ‚àß C(x) is an exact domain
Q

It is obvious that in spite of the fact that the query Q is not domain independent, it
is domain independent with respect to the ontology KB. In other words, in this case the
ontology guarantees the existence of an exact domain independent reformulation.
With queries that are domain independent with respect to an ontology, the following
theorem holds, giving the semantic requirements for the existence of an exact domain
independent reformulation.
893

Franconi, Kerhet, & Ngo

Theorem 4 (Semantic Characterisation). Given a set of database predicates PDB , a
domain independent ontology KB, and a query Q[X] , a domain independent exact reformub[X] of Q[X] over PDB under KB exists if and only if Q[X] is implicitly definable from
lation Q
PDB under KB and it is domain independent with respect to KB.
The above theorem shows us the semantic conditions to have an exact domain independent reformulation of a query, but it does not give us a method to compute such reformulation and its equivalent safe-range form. The following theorem gives us sufficient
conditions for the existence of an exact safe-range reformulation in any decidable fragment of
FOL(C, P) where finite and unrestricted determinacy coincide, and gives us a constructive
way to compute it, if it exists.
Theorem 5 (Constructive). If:
g |= ‚àÄX. Q[X] ‚Üî Q
e[X] (that is, Q[X] is implicitly definable),
1. KB ‚à™ KB
2. Q[X] is safe-range (that is, Q[X] is domain independent),
3. KB is safe-range (that is, KB is domain independent),
b[X] of Q[X] as a safe-range query in FOL(C, P)
then there exists an exact reformulation Q
over PDB under KB, that can be obtained constructively.
In order to constructively compute the exact safe-range query reformulation we use the
b[X] from a
tableau based method to find the Craig‚Äôs interpolant (Fitting, 1996) to compute Q
g‚ÜíQ
e[X] ). See Section 6 for full details.
validity proof of the implication (KB ‚àß Q[X] ) ‚Üí (KB
Let us now consider a fully worked out example, adapted from the paper by Nash et al.
(2010).
Example 5. Given: P = {R, V1 , V2 , V3 , A}, PDB = {V1 , V2 , V3 , Adom} where Adom is the
active domain of DB,
KB = { ‚àÄx, y. V1 (x, y) ‚Üî ‚àÉz, v. R(z, x) ‚àß R(z, v) ‚àß R(v, y),
‚àÄx, y. V2 (x, y) ‚Üî ‚àÉz. R(x, z) ‚àß R(z, y),
‚àÄx, y. V3 (x, y) ‚Üî ‚àÉz, v. R(x, z) ‚àß R(z, v) ‚àß R(v, y),
Q(x, y) = ‚àÉz, v, u. R(z, x) ‚àß R(z, v) ‚àß R(v, u) ‚àß R(u, y)}.
The conditions of the theorem are satisfied: Q(x, y) is implicitly definable from PDB under
KB; Q(x, y) is safe-range; KB is safe-range.
b y)
Therefore, with the tableau method one finds the Craig‚Äôs interpolant to compute Q(x,
g
e
b
from a validity proof of the implication (KB ‚àß Q[X] ) ‚Üí (KB ‚Üí Q[X] ) and obtain Q(x, y) =
‚àÉz. V1 (x, z) ‚àß ‚àÄv. (V2 (v, z) ‚Üí V3 (v, y))‚Äîan exact ground safe-range reformulation. Since
b y) ‚Üí Adom(x) ‚àß
the answer of Q is in the active domain, we also have KB |= Q(x,
b
Adom(y). Then KB |= Q(x, y) ‚Üî Q(x, y) ‚àß Adom(x) ‚àß Adom(y). Therefore, ‚àÉz. V1 (x, z) ‚àß
‚àÄv. (V2 (v, z) ‚Üí V3 (v, y))‚àßAdom(x)‚àßAdom(y) is an exact safe-range reformulation of Q(x, y)
from PDB under KB.
894

Exact Query Reformulation over DBs with FO and DL Ontologies

6. Constructing the Safe-Range Reformulation
In this section we introduce a method to compute a safe-range reformulation of an implicitly
definable query when conditions in theorem 5 are satisfied. The method is based on the
notion of interpolant introduced by Craig (1957).
Definition 6 (Interpolant). The sentence œá is an interpolant for the sentence œÜ ‚Üí œà
in FOL(C, P), if all predicate and constant symbols of œá are in the set of predicate and
constant symbols of both œÜ and œà, and both œÜ ‚Üí œá and œá ‚Üí œà are valid sentences in
FOL(C, P).
Theorem 6 (Craig‚Äôs interpolation). If œÜ ‚Üí œà is a valid sentence in FOL(C, P), and
neither œÜ nor œà are valid, then there exists an interpolant.
Note, that the Beth definability (Theorem 1) and Craig‚Äôs interpolation theorem do not
hold for all fragments of FOL(C, P): an interpolant may not always be expressed in the
fragment itself, but obviously it is in FOL(C, P) (because of Theorem 6).
An interpolant is used to find an exact reformulation of a given implicitly definable
query as follows.
Theorem 7 (Interpolant as definition). Let Q[X] be a query with n ‚â• 0 free variables
implicitly definable from the database predicates PDB under the ontology KB. Then, the
closed formula with c1 , ..., cn distinct constant symbols in C not appearing in KB or Q[X] :
^
^
g ‚ÜíQ
e[X/c ,...,c ] )
(( KB) ‚àß Q[X/c1 ,...,cn ] ) ‚Üí (( KB)
(1)
n
1
b[c ,...,c /X] is an exact reformulation of Q[X] under KB over
is valid, and its interpolant Q
n
1
PDB .
Therefore, to find an exact reformulation of an implicitly definable query in terms of
database predicates it is enough to find an interpolant of the implication (1) and then to
substitute all the constants c1 , . . . , cn back with the free variables X of the original query.
An interpolant can be constructed from a validity proof of (1) by using automated theorem
proving techniques such as tableau or resolution. In order to guarantee the safe-range
property of the reformulation, we use a tableau method as in the book by Fitting (1996).
6.1 Tableau-based Method to Compute an Interpolant
In this section we recall in our context the tableau based method to compute an interpolant (Fitting, 1996).
Assume œÜ ‚Üí œà is valid, therefore œÜ ‚àß ¬¨œà is unsatisfiable. Then there is a closed tableau
corresponding to œÜ ‚àß ¬¨œà. In order to compute an interpolant from this tableau one needs
to modify it to a biased tableau.
Definition 7 (Biased tableau). A biased tableau for formulas œÜ ‚àß ¬¨œà is a tree T = (V, E)
where:
‚Ä¢ V is a set of nodes, each node is labelled by a set of biased formulas. A biased formula
is an expression in the form of L(œï) or R(œï) where œï is a formula. For each node n,
S(n) denotes the set of biased formulas labelling n.
895

Franconi, Kerhet, & Ngo

‚Ä¢ The root of the tree is labelled by {L(œÜ), R(¬¨œà)}
‚Ä¢ E is a set of edges. Given 2 nodes n1 and n2 , (n1 , n2 ) ‚àà E iff there is a biased
completion rule from n1 to n2 . We say there is a biased completion rule from n1 to
n2 if
‚Äì Y (¬µ) is the result of applying a rule to X(œï), where X and Y refer to L or R
(for some rules, there are two possibilities of choosing Y (¬µ)), and
‚Äì S(n2 ) = (S(n1 ) \ {X(œï)}) ‚à™ {Y (¬µ)}.
Let C be the set of all constants in the input formulas of the tableau. C par extends C
with an infinite set of new constants. A constant is new if it does not occur anywhere in
the tableau. With these notations, we have the following rules :
‚Ä¢ Propositional rules
X(¬¨¬¨œï)
X(œï)

Negation rules
X(¬¨>)
X(‚ä•)

Œ±‚àírule
X(œï1 ‚àß œï2 )

X(¬¨‚ä•)
X(>)

X(œï1 )
X(œï2 )

Œ≤‚àírule
X(¬¨(¬¨œï1 ‚àß ¬¨œï2 ))
X(œï1 ) | X(œï2 )

‚Ä¢ First order rules
Œ≥‚àírule
X(‚àÄx.œï)

œÉ‚àírule
X(‚àÉx.œï)

X(œï(t))
for any t ‚àà C par

X(œï(c))
for a new constant c

‚Ä¢ Equality rules
reflexivity rule

replacement rule
X(t = u)
Y (œï(t))

X(œï)
t‚àà

X(t = t)
occurs in œï

Y (œï(u))

C par

A node in the tableau is closed if it contains X(œï) and Y (¬¨œï). If a node is closed, no
rule is applied. In the other words, it becomes a leaf of the tree. A branch is closed if it
contains a closed node and a tableau is closed if all of its branches are closed. Obviously, if
the standard tableau for FOL is closed then so is the biased tableau and vice versa.
Given a closed biased tableau, the interpolant is computed by applying interpolant rules.
int
An interpolant rule is written as S ‚àí‚Üí I, where I is a formula and
S = {L(œÜ1 ), L(œÜ2 ), ..., L(œÜn ), R(œà1 ), R(œà2 ), ..., R(œàm )}.
‚Ä¢ Rules for closed branches
int

int

r1. S ‚à™ {L(œï), L(¬¨œï)} ‚àí‚Üí ‚ä•

r2. S ‚à™ {R(œï), R(¬¨œï)} ‚àí‚Üí >

int

int

r3. S ‚à™ {L(‚ä•)} ‚àí‚Üí ‚ä•

r4. S ‚à™ {R(‚ä•)} ‚àí‚Üí >
int

int

r5. S ‚à™ {L(œï), R(¬¨œï)} ‚àí‚Üí œï

r6. S ‚à™ {R(œï), L(¬¨œï)} ‚àí‚Üí ¬¨œï
896

Exact Query Reformulation over DBs with FO and DL Ontologies

‚Ä¢ Rules for propositional cases
int
S ‚à™ {X(œï)} ‚àí‚Üí I
p1.

p4.

p6.

int

p2.

int

S ‚à™ {X(¬¨¬¨œï)} ‚àí‚Üí I
int
S ‚à™ {X(œï1 ), X(œï2 )} ‚àí‚Üí I

S ‚à™ {X(>)} ‚àí‚Üí I
int

int

p3.

S ‚à™ {X(‚ä•)} ‚àí‚Üí I
int

S ‚à™ {X(¬¨‚ä•)} ‚àí‚Üí I
S ‚à™ {X(¬¨>)} ‚àí‚Üí I
int
int
S ‚à™ {L(œï1 )} ‚àí‚Üí I1 S ‚à™ {L(œï2 )} ‚àí‚Üí I2
p5.

int

int

S ‚à™ {X(œï1 ‚àß œï2 )} ‚àí‚Üí I
S ‚à™ {L(¬¨(¬¨œï1 ‚àß ¬¨œï2 ))} ‚àí‚Üí I1 ‚à® I2
int
int
S ‚à™ {R(œï1 )} ‚àí‚Üí I1 S ‚à™ {R(œï2 )} ‚àí‚Üí I2
int

S ‚à™ {R(¬¨(¬¨œï1 ‚àß ¬¨œï2 ))} ‚àí‚Üí I1 ‚àß I2
‚Ä¢ Rules for first order cases :
int
S ‚à™ {X(œï(p))} ‚àí‚Üí I
f1.

f2.

f3.

f4.

f5.

where p is a parameter that does not occur in S or œï

int

S ‚à™ {X(‚àÉx.œï(x))} ‚àí‚Üí I
int
S ‚à™ {L(œï(c))} ‚àí‚Üí I
int

if c occurs in {œï1 , ..., œïn }

S ‚à™ {L(‚àÄx.œï(x))} ‚Üí I
int
S ‚à™ {R(œï(c))} ‚àí‚Üí I
int

if c occurs in {œà1 , ..., œàm }

S ‚à™ {R(‚àÄx.œï(x))} ‚àí‚Üí I
int
S ‚à™ {L(œï(c))} ‚àí‚Üí I
int

S ‚à™ {L(‚àÄx.œï(x))} ‚àí‚Üí ‚àÄx.I[c/x]
int
S ‚à™ {R(œï(c))} ‚àí‚Üí I
int

if c does not occur in {œï1 , ..., œïn }
if c does not occur in {œà1 , ..., œàm }

S ‚à™ {R(‚àÄx.œï(x))} ‚àí‚Üí ‚àÉx.I[c/x]
‚Ä¢ Rules for equality cases
int
S ‚à™ {X(œï(p)), X(t = t)} ‚àí‚Üí I
e1.

e3.

int

int

e2.

S ‚à™ {X(œï(p))} ‚àí‚Üí I
int
S ‚à™ {L(œï(u)), R(t = u)} ‚àí‚Üí I
int

S ‚à™ {X(œï(u)), X(t = u)} ‚àí‚Üí I
int

S ‚à™ {X(œï(t)), X(t = u)} ‚àí‚Üí I
if u occurs in œï(t), œà1 , ..., œàm

S ‚à™ {L(œï(t)), R(t = u)} ‚àí‚Üí t = u ‚Üí I
int
S ‚à™ {R(œï(u)), L(t = u)} ‚àí‚Üí I

if u occurs in œï(t), œà1 , ..., œàm
int
S ‚à™ {R(œï(t)), L(t = u)} ‚àí‚Üí t = u ‚àß I
int
S ‚à™ {L(œï(u)), R(t = u)} ‚àí‚Üí I
e5.
if u does not occur in œï(t), œà1 , ..., œàm
int
S ‚à™ {L(œï(t)), R(t = u)} ‚àí‚Üí I[u/t]
int
S ‚à™ {R(œï(u)), L(t = u)} ‚àí‚Üí I
e6.
if u does not occur in œï(t), œà1 , ..., œàm
int
S ‚à™ {R(œï(t)), L(t = u)} ‚àí‚Üí I[u/t]
e4.

In summary, in order to compute an interpolant of œÜ and œà, one first need to generate
a biased tableaux proof of unsatisfiability of œÜ ‚àß ¬¨œà using biased completion rules and then
apply interpolant rules from bottom leaves up to the root.
Let us consider an example to demonstrate how the method works.
Example 6. Let P = {S, G, U }, PDB = {S, U },
897

Franconi, Kerhet, & Ngo

KB = { ‚àÄx(S(x) ‚Üí (G(x) ‚à® U (x)))
‚àÄx(G(x) ‚Üí S(x))
‚àÄx(U (x) ‚Üí S(x))
‚àÄx(G(x) ‚Üí ¬¨U (x))}
Q(x) = G(x)
Obviously, Q is implicitly definable from S and U , since the ontology states that G and
U partition S. Now we will follow the tableau method to find its exact reformulation. For
int
compactness, we use the notation S I instead of S ‚àí‚Üí I.
S0 = {L(‚àÄx(S(x) ‚Üí (G(x) ‚à® U (x)))),
L(‚àÄx(G(x) ‚Üí S(x))),
L(‚àÄx(U (x) ‚Üí S(x))),
L(‚àÄx(G(x) ‚Üí ¬¨U (x))),
L(G(c)),
R(‚àÄx(S(x) ‚Üí (G1 (x) ‚à® U (x)))),
R(‚àÄx(G1 (x) ‚Üí S(x))),
R(‚àÄx(U (x) ‚Üí S(x))),
R(‚àÄx(G1 (x) ‚Üí ¬¨U (x))),
R(¬¨G1 (c))}
By applying the rule for ‚àÄ and removing the implication, we have:
S1 = {L(¬¨S(c) ‚à® G(c) ‚à® U (c)),
L(¬¨G(c) ‚à® S(c))),
L(¬¨U (c) ‚à® S(c)),
L(¬¨G(c) ‚à® ¬¨U (c)),
L(G(c)),
R(¬¨S(c) ‚à® G1 (c) ‚à® U (c)),
R(¬¨G1 (c) ‚à® S(c)),
R(¬¨U (c) ‚à® S(c)),
R(¬¨G1 (c) ‚à® ¬¨U (c)),
R(¬¨G1 (c))}
and the interpolant of S1 can be computed as follows:
S4 ‚à™ {R(¬¨S(c)}S(c)

S4 ‚à™ {R(U (c))}¬¨U (c)

S4 = S3 ‚à™ {R(¬¨S(c) ‚à® U (c))}(S(c)‚àß¬¨U (c))

‚à®

S3 ‚à™ {R(G1 (c))}>

(S(c)‚àß¬¨U (c))

B.7

S2 ‚à™ {L(¬¨G(c))}‚ä•

S3 = S2 ‚à™ {L(¬¨U (c))}

(S(c)‚àß¬¨U (c))

S2 = S1 ‚à™ {L(S(c))}

(S(c)‚àß¬¨U (c))

B.5

S1 ‚à™ {L(¬¨G(c))}‚ä•

B.3

S1

b
Therefore, S(c)‚àß¬¨U (c) is the interpolant and Q(x)
= S(x)‚àß¬¨U (x) is an exact reformulation
of Q(x).
898

Exact Query Reformulation over DBs with FO and DL Ontologies

Algorithm 1 Safe-range Reformulation
Input: a safe-range KB, a safe-range and implicitly definable query Q[X] .
Output: an exact safe-range reformulation.
b[X] as in Theorem 7
1: Compute the interpolant Q
b[X] do
2: For each free variable x which is not bounded by any positive predicate in Q
b[X] := Q
b[X] ‚àß Adom b (x)
Q
Q
b[X]
3: Return Q

6.2 A Safe-Range Reformulation
Now we want to show that the reformulation computed by the above tableau based method
under the condition of Theorem 5 generates a ground safe-range query.
Theorem 8 (Ground safe-range Reformulation). Let KB be an ontology, and let Q be
a query which is implicitly definable from PDB . If KB and Q are safe-range then a rewritten
b obtained using the tableau method described in Section 6.1 is ground safe-range.
query Q
In other words, the conditions of Theorem 8 guarantee that all quantified variables in the
reformulation are range-restricted. We need to consider now the still unsafe free variables.
The theorem below will help us deal with non-range-restricted free variables. Let us first
define the active domain predicate of a query Q as the safe-range formula:
Adom Q (x) :=
 W
W
P ‚ààPQ ‚àÉz1 , . . . , zar(P )‚àí1 . P (x, z1 , . . . , zar(P )‚àí1 ) ‚à® . . . ‚à® P (z1 , . . . , zar(P )‚àí1 , x) ‚à®
c‚ààCQ (x = c).

Theorem 9 (Range of the query). Let KB be a domain independent ontology, and let
Q[x1 ,...,xn ] be a query which is domain independent with respect to KB. Then
KB |= ‚àÄx1 , . . . , xn . Q[x1 ,...,xn ] ‚Üí Adom Q (x1 ) ‚àß . . . ‚àß Adom Q (xn ).
Given a safe-range ontology, a safe-range and implicitly definable query is obviously
domain independent with respect to the ontology. In this case, Theorem 9 says that the
answer of the reformulation can only include active domain elements. Therefore, the active
domain predicate can be used as a ‚Äúguard‚Äù for free variables which are not bounded by any
positive predicate.
Based on Theorem 8 and Theorem 9, we propose a complete procedure to construct a
safe-range reformulation in Algorithm 1.

7. The Guarded Negation Fragment of ALCHOIQ
ALCHOIQ is an extension of the description logic ALC with role hierarchies, individuals,
inverse roles, and qualified cardinality restrictions: it corresponds to the SHOIQ description logic without transitive roles; it is the logic at the basis of OWL. The syntax and
semantics of ALCHOIQ concept expressions is summarised in the Figure 1, where A is an
atomic concept, C and D are concepts, o is an individual name, P is an atomic role, and
R is either P or P ‚àí . The forall and the qualified and unqualified atmost operators can be
derived by using negation and the atleast operator in the usual way. A TBox in ALCHOIQ
899

Franconi, Kerhet, & Ngo

Syntax
A
{o}
P
P‚àí
¬¨C
C uD
C tD
‚â• nR
‚â• nR.C

Semantics
AI ‚äÜ ‚àÜI
{oI } ‚äÜ ‚àÜI
P I ‚äÜ ‚àÜI √ó ‚àÜI
{(y, x)|(x, y) ‚àà P I }
‚àÜI \C I
C I ‚à© DI
C I ‚à™ DI
{x|#({y|(x, y) ‚àà RI }) ‚â• n}
{x|#({y|(x, y) ‚àà RI } ‚à© C I ) ‚â• n}

Figure 1: Syntax and semantics of ALCHOIQ concepts and roles
is a set of concept inclusion axioms C v D and role inclusion axioms R v S (where C, D
are concepts and R, S are roles) with the usual description logics semantics.
In this section, we present an application of Theorem 5, by introducing the ALCHOIQGN
description logic, the guarded negation syntactic fragment of ALCHOIQ (Figure 2) which
happens to express exactly the domain independent concepts and TBoxes of ALCHOIQ.
The language restricts ALCHOIQ by just prescribing that negated concepts should be
guarded by some generalised atom (an atomic concept, a nominal, an unqualified atleast
number restriction), i.e., absolute negation is forbidden. Similarly, the derived forall and
atmost operators would be guarded by using their standard definition as the dual of the
atleast operator, but with the guarded negation. ALCHOIQGN is actually at the intersection of the GNFO fragment (BaÃÅraÃÅny, ten Cate, & Otto, 2012) and ALCHOIQ (see
Appendix A.5 for details on GNFO).
ALCHOIQGN has the very important property of coinciding with the domain independent fragment of ALCHOIQ, therefore providing an excellent candidate language for
ontologies and queries satisfying the conditions of Theorem 5.
Theorem 10 (Expressive power equivalence). The domain independent fragment of
ALCHOIQ and ALCHOIQGN are equally expressive.
In other words the theorem says that any domain independent TBox axiom and any
domain independent concept query in ALCHOIQ is logically equivalent, respectively, to a
TBox axiom and a concept query in ALCHOIQGN , and vice-versa. This theorem provides
the description logics version of Codd‚Äôs theorem. Codd‚Äôs theorem states that the safe-range
syntactic fragment of FOL and the domain-independent fragment of FOL are precisely
equivalent in expressive power; that is, a database query can be formulated in one language
if and only if it can be expressed in the other.
R
B
C

::=
::=
::=

P | P‚àí
A | {o} | ‚â• nR
B | ‚â• nR.C | ‚â• nR.¬¨C | B u ¬¨C | C u D | C t D
Figure 2: Syntax of ALCHOIQGN concepts and roles
900

Exact Query Reformulation over DBs with FO and DL Ontologies

7.1 Applying the Constructive Theorem
We want to reformulate concept queries over an ontology with a DBox so that the reformulated query can be evaluated as an SQL query over the database represented by the DBox.
In this context, the database is a DBox, the ontology is an ALCHOIQGN TBox, and the
query is an ALCHOIQGN concept query. A concept query is either an ALCHOIQGN
concept expression denoting an open formula with one free variable, or an ALCHOIQGN
ABox concept assertion denoting a boolean query. As expected, a DBox includes ground
atomic statements of the form A(a) and P (a, b) (where A is an atomic concept and P is an
atomic role). From Theorem 10 we can draw the following corollary.
Corollary 1. ALCHOIQGN TBoxes and concept queries are domain independent.
We can also prove the following theorem.
Theorem 11. ALCHOIQGN TBoxes with concept queries have finitely controllable determinacy.
Therefore, we satisfy the conditions of Theorem 5, with a language which is like the
very expressive ALCHOIQ description logic, but with guarded negation.
We argue that non-guarded negation should not appear in a cleanly designed ontology,
and, if present, should be fixed. Indeed, the use of absolute negative information‚Äîsuch as,
e.g., in ‚Äúa non-male is a female‚Äù (¬¨ male v female)‚Äîshould be discouraged by a clean
design methodology, since the subsumer would include all sorts of objects in the universe
(but the ones of the subsumee type) without any obvious control. Only guarded negative
information in the subsumee should be allowed‚Äîsuch as in the axiom ‚Äúa non-male person
is a female‚Äù (person u ¬¨ male v female).
This observation suggests a fix for non-guarded negations: for every non-guarded negation users will be asked to replace it by a guarded one, where the guard may be an arbitrary
atomic concept, or nominal, or non-qualified existential. Therefore, the user is asked to make
explicit the type of that concept, in a way to make it domain independent; note that the
type could be also a fresh new atomic concept. We believe that the fix we are proposing
for ALCHOIQ is a reasonable one, and would make all ALCHOIQ ontologies eligible to
be used with our framework.
7.2 A Complete Procedure
ALCHOIQGN is a decidable logic and it is a feasible application of our general framework.
Given an ALCHOIQGN ontology KB and a concept query Q, we can apply the procedure
below to generate a safe-range reformulation over the database concepts and roles (based
on the constructive theorem, all the conditions of which are satisfied), if it exists.
Input: An ALCHOIQGN TBox KB, a concept query Q in ALCHOIQGN , and a
database signature (database atomic concepts and roles).
g |= Q ‚â° Q
e using
1. Check the implicit definability of the query Q by testing if KB ‚à™ KB
a standard OWL2 reasoner (ALCHOIQGN is a sublanguage of OWL2). Continue if
this holds.
901

Franconi, Kerhet, & Ngo

b from the tableau proof generated in step 1 (see
2. Compute a safe-range reformulation Q
Section 6). This can be implemented as a simple extension of a standard DL reasoner
even in the presence of the most important optimisation techniques such as semantic
branching, absorption, and backjumping as explained by Seylan et al. (2009) and ten
Cate, Franconi, and Seylan (2011).
b expressed over the database signature.
Output: A safe-range reformulation Q
Note that the procedure for checking determinacy and computing the reformulation
could be run in offline mode at compile time. Indeed, it could be run for each atomic concept
in the ontology, and store persistently the outcome for each of them if the reformulation has
been successful. This pre-computation may be an expensive operation, since‚Äîas we have
seen‚Äîit is based on entailment, but the complexity involves only the size of the ontology
and not of the data.
In order to get an idea about the size of the reformulations, for the ALCF I description
logic there is a tableau-based algorithm computing explicit definitions of at most double
exponential size (ten Cate et al., 2011; ten Cate, Franconi, & Seylan, 2013); this algorithm is
optimal because it is also shown that the smallest explicit definition of an implicitly defined
concept may be double exponentially long in the size of the input TBox.
Clearly, similarly to DL-Lite reformulations, more research is needed in order to optimise
the reformulation step in order to make it practical. However, note that the framework
presented here has a clear advantage from the point of view of conceptual modelling since
implicit definitions (that is, queries) under general TBoxes can be double exponentially
more succinct than acyclic concept definitions (that is, explicit queries over the database).
There is also another interesting open problem about checking that a given database
is legal with respect to a given ontology. Remember that a database DB is legal for an
ontology KB if there exists a model of KB embedding DB. This check involves heavy
computations for which an optimised algorithm is still unknown: as a matter of fact, the
only known method today is to reduce the problem to a satisfiability problem where the
database is embedded in a TBox using nominals (Franconi et al., 2011). More research is
needed in order to optimise the reasoning with nominals in this special case.
Appendix A.5 contains all the definitions and theorems needed to prove theorems 10
and 11.

8. Conclusion
We have introduced a framework to compute the exact reformulation of first-order queries
to a database under ontologies. We have found the exact conditions which guarantee that
a safe-range reformulation exists, and we show that it can be evaluated as a relational
algebra query over the database to give the same answer as the original query under the
ontology. A non-trivial case study has been presented in the field of description logics, with
the ALCHOIQ language.
We have also implemented a tool based on the Prover9 theorem prover (McCune, 2011).
Given an arbitrary first-order ontology, a database signature, and an arbitrary first-order
query in TPTP syntax, the tool performs all the tests on them to check whether a reformulation can be computed, and it computes an optimal safe-range reformulation.
902

Exact Query Reformulation over DBs with FO and DL Ontologies

This framework is useful in data exchange-like scenarios, where the target database
(made by determined relations) should be materialised as a proper database, over which
arbitrary queries should be performed. This is not achieved in a context with non-exact
rewritings preserving the certain answers. In our scenario with description logics ontologies,
rewritings of concept queries are pre-computed offline once. We have shown that our framework works in theory also in the case of arbitrary safe-range first-order queries, and our tool
shows that this is possible in practice. In the case of description logics, we are working on
extending the theoretical framework with conjunctive queries: we need finitely controllable
determinacy with conjunctive queries, which seems to follow for some description logic from
the works by BaÃÅraÃÅny, Gottlob, and Otto (2010) and Rosati (2011).
In future work, we would like to study optimisations of reformulations. From the practical perspective, since there might be many rewritten queries from one original query, the
problem of selecting an optimised query in terms of query evaluation is very important. In
fact, one has to take into account which criteria should be used to optimise, such as: the
size of the rewritings, the numbers of used predicates, the priority of predicates, the number
of relational operators, and clever usage of duplicates. With the tool, we plan to evaluate
our proposed technique in a real context.
Concurrently, we are exploring the problem of fixing real ontologies in order to enforce
definability when it is known it should be the case (Franconi, Ngo, & Sherkhonov, 2012c).
This happens when it is intuitively obvious that the answer of a query can be found from
the available data (that is, the query is definable from the database), but the mediating
ontology does not entail the definability. We introduce the novel problem of definability
abduction and we solve it completely in the data exchange scenario.
We thank the anonymous reviewers for the very useful comments we got on earlier versions of this paper. We wish to thank Alex Borgida, Tommaso Di Noia, Umberto Straccia,
David Toman, and Grant Weddell for the fruitful discussions we had on the topics of this
paper.

Appendix A. Proofs
A.1 Proofs of Section 2
Proposition 1
Proof.

Let

Asna = {Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà I(SNA)‚à©M (KB)‚à©E(DB) : I |= Q[X/Œò] }
and
Auna = {Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà I(UNA)‚à©M (KB)‚à©E(DB) : I |= Q[X/Œò] }
Since SNA is stricter than UNA, i.e. I(SNA) ‚äÜ I(UNA), we have: Auna ‚äÜ Asna trivially.
Let ŒòÃÑ ‚àà Asna . If ŒòÃÑ ‚àà
/ Auna then there is an interpretation IÃÑ = h‚àÜIÃÑ , ¬∑IÃÑ i embedding
DB and satisfying UNA such that IÃÑ ‚àà M (KB) and IÃÑ 6|= Q[X/ŒòÃÑ] . Let us construct new
¬Ø
¬Ø
interpretation J¬Ø = h‚àÜJ , ¬∑J i embedding DB as follows:
¬Ø

‚Ä¢ ‚àÜJ := (‚àÜIÃÑ \ {aIÃÑ | a ‚àà C}) ‚à™ C;
903

Franconi, Kerhet, & Ngo

¬Ø

‚Ä¢ for each constant a ‚àà C, aJ := a;
¬Ø

‚Ä¢ for every predicate P ‚àà P, PJ is constructed from PIÃÑ by replacing of each element
aIÃÑ ‚àà PIÃÑ , where a is some constant, with a.
Obviously, J¬Ø satisfies SNA and J¬Ø and IÃÑ are isomorphic. Since first-order logic sentences cannot distinguish two isomorphic structures, J¬Ø 6|= Q[X/ŒòÃÑ] which contradicts with
the assumption ŒòÃÑ ‚àà Asna . Therefore ŒòÃÑ ‚àà Auna .
A.2 Proofs of Section 4
Proposition 2.
b[X] is an exact reformulation of Q[X] , KB |= ‚àÄX.Q[X] ‚Üî Q
b[X] . Then, for any
Proof. Since Q
I
b[X] ,
model I ‚àà M (KB) and for any substitution Œò : X 7‚Üí ‚àÜ we have: I, Œò |= Q[X] ‚Üî Q
b[X] ).
which is equivalent to (I, Œò |= Q[X] ‚áê‚áí I, Œò |= Q
Now, let ŒòÃÑ be any substitution from {Œò | dom(Œò) = X, rng(Œò) = C, ‚àÄ I ‚àà M (KB) ‚à©
E(DB) : I |= Q[X/Œò] }, and I = h‚àÜ, ¬∑I i be any model of the KB embedding the DB (if
there are any). Let ŒòÃÉ := ¬∑I ‚ó¶ ŒòÃÑ‚Äîa composition of the substitution ŒòÃÑ and the interpretation
function ¬∑I (i.e. ŒòÃÉ(x) = a ‚àà ‚àÜ iff ŒòÃÑ(x) = c ‚àà C and cI = a). Then I, ŒòÃÉ |= Q[X] ‚áê‚áí
b[X] ‚áê‚áí I |= Q
b
b
I |= Q[X/ŒòÃÑ] and I, ŒòÃÉ |= Q
[X/ŒòÃÑ] . Summing up: I |= Q[X/ŒòÃÑ] ‚áê‚áí I |= Q[X/ŒòÃÑ] .
b[X/Œò] }. The
Hence, ŒòÃÑ ‚àà {Œò | dom(Œò) = X, rng(Œò) = C, ‚àÄ I ‚àà M (KB) ‚à© E(DB) : I |= Q
inverse inclusion can be proved similarly.
Theorem 3.
Proof. First of all recall that we assume SNA. In order to prove the theorem, one needs the
following two propositions.
Proposition 3 (Domain Independence). A query Q[X] is domain independent iff for
every two interpretations I = h‚àÜI , ¬∑I i and J = h‚àÜJ , ¬∑J i which agree on the interpretation
of the predicates from PQ (and all constants C), and for every substitution Œò : X 7‚Üí ‚àÜI ‚à™‚àÜJ
we have:
rng(Œò) ‚äÜ ‚àÜI and I, Œò |= Q[X]
iff
rng(Œò) ‚äÜ ‚àÜJ and J , Œò |= Q[X] .
Proof. (‚áê) Obviously, if the second part of the proposition holds, then the query is domain
independent.
(‚áí) Suppose, the query is domain independent. Let I = h‚àÜI , ¬∑I i and J = h‚àÜJ , ¬∑J i
be any two interpretations, which agree on the interpretation of all the predicates from PQ
(and all constants C), that is ¬∑I|PQ ‚à™C = ¬∑J |PQ ‚à™C . Let us fix any substitution Œò : X 7‚Üí ‚àÜI ‚à™‚àÜJ
(if the query is closed, we just omit everything, that concerns a substitution below in the
proof) such that:
rng(Œò) ‚äÜ ‚àÜI and I, Œò |= Q[X] .
(2)
904

Exact Query Reformulation over DBs with FO and DL Ontologies

0

0

Let us consider interpretations I 0 = h‚àÜI , ¬∑I i and J 0 = h‚àÜJ , ¬∑J i, such that ¬∑I|PQ ‚à™C =
0
0
0
I 0 |PQ ‚à™C
¬∑
= ¬∑J |PQ ‚à™C = ¬∑J |PQ ‚à™C , and ‚àÄP ‚àà P \ PQ : P I = ‚àÖ = P J . Let us consider now I and
I 0 . They have the same domain and interpret all the predicates and constants, occurring
in Q[X] equally. Therefore, since I, Œò |= Q[X] (by (2)), I 0 , Œò |= Q[X] .
Let us consider interpretations I 0 and J 0 . By construction, they agree on interpretation of all predicates and constants. Therefore, we can apply the definition of domain
independence to them. Then, since
rng(Œò) ‚äÜ ‚àÜI and I 0 , Œò |= Q[X] ,

(3)

rng(Œò) ‚äÜ ‚àÜJ and J 0 , Œò |= Q[X] .

(4)

we have, that
Then again interpretations J and J 0 have the same domain and interpret all the predicates
and constants, occurring in Q[X] equally. Thus, because of (4),
rng(Œò) ‚äÜ ‚àÜJ and J , Œò |= Q[X] .

(5)

Therefore, (2) =‚áí (5). Similarly (5) =‚áí (2), and the proposition is proved.

Proposition 4. If Q[X] is domain independent, then for any interpretation I = h‚àÜ, ¬∑I i
and any substitution Œò : X 7‚Üí ‚àÜ, such that I, Œò |= Q[X] , the following holds:
rng(Œò) ‚äÜ adom(œÉ(Q[X] ), I).
Proof. Assume, that X = {x}, that is Q has one free variable x (the proof can be easily
extended then to the general case).
Let us prove by contradiction. Suppose, there exists a substitution {x ‚Üí b} such that
I, {x ‚Üí b} |= Q(x) and b ‚àà ‚àÜ \ adom(œÉ(Q(x)), I). Let us consider interpretation I 0 =
h‚àÜ ‚à™ {a}, ¬∑I i, where a is any brand-new element, that does not appear in ‚àÜ. Then I 0 , {x ‚Üí
b} |= Q(x) because of domain independence of Q(x). Consider then another interpretation
00
I 00 = h‚àÜ ‚à™ {a}, ¬∑I i such that occurrence of b in interpretation of any predicate is replaced
with the element a. In other words, for any n-ary predicate P ‚àà P \ œÉ(Q(x)), (. . . , a, . . .) ‚àà
00
0
P I iff (. . . , b, . . .) ‚àà P I (since by supposition b does not appear in interpretations of
predicates in the query). Interpretations of all the other predicates and all the constants
are the same. Then I 00 satisfies SNA (even if b ‚àà C). Then, since I 0 , {x ‚Üí b} |= Q[X] , by
construction of I 00 we have: I 00 , {x ‚Üí a} |= Q(x), because we changed just interpretations
of predicates, that do not appear in the query. Then since I 0 and I 00 have the same domain
and agree on interpretations of all the predicates in Q(x) and all constants, the following
holds: I 0 , {x ‚Üí a} |= Q(x).
Let us now consider interpretations I = h‚àÜ, ¬∑I i and I 0 = h‚àÜ ‚à™ {a}, ¬∑I i. They have the
same interpretation function. Therefore, since Q(x) is domain independent and I 0 , {x ‚Üí
a} |= Q(x), we have: rng({x ‚Üí a}) ‚äÜ ‚àÜ. That is a ‚àà ‚àÜ. It is a contradiction, because by
supposition a 6‚àà ‚àÜ.
905

Franconi, Kerhet, & Ngo

Now we prove the theorem itself.
L := {Œò | dom(Œò) = X, rng(Œò) ‚äÜ C, ‚àÄ I ‚àà M (KB) ‚à© E(DB) : I |= Q[X/Œò] };
b DB), ‚àÄI = hC, ¬∑I i ‚àà E(DB) : I|P
R := {Œò | dom(Œò) = X, rng(Œò) ‚äÜ adom(œÉ(Q),

DB ‚à™C

b[X/Œò] }.
|= Q

b
Let ŒòÃÑ ‚àà L. Then for any I ‚àà M (KB) ‚à© E(DB) we have: I |= Q[X/ŒòÃÑ] and I |= Q
[X/ŒòÃÑ] ,
because of Proposition 2.
Consider any J = hC, ¬∑I i embedding DB. I and J agree on interpretations of C
b ‚à© P which is a subset of PDB .
(since we have SNA) and predicates from the set œÉ(Q)
b[X] is domain independent, by Proposition 3 we have: J |= Q
b
Then, since Q
[X/ŒòÃÑ] . Since
b
b
b
œÉ(Q[X] ) ‚äÜ PDB ‚à™ C, J |P ‚à™C |= Q
. Since Q[X] is domain independent, by Proposition
DB

[X/ŒòÃÑ]

b[X] ), J ). adom(œÉ(Q
b[X] ), J ) = adom(œÉ(Q
b[X] ), DB), because
4 we have: rng(ŒòÃÑ) ‚äÜ adom(œÉ(Q
b[X] ) ‚äÜ PDB ‚à™ C. Therefore, rng(ŒòÃÑ) ‚äÜ adom(œÉ(Q
b[X] ), DB). Then
we assume SNA and œÉ(Q
ŒòÃÑ ‚àà R and, hence, L ‚äÜ R.
b[X] ), DB)). Then for any J = hC, ¬∑I i embedding DB we
Let ŒòÃÑ ‚àà R (rng(ŒòÃÑ) ‚äÜ adom(œÉ(Q
b
b
have: J |PDB ‚à™C |= Q
[X/ŒòÃÑ] . Then J |= Q[X/ŒòÃÑ] . Consider any I ‚àà M (KB) ‚à© E(DB). Then J
b
and I agree on interpretations of C (since we have SNA) and PDB . Since œÉ(Q
) ‚äÜ PDB ‚à™C
[X/ŒòÃÑ]

b[X] is domain independent, by Proposition 3 we have: I |= Q
b
b
and Q
[X/ŒòÃÑ] . Since Q[X] is exact
reformulation of Q[X] under KB over PDB , by Proposition 2 we have: I |= Q[X/ŒòÃÑ] . Then
ŒòÃÑ ‚àà L and, hence, R ‚äÜ L.
Theorem 3 is proved completely.
A.3 Definitions and Proofs of Section 5
Proposition 5. Let KB be a domain independent ontology. If interpretation I = h‚àÜI , ¬∑I i
is a model of KB, then any J = h‚àÜJ , ¬∑J i, such that ¬∑I = ¬∑J , is also a model of KB.
Proof. Let Œ± be any sentence from KB. Then, since I is a model of KB, I |= Œ±. Œ± is domain
independent, because KB is domain independent. Hence, since ¬∑I = ¬∑J , J |= Œ±. Thus, J is
a model of any sentence from KB. It means, that J is a model of KB.

Proposition 6. Let KB be an ontology, and let Q[X] be a query which is domain independent
with respect to KB. Any exact reformulation of Q[X] under KB (over any set of predicates)
is also domain independent with respect to KB.
b[X] be any exact reformulation of Q[X] under KB (over some set of predicates),
Proof. Let Q
I
I
I = h‚àÜ , ¬∑ i and J = h‚àÜJ , ¬∑J i be any two models of KB such that ¬∑I = ¬∑J , and
Œò : X 7‚Üí ‚àÜI ‚à™ ‚àÜJ be any substitution such that
b[X] .
rng(Œò) ‚äÜ ‚àÜI and I, Œò |= Q
b
Then, since Q[X] is exact reformulation of Q[X] , we have: I, Œò |= Q[X] . Then, since Q[X]
is domain independent with respect to KB, we have:
rng(Œò) ‚äÜ ‚àÜJ and J , Œò |= Q[X] .
b[X] is exact reformulation of Q[X] , we have: J , Œò |= Q
b[X] . Thus, Q
b[X]
And again, since Q
is domain independent with respect to KB by definition.

906

Exact Query Reformulation over DBs with FO and DL Ontologies

Lemma 1. Let KB be a domain independent ontology, and let Q[X] be a query which is
domain independent with respect to KB. Then for any I = h‚àÜ, ¬∑I i which is a model of KB
and any substitution Œò : X 7‚Üí ‚àÜ such that I, Œò |= Q[X] the following holds:
rng(Œò) ‚äÜ adom(œÉ(Q[X] ), I).
Proof. Without loss of generality assume, that X = {x}, that is Q has one free variable x
(the proof can be easily extended then to the general case).
Let us prove by contradiction. Suppose that I, {x ‚Üí b} |= Q(x), where b ‚àà ‚àÜ \
adom(œÉ(Q[X] ), I). Since KB is domain independent, for any brand-new element a, that
does not appear in ‚àÜ, interpretation IÃÑ = h‚àÜ ‚à™ {a}, ¬∑I i is also a model of KB by Proposition
5. Then, since Q(x) is domain independent with respect to KB and I and IÃÑ have the same
interpretation function, IÃÑ, {x ‚Üí b} |= Q(x).
1
Consider a new interpretation I 1 = h‚àÜ ‚à™ {a}, ¬∑I i constructed from IÃÑ such that occurrence of b in interpretation of any predicate is replaced by element a. In other words, for
1
any n-ary predicate P ‚àà P \ PQ , (. . . , a, . . .) ‚àà P I iff (. . . , b, . . .) ‚àà P I (since by supposition
b does not appear in interpretations of predicates in the query).
Then, since IÃÑ, {x ‚Üí b} |= Q(x) and by construction of I 1 we have: I 1 , {x ‚Üí a} |= Q(x)
(since we simply replace b, that does not appear neither as a constant in Q(x) nor in
interpretations of predicates in Q(x), with a). Then, since IÃÑ and I 1 have the same domain
‚àÜ ‚à™ {a} and agree on interpretations of all the predicates from Q(x) and all the constants
(since we assume SNA), we have: IÃÑ, {x ‚Üí a} |= Q(x).
Let us now consider interpretations I = h‚àÜ, ¬∑I i and IÃÑ = h‚àÜ ‚à™ {a}, ¬∑I i. They are both
models of KB and have the same interpretation function ¬∑I . So, since Q(x) is domain
independent with respect to KB and IÃÑ, {x ‚Üí a} |= Q(x), we have: a ‚àà ‚àÜ and I, {x ‚Üí
a} |= Q(x) by definition of domain independence with respect to an ontology. It is a
contradiction, because by supposition a 6‚àà ‚àÜ. The lemma is proved.
Let Œ± be any set of formulas. Then Adom Œ± is defined similarly to Adom Q , where Q is
a query.
Lemma 2. Let KB be a domain independent ontology, and let Q[X] (X = {x1 , ..., xn }) be a
query which is domain independent with respect to KB. Then the following holds:
KB |= ‚àÄX.Q[X] ‚Üî Q[X] |Adom KB‚à™Q
where Q[X] |Adom KB‚à™Q is Q0 [X] ‚àß Adom KB‚à™Q (x1 ) ‚àß ... ‚àß Adom KB‚à™Q (xn ), and Q0 [X] is Q[X]
such that:
‚Ä¢ Every sub-formula of Q[X] in the form of ‚àÉx.œÜ(x) is replaced by ‚àÉx.œÜ(x)‚àßAdom KB‚à™Q (x)
‚Ä¢ Every sub-formula of Q[X] in the form of ‚àÄx.œÜ(x) is replaced by ‚àÄx.Adom KB‚à™Q (x) ‚Üí
œÜ(x)
Proof. Without loss of generality, we will prove the lemma when n = 1. In this case, we
write Q(x) instead of Q[X] . We prove by contradiction.
Assume there is a model I = h‚àÜI , ¬∑I i of KB and an element a ‚àà ‚àÜI such that I, {x ‚Üí
a} |= Q(x) but I, {x ‚Üí a} 6|= Q(x)|Adom KB‚à™Q .
907

Franconi, Kerhet, & Ngo

We construct a new interpretation J = hAdom IKB‚à™Q ‚à™ C, ¬∑J i such that for any predicate
P ‚àà PKB‚à™Q , P J := P I , and for any predicate P ‚àà P \ PKB‚à™Q , P J := ‚àÖ.
Since KB is domain independent, J is also a model of KB by Proposition 5. Then,
J , {x ‚Üí a} |= Q(x) because Q is domain independent with respect to KB. As a consequence, however, J , {x ‚Üí a} |= Q(x)|Adom KB‚à™Q by the definition of Q(x)|Adom KB‚à™Q .
Q(x)|Adom KB‚à™Q is safe-range by construction (see Definition 10). Hence, it is domain
independent. Therefore I, {x ‚Üí a} |= Q(x)|Adom KB‚à™Q . Contradiction.
Assume there is a model I = h‚àÜI , ¬∑I i of KB and an element a ‚àà ‚àÜI such that I, {x ‚Üí
a} |= Q(x)|Adom KB‚à™Q but I, {x ‚Üí a} 6|= Q(x). One can lead to a contradiction similarly
as above. Therefore, the lemma is proved.
Theorem 4.
Proof. The theorem can be proved after Theorem 5.
‚Ä¢ The ‚Äúif‚Äù direction. Based on Lemma 2, one can see that exact reformulations of Q[X]
are also exact reformulations of Q[X] |Adom KB‚à™Q . Since Q[X] |Adom KB‚à™Q is safe-range
and KB can always be transformed to a logically equivalent safe-range ontology KB 0 ,
b[X] found in Theorem 5 which takes
obviously the exact safe-range reformulation Q
0
KB and Q[X] |Adom KB‚à™Q as its input is the exact domain independent reformulation
of Q[X] .
‚Ä¢ The ‚Äúonly if‚Äù direction.
b[X] of Q[X]
Suppose, that there exists an exact domain independent reformulation Q
over PDB under KB. Then it is domain independent with respect to KB. Hence, by
Proposition 6, Q[X] is domain independent with respect to KB. Since there exists an
exact reformulation of Q[X] , Q[X] is implicitly definable from PDB under KB by the
Theorem 1.
The theorem is proved completely.
In order to help readers follow easier, we recall here formal definitions of safe-range and
safe-range normal form (Abiteboul et al., 1995).
Definition 8 (safe-range normal form). denoted by SRNF
A first order formula can be transformed to SRNF by following steps :
‚Ä¢ Variable substitution: no distinct pair of quantifiers may employ same variable.
‚Ä¢ Remove universal quantifiers
‚Ä¢ Remove implications
‚Ä¢ Push negation
‚Ä¢ Flatten and/or
908

Exact Query Reformulation over DBs with FO and DL Ontologies

Definition 9 (Range restriction of a formula). denoted by rr
Input : a formula œï in SRNF
Output : a subset of free(œï) or ‚ä•
Case œï of
‚Ä¢ R(e1 , ..., en ) : rr(œï) = set of variables in e1 , ..., en
‚Ä¢ x = a or a = x, where a is a constant : rr(œï) = {x}
‚Ä¢ x = y : rr(œï) = ‚àÖ
‚Ä¢ œï1 ‚àß œï2 : rr(œï) = rr(œï1 ) ‚à™ rr(œï2 )
‚Ä¢ œï1 ‚à® œï2 : rr(œï) = rr(œï1 ) ‚à© rr(œï2 )
‚Ä¢ œï1 ‚àß x = y : rr(œï) = rr(œï1 ) if {x, y} ‚à© rr(œï1 ) = ‚àÖ; rr(œï) = rr(œï1 ) ‚à™ {x, y} otherwise
‚Ä¢ ¬¨œï1 : rr(œï) = ‚àÖ ‚à© rr(œï1 )
‚Ä¢ ‚àÉxœï1 : rr(œï) = rr(œï1 )\{x} if x ‚àà rr(œï1 ); rr(œï) = ‚ä• otherwise
Note : ‚ä• ‚à™ Z = ‚ä• ‚à© Z = ‚ä•\Z = Z\‚ä• = ‚ä•
Definition 10 (safe-range). A formula œï is safe-range iff rr(SRNF(œï)) = free(œï).
Definition 11 (ground safe-range). A formula œï is ground safe-range iff after substitution of free variables of œï with constants it becomes safe-range.
Observation 1.
1. For any query Q[X] and any interpretation I = h‚àÜ, ¬∑I i the following holds:
Adom IQ = adom(œÉ(Q[X] ), I).
2. Adom Q (x) is safe-range.
Theorem 5.
Proof. The theorem can be proved after Theorem 8 and Theorem 9.
We will use the following lemma in the proof.
Lemma 3. If KB is an ontology, Q[X] (X = {x1 , . . . , xn }) is ground safe-range query and
KB |= ‚àÄX. Q[X] ‚Üí œà1 (x1 ) ‚àß . . . ‚àß œàn (xn ),

(6)

b[X] := Q[X] ‚àßœà1 (x1 )‚àß. . .‚àßœàn (xn )
where œà1 , . . . , œàn are n safe-range formulas, then the query Q
b
is safe-range and KB |= ‚àÄX. Q[X] ‚Üî Q[X] .
909

Franconi, Kerhet, & Ngo

Proof. Let Q0[X] be a safe-range normal form of the query Q[X] , i.e. Q0[X] := SRNF(Q[X] ) =
‚àÉY. œÜ[X‚à™Y] , where œÜ[X‚à™Y] is in conjunctive normal form (the safe-range normal form of the
query is in prenex normal form). Then Q0[X] is ground safe-range, and KB |= Q0[X] ‚Üî Q[X] .
Hence, KB |= ‚àÄX. Q0[X] ‚Üí œà1 (x1 ) ‚àß . . . ‚àß œàn (xn ). Let Q00[X] := Q0[X] ‚àß œà10 (x1 ) ‚àß . . . ‚àß œàn0 (xn ),
where each œài0 (xi ) = SRNF(œài (xi )). Then by 6, KB |= Q0[X] ‚Üî Q00[X] . On the other hand
b[X] ‚Üî Q00 by construction. Summing up everything, we have: KB |= Q
b[X] ‚Üî
KB |= ‚àÄX. Q
[X]

b[X] is safe-range.
Q[X] and the only thing we need to prove is that Q
00
0
One can see, that Q[X] ‚â° ‚àÉY. (œÜ[X‚à™Y] ‚àßœà1 (x1 )‚àß. . .‚àßœàn0 (xn )) which is a safe-range normal
b[X] . Since Q0 = ‚àÉY. œÜ[X‚à™Y] is ground safe-range, then rr(œÜ[X‚à™Y] ) \ X = Y0 ‚äÜ Y,
form of Q
[X]

where for any y ‚àà Y\Y0 there exists a conjunct x = y in œÜ[X‚à™Y] , for some x ‚àà X. Then, since
each œài0 (xi ) is safe-range, by definition of range restriction rr(œÜ[X‚à™Y] ‚àßœà10 (x1 )‚àß. . .‚àßœàn0 (xn )) =
X ‚à™ Y, and then rr(‚àÉY. (œÜ[X‚à™Y] ‚àß œà10 (x1 ) ‚àß . . . ‚àß œàn0 (xn ))) = X = free(Q00[X] ). Therefore,
b[X] is safe‚àÉY. (œÜ[X‚à™Y] ‚àß œà10 (x1 ) ‚àß . . . ‚àß œàn0 (xn )) is safe-range by definition, and hence Q
range.
Let us continue to prove the theorem.
b by using
If X = ‚àÖ, (Q is closed) then we build an exact safe-range reformulation Q
Theorem 8.
Suppose now, X = {x1 , . . . , xn }. Since Q[X] is safe-range and implicitly definable from
PDB , we apply Theorem 8 for Q[X] and construct a ground safe-range rewriting Q0[X] expressed over PDB such that KB |= ‚àÄX. Q[X] ‚Üî Q0[X] . Since Q[X] is domain independent
(since it is safe-range), it is also domain independent with respect to KB. Hence, by Proposition 6, Q0[X] is also domain independent with respect to KB. Moreover, KB is safe-range
and, hence, domain independent. Then by Theorem 9:
KB |= ‚àÄX. Q0[X] ‚Üí Adom Q (x1 ) ‚àß . . . ‚àß Adom Q (xn ).
By the second item of Observation 1 Adom Q (x) is a safe-range formula. Then by Lemma 3
b[X] := Q0 ‚àß Adom Q0 (x1 ) ‚àß . . . ‚àß Adom Q0 (xn ) is safe-range and KB |= ‚àÄX. Q0 ‚Üî
the query Q
[X]
[X]
b[X] . Since KB |= ‚àÄX. Q[X] ‚Üî Q0 , we have: KB |= ‚àÄX. Q[X] ‚Üî Q
b[X] . Therefore, the
Q
[X]

b[X] is the one we were looking for.
constructed query Q
Theorem 5 is proved completely.
A.4 Proofs of Section 6
Theorem 7.
Proof. First we will prove that if Q is implicitly definable then the formula (1) is valid.
g |= ‚àÄX.Q[X] ‚Üî Q
g
Applying syntactic definition of implicit definability: KB ‚à™ KB
[X] . Therefore,
when
we
replace
X
by
a
set
of
constants
c
,
...,
c
,
the
following
formula
is valid
1
n
V
Vg
e[X/c ,...,c ] ). As a consequence, (1) is valid.
( KB ‚àß KB)
‚Üí (Q[X/c1 ,...,cn ] ‚Üî Q
n
1
b[c ,...,c /X] ) where Q
b[X/c ,...,c ] is a Craig interNext, we have to prove KB |= (Q[X] ‚Üî Q
n
0
n‚àí1
1
b[X/c ,...,c ] is an interpolant:
polant of (1). Since Q
1

n

910

Exact Query Reformulation over DBs with FO and DL Ontologies

V
b[X/c ,...,c ]
1. (( KB) ‚àß Q[X/c1 ,...,cn ] ) ‚Üí Q
n
1
b[X/c ,...,c ] )
Then : KB |= (Q[X/c1 ,...,cn ] ‚Üí Q
n
1
g ‚ÜíQ
e[X/c ,...,c ] )
b[X/c ,...,c ] ‚Üí ((V KB)
2. Q
n
n
1
1
g |= (Q
b[X/c ,...,c ] ‚Üí Q
e[X/c ,...,c ] ).
Then : KB
n
n
1
1
b ‚äÜ PDB , the relation KB |= (Q
b[X/c ,...,c ] ‚Üí Q[X/c ,...,c ] ) holds as well
Since œÉ(Q)
n
n
1
1
From(1)(2) we have the expected statement.
b[X/c ,...,c ] ) ‚äÜ PDB then œÉ(Q
b[c ,...,c /X] ) ‚äÜ PDB .
Last but not least, since œÉ(Q
n
n
1
1
b[c ,...,c /X] is really an explicit definition of Q
With above statements, Q
n
1
Theorem 8.
Proof. We need the following propositions to prove the theorem.
Proposition 7. œï1 ‚àß œï2 is safe-range and closed iff œï1 and œï2 are safe-range and closed.
Proof. We have:
‚Ä¢ rr(œï1 ‚àß œï2 ) = rr(œï1 ) ‚à™ rr(œï2 )
‚Ä¢ free(œï1 ‚àß œï2 ) = free(œï1 ) ‚à™ free(œï2 )
‚Ä¢ rr(œï1 ) = ‚ä• or rr(œï1 ) ‚äÜ free(œï1 )
‚Ä¢ rr(œï2 ) = ‚ä• or rr(œï2 ) ‚äÜ free(œï2 )
‚Ä¢ œï1 ‚àß œï2 is closed iff f ree(œï1 ) = free(œï2 ) = ‚àÖ
‚Ä¢ œï1 is closed iff free(œï1 ) = ‚àÖ
‚Ä¢ œï2 is closed iff free(œï2 ) = ‚àÖ
‚Ä¢ œï1 ‚àß œï2 is safe-range iff rr(œï1 ‚àß œï2 ) = free(œï1 ‚àß œï2 )
‚Ä¢ œï1 is safe-range iff rr(œï1 ) = free(œï1 )
‚Ä¢ œï1 is safe-range iff rr(œï2 ) = free(œï2 )
Therefore:
‚Ä¢ œï1 ‚àß œï2 is closed iff œï1 and œï2 are closed
‚Ä¢ œï1 ‚àß œï2 is closed, safe-range iff œï1 and œï2 are closed, safe-range.

Proposition 8. œï1 ‚à® œï2 is safe-range and closed iff œï1 and œï2 are safe-range and closed.
Proof. We have:
‚Ä¢ rr(œï1 ‚à® œï2 ) = rr(œï1 ) ‚à© rr(œï2 )
911

Franconi, Kerhet, & Ngo

‚Ä¢ free(œï1 ‚à® œï2 ) = free(œï1 ) ‚à™ free(œï2 )
‚Ä¢ rr(œï1 ) = ‚ä• or rr(œï1 ) ‚äÜ free(œï1 )
‚Ä¢ rr(œï2 ) = ‚ä• or rr(œï2 ) ‚äÜ free(œï2 )
‚Ä¢ œï1 ‚à® œï2 is closed iff free(œï1 ) = free(œï2 ) = ‚àÖ
‚Ä¢ œï1 is closed iff free(œï1 ) = ‚àÖ
‚Ä¢ œï2 is closed iff free(œï2 ) = ‚àÖ
‚Ä¢ œï1 ‚à® œï2 is safe-range iff rr(œï1 ‚à® œï2 ) = free(œï1 ‚à® œï2 )
‚Ä¢ œï1 is safe-range iff rr(œï1 ) = free(œï1 )
‚Ä¢ œï1 is safe-range iff rr(œï2 ) = free(œï2 )
Therefore:
‚Ä¢ œï1 ‚à® œï2 is closed iff œï1 and œï2 are closed
‚Ä¢ œï1 ‚à® œï2 is closed, safe-range iff œï1 and œï2 are closed, safe-range.

Proposition 9. ‚àÄ~xœï(~x) is closed and safe-range then œï(~t) is closed and safe-range where
~t are constants.
Proof. Obviously, if ‚àÄ~xœï(~x) is closed then œï(~t) is closed.
Assume that œï(~t) is not safe-range. Since it‚Äôs closed rr(SRNF(œï(~t))) = ‚ä•
‚áí SRNF(œï(~t)) must contain a subformula which is in the form ‚àÉ~zœï0 (~t, ~z)
where ~z 6‚äÜ rr(SRNF(œï0 (~t, ~z)))
‚áí SRNF(œï(~x)) must contain a subformula which is in the form ‚àÉ~zœï0 (~x, ~z)
where ~z 6‚äÜ rr(SRNF(œï0 (~x, ~z)))
‚áí SRNF(¬¨œï(~x)) must contain a subformula which is in the form ‚àÉ~zœï0 (~x, ~z)
where ~z 6‚äÜ rr(SRNF(œï0 (~x, ~z))) because pushing negation does not effect the formula under
‚àÉ
‚áí rr(SRNF(¬¨œï(~x))) = ‚ä•
‚áí rr(SRNF(¬¨‚àÉ~x¬¨œï(~x))) = ‚ä•
‚áí rr(SRNF(‚àÄ~xœï(~x))) = ‚ä•
‚àÄ~xœï(~x) is not safe-range
‚áí contradiction.
Proposition 10. ‚àÉ~xœï(~x) is closed and safe-range then œï(~t) is closed and safe-range where
~t are constants.
Proof. Undoubtedly, if ‚àÉ~xœï(~x) is closed then œï(~t) is closed.
Assume that œï(~t) is not safe-range. Since it is closed, rr(SRNF(œï(~t))) = ‚ä•
‚áí SRNF(œï(~t)) must contain a subformula which is in the form ‚àÉ~zœï0 (~t, ~z)
where ~z 6‚äÜ rr(SRNF(œï0 (~t, ~z)))
912

Exact Query Reformulation over DBs with FO and DL Ontologies

‚áí SRNF(œï(~x)) must contain a subformula which is in the form ‚àÉ~zœï0 (~x, ~z)
where ~z 6‚äÜ rr(SRNF(œï0 (~x, ~z)))
‚áí rr(SRNF(œï(~x))) = ‚ä•
‚áí rr(SRNF(‚àÉ~xœï(~x))) = ‚ä•
‚áí‚àÉ~xœï(~x) is not safe-range
‚áí contradiction.
Based on these propositions, we prove Theorem 8 as follows.
First, we will show that if œÜ and œà are closed and safe-range and œÜ ‚Üí œà is valid then
so is their interpolant. Assume T is a biased tableau of of œÜ ‚àß ¬¨œà. Therefore the root node
of T is S = {L(œÜ), R(¬¨œà)}. Based on all the tableau expansion rules and above propositions, at every expansion step where S = {L(œï1 ), ..., L(œïn ), R(œà1 ), ..., R(œàm )}, œï1 , ..., œïn
and œà1 , ..., œàm are safe-range and closed(*) .
Now we need to prove that the interpolant at each step is safe-range and closed (**) by
induction on the shape of proof and the set of rules in Section 6.
‚Ä¢ Rules for closed branches: It‚Äôs trivial because œï and ¬¨œï are safe-range and closed
because of (*)
‚Ä¢ Rules for propositional case :
For the rule (p1)(p2)(p3)(p4) nothing changes, so one does not need to prove.
For the rule (p5), apply the Proposition 8, (**) holds.
For the rule (p6), apply the Proposition 7,(**) holds.
‚Ä¢ Rules for first order case :
For the rule (f1) (f2) (f3) nothing changes, so one does not need to prove.
For the rule (f4), since c does not occur in {œï1 , ..., œïn } then the only case to have c in
int
I is that S contains R(¬¨œï(c)). Therefore S ‚à™ {L(œï(c))} ‚Üí I = œï(c). Since ‚àÄx.œï(x) is
safe-range (due to (*)) then ‚àÄx.I[c/x] is safe-range too
For the rule (f5), since c does not occur in {œà1 , ..., œàm } then the only case to have c in
int
I is that S contains L(¬¨œï(c)). Therefore S ‚à™ {R(œï(c))} ‚Üí I = ¬¨œï(c). Since ‚àÄx.œï(x)
is safe-range (due to (*)) then ‚àÉx.¬¨I[c/x] is safe-range too
‚Ä¢ Rules for equality : Because all the input formulas are closed and do not contain
function symbols, all equations are ground. Therefore, they do not influence the
safe-range property of interpolant in each step.
As a consequence, because Q(~c), KB, KB 0 ,¬¨Q0 (~c) are closed and safe-range then so is the
b c) of KB ‚àß Q(~c) and KB 0 ‚Üí Q0 (~c).
interpolant Q(~
Theorem 9.
Proof. As a consequence of Lemma 1, Theorem 9 holds.
913

Franconi, Kerhet, & Ngo

A.5 Definitions and Proofs of Section 7
The safe-range fragment of ALCHOIQ. We call any axiom (concept) in ALCHOIQ
(ground) safe-range, if the corresponding logically equivalent (open) formula in FOL(C, P)
is (ground) safe-range. For any concept C we denote the corresponding logically equivalent
formula in FOL(C, P) with one free variable x as C(x). Unfortunately concept inclusion
axioms in ALCHOIQ ontologies may not be safe-range: for example, the axiom ¬¨ male v
female is not safe-range. It is easy to see that an axiom C v D is not safe-range if and only
if C(x) is not safe-range and D(x) is safe-range: just observe that the axiom is logically
equivalent to the formula ¬¨‚àÉx. C(x) ‚àß ¬¨D(x) in FOL(C, P) (which is actually in a saferange normal form). The following proposition provides recursive rules deciding whether
an ALCHOIQ concept is safe-range.
Proposition 11. Let A be an atomic concept, let C and D be ALCHOIQ concepts, and
let R be either an atomic role or an inverse atomic role. Then:
1. A, {o}, ‚â• nR, ‚â• nR.C are safe-range;
2. C u D is safe-range if and only if C is safe-range or D is safe-range;
3. C t D is safe-range if and only if C is safe-range and D is safe-range;
4. ¬¨C is safe-range if and only if C is not safe-range.
Proof. It is enough to prove the proposition just for atomic roles because the order of
variables in binary atoms of a first-order logic translation of an ALCHOIQ concept does
not affect the safe-range property of the translation. Therefore hereafter we assume that R
is an atomic role.
‚Ä¢ Since A is an atomic concept, A(x) is safe-range.
‚Ä¢ {o}(x) = (x = o) - safe-range.
‚Ä¢ (‚â• nR)(x) = ‚àÉx1 , . . . , xn . R(x, x1 ) ‚àß . . . ‚àß R(x, xn ) ‚àß (x1 6= x2 ) ‚àß . . . ‚àß (xn‚àí1 6= xn ) safe-range.
‚Ä¢ (‚â• nR.C)(x) = ‚àÉx1 , . . . , xn . R(x, x1 ) ‚àß . . . ‚àß R(x, xn ) ‚àß C(x1 ) ‚àß . . . ‚àß C(xn ) ‚àß (x1 6=
x2 ) ‚àß . . . ‚àß (xn‚àí1 6= xn ) - safe-range.
‚Ä¢ Let us prove, that (C u D)(x) = C(x) ‚àß D(x) is safe-range if and only if C(x) is
safe-range or D(x) is safe-range.
‚áê) Let C(x) or D(x) be safe-range and let both of them be in safe-range normal
forms. Then
C(x) ‚àß D(x) is safe-range by definition.
‚áí) Let C(x) ‚àß D(x) be safe-range and in safe-range normal form (i.e. both C(x) and
D(x) are in safe-range normal form). Let us prove by contradiction. Suppose, both
C(x) and D(x) are not safe-range. Then C(x) ‚àß D(x) is not safe-range by definition.
It is a contradiction. Therefore, C(x) is safe-range or D(x) is safe-range.
914

Exact Query Reformulation over DBs with FO and DL Ontologies

‚Ä¢ Let us prove, that (C t D)(x) = C(x) ‚à® D(x) is safe-range if and only if C(x) is
safe-range and D(x) is safe-range.
‚áê) Let C(x) and D(x) be both safe-range and in safe-range normal forms. Then
C(x) ‚à® D(x) is safe-range by definition.
‚áí) Let C(x) ‚à® D(x) be safe-range and in safe-range normal form (i.e. both C(x) and
D(x) are in safe-range normal form). Let us prove by contradiction. Suppose, C(x)
or D(x) is not safe-range. Then C(x) ‚à® D(x) is not safe-range by definition. It is a
contradiction. Therefore, C(x) is safe-range and D(x) is safe-range.
‚Ä¢ Let us prove, that ¬¨C(x) is safe-range if and only if C(x) is not safe-range.
‚áí) Let ¬¨C(x) be safe-range. Let us prove by contradiction. Let C(x) be also saferange. Then both ¬¨C(x) and C(x) are domain independent. But one can easily see
(looking at the definition of domain independence), that it is impossible. Therefore,
C(x) is not safe-range. ‚áê) We need to prove, that if C(x) is not safe-range, then
¬¨C(x) is safe-range.
Let us prove by induction on structure of the formula. Suppose, the item is true for
any subformula of the formula C(x).
Suppose, C(x) is not safe-range. Let us consider (using already proved items) all the
possible cases, when C(x) is not safe-range.
‚Äì C(x) = (‚àÄR.D)(x) = ‚àÄy. R(x, y) ‚Üí D(y) ‚â° ¬¨‚àÉy.R(x, y)‚àß¬¨D(y) - not safe-range,
where D is any (possibly complex) concept. Then ¬¨C(x) = ‚àÉy.R(x, y) ‚àß ¬¨D(y)
is safe-range by definition.
‚Äì Suppose, C(x) = (D u F )(x) is not safe-range. Then D(x) is not safe-range and
F (x) is not safe-range. Since both D(x) and F (x) are subformulas of C(x), by
applying the current item we get: ¬¨D(x) and ¬¨F (x) are safe-range. ¬¨C(x) ‚â°
¬¨(D(x) ‚àß F (x)) ‚â° ¬¨D(x) ‚à® ¬¨F (x) - safe-range, because ¬¨D(x) and ¬¨F (x) are
safe-range.
‚Äì Suppose, C(x) = (D t F )(x) is not safe-range. Then D(x) is not safe-range or
F (x) is not safe-range. Since both D(x) and F (x) are subformulas of C(x), by
applying the current item we get: either ¬¨D(x) or ¬¨F (x) is safe-range. ¬¨C(x) ‚â°
¬¨(D(x) ‚à® F (x)) ‚â° ¬¨D(x) ‚àß ¬¨F (x) - safe-range, because either ¬¨D(x) or ¬¨F (x)
is safe-range.
‚Äì Suppose, C(x) = ¬¨D(x) is not safe-range. We need to prove, that ¬¨C(x) ‚â° D(x)
is safe-range. Let us prove by contradiction. Suppose, D(x) is not safe-range.
Then, since D(x) is a subformula of C(x), by applying the current item we get:
¬¨D(x) ‚â° C(x) is safe-range. It is a contradiction. Hence, ¬¨C(x) is safe-range.
The item is proved completely.
The proposition is proved completely.
Proposition 12. All ALCHOIQ role inclusion axioms are safe-range.
915

Franconi, Kerhet, & Ngo

Proof. Let S v R be any role inclusion axiom in ALCHOIQ. The formula ¬¨‚àÉx, y. S(x, y)‚àó ‚àß
¬¨R(x, y)‚àó is a first-order logic translation of the axiom, where (x, y)‚àó stands for (x, y) if the
preceding role is atomic and (x, y)‚àó stands for (y, x) if the preceding role is inverse atomic.
This formula is safe-range.
Guarded negation first-order logic. We recall the definition of guarded negation firstorder logic (GNFO) given in the paper by BaÃÅraÃÅny et al. (2012). GNFO is a fragment of
first-order logic consisting of all formulas generated by the following recursive definition:
œÜ ::= R(t1 , . . . , tn ) | t1 = t2 | œÜ1 ‚àß œÜ2 | œÜ1 ‚à® œÜ2 | ‚àÉx. œÜ | Œ± ‚àß ¬¨œÜ

(7)

where each ti is either a variable or a constant, Œ± in Œ± ‚àß ¬¨œÜ is an atomic formula (possibly
an equality statement) containing all free variables of œÜ.
Guarded negation fragment of ALCHOIQ. Now we consider ALCHOIQGN - a
guarded negation fragment of ALCHOIQ (i.e. an intersection of GNFO and ALCHOIQ).
We say, that
‚Ä¢ a concept C is an ALCHOIQGN concept if C is an ALCHOIQ concept and the
corresponding first-order logic translation C(x) is expressed in GNFO;
‚Ä¢ a concept inclusion axiom C v D is an ALCHOIQGN concept inclusion axiom if
C and D are ALCHOIQ concepts and the formula ¬¨‚àÉx. C(x) ‚àß ¬¨D(x) (which is
equivalent to the first-order translation of C v D) is expressed in GNFO;
‚Ä¢ a role inclusion axiom S v R is an ALCHOIQGN role inclusion axiom if S and R are
roles (atomic or inverse atomic) and the formula ¬¨‚àÉx, y. S(x, y)‚àó ‚àß ¬¨R(x, y)‚àó , where
(x, y)‚àó stands for (x, y) if the preceding role is atomic and (x, y)‚àó stands for (y, x) if
the preceding role is inverse atomic, is expressed in GNFO.
It is easy to see, that any ALCHOIQ role inclusion axiom is an ALCHOIQGN role inclusion
axiom. Then because of Proposition 12 the following holds.
Proposition 13.

‚Ä¢ All ALCHOIQGN role inclusion axioms are safe-range.

‚Ä¢ All safe-range role inclusion axioms in ALCHOIQ are in ALCHOIQGN .
From the definition of GNFO and ALCHOIQ it follows, that the complex concept C
of the logic ALCHOIQGN is recursively defined as follows:
B ::= A | {o} | ‚â• nR
C ::= B | ‚â• nR.C | ‚â• nR.¬¨C | B u ¬¨C | C u D | C t D

(8)

where A is an atomic concept, R is an atomic role or an inverse atomic role, and C and D
are ALCHOIQGN concepts (possibly complex).
Note, that in general, according to the definition (7) of GNFO all formulas with atleast
operator for n ‚â• 2 are not in GNFO because of non-guarded inequality statements xi 6=
xj . We fix this by assuming that inequality relation is actually a special binary database
predicate. This assumption is usual for databases.
916

Exact Query Reformulation over DBs with FO and DL Ontologies

Also strictly speaking ‚â• nR u ¬¨C is not in GNFO. Indeed, the formula
(‚àÉx1 , . . . , xn . R(x, x1 ) ‚àß . . . ‚àß R(x, xn ) ‚àß (x1 6= x2 ) ‚àß . . . ‚àß (xn‚àí1 6= xn )) ‚àß ¬¨C(x) is not in
GNFO (R(x, y) here stands for P (x, y) if R stands for an atomic role P , and R(x, y) stands
for P (y, x) if R stands for an inverse atomic role P ‚àí ), but it can be easily transformed to a
logically equivalent GNFO one by simply shifting the parentheses: ‚àÉx1 , . . . , xn . (R(x, x1 ) ‚àß
. . . ‚àß R(x, xn ) ‚àß (x1 6= x2 ) ‚àß . . . ‚àß (xn‚àí1 6= xn ) ‚àß ¬¨C(x)). So, we can assume, that the formula
‚â• nR u ¬¨C is in ALCHOIQGN .
Proposition 14. All ALCHOIQGN concepts are safe-range.
Proof. Let us prove by induction on the structure of ALCHOIQGN concepts defined by
(8).
1. A, {o}, ‚â• nR, ‚â• nR.C, ‚â• nR.¬¨C (C is an ALCHOIQGN concept) are safe-range
because of the item 1 of Proposition 11.
2. For any atomic concept A, any individual o any role R and any natural number n the
concepts A u ¬¨C, {o} u ¬¨C and ‚â• nR u ¬¨C are safe-range because of the item 3 of
Proposition 11 and since A, {o} and ‚â• nR are safe-range by the first item.
3. Suppose, that ALCHOIQGN concepts C and D are safe-range. Then the concepts
C u D and C t D are safe-range by the items 2 and 3 of Proposition 11 respectively.
The proposition is proved.
Lemma 4. For any safe-range concept C in ALCHOIQ the following holds:
C v B1 t . . . t Bn ,
where Bi appears as a subconcept in C and is one of the following concepts:
‚Ä¢ an atomic concept A;
‚Ä¢ {o}, where o is an individual name;
‚Ä¢ ‚â• nR, where R is an atomic role or inverse atomic role, n is a natural number.
Proof. Let us prove the proposition by induction for all safe-range concepts of ALCHOIQ.
‚Ä¢ A, {o}, ‚â• nR, ‚â• nR.C are safe-range by Proposition 11. A v A, {o} v {o}, ‚â• nR v
‚â• nR, ‚â• nR.C v ‚â• nR.
Suppose now that C is a complex safe-range concept and the proposition holds for all
safe-range subconcepts of C.
1. C = C1 u C2 - safe-range. Then either C1 or C2 is safe-range. Let C1 be safe-range.
Hence, C1 v B1 t . . . t Bm , where Bi is a concept of the aforementioned type. Then
C1 u C2 v C1 v B 1 t . . . t B m .
2. C = C1 t C2 - safe-range. Then C1 and C2 are safe-range. Hence, C1 v B1 t . . . t Bk
and C2 v Bk+1 t . . . t Bm , where Bi is a concept of the aforementioned type. Then
C1 t C2 v (B1 t . . . t Bk ) t (Bk+1 t . . . t Bm ) v B1 t . . . t Bm .
917

Franconi, Kerhet, & Ngo

3. C = ¬¨D is safe-range. By Proposition 11 it is possible if and only if D is not saferange. That is one of the following cases takes place.
‚Ä¢ D = D1 u D2 . Then ¬¨D ‚â° ¬¨D1 t ¬¨D2 . And we reduced this case to the item 2.
‚Ä¢ D = D1 t D2 . Then ¬¨D ‚â° ¬¨D1 u ¬¨D2 . And we reduced this case to the item 1.
‚Ä¢ D = ¬¨D1 . Then ¬¨D ‚â° ¬¨¬¨D1 ‚â° D1 . Hence, D1 is a safe-range subconcept of ¬¨D.
Then the proposition holds for D1 and, hence, also for C, because C ‚â° ¬¨D ‚â° D1 .
The lemma is proved completely.
Lemma 5. For any ALCHOIQ concept C there exists an ALCHOIQGN concept C 0 such
that either C ‚â° C 0 or C ‚â° ¬¨C 0 .
Proof. Suppose that the lemma holds for all ALCHOIQ subconcepts of the ALCHOIQ
concept C. Let us prove it for C.
1. Base. A, {o}, ‚â• nR are ALCHOIQGN concepts by the definition of ALCHOIQGN
concept (8).
2. C = ‚â• nR.D and D0 is an ALCHOIQGN concept such that D ‚â° D0 or D ‚â°
¬¨D0 . Then C ‚â°‚â• nR.D0 or C ‚â°‚â• nR.¬¨D0 . ‚â• nR.D0 and ‚â• nR.¬¨D0 are both
ALCHOIQGN concepts. Hence, the item is proved.
3. C = ¬¨D and D0 is an ALCHOIQGN concept such that D ‚â° D0 or D ‚â° ¬¨D0 . Then
C ‚â° ¬¨D0 or C ‚â° ¬¨¬¨D0 ‚â° D0 . The item is proved.
4. C = C1 u C2 and C10 is an ALCHOIQGN concept such that C1 ‚â° C10 or C1 ‚â° ¬¨C10 , C20
is an ALCHOIQGN concept such that C2 ‚â° C20 or C2 ‚â° ¬¨C20 . Consider all possible
cases.
(a) C1 ‚â° C10 and C2 ‚â° C20 . Then C ‚â° C 0 , where C 0 = C10 u C20 is an ALCHOIQGN
concept (because C10 and C20 are ALCHOIQGN concepts).
(b) C1 ‚â° ¬¨C10 and C2 ‚â° ¬¨C20 . Then C ‚â° ¬¨C10 u ¬¨C20 ‚â° ¬¨(C10 t C20 ) = ¬¨C 0 , where
C 0 = C10 tC20 is an ALCHOIQGN concept (because C10 and C20 are ALCHOIQGN
concepts).
(c) C1 ‚â° C10 and C2 ‚â° ¬¨C20 (the case when C1 ‚â° ¬¨C10 and C2 ‚â° C20 is the similar
one). Then C ‚â° C10 u ¬¨C20 . Since C10 is an ALCHOIQGN concept by Proposition
14 it is safe-range and, hence, by Lemma 4 C10 v B1 t . . . t Bn , where each Bi is
either an atomic concept A or {o} or ‚àÉR. Then C10 ‚â° C10 u (B1 t . . . t Bn ) and,
hence, C ‚â° C10 u (B1 t . . . t Bn ) u ¬¨C20 ‚â° C10 u (B1 u ¬¨C20 t . . . t Bn u ¬¨C20 ). Each
disjunct Bi u ¬¨C20 is an ALCHOIQGN concept (because C2 is ALCHOIQGN
concept and by the definition (8) of ALCHOIQGN concepts). Then C 0 = C10 u
(B1 u ¬¨C20 t . . . t Bn u ¬¨C20 ) is an ALCHOIQGN concept. C ‚â° C 0 . The item is
proved.
5. C = C1 t C2 ‚â° ¬¨(¬¨C1 u ¬¨C2 ). This case is reduced to the items 3 and 4.
918

Exact Query Reformulation over DBs with FO and DL Ontologies

The lemma is proved completely.
Corollary 2. For any ALCHOIQ concept C and any concept B, which is either an atom
A or {o} or ‚â• nR, the concept B u C is equivalent to some ALCHOIQGN concept.
Proof. By Lemma 5 there exists an ALCHOIQGN concept C 0 such that either C ‚â° C 0
or C ‚â° ¬¨C 0 . Then B u C ‚â° B u C 0 or B u C ‚â° B u ¬¨C 0 . Both B u C 0 and B u ¬¨C 0
are ALCHOIQGN concepts (by the definition (8) of ALCHOIQGN concepts). Hence, the
corollary is proved.
Proposition 15. Any safe-range ALCHOIQ concept is equivalent to some ALCHOIQGN
concept.
Proof. Let C be any safe-range ALCHOIQ concept. By Lemma 4 C v B1 t . . . t Bn ,
where each Bi is either an atom A or {o} or ‚â• nR. Then C ‚â° C u (B1 t . . . t Bn ) ‚â°
B1 uCt. . .tBn uC. By the corollary 2 for each disjunct Bi uC there exists an ALCHOIQGN
concept Di such that Bi u C ‚â° Di . Then C ‚â° D1 t . . . t Dn . The concept D1 t . . . t Dn is an
ALCHOIQGN concept as a disjunction of ALCHOIQGN concepts. Hence, the proposition
is proved.
Proposition 16. All ALCHOIQGN concept inclusion axioms are safe-range.
Proof. Let C v D be any concept inclusion axiom in ALCHOIQGN . It means that the
corresponding first-order logic translation ¬¨‚àÉx. C(x) ‚àß ¬¨D(x) is in GNFO. Hence, C(x) ‚àß
¬¨D(x) is in GNFO or, that is the same, C u ¬¨D is in ALCHOIQGN . It is easy to see, that
¬¨‚àÉx. C(x) ‚àß ¬¨D(x) is safe-range if and only if the formula C(x) ‚àß ¬¨D(x) is safe-range, that
is if and only if the corresponding ALCHOIQGN concept C u ¬¨D is safe-range. But by
Proposition 14 any ALCHOIQGN concept is safe-range. The proposition is proved.
Lemma 6. For any safe-range ALCHOIQ concept C and any ALCHOIQ concept D the
concept C u D is equivalent to some ALCHOIQGN concept C 0 u D0 , where C 0 and D0 are
ALCHOIQGN concepts.
Proof. Since C is safe-range by Lemma 4 C v B1 t . . . t Bn , where each Bi is either an
atomic concept A or {o} or ‚àÉR. Then C ‚â° C u (B1 t . . . t Bn ) and, hence, C u D ‚â°
C u (B1 t . . . t Bn ) u D ‚â° C u (B1 u D t . . . t Bn u D). By the corollary 2 each disjunct
Bn uD is an ALCHOIQGN concept. Hence, D0 := B1 uDt. . .tBn uD is an ALCHOIQGN
concept. Since C is s safe-range by Proposition 15 there exists an ALCHOIQGN concept
C 0 such that C ‚â° C 0 . Then C u D ‚â° C 0 u D0 , and C 0 u D0 is an ALCHOIQGN concept,
where C 0 and D0 are ALCHOIQGN concepts.
Proposition 17. Any safe-range ALCHOIQ concept inclusion axiom C v D can be transformed to a concept inclusion axiom C 0 v ¬¨D0 , where C 0 and D0 are ALCHOIQGN .
Proof. Let C v D be any safe-range ALCHOIQ concept inclusion axiom. Then the corresponding formula ¬¨‚àÉx. C(x) ‚àß ¬¨D(x) is safe-range. Then the first-order logic formula
C(x) ‚àß ¬¨D(x) is safe-range, or, that is the same, the ALCHOIQ concept C u ¬¨D is saferange. By Proposition 11 we have that C is safe-range or ¬¨D is safe-range.
919

Franconi, Kerhet, & Ngo

‚Ä¢ C is safe-range. Then by Lemma 6 there exist two ALCHOIQGN concepts C 0 and
D0 such that C u ¬¨D is logically equivalent to the ALCHOIQGN concept C 0 u D0 .
Then ¬¨‚àÉx. C(x) ‚àß ¬¨D(x) is logically equivalent to ¬¨‚àÉx. C 0 (x) ‚àß D0 (x). Hence, C v D
is logically equivalent to C 0 v ¬¨D0 (C 0 and D0 are ALCHOIQGN concepts).
‚Ä¢ ¬¨D is safe-range. The proof is similar to the previous item.
The proposition is proved completely.
Proposition 18. For any two ALCHOIQGN concepts C and D the axiom C v ¬¨D is an
ALCHOIQGN concept inclusion axiom.
Proof. The axiom C v ¬¨D is logically equivalent to the first-order logic formula ¬¨‚àÉx. C(x)‚àß
D(x), where C(x) and D(x) are in GNFO. Then ¬¨‚àÉx. C(x) ‚àß D(x) is also in GNFO. Hence,
by the definition of ALCHOIQGN concept inclusion axiom the axiom C v ¬¨D is an
ALCHOIQGN concept inclusion axiom.
Propositions 17 and 18 imply the following.
Proposition 19. Any safe-range ALCHOIQ concept inclusion axiom is equivalent to some
ALCHOIQGN concept inclusion axiom.
We consider a connection between safe-range fragment of ALCHOIQ and guarded negation fragment of ALCHOIQ, that is ALCHOIQGN . When we say ‚Äùfragment‚Äù, we mean a
set of TBox assertions (concept and role inclusion axioms) and concepts (open formulas) of
ALCHOIQ satisfying a particular property (e.g safe-range or guarded negation). Taking
into account propositions 14, 15, 16, 19 and 13, we have the following theorem.
Proposition 20. The safe-range fragment of ALCHOIQ and ALCHOIQGN are equally
expressive.
This proves Theorem 10:
Theorem 10 (Expressive power equivalence). The domain independent fragment of
ALCHOIQ and ALCHOIQGN are equally expressive.
Theorem 11. ALCHOIQGN TBoxes have finitely controllable determinacy of concept
queries.
Proof. We need to prove, that for any ALCHOIQGN TBox T (ontology), any concept
query Q in ALCHOIQGN and any set of database predicates PDB , whenever the query is
finitely determined by the database predicates under the ontology then it is also determined
in unrestricted models.
Suppose, that Q is finitely determined by PDB under T . Then from Theorem 2 it
e where |=fin P means entailment over models with a
follows, that T ‚à™ Te |=fin PDB Q v Q,
DB
e
finite interpretation to the database predicates. Hence, in particular T ‚à™ Te |=fin Q v Q,
where |=fin means entailment over finite models. Hereafter let œÑ be one sentence, that is a
first-order logic translation of a conjunction of all axioms in the TBox T . Then from the
aforementioned entailment we have:
e
|=fin (¬¨œÑ ‚à® ¬¨e
œÑ ) ‚à® (¬¨‚àÉx. Q(x) ‚àß ¬¨Q(x)).
920

(9)

Exact Query Reformulation over DBs with FO and DL Ontologies

e
By Proposition 14 Q(x) is safe-range. Hence, Q(x) ‚àß ¬¨Q(x)
is safe-range, hence the
e is safe-range and, hence, by Proposition 15 there exists an
ALCHOIQ concept Q u ¬¨Q
e ‚â° C 0 . Then ¬¨‚àÉx. Q(x) ‚àß ¬¨Q(x)
e
ALCHOIQGN concept C 0 such that Q u ¬¨Q
‚Üî ¬¨‚àÉx.C 0 (x)
and the following holds:
|=fin (¬¨œÑ ‚à® ¬¨e
œÑ ) ‚à® (¬¨‚àÉx.C 0 (x)).
(10)
¬¨‚àÉx.C 0 (x) is in GNFO, because C 0 (x) is in GNFO. Since all the axioms in T are ALCHOIQGN
TBox axioms, the sentences œÑ and œÑe are in GNFO. Then the sentence ¬¨œÑ ‚à® ¬¨e
œÑ is in GNFO.
Therefore the right hand side of the entailment (10) is in GNFO. Then ¬¨((¬¨œÑ ‚à® ¬¨e
œÑ) ‚à®
(¬¨‚àÉx.C 0 (x))) is also in GNFO and by the entailment (10) does not have a finite model.
Then, since GNFO has the finite model property, ¬¨((¬¨œÑ ‚à® ¬¨e
œÑ ) ‚à® (¬¨‚àÉx.C 0 (x))) is unsatisfiable. Hence, we have:
|= (¬¨œÑ ‚à® ¬¨e
œÑ ) ‚à® (¬¨‚àÉx.C 0 (x)).
e
Since ¬¨‚àÉx.C 0 (x) ‚Üî ¬¨‚àÉx. Q(x) ‚àß ¬¨Q(x),
the following holds:
e
|= (¬¨œÑ ‚à® ¬¨e
œÑ ) ‚à® (¬¨‚àÉx. Q(x) ‚àß ¬¨Q(x)).
e By Theorem 2 it means, that the query Q is determined in
Then T ‚à™ Te |= Q v Q.
unrestricted models by the database predicates PDB under the ontology T .
The proposition is proved.

References
Abiteboul, S., Hull, R., & Vianu, V. (1995). Foundations of Databases. Addison-Wesley.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). The DL-Lite family
and relations. J. Artif. Intell. Res. (JAIR), 36, 1‚Äì69.
Avron, A. (2008). Constructibility and decidability versus domain independence and absoluteness. Theor. Comput. Sci., 394, 144‚Äì158.
BaÃÅraÃÅny, V., Gottlob, G., & Otto, M. (2010). Querying the guarded fragment. In Proceedings
of the 25th Annual IEEE Symposium on Logic in Computer Science (LICS 2010), pp.
1‚Äì10.
BaÃÅraÃÅny, V., ten Cate, B., & Otto, M. (2012). Queries with guarded negation (full version).
CoRR, abs/1203.0077.
Beth, E. (1953). On Padoa‚Äôs method in the theory of definition. Indagationes Mathematicae,
15, 330‚Äì339.
Craig, W. (1957). Three uses of the Herbrand-Gentzen theorem in relating model theory
and proof theory. J. Symb. Log., 22 (3), 269‚Äì285.
Etzioni, O., Golden, K., & Weld, D. S. (1997). Sound and efficient closed-world reasoning
for planning. Artif. Intell., 89, 113‚Äì148.
Fan, W., Geerts, F., & Zheng, L. (2012). View determinacy for preserving selected information in data transformations. Inf. Syst., 37, 1‚Äì12.
Fitting, M. (1996). First-order logic and automated theorem proving (2nd edition). Springer.
921

Franconi, Kerhet, & Ngo

Franconi, E., Ibanez-Garcia, Y. A., & Seylan, IÃánancÃß. (2011). Query answering with DBoxes
is hard. Electronic Notes in Theoretical Computer Science, Elsevier, 278, 71‚Äì84.
Franconi, E., Kerhet, V., & Ngo, N. (2012a). Exact query reformulation over SHOQ DBoxes.
In Proc. of the 2012 International workshop on Description Logics (DL-2012).
Franconi, E., Kerhet, V., & Ngo, N. (2012b). Exact query reformulation with first-order ontologies and databases. In Logics in Artificial Intelligence - 13th European Conference,
JELIA 2012, pp. 202‚Äì214.
Franconi, E., Ngo, N., & Sherkhonov, E. (2012c). The definability abduction problem for
data exchange. In Web Reasoning and Rule Systems - 6th International Conference
RR 2012.
Gurevich, Y. (1984). Toward logic tailored for computational complexity. In Computation
and Proof Theory, Vol. 1104, pp. 175‚Äì216. Springer.
Halevy, A. Y. (2001). Answering queries using views: A survey. The VLDB Journal, 10,
270‚Äì294.
Marx, M. (2007). Queries determined by views: pack your views. In Proceedings of the 26th
ACM symposium on Principles of Database Systems, PODS ‚Äô07, pp. 23‚Äì30.
McCune, W. (2005‚Äì2011).
prover9.

Prover9 and Mace4.

http://www.cs.unm.edu/~mccune/

Nash, A., Segoufin, L., & Vianu, V. (2010). Views and queries: Determinacy and rewriting.
ACM Trans. Database Syst., 35, 21:1‚Äì21:41.
Rosati, R. (2011). On the finite controllability of conjunctive query answering in databases
under open-world assumption. J. Comput. Syst. Sci., 77 (3), 572‚Äì594.
Seylan, IÃánancÃß., Franconi, E., & de Bruijn, J. (2009). Effective query rewriting with ontologies over DBoxes. In Proc. of the 21st International Joint Conference on Artificial
Intelligence (IJCAI 2009), pp. 923‚Äì925.
ten Cate, B., Franconi, E., & Seylan, IÃánancÃß. (2011). Beth definability in expressive description logics. In Proc. of the 22nd International Joint Conference on Artificial
Intelligence (IJCAI 2011), pp. 1099‚Äì1106.
ten Cate, B., Franconi, E., & Seylan, IÃánancÃß. (2013). Beth definability in expressive description logics. Journal of Artificial Intelligence Research (JAIR), 48, 347‚Äì414.

922

Journal of Artificial Intelligence Research 48 (2013) 347-414

Submitted 05/13; published 11/13

Beth Definability in Expressive Description Logics
Balder ten Cate

btencate@ucsc.edu

UC Santa Cruz

Enrico Franconi

franconi@inf.unibz.it

Free University of Bozen-Bolzano

IÃánancÃß Seylan

seylan@informatik.uni-bremen.de

University of Bremen

Abstract
The Beth definability property, a well-known property from classical logic, is investigated in the context of description logics: if a general L -TBox implicitly defines an
L -concept in terms of a given signature, where L is a description logic, then does there
always exist over this signature an explicit definition in L for the concept? This property
has been studied before and used to optimize reasoning in description logics. In this paper
a complete classification of Beth definability is provided for extensions of the basic description logic ALC with transitive roles, inverse roles, role hierarchies, and/or functionality
restrictions, both on arbitrary and on finite structures. Moreover, we present a tableaubased algorithm which computes explicit definitions of at most double exponential size.
This algorithm is optimal because it is also shown that the smallest explicit definition of an
implicitly defined concept may be double exponentially long in the size of the input TBox.
Finally, if explicit definitions are allowed to be expressed in first-order logic, then we show
how to compute them in single exponential time.

1. Introduction
We address the Beth definability property (Beth, 1953) in the context of description logics
(DLs). The Beth definability property relates two notions of definability in a logic L ,
implicit definability and explicit definability. Implicit definability is a semantic notion: it
asks whether the interpretation of a given L -formula œï is fully determined by the universe
of discourse and the interpretation of some given predicates Œ£ in all models of a theory
T . Explicit definability on the other hand is more syntactic: it asks whether there is some
L -formula œà over the set of predicates Œ£ that is equivalent to œï under T . Clearly, explicit
definability implies implicit definability. If the converse holds as well, then the logic L is
said to have the Beth definability property. Logics having this property are considered to be
well-balanced in terms of their syntax and semantics since it connects the model-theoretic
notion of implicit definability to explicit definability.
The Beth definability property can be naturally formulated for DLs by slightly changing the terminology in the paragraph above: formulas become concepts, theories become
TBoxes, and Œ£ consists of unary and binary predicates (respectively called concept names
and role names).
c
2013
AI Access Foundation. All rights reserved.

Ten Cate, Franconi, & Seylan

Example 1.1. Consider the following ALC-TBox T .
Parent
Parent
Father
Mother
Man

‚â°
‚â°
v
v
v

‚àÉhasChild.>
Father t Mother
Man
Woman
¬¨Woman

The concept name Mother is implicitly definable from Œ£ = {hasChild, Woman} under T .
Precisely what we mean by this will be clear once we present Definition 4.1; intuitively, we
mean that the instances of Mother in a model I of T can be exactly determined once we know
the domain of I and the instances of Œ£ in I. In fact, we can spell this implicit definition out
as the ALC-concept Woman u ‚àÉhasChild.>. This concept is an explicit definition of Mother
from Œ£ under T because T |= Mother ‚â° Woman u ‚àÉhasChild.> (cf. Definition 4.5).
Beth definability in DLs has found applications in optimizing reasoning. The first application is related to extracting an equivalent acyclic L -terminology from a general TBox
in L (Baader & Nutt, 2003; ten Cate, Conradie, Marx, & Venema, 2006). An acyclic
terminology consists only of acyclic definitions for concept names and they are of particular
interest because reasoning with them is ‚Äòeasier‚Äô than with general TBoxes. For example, satisfiability of an ALC-terminology is a PSpace-complete problem whereas the same problem
for general ALC-TBoxes is ExpTime-complete (Donini, 2003). The second application is
related to an ontology-based data access setting, which assumes the existence of a database
instance (also referred to as ‚ÄòDBox‚Äô in this context) and a TBox that may speak about
more predicates than the database instance (Seylan, Franconi, & de Bruijn, 2009). In this
setting, the user may ask concept queries over the signature of the TBox; and the idea is
to find an equivalent rewriting of the original query in terms of the predicates that appear
in the DBox. If such a rewriting exists, then determining the certain answers of the query
can be reduced to query answering in relational databases, which is known to be in AC0 in
data complexity in contrast to the general coNP-completeness of concept querying in ALC
with DBoxes (Seylan et al., 2009).
Both of these applications involve computing explicit definitions on the basis of implicit
definitions. Here, the problem is that this may not always be possible for some DLs, i.e.,
some DLs may lack the Beth definability property.
Example 1.2. In this example, we model a scenario about cars, their owners, and the
relationships between the owners and their cars. Consider the following ALCH-TBox T
consisting of the concept inclusion axioms
SportsCar
FuelEfficientCar
SportsCar
¬¨‚àÉproudOwner.Car

v
v
v
v

Car
Car
¬¨FuelEfficientCar
(‚àÄloves.SportsCar u ¬¨‚àÉowns.SportsCar)) t
(‚àÄloves.FuelEfficientCar u ¬¨‚àÉowns.FuelEfficientCar))

and the role inclusion axioms
proudOwner v owns
proudOwner v loves
348

Beth Definability in Expressive Description Logics

The concept ‚àÉproudOwner.Car is implicitly definable from Œ£ = {owns, loves} under T , in the
sense that the instances of ‚àÉproudOwner.Car in a model I of T can be exactly determined
once we know the domain of I and the instances of the roles in Œ£. Indeed, an individual
is a proud owner of a car if and only if the individual owns something that he/she loves.
The fact that the left-to-right direction of this equivalence holds in every model of T follows
immediately from the role inclusion axioms, and similarly, the fact that the (contrapositive
of the) right-to-left direction holds in models of T follows immediately from the other TBox
axioms. This implicit definition can be made explicit using the role conjunction operator
as the concept ‚àÉ(owns u loves).>. However, it can be shown that no ALCH-concept is an
explicit definition of ‚àÉproudOwner.Car from Œ£ under T . We will not formally prove this
here, but see the proof of Theorem 4.18 in Section 4.2 for a similar example. In particular,
this shows that ALCH lacks the Beth definability property.
A natural research agenda in this case is to identify DLs that have the Beth definability
property. Since this property is useful for computing explicit definitions on the basis of
implicit definitions, a vital question then is the complexity of this task, both in terms of
the time needed to compute the explicit definitions, and in terms of the size of the explicit
definitions obtained. This question was first studied by ten Cate et al. (2006) for a weaker
Beth definability property, which considers only concept names in the signature. In this
paper we are interested in the more general Beth definability property that takes into
account role names in the signature. We believe that this is more natural for DLs because
in a DL knowledge base, role names are considered to be a part of the signature. We present
a worst-case optimal algorithm for constructing explicit definitions.
Since the work of Craig (1957), it has been customary to establish Beth definability
via an interpolation theorem; and our work is no exception. In particular, we obtain our
positive results on Beth definability through a worst-case optimal algorithm for constructing
interpolants in the description logics that we consider.
Our contributions in this paper are as follows.
‚Ä¢ We obtain a complete classification of the Beth definability property for extensions
of ALC with transitive roles, inverse roles, role hierarchies, and/or functionality restrictions, both on arbitrary structures (BP) and on finite structures (BPF). These
results are summarized in Table 1. Note that the finite model property (FMP) of all
sub-logics of SHOQ is shown by Lutz, Areces, Horrocks, and Sattler (2005); FMP
of all sub-logics of SHIO+ by Duc and Lamolle (2010); and the failure of FMP in
ALCF I and all its extensions is well-known (cf. Calvanese & Giacomo, 2003).
‚Ä¢ We present a constructive algorithm based on an interpolating tableau calculus to
compute explicit definitions in ALC and all of its considered extensions having the
Beth definability property. This algorithm runs in double exponential time and computes in the worst case an explicit definition of double exponential size if the concept
is implicitly definable. In this respect, the algorithm is optimal because we also show
that the smallest explicit definition of an implicitly defined concept may be double
exponentially long in the size of the input TBox for each of these DLs.
‚Ä¢ We consider the case where explicit definitions are allowed to be expressed in firstorder logic. This is particularly relevant for the use case for computing certain answers
349

Ten Cate, Franconi, & Seylan

S

H

I

F
‚Ä¢

‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

‚Ä¢
‚Ä¢

‚Ä¢
‚Ä¢

‚Ä¢
‚Ä¢

‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

‚Ä¢
‚Ä¢

‚Ä¢
‚Ä¢

‚Ä¢

FMP
+
+
+
+
+
+
+
+
+
+
+
+
-

BP
+
+
+
+
+
+
+
+
-

BPF
+
+
+
+
+
+
-

Table 1: BP and BPF from ALC to SHIF

of a query given a DBox and a TBox. We present an algorithm that computes a firstorder explicit definition of an implicitly defined concept in single exponential time for
all DLs with BP or BPF.

1.1 Related Work
The Beth definability property, in the general sense, has been first shown to hold for firstorder logic (Beth, 1953). Beth definability comes in different flavors and the one we are
interested in is related more to projective Beth definability. Here, projective refers to the
ability to specify the set of predicates Œ£. The projective version is known be stronger than
Beth‚Äôs original formulation (cf. Hoogland, 2001) and first shown to hold for first-order logic
by Craig (1957). Since the seminal works of Beth and Craig, Beth definability has been
studied for many other logics.
Lang and Marquis (2008), also motivated from AI, study the propositional variant. The
modal and temporal variants have been extensively studied (cf. Gabbay & Maksimova,
2005). The k-variable fragment of first-order logic, for k ‚â• 2, is known to lack the Beth
definability property, whereas the Guarded and Packed Fragments satisfy a non-projective
version of the Beth property (cf. Hoogland, 2001). The guarded-negation fragment was
recently shown to have the Beth definability property as well (BaÃÅraÃÅny, Benedikt, & ten
Cate, 2013).
Beth definability has practical applications in relational databases for query rewriting
using exact views (Nash, Segoufin, & Vianu, 2010; Afrati, 2011; Marx, 2007; Pasaila, 2011;
BaÃÅraÃÅny et al., 2013). Here, the idea is to decide if the answers to a given query can be inferred
from the content of a collection of views (that is, whether the theory consisting of the view
definitions implicitly defines the query in terms of the view predicates), and, if this is indeed
the case, to rewrite the query into a query over the schema consisting of the view predicates
350

Beth Definability in Expressive Description Logics

(that is, an explicit definition of the query in terms of the view predicates). View-based
query rewriting naturally arises in various settings, including query optimization, querying
under access restrictions, data integration, and privacy analysis.
Beth definability has also been studied in the DL literature. Similarly to the relational
database case, it finds applications in computing explicit definitions on the basis of implicit
definitions (Baader & Nutt, 2003; ten Cate et al., 2006; Seylan et al., 2009; Seylan, Franconi, & de Bruijn, 2010). Some of these papers also present results on the size of explicit
definitions that can be obtained for implicitly defined concepts. Ten Cate et al. establish
a single exponential lower bound and a triple exponential upper bound for ALC. It is not
hard to see that the lower bound proof by ten Cate et al. carries to the Beth definability
property we consider. A matching single exponential upper bound on the size of explicit
definitions was claimed to be established by Seylan et al. (2010) in Theorem 1; however,
this theorem is wrong since a crucial step for its proof, namely Lemma 1, is erroneous.
In this paper, we improve the single exponential lower bound of ten Cate et al. to double
exponential and correct the single exponential upper bound of Seylan et al. to double exponential, thus obtaining tight complexity bounds. These bounds in DLs are in sharp contrast
to first-order logic since there is no recursive bound on the minimal number of quantifier
alternations in explicit definitions in first-order logic (Friedman, 1976). BP has been first
shown to hold for ALC by Seylan et al. (2009) and it is stronger than the variant studied by
ten Cate et al.. Specifically, we show that all DLs we consider that support role hierarchies
actually lack BP, whereas they satisfy the variant of BP studied by ten Cate et al.. In this
respect, Theorem 10 by Seylan et al. (2010) claiming that these DLs have BP is erroneous.
The mistake in the proof is that Theorem 9, which presents a reduction from the concept
satisfiability problem w.r.t. TBoxes in SHI to the same problem in ALC, can not actually
be used for computing SHI-interpolants.
Since the work of Craig (1957), it has been customary to establish Beth definability
via an interpolation lemma; and our work is no exception. An interpolation lemma is
usually established by a model-theoretic or a proof-theoretic argument (Hoogland, 2001).
The advantage of the latter over the former is that it yields a procedure to construct the
interpolant. Several interpolation properties formulated for general TBoxes were studied
in the ALC- (ten Cate et al., 2006; Ghilardi, Lutz, & Wolter, 2006; Konev, Lutz, Walther,
& Wolter, 2009a; Seylan et al., 2009; Konev, Lutz, Ponomaryov, & Wolter, 2010; Lutz
& Wolter, 2011) and EL-family of DLs (Konev, Walther, & Wolter, 2009b; Lutz, Piro,
& Wolter, 2010; Nikitina & Rudolph, 2012; Lutz, Seylan, & Wolter, 2012a). A notable
variant is the uniform interpolation property. A uniform interpolant of a given L -TBox
T and a set of predicates Œ£ is another L -TBox T 0 such that T 0 uses only predicates from
Œ£ and the logical consequences of T and T 0 formulated over Œ£ coincide. In this paper,
we do not consider uniform interpolation because it is not the right interpolation property
for establishing tight bounds on the size of explicit definitions. This is witnessed by the
following observations. Deciding the existence of a uniform interpolant for a given ALCTBox and a set of predicates is known to be 2-ExpTime-complete (Lutz & Wolter, 2011),
whereas the same problem formulated for the interpolation property we study here is in
ExpTime. In the simpler DL EL, uniform interpolants are also more ‚Äòexpensive‚Äô than the
non-uniform ones. In particular, deciding the existence of uniform interpolants in EL is
ExpTime-complete (Lutz et al., 2012a); and Nikitina and Rudolph (2012) establish triple
351

Ten Cate, Franconi, & Seylan

exponential tight bounds on the size of uniform interpolants. On the other hand, deciding
the existence of interpolants, as we consider in this paper but for the description logic EL,
is in PTime because this problem can be reduced to concept subsumption w.r.t. a TBox in
EL by Lemma 3 of Lutz, Seylan, and Wolter (2012b).
Most of the results in this paper were announced by ten Cate, Franconi, and Seylan
(2011) in an extended abstract. The current paper extends this work by full proofs of the
claimed results and the new material in Section 4.4.
1.2 Outline
We start by introducing in Section 2 the DLs for which we study BP and some reasoning
problems that are relevant for us in this paper. We also fix in this section our first-order
notation and the standard translation of DLs to first-order logic. We will be using firstorder logic extensively in Section 3.3. The hammer with which we nail all the positive
results, i.e., +, to the columns BP and BPF in Table 1, is a worst-case optimal algorithm
for constructing interpolants. Section 3 is dedicated to this interpolation result. Finally, all
our results about BP are presented in Section 4. Since the interpolation results are used to
prove BP, Section 3 naturally comes before Section 4, but the reader who is less interested
in the interpolation results may prefer to skip Section 3 initially.

2. Preliminaries
In this section, we introduce the description logics that we will study. They are frequently
used logics in the expressive ALC-family of description logics.
2.1 Description Logics
Let NC and NR be countably infinite and mutually disjoint sets of concept names and
role names, respectively. For reasons that will become clear in a moment, we also assume a
countably infinite subset of NR , denoted by NR+ , where NR \ NR+ is also countably infinite.
The role names in NR+ are, intuitively, designated as being transitive, and are allowed to
be used only in description logics with transitive roles. An element of NC or NR is also
called a predicate, and a set Œ£ ‚äÜ NC ‚à™ NR of concept and role names is called a signature.
To ease the exposition, we first introduce the description logic ALCF I, and we then
define the other description logics that we study. The concept language of ALCF I is defined
as follows:
Concepts:
Roles:

C, D ::= > | A | ¬¨C | C u D | ‚àÉR.C | ‚â§ 1R
R
::= P | P ‚àí

where A ‚àà NC and P ‚àà NR \ NR+ . The concept constructors ‚ä•, t, ‚àÄR.C, and ‚â• 2R
are defined as abbreviations in the usual way. Also, by a slight abuse of notation, we will
sometimes write (P ‚àí )‚àí , for P ‚àà NR , in which case it refers to the role name P itself. An
ALCFI-TBox T is a finite set of concept inclusion axioms (CIAs) C v D, where C and D
are ALCF I-concepts.
The semantics of ALCF I-concepts and roles is given in terms of interpretations. An
interpretation is a pair I = h‚àÜI , ¬∑I i where ‚àÜI is a non-empty set called the domain of
352

Beth Definability in Expressive Description Logics

>I
(¬¨C)I
(C u D)I
(‚àÉR.C)I
(‚â§ 1R)I
(P ‚àí )I

=
=
=
=
=
=

‚àÜI ,
‚àÜI \ C I ,
C I ‚à© DI ,
{s ‚àà ‚àÜI | there exists t ‚àà ‚àÜI such that hs, ti ‚àà RI and t ‚àà C I },
{s ‚àà ‚àÜI | for all t, u ‚àà ‚àÜI , if hs, ti ‚àà RI and hs, ui ‚àà RI then t = u},
{hs, ti | ht, si ‚àà P I }.

Table 2: Semantics of complex ALCF I-concepts and roles
I, and ¬∑I is a function that maps each concept name A ‚àà NC to a subset AI of ‚àÜI and
each role name P ‚àà NR to a binary relation P I on ‚àÜI . In anticipation of the discussion of
description logics with transitive roles below, we require also that for each P ‚àà NR+ , the
relation P I is transitive. The map ¬∑I is extended to complex concepts and roles by means
of the inductive definitions provided in Table 2.
An interpretation I satisfies (or, is a model of) a CIA C v D if C I ‚äÜ DI , and I satisfies
(or, is a model of) a TBox T if it satisfies every CIA in T . We use the notation I |= C v D
and I |= T to express that I satisfies C v D, respectively, that I satisfies T .
The description logic ALCF I that we defined above is a member of a larger family of
description logics. The ‚Äúbasic‚Äù description logic ALC is defined as ALCF I without inverse
roles (i.e., without roles of the form P ‚àí ) and without functionality restrictions (i.e., without
concepts of the form ‚â§ 1R). For X ‚äÜ {S, H, I, F}, the description logic ALCX extends
ALC with
1. Functionality restrictions (as in ALCF I) if F ‚àà X,
2. Inverse roles (as in ALCF I) if I ‚àà X,
3. Transitive roles if S ‚àà X. By this, we mean that the role names in NR+ are allowed
to be used.
4. Role hierarchies if H ‚àà X. By this, we mean that a TBox may contain role inclusion
axioms (RIAs) of the form R v S, where R and S are roles, which are satisfied in an
interpretation I if RI ‚äÜ S I .
For DLs that include both transitive roles (S) and functionality restrictions (F), a further
syntactic restriction is imposed: whenever ‚â§ 1R occurs in a concept, then R is required to
be a simple role with respect to the TBox at hand (Horrocks, Sattler, & Tobies, 2000). A
simple role is, intuitively, a role does not have a transitive subrole. The formal definition of
simplicity is as follows: let us write R vT S if either R = S or there are roles R1 , . . . , Rn
such that R1 = R, Rn = S, and for all 1 ‚â§ i < n, T contains either the RIA Ri v Ri+1
‚àí
or the RIA Ri‚àí v Ri+1
. We say R is simple with respect to T if there does not exist
a role S such that S vT R and such that S is of the form P or P ‚àí with P ‚àà NR+ .
The motivation for this standard syntactic restriction is that, without it, basic decision
problems such as satisfiability and concept subsumption with respect to a TBox (defined
below) quickly become undecidable (Horrocks et al., 2000).
353

Ten Cate, Franconi, & Seylan

For X ‚äÜ {S, H, I, F} with S ‚àà X, it is customary to omit the prefix ALC in the notation ALCX. In particular, the description logic ALCSHIF (which is the most expressive
description logic we consider in this paper) is referred to simply as SHIF. SHIF is also
the theoretical basis of the Web Ontology Language OWL-Lite (Horrocks, Patel-Schneider,
& van Harmelen, 2003), which makes it an important DL from a practical viewpoint.
For an L -concept C, the set sub(C) consists of C and all its subconcepts. For a concept
C and a TBox T , rol(C, T ) denotes the set of roles occurring in C or T ; and sig(C, T )
denotes the set of concept names and role names occurring in C or T , i.e., the signature
of C and T . We use sig(C) as an abbreviation for sig(C, ‚àÖ). The size of an L -concept C
(L -role R), written |C| (resp. |R|), is the number of occurrences of symbols needed to write
C (resp. R). The size of an L -TBox T , written |T |, is defined analogously. Later on, in
Section 3.3 we will also consider other, more succinct, ways of representing concepts.
There are alternative ways to represent functionality restrictions and transitive roles in
the DL literature. For example, functionality and transitivity axioms of the form funct R
or Trans(R) are sometimes treated as axioms in the TBox. Although such syntactic differences can be considered minor as far as the standard reasoning tasks (cf. Section 2.2)
are concerned, interpolation results are sensitive to changes in the language. For example,
opting for TBox axioms of the form funct R instead of freely allowing ‚â§ 1R as a construct
in the concept language would change the expressive power of languages we consider. In
Section 3.1, we show that ALCF has the interpolation property. The interested reader
is invited to check if our proof can be adapted to the case where we allow functionality
restrictions only as TBox axioms.
2.2 Decision Problems
A concept C is satisfiable with respect to TBox T if there exists a model I of T such that
C I 6= ‚àÖ. A CIA C v D follows from a TBox T (denoted by T |= C v D), if every model
of T is a model of C v D. We write T |= C ‚â° D if both T |= C v D and T |= D v C hold
true.
The following decision problems will be relevant for us:
‚Ä¢ Concept satisfiability with respect to a TBox :
Given C and T , to determine if C is satisfiable w.r.t. T .
‚Ä¢ Concept subsumption with respect to a TBox :
Given C v D and T , to determine if T |= C v D.
Both problems are parametrized by a description logic L , in which the input concept(s)
and TBox are specified. The two problems are reducible to each (or, more accurately, to
each others complement) for all the logics we consider, due to the fact that their concept
languages are closed under negation. In fact, both problems are ExpTime-complete for
each of the description logics that we consider (Tobies, 2001).
The same decision problems can also be considered over the restricted class of finite
interpretations, i.e., interpretations whose domain is a finite set. We will refer to these
variants of the above decision problems as finite concept satisfiability and finite concept
subsumption. Thus, finite concept satisfiability with respect to a TBox is the problem of
deciding whether a given concept has a non-empty denotation in some finite model of a
354

Beth Definability in Expressive Description Logics

given TBox. It is known (Lutz, Sattler, & Tendera, 2005) that finite concept satisfiability
and finite concept subsumption are also ExpTime-complete for all the description logics we
consider here.
When the finite concept satisfiability problem coincides with the unrestricted satisfiability problem, then we say that the description logic in question has the finite model
property.
Definition 2.1 (Finite model property). A DL L is said to have the finite model property
(FMP) if for every L -concept C and every L -TBox T , if C is satisfiable w.r.t. T , then
there is some finite interpretation I such that I is a model of T and C I 6= ‚àÖ.
It is well-known that ALCF I and its extensions lack the finite model property (Calvanese
& Giacomo, 2003).
2.3 First-Order Translation
It is well-known from the correspondence theory of modal/description logics that description
logic concepts can, in general, be translated into first-order logic formulae with one free
variable (Sattler, Calvanese, & Molitor, 2003). In this translation, each concept name A is
viewed as a unary predicate symbol and each role name R is viewed as a binary predicate
symbol of our first-order language. An interpretation, then, corresponds to a first-order
structure.
We assume that the reader is familiar with basic notation and terminology for first-order
logic. In particular, we will use the notation I, Œ± |= œï to express that the first-order formula
œï is satisfied in the structure I under the first-order variable assignment Œ±. Sometimes, it
will be convenient to use a different notation to express the same thing: if œï(x1 , . . . , xn ) is a
first-order formula whose free variables are x1 , . . . , xn , and if a1 , . . . , an are elements of the
domain of a structure I, we will write I |= œï [a1 , . . . , an ] to express that œï is satisfied in I
under the variable assignment that sends each variable xi to the corresponding element ai .
Note that this notation implicitly assumes an order on the free variables of œï, which will
always be clear from the context.
Definition 2.2. The mapping œÄx from SHIF-concepts to first-order formulae is defined
as follows:
œÄx (>) = >,
œÄx (A) = A(x),
œÄx (¬¨C) = ¬¨œÄx (C),
œÄx (C u D) = œÄx (C) ‚àß œÄx (D),
œÄx (‚àÉP.C) = ‚àÉy[P (x, y) ‚àß œÄy (C)],
œÄx (‚àÉP ‚àí .C) = ‚àÉy[P (y, x) ‚àß œÄy (C)],
œÄx (‚â§ 1P ) = ‚àÄz1 ‚àÄz2 [P (x, z1 ) ‚àß P (x, z2 ) ‚Üí z1 = z2 ],
œÄx (‚â§ 1P ‚àí ) = ‚àÄz1 ‚àÄz2 [P (z1 , x) ‚àß P (z2 , x) ‚Üí z1 = z2 ],
355

Ten Cate, Franconi, & Seylan

where œÄy is obtained from the above definition by replacing
all occurrences of x by y and
V
vice versa. For a SHIF-TBox T , œÄ(T ) is defined as œï‚ààT œÄ(œï), where
œÄ(C v D) = ‚àÄx[œÄx (C) ‚Üí œÄx (D)]
œÄ(R v S) = ‚àÄx‚àÄy[œÄxy (R) ‚Üí œÄxy (S)]
where, for P ‚àà NR , œÄxy (P ) = P (x, y) and œÄxy (P ‚àí ) = P (y, x).
The translation above is model-preserving, i.e., for all SHIF-concepts C, interpretations
I, and first-order assignments Œ± for I, we have Œ±(x) ‚àà C I iff I, Œ± |= œÄx (C); and similarly
for CIAs, RIAs, and TBoxes.

3. Constructive Interpolation with Tableaux
This section provides a constructive proof of an interpolation property in the DLs we are
interested in. This property will be the essential part of the proof of BP in these DLs (cf.
Definition 4.7). Resorting to interpolation to show the Beth definability property in a logic
has been a standard technique since the seminal work of Craig (1957). We start by defining
this interpolation property.
Definition 3.1 (Interpolation property). A DL L is said to have the interpolation property
if and only if for all L -concepts C1 , C2 and all L -TBoxes T1 , T2 , if T1 ‚à™ T2 |= C1 v C2 ,
then there is some L -concept I such that
‚Ä¢ sig(I) ‚äÜ sig(C1 , T1 ) ‚à© sig(C2 , T2 ),
‚Ä¢ T1 ‚à™ T2 |= C1 v I, and
‚Ä¢ T1 ‚à™ T2 |= I v C2 .
Such a concept is called an interpolant of C1 and C2 under hT1 , T2 i.
The interpolation property we consider is defined specifically to prove BP. Normally,
the Craig interpolation property for first-order logic is stated as follows: for all first-order
formulae œï and œà, if œï |= œà, then there exists a first-order formula œë such that sig(œë) ‚äÜ
sig(œï) ‚à© sig(œà), œï |= œë, and œë |= œà. We can however relate the interpolation property we
consider to first-order Craig interpolation using the standard translation of Definition 2.2.
Given L -concepts C1 , C2 and L -TBoxes T1 , T2 , we have by the standard translation the
following equivalences:
T1 ‚à™ T2 |= C1 v C2
œÄ(T1 ) ‚àß œÄ(T2 ) |= œÄx (C1 ) ‚Üí œÄx (C2 )
œÄ(T1 ) ‚àß œÄx (C1 ) |= œÄ(T2 ) ‚Üí œÄx (C2 )
Thus, by setting œï = œÄ(T1 ) ‚àß œÄx (C1 ) and œà = œÄ(T2 ) ‚Üí œÄx (C2 ), we know by Craig‚Äôs
Interpolation Theorem for first-order logic that we always have a first-order interpolant œë
for œï and œà, if œï |= œà (Craig, 1957). However, we do not know in general whether such
an interpolant can be expressed as an L -concept. Because of this reason we will work in
356

Beth Definability in Expressive Description Logics

the DL setting instead of full first-order. Our proofs are constructive in the sense that we
present effective procedures for computing the interpolants. This also allows us to establish
upper bounds on the size of interpolants.
This section is organized as follows. In Section 3.1, we show directly that the interpolation property holds for ALC and ALCF using a worst-case optimal tableau (plural:
tableaux) algorithm in the style of GoreÃÅ and Nguyen (2007). Then in Section 3.2, we show
that the interpolation property also holds in the extensions of ALC and ALCF with transitive and inverse roles. Instead of establishing these results directly using tableaux, we
make use of some satisfiability and signature preserving reductions to ALC and ALCF.
Our main result says that the interpolants in these logics can be computed in double exponential time. In Section 3.3, we study what happens when interpolants are allowed to be
expressed in full first-order logic and show that first-order interpolants can be computed in
single exponential time.
3.1 A Direct Algorithm for Computing Interpolants in ALCF
In this section, we assume that ALCF-concepts are defined recursively as in Section 2.1 using
also ‚ä•, t, ‚àÄR.C, and ‚â• 2R as primitives, i.e., we assume that, e.g., ‚â• 2R is a constructor of
our concept language and not an abbreviation for ¬¨(‚â§ 1R) anymore. Moreover, we assume
that all concepts are in negation normal form (NNF), i.e., the negation occurs only in front
of concept names. It is well-known that every ALCF-concept can easily be transformed
to an equivalent one in NNF by pushing the negation inwards using the dualities between
concept constructors (Tobies, 2001), e.g., ‚àÄR.C and ¬¨‚àÉR.¬¨C. The NNF of the complement
of a concept C is written as ¬¨C.
Àô
Another assumption we make is that ALCF-TBoxes
consist only of axioms of the form > v C. These assumptions make our tableau notation
more compatible with the standard tableau notation for DLs. More precisely, we want to
have a separate rule for each concept constructor in the language (Horrocks et al., 2000).
The main result we present in this section, namely Theorem 3.10, can easily be shown to
hold in the case where we do not make these assumptions.
Definition 3.2. Let C be an ALCF-concept and let T be an ALCF-TBox. The concept
closure cl(C, T ) of C and T is the smallest set of concepts satisfying the following conditions:
‚Ä¢ C ‚àà cl(C, T );
‚Ä¢ if > v D ‚àà T , then D ‚àà cl(C, T );
‚Ä¢ if D ‚àà cl(C, T ) and E ‚àà sub(D), then E ‚àà cl(C, T );
‚Ä¢ if ‚àÉR.D ‚àà cl(C, T ) then ‚àÄR.D ‚àà cl(C, T ).
For the rest of this section, fix two ALCF-concepts C0 , D0 and two ALCF-TBoxes Tl ,
Tr . We will denote the union Tl ‚à™ Tr by T . l stands for left and r for right and it is a
naming scheme adopted from Fitting (1996). It will allow us to identify from which TBox
(Tl or Tr ) or concept (C0 or D0 ) an inference is made. A biased concept is an expression of
the form C Œª , where C is an ALCF-concept and Œª ‚àà {l, r} is a bias. Two relevant biased
concept closures cll and clr are defined as follows.
cll = {C l | C ‚àà cl(C0 , Tl )} and clr = {C r | C ‚àà cl(¬¨D
Àô 0 , Tr )}.
357

Ten Cate, Franconi, & Seylan

We use the Greek letters Œª, Œ∫ to denote a bias.
Our tableau rules will be producing subsets of cll ‚à™ clr in a systematic way. To this aim,
we make use of the metaphor of a burden and relief. Intuitively, a subset Œ¶ of cll ‚à™ clr has
a burden if the satisfiability of Œ¶ depends on the satisfiability of one or more subsets of
cll ‚à™ clr that we call the reliefs of Œ¶.
Definition 3.3. Let Œ¶ ‚äÜ cll ‚à™ clr. Then
‚Ä¢ (C1 u C2 )Œª is an u-burden of Œ¶ iff (C1 u C2 )Œª ‚àà Œ¶ and {(C1 )Œª , (C2 )Œª } 6‚äÜ Œ¶;
‚Ä¢ (C1 t C2 )Œª is an t-burden of Œ¶ iff (C1 t C2 )Œª ‚àà Œ¶ and {(C1 )Œª , (C2 )Œª } ‚à© Œ¶ = ‚àÖ;
‚Ä¢ (‚â§ 1R)Œª is an ‚â§ 1-burden of Œ¶ iff (‚â§ 1R)Œª ‚àà Œ¶ and {(‚àÄR.C)Œ∫ | (‚àÉR.C)Œ∫ ‚àà Œ¶} 6‚äÜ Œ¶;
‚Ä¢ (‚àÉR.C)Œª is an ‚àÉ-burden of Œ¶ iff (‚àÉR.C)Œª is in Œ¶;
‚Ä¢ (‚â• 2R)Œª is an ‚â• 2-burden of Œ¶ iff (‚â• 2R)Œª is in Œ¶.
A burden of Œ¶ is any type of burden from above.
Definition 3.4. Let Œ¶ ‚äÜ cll ‚à™ clr, C Œª be a burden of Œ¶, and S = {Dl | > v D ‚àà Tl } ‚à™ {Dr |
> v D ‚àà Tr }. Then Œ® ‚äÜ cll ‚à™ clr is called a C Œª -relief of Œ¶ if
‚Ä¢ C = (C1 u C2 )Œª and Œ® = {(C1 )Œª , (C2 )Œª } ‚à™ Œ¶;
‚Ä¢ C = (C1 t C2 )Œª and either Œ® = Œ¶ ‚à™ {(C1 )Œª } or Œ® = Œ¶ ‚à™ {(C2 )Œª };
‚Ä¢ C = (‚â§ 1R)Œª and Œ® = Œ¶ ‚à™ {(‚àÄR.C)Œ∫ | (‚àÉR.C)Œ∫ ‚àà Œ¶};
‚Ä¢ C = (‚àÉR.C)Œª and Œ® = {C Œª } ‚à™ {DŒ∫ | (‚àÄR.D)Œ∫ ‚àà Œ¶} ‚à™ S;
‚Ä¢ C = (‚â• 2R)Œª and Œ® = {DŒ∫ | (‚àÄR.D)Œ∫ ‚àà Œ¶} ‚à™ S.
A biased hC0 v D0 , T i-tableau (hC0 v D0 , T i-tableau for short) is a vertex-labeled
directed graph hV, Ei with the labeling content : V ‚Üí 2cll‚à™clr . Intuitively, for all edges hg, g 0 i
constructed by our algorithm, g 0 .content will correspond to some C Œª -relief of g.content. Note
that a tableau is neither required to be a tree nor a directed acyclic graph (DAG) because
cycles may occur in general. We say that a node g in a tableau contains a clash if and only
if either one of the following holds.
‚Ä¢ ‚ä•Œª ‚àà g.content,
‚Ä¢ {AŒª , (¬¨A)Œ∫ } ‚äÜ g.content,
‚Ä¢ {(‚â§ 1R)Œª , (‚â• 2R)Œ∫ } ‚äÜ g.content.
The tableau expansion rules given in Figure 1 expand a tableau by making use of the
semantics of concepts. A rule is said to be applicable to a node g if and only if its condition
is satisfied in g, no rule was applied to g before, and g does not contain a clash. In order to
guarantee a finite expansion, we use proxies in the following way. Whenever a rule creates
a new node g 0 from g, before attaching the edge hg, g 0 i to E, the tableau is searched for a
358

Beth Definability in Expressive Description Logics

The Ru rule
Condition:
Action:
The Rt rule
Condition:
Action:

(C1 u C2 )Œª is an u-burden of g.content.
E ‚Üê E ‚à™ {hg, g 0 i} and g 0 .content ‚Üê Œ¶, where Œ¶ is the (C1 u C2 )Œª -relief
of g.content.
(C1 t C2 )Œª is an t-burden of g.content.
E ‚Üê E ‚à™ {hg, g1 i, hg, g2 i}, g1 .content ‚Üê Œ¶1 , and g2 .content ‚Üê Œ¶2 ,
where Œ¶1 , Œ¶2 are (C1 t C2 )Œª -reliefs of g.content.

The R‚â§1 rule
Condition:
(‚â§ 1R)Œª is an ‚â§ 1-burden of g.content.
Action:
E ‚Üê E ‚à™ {hg, g 0 i} and g 0 .content ‚Üê Œ¶, where Œ¶ is the (‚â§ 1R)Œª -relief of
g.content.
The R‚àÉ rule
Condition:
Œ¶ = {(C1 )Œª1 , . . . , (Cn )Œªn } such that C Œª ‚àà Œ¶ iff C Œª is an ‚àÉ- or ‚â• 2-burden
of g.content.
Action:
E ‚Üê E ‚à™ {hg, gi i | 1 ‚â§ i ‚â§ n} and for 1 ‚â§ i ‚â§ n,
gi .content ‚Üê Œ¶i , where Œ¶i is the (Ci )Œªi -relief of g.content.
Figure 1: Tableau expansion rules for ALCF
node g 00 ‚àà V such that g 0 .content = g 00 .content. If such a g 00 is found, then the edge hg, g 00 i
is added to E and g 0 is discarded.
We are interested in deciding T |= C0 v D0 . The tableau algorithm consists of two
phases. The first phase starts with the initial hC0 v D0 , T i-tableau T = h{g0 }, ‚àÖi, where
g0 .content = {(C0 )l , (¬¨D
Àô 0 )r } ‚à™ {E l | > v E ‚àà Tl } ‚à™ {E r | > v E ‚àà Tr }. T is then
expanded by repeatedly applying the tableau expansion rules in such a way that if more
than one rule is applicable to a node at the same time, then the first applicable rule in the
list [Ru , Rt , R‚â§1 , R‚àÉ ] is chosen. The first phase continues as long as some rule is applicable
to T. A hC0 v D0 , T i-tableau is called complete if and only if it is the output of the first
phase of the tableau algorithm.
Lemma 3.5. The first phase of the tableau algorithm terminates in time 2O(n) , where
n = |cll ‚à™ clr|. Moreover for the complete hC0 v D0 , T i-tableau T = hV, Ei it produces, we
have |V| ‚â§ 2n and |E| ‚àà 2O(n) .
Proof. By definition, the first phase continues as long as some rule is applicable to some
node in the tableau. Then by the definition of applicability, we have that at most one rule
is applied to a node in the tableau.
Let n = |cll ‚à™ clr|. By the definition of a proxy, we have |V| ‚â§ 2n since there are 2n
distinct subsets of cll ‚à™ clr. Combining this with the fact that there is at most one rule
application per node, we obtain 2n as a bound on the number of rule applications. Now,
it is easy to see that each rule executes in time polynomial in n, i.e., the execution time of
each rule is bounded by nk , where k is a constant. Then we have that the whole running
359

Ten Cate, Franconi, & Seylan

time of the first phase is 2n ¬∑ nk . That is,
k

2n ¬∑ nk = 2n+log n

= 2n+k¬∑log n
‚àà 2O(n) .
It only remains to show the bound on |E|. By the definition of tableau rules, the out-degree
of a node cannot exceed n. Therefore, |E| ‚â§ n ¬∑ 2n , i.e., |E| ‚àà 2O(n) .
Let T be the complete hC0 v D0 , T i-tableau obtained from the first phase of the algorithm. The purpose of the second phase of the tableau algorithm, i.e., Algorithm 1, is to
construct the following functions:
1. status : V ‚Üí {sat, unsat} is a total function,
2. int is a partial function from V to ALCF-concepts.
For a g ‚àà V, the values that are assigned to g by thesedfunctions are denoted by g.status
and int(g). Intuitively, the status of a node g denotes if C Œª ‚ààg.content C is satisfiable or not
w.r.t. T ; and int(g), if defined, is an interpolant of g.content in the following sense.
Definition 3.6. Let Œ¶ ‚äÜ cll ‚à™ clr. A concept I is called an interpolant of Œ¶ if and only if
F
d
‚Ä¢ T |= C l ‚ààŒ¶ C v I and T |= I v C r ‚ààŒ¶ ¬¨C
d
F
‚Ä¢ sig(I) ‚äÜ sig( C l ‚ààŒ¶ C) ‚à© sig( C r ‚ààŒ¶ ¬¨C),
By the definition of Algorithm 1, it will be that for all g ‚àà V, int(g) is defined if, and only
if, g.status = unsat. In order to compute int(g) for a node g ‚àà V with g.status = unsat,
Algorithm 1 uses the interpolant calculation rules that are presented in Figures 2, 3, 4. The
rules in Figure 2 compute int(g) based solely on g.content; ones in Figure 3 take into account
g.content and for some successor g 0 of g, the values g 0 .content and int(g 0 ); and finally, ones
in Figure 4 take into account g.content and for every successor g 0 of g, the values g 0 .content
and int(g 0 ). We invite the reader to verify that, indeed, whenever Algorithm 1 assigns unsat
to g.status, for a node g of the tableau, then there is an interpolant calculation rule that
can be applied to compute int(g). Furthermore, each interpolant calculation rule is easily
seen to be sound. For example, the interpolant calculation rule Cu in Figure 3 is sound
because, if for a successor g 0 of g, g 0 .content is the (C1 u C2 )Œª -relief of g.content and int(g 0 )
is an interpolant of g 0 .content (in the sense of Definition 3.6) then it is necessarily also an
interpolant of g.content.
Let T = hV, Ei be a complete hC0 v D0 , T i-tableau which is an output of the second
phase. T is said to be open if and only if g0 .status = sat; and it is said to be closed if and
only if g0 .status = unsat. If T is determined to be open after the second phase, then the
tableau algorithm returns ‚ÄúT 6|= C0 v D0 ‚Äù, otherwise it returns ‚ÄúT |= C0 v D0 ‚Äù.
The next three results establish some important properties of our tableau algorithm and
we use them to prove Theorem 3.10. The proofs of these results require the introduction
of standard but substantial amount of notation from the DL and modal logic literature. In
order to present Theorem 3.10 more clearly, we defer these proofs to Appendix C.
360

Beth Definability in Expressive Description Logics

Algorithm 1 Second phase of the tableau algorithm
Propagate:
do
‚Ä¢ done ‚Üê true.
‚Ä¢ For every g ‚àà V with g.status 6= unsat:
‚Äì if g contains a clash, then
1. g.status ‚Üê unsat,
lr
rl
2. apply one of {Cl‚ä• , Cr‚ä• , Cll¬¨ , Crr
¬¨ , C¬¨ , C¬¨ }, one whose condition is satisfied, to
calculate int(g),
3. done ‚Üê false.
‚Äì if ‚àÉg 0 ‚àà V with hg, g 0 i ‚àà E, g 0 .status = unsat, and g 0 .content is some (C1 u C2 )Œª -,
(‚â§ 1R)Œª -, (‚àÉR.C)Œª , or (‚â• 2R)Œª -relief of g.content, then
1. g.status ‚Üê unsat,
r6R
R
R
l6R
rR
lR
rR
2. apply one of {Cu , Cl6‚â§1
, Cr6‚â§1
, ClR
‚â§1 , C‚â§1 , C‚àÉ , C‚àÉ , C‚àÉ , C‚àÉ }, one whose condition is satisfied, to calculate int(g),
3. done ‚Üê false.
‚Äì if ‚àÉg1 , g2 ‚àà V with g1 6= g2 , hg, g1 i, hg, g2 i ‚àà E, gi .status = unsat for each
i ‚àà {1, 2}, gi .content is a (C1 t C2 )Œª -relief of g.content for each i ‚àà {1, 2}, then
1. g.status ‚Üê unsat,
2. apply one of {Clt , Crt }, one whose condition is satisfied, to calculate int(g),
3. done ‚Üê false.
while done = false.
Assign:
For every g ‚àà V with g.status 6= unsat, g.status ‚Üê sat.

361

Ten Cate, Franconi, & Seylan

The Cl‚ä• rule
Condition:
Action:
The Cr‚ä• rule
Condition:
Action:
The Cll¬¨ rule
Condition:
Action:
The Crr
¬¨ rule
Condition:
Action:
The Clr
¬¨ rule
Condition:
Action:
The Crl
¬¨ rule
Condition:
Action:

‚ä•l ‚àà g.content.
int(g) ‚Üê ‚ä•
‚ä•r ‚àà g.content.
int(g) ‚Üê >
{C l , (¬¨C)
Àô l } ‚äÜ g.content, for a C of the form A or ‚â§ 1R.
int(g) ‚Üê ‚ä•
{C r , (¬¨C)
Àô r } ‚äÜ g.content, for a C of the form A or ‚â§ 1R.
int(g) ‚Üê >
{C l , (¬¨C)
Àô r } ‚äÜ g.content, for a C of the form A or ‚â§ 1R.
int(g) ‚Üê C
{C r , (¬¨C)
Àô l } ‚äÜ g.content, for a C of the form A or ‚â§ 1R.
int(g) ‚Üê ¬¨C
Àô

Figure 2: Interpolant calculation rules for ALCF (content dependent rules)
Lemma 3.7. Let T = hV, Ei be the output of the second phase. For all g ‚àà V, if g.status =
unsat, then
1. g.content is unsatisfiable w.r.t. T ;
2. int(g) is defined and it is an interpolant of g.content; and
n

3. |int(g)| ‚àà O(22 ), where n = |cll ‚à™ clr|.
The next lemma establishes a double exponential upper bound for the runtime of Algorithm 1. This is a consequence of interpolant calculation and our double exponential upper
bound on the size of these interpolants (cf. Lemma 3.7).
Lemma 3.8. The second phase of the tableau algorithm, i.e., Algorithm 1, runs in time
n
O(22 ), where n = |cll ‚à™ clr|.
The next proposition establishes the soundness and the completeness of our algorithm
for concept subsumption w.r.t. TBoxes in ALCF.
Proposition 3.9. T is a closed hC0 v D0 , T i-tableau if and only if T |= C0 v D0 .
The tableau algorithm we presented in this section with the two phases is actually
an algorithm to compute interpolants of at most double exponential size in ALCF. This
upper bound is optimal because the results we establish in Section 4 imply that smallest
interpolants can be of double exponential size.
362

Beth Definability in Expressive Description Logics

The Cu rule
Condition:
g 0 .content is the (C1 u C2 )Œª -relief of g.content.
Action:
int(g) ‚Üê int(g 0 ).
R
The Cl6‚â§1
rule
Condition:
g 0 .content is the (‚â§ 1R)l -relief of g.content and
there is no biased concept of the form (‚àÉR.C)r ‚àà g.content.
Action:
int(g) ‚Üê int(g 0 ).
r6R
The C‚â§1 rule
Condition:
g 0 .content is the (‚â§ 1R)r -relief of g.content and
there is no biased concept of the form (‚àÉR.C)l ‚àà g.content.
Action:
int(g) ‚Üê int(g 0 ).
lR
The C‚â§1 rule
Condition:
g 0 .content is the (‚â§ 1R)l -relief of g.content and
there is some biased concept of the form (‚àÉR.C)r ‚àà g.content.
Action:
int(g) ‚Üê int(g 0 )u ‚â§ 1R.
The CrR
‚â§1 rule
Condition:
g 0 .content is the (‚â§ 1R)r -relief of g.content and
there is some biased concept of the form (‚àÉR.C)l ‚àà g.content.
Action:
int(g) ‚Üê int(g 0 )t ‚â• 2R.
l6R
The C‚àÉ rule
Condition:
g 0 .content is the (‚àÉR.C)l - or (‚â• 2R)l -relief of g.content,
there is no biased concept of the form (‚àÄR.D)r ‚àà g.content.
Action:
int(g) ‚Üê ‚ä•.
The Cr6‚àÉR rule
Condition:
g 0 .content is the (‚àÉR.C)r - or (‚â• 2R)r -relief of g.content,
there is no biased concept of the form (‚àÄR.D)l ‚àà g.content.
Action:
int(g) ‚Üê >.
The ClR
rule
‚àÉ
Condition:
g 0 .content is the (‚àÉR.C)l - or (‚â• 2R)l -relief of g.content,
there is some biased concept of the form (‚àÄR.D)r ‚àà g.content.
Action:
int(g) ‚Üê ‚àÉR.int(g 0 ).
The CrR
‚àÉ rule
Condition:
g 0 .content is the (‚àÉR.C)r - or (‚â• 2R)r -relief of g.content,
there is some biased concept of the form (‚àÄR.D)l ‚àà g.content.
Action:
int(g) ‚Üê ‚àÄR.int(g 0 ).
Figure 3: Interpolant calculation rules for ALCF (single successor dependent rules)
Theorem 3.10. For all ALCF-concepts C, D and all ALCF-TBoxes T1 , T2 if T1 ‚à™ T2 |=
C v D then there exists an interpolant of C and D under hT1 , T2 i that can be computed in
time double exponential in |T1 | + |T2 | + |C| + |D|.
Proof. Suppose C, D are ALCF-concepts and T1 , T2 , and T are ALCF-TBoxes such that
T1 ‚à™ T2 = T and T |= C v D. Then by Proposition 3.9, there is a closed hC v D, T i363

Ten Cate, Franconi, & Seylan

The Clt rule
Condition:
Action:
The Crt rule
Condition:
Action:

g1 .content, g2 .content are (C1 t C2 )l -reliefs of g.content.
int(g) ‚Üê int(g1 ) t int(g2 ).
g1 .content, g2 .content are (C1 t C2 )r -reliefs of g.content.
int(g) ‚Üê int(g1 ) u int(g2 ).

Figure 4: Interpolant calculation rules for ALCF (multiple successor dependent rules)
tableau T = hV, Ei. This means g0 .status = unsat, and thus by Lemma 3.7, there is
some d
ALCF-concept I suchFthat int(g0 ) = I and I is an interpolant of g0 .content. Let
X = >vE‚ààT1 E and Y = >vE‚ààT2 ¬¨E. Since I is an interpolant of g0 .content, we have
T |= C u X v I, T |= I v D t Y , and sig(I) ‚äÜ sig(C u X) ‚à© sig(D t Y ). Then by the
fact that T |= X ‚â° > and T |= Y ‚â° ‚ä•, we obtain T |= C v I and T |= I v D; and by
sig(I) ‚äÜ sig(C u X) ‚à© sig(D t Y ), we obtain sig(I) ‚äÜ sig(C, T1 ) ‚à© sig(D, T2 ). Hence I is an
interpolant of C and D under hT1 , T2 i. Finally by Lemma 3.8, I can be computed in time
double exponential in |T1 | + |T2 | + |C| + |D|.
We end this section with a discussion of the techniques we used. The tableau algorithm
we defined is based on a tableau algorithm by GoreÃÅ and Nguyen (2007). Here we extended
this algorithm for ALCF and added more machinery to compute interpolants. In general
interpolation follows as a corollary to a cut-free sequent or tableau calculus1 for a logic (e.g.,
see Rautenberg, 1983; Fitting, 1996; Kracht, 2007); but such a corollary does not give upper
bounds on the size and computation time of interpolants unless the calculus is combined
with a decision procedure. In this section, our goal was to obtain tight upper bounds on the
size and computation time of interpolants in ALCF. More traditional tableau algorithms
for DLs, e.g., the one by Horrocks et al. (2000), can also be used to establish similar results
(Seylan et al., 2009). Here the crucial idea is that the tableau algorithm should provide
an explicit representation of the tableau rule applications so that an interpolant can be
calculated by induction on the rule applications. We chose a non-traditional DL tableau
algorithm for our purposes because it is based on a non-labeled2 tableau calculus and such
calculi are actually more commonly used for proving interpolation results in modal logics
(e.g., Rautenberg, 1983).
3.2 Extending Interpolation to Transitive and Inverse Roles
In this section, we extend Theorem 3.10 to more logics in order to obtain our main interpolation result Theorem 3.22. To this aim, we present various polynomial reductions from
reasoning in one DL to another. The purpose of these reductions is to eliminate some constructors in the language. The technique we use for these reductions is well-known in the DL
literature and it is called the axiom schema instantiation technique (Calvanese, Giacomo,
& Rosati, 1998; Calvanese, Giacomo, Lenzerini, & Nardi, 2001). Similar techniques also
1. A tableau calculus is defined as a set of tableau rules.
2. A non-labeled tableau calculus provides no explicit representation of individuals in the interpretations.

364

Beth Definability in Expressive Description Logics

appear in modal logic (Kracht, 2007). The idea behind this technique can be summarized
as follows.
DLs are syntactic variants of modal logics. It is well-known that an axiom schema that
is valid in a modal logic corresponds to a certain condition on the accessibility relation in the
frames of that logic (Blackburn, de Rijke, & Venema, 2001). For example the axiom schema
4 : 2œï ‚Üí 22œï defines the class of transitive frames. The axiom schema instantiation
technique is based on instantiating an axiom schema a finite number of times for each
concept in cl or a relevant concept closure, and adding these instances to the TBox to
obtain an equi-satisfiable TBox. The resulting TBox will then be free of the constructor in
the language for which we instantiated the axiom schema.
We note that the input in these reductions is normally a concept and a TBox; but
for interpolation, we are given a pair of concepts C1 , C2 and a pair of TBoxes T1 , T2 .
Therefore, we require from these reductions that they do not mix the signature of sig(C1 , T1 )
and sig(C2 , T2 ) in an ‚Äòuncontrolled‚Äô way. What exactly we mean by this will be clear in
Lemma 3.14 and Lemma 3.19. Naturally, this calls for extra notation.
Definition 3.11. An injective function Œ∂ : X ‚Üí NR , where X is a finite subset of NR ‚à™
{P ‚àí | P ‚àà NR }, is called a role renaming if for all P ‚àà NR , we have {P, P ‚àí } 6‚äÜ X. A role
renaming Œ∂ is called safe for a signature Œ£ if range(Œ∂) ‚à© Œ£ = ‚àÖ.
Given an L -concept C and a role renaming Œ∂, ZŒ∂ (C) is the concept obtained from C by
replacing every occurrence of every R ‚àà dom(Œ∂) by Œ∂(R).
Intuitively, we use role renamings, as the name suggests, to rename roles in concepts. We
need to make sure that the renaming operation is well-defined and thus, we avoid mappings
where a role and its inverse are in the domain of the mapping. Safeness of the mapping
w.r.t. a signature is a property that we desire in the following reductions. We start with
transitive roles and thus, instantiate the axiom schema 2œï ‚Üí 22œï.
Definition 3.12. Let C0 be a SIF-concept, T be a SIF-TBox, and Œ∂ be a safe role
renaming for sig(C0 , T ) with dom(Œ∂) = sig(C0 , T ) ‚à© NR+ and range(Œ∂) ‚à© NR+ = ‚àÖ. Then
œÑS (C0 , T , Œ∂) is defined as the ALCF I-TBox œÑS1 (C0 , T , Œ∂)‚à™œÑS2 (C0 , T , Œ∂), where œÑS1 (C0 , T , Œ∂) =
{> v ZŒ∂ (C) | > v C ‚àà T } and
œÑS2 (C0 , T , Œ∂) = {ZŒ∂ (‚àÄR.C) v ZŒ∂ (‚àÄR.‚àÄR.C) | ‚àÄR.C ‚àà cl(C0 , T ) and {R, R‚àí } ‚à© NR+ 6= ‚àÖ}
Note that in the definition above, the signature of the resulting ALCF I-TBox will not be
equal to the signature of the original SIF-TBox T if C0 or T contains transitive roles.
Introducing these new non-transitive role names is necessary because we are not allowed
to use symbols from NR+ in logics without transitive roles (cf. Section 2.1). Although the
formulation of the following proposition is slightly different from the one of Lemma 6.23 by
Tobies (2001), the proof idea is the same.
Proposition 3.13. A SIF-concept C0 is satisfiable w.r.t. a SIF-TBox T if and only if
the ALCF I-concept ZŒ∂ (C0 ) is satisfiable w.r.t. the ALCF I-TBox œÑS (C0 , T , Œ∂), where Œ∂ is a
safe role renaming for sig(C0 , T ) with dom(Œ∂) = sig(C0 , T ) ‚à© NR+ and range(Œ∂) ‚à© NR+ = ‚àÖ.
The reduction (for concept satisfiability w.r.t. TBoxes) in Definition 3.12 satisfies the
following property that will be essential for extending our interpolation results to logics
365

Ten Cate, Franconi, & Seylan

with transitive roles. In this respect, it also resembles the splitting reduction functions of
Kracht (2007).
Lemma 3.14. Let T1 , T2 be SIF-TBoxes and let C1 , C2 be SIF-concepts. Then
T1 ‚à™ T2 |= C1 v C2 iff œÑS (C1 , T1 , Œ∂) ‚à™ œÑS (¬¨C
Àô 2 , T2 , Œ∂) |= ZŒ∂ (C1 ) v ZŒ∂ (C2 )
where Œ∂ is a safe role renaming for sig(C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 ) with dom(Œ∂) = sig(C1 u ¬¨C
Àô 2 , T1 ‚à™
T2 ) ‚à© NR+ and range(Œ∂) ‚à© NR+ = ‚àÖ.
Proof. Let Œ∂ be a safe role renaming for sig(C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 ) as specified in the lemma.
We will use the following claims for the proof.
Claim 3.15. œÑS (C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 , Œ∂) = œÑS (C1 u ¬¨C
Àô 2 , T1 , Œ∂) ‚à™ œÑS (C1 u ¬¨C
Àô 2 , T2 , Œ∂).
Proof of claim. (‚áí) Suppose C v D ‚àà œÑS (C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 , Œ∂). Then either C v D ‚àà
2
1
Àô 2 , T1 ‚à™ T2 , Œ∂). If the former holds, then we
Àô 2 , T1 ‚à™ T2 , Œ∂) or C v D ‚àà œÑS (C1 u ¬¨C
œÑS (C1 u ¬¨C
immediately obtain the desired result; thus, suppose the latter holds. Then C v D is of the
form ZŒ∂ (‚àÄR.C) v ZŒ∂ (‚àÄR.‚àÄR.C), ‚àÄR.C ‚àà cl(C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 ), and {R, R‚àí } ‚à© NR+ 6= ‚àÖ. By
Definition 3.2 and ‚àÄR.C ‚àà cl(C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 ), we obtain ‚àÄR.C is in cl(C1 u ¬¨C
Àô 2 , T1 ) or
cl(C1 u ¬¨C
Àô 2 , T2 ). Then by Definition 3.12 and the fact that either R ‚àà NR+ or R‚àí ‚àà NR+ ,
we have that ZŒ∂ (‚àÄR.C) v ZŒ∂ (‚àÄR.‚àÄR.C) ‚àà œÑS (C1 u ¬¨C
Àô 2 , T1 , Œ∂) ‚à™ œÑS (C1 u ¬¨C
Àô 2 , T2 , Œ∂), which
is what we wanted to show.
(‚áê) It is rather easy to see that this direction of the claim holds.

a

Claim 3.16. œÑS (C1 u ¬¨C
Àô 2 , T1 , Œ∂) ‚à™ œÑS (C1 u ¬¨C
Àô 2 , T2 , Œ∂) = œÑS (C1 , T1 , Œ∂) ‚à™ œÑS (¬¨C
Àô 2 , T2 , Œ∂).
Proof of claim. (‚áê) Suppose C v D ‚àà œÑS (C1 , T1 , Œ∂) ‚à™ œÑS (¬¨C
Àô 2 , T2 , Œ∂). The desired result
0
follows immediately if C v D = > v ZŒ∂ (C ), for some > v C 0 ‚àà T1 ‚à™T2 . Otherwise, we have
by Definition 3.12 that C v D is of the form ZŒ∂ (‚àÄR.C) v ZŒ∂ (‚àÄR.‚àÄR.C), ‚àÄR.C ‚àà cl(C1 , T1 )‚à™
cl(¬¨C
Àô 2 , T2 ) and either R ‚àà NR+ or R‚àí ‚àà NR+ . Then by ‚àÄR.C ‚àà cl(C1 , T1 ) ‚à™ cl(¬¨C
Àô 2 , T2 )
and cl(C1 , T1 ) ‚à™ cl(¬¨C
Àô 2 , T2 ) ‚äÜ cl(C1 u ¬¨C
Àô 2 , T1 ) ‚à™ cl(C1 u ¬¨C
Àô 2 , T2 ), we obtain ‚àÄR.C ‚àà cl(C1 u
¬¨C
Àô 2 , T1 ) ‚à™ cl(C1 u ¬¨C
Àô 2 , T2 ). Then by Definition 3.12 and the fact that either R ‚àà NR+ or
‚àí
R ‚àà NR+ , we have ZŒ∂ (‚àÄR.C) v ZŒ∂ (‚àÄR.‚àÄR.C) ‚àà œÑS (C1 u ¬¨C
Àô 2 , T1 , Œ∂) ‚à™ œÑS (C1 u ¬¨C
Àô 2 , T2 , Œ∂),
which is what we wanted to show.
(‚áí) Suppose C v D ‚àà œÑS (C1 u ¬¨C
Àô 2 , T1 , Œ∂) ‚à™ œÑS (C1 u ¬¨C
Àô 2 , T2 , Œ∂). The desired result follows
immediately if C v D = > v ZŒ∂ (C 0 ), for some > v C 0 ‚àà T1 ‚à™ T2 . Otherwise, we have
by Definition 3.12 that C v D is of the form ZŒ∂ (‚àÄR.C) v ZŒ∂ (‚àÄR.‚àÄR.C), ‚àÄR.C ‚àà cl(C1 u
¬¨C
Àô 2 , T1 ) ‚à™ cl(C1 u ¬¨C
Àô 2 , T2 ), and either R ‚àà NR+ or R‚àí ‚àà NR+ . Then by ‚àÄR.C ‚àà cl(C1 u
¬¨C
Àô 2 , T1 ) ‚à™ cl(C1 u ¬¨C
Àô 2 , T2 ), the fact that C1 u ¬¨C
Àô 2 6= ‚àÄR.C, and Definition 3.2, we obtain
‚àÄR.C ‚àà cl(C1 , T1 ) ‚à™ cl(¬¨C
Àô 2 , T2 ). Then by Definition 3.12 and the fact that either R ‚àà NR+
or R‚àí ‚àà NR+ , we have ZŒ∂ (‚àÄR.C) v ZŒ∂ (‚àÄR.‚àÄR.C) ‚àà œÑS (C1 , T1 , Œ∂) ‚à™ œÑS (¬¨C
Àô 2 , T2 , Œ∂), which is
what we wanted to show.
a
Now the lemma can be shown in the following way.
‚Ä¢ T1 ‚à™ T2 |= C1 v C2 , iff
366

Beth Definability in Expressive Description Logics

‚Ä¢ C1 u ¬¨C
Àô 2 is unsatisfiable w.r.t. T1 ‚à™ T2 , iff
‚Ä¢ ZŒ∂ (C1 u ¬¨C
Àô 2 ) is unsatisfiable w.r.t. œÑS (C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 , Œ∂) (Proposition 3.13), iff
‚Ä¢ ZŒ∂ (C1 u ¬¨C
Àô 2 ) is unsatisfiable w.r.t. œÑS (C1 u ¬¨C
Àô 2 , T1 , Œ∂) ‚à™ œÑS (C1 u ¬¨C
Àô 2 , T2 , Œ∂) (first
claim), iff
‚Ä¢ ZŒ∂ (C1 u ¬¨C
Àô 2 ) is unsatisfiable w.r.t. œÑS (C1 , T1 , Œ∂) ‚à™ œÑS (¬¨C
Àô 2 , T2 , Œ∂) (second claim), iff
‚Ä¢ œÑS (C1 , T1 , Œ∂) ‚à™ œÑS (¬¨C
Àô 2 , T2 , Œ∂) |= ZŒ∂ (C1 ) v ZŒ∂ (C2 ).

We need a similar reduction to eliminate inverse roles. De Giacomo (1996) presents a
method to reduce converse-PDL satisfiability to PDL satisfiability using the axiom schema
instantiation technique. Since DLs are notational variants of PDLs, this technique can
easily be adapted to DLs as done by Calvanese et al. (1998, 2001). The idea is to instantiate
the converse-PDL axiom schemas œï ‚Üí [Œ±]hŒ±‚àí iœï and œï ‚Üí [Œ±‚àí ]hŒ±iœï.
Definition 3.17. Let C0 be an ALCF I-concept, let T be an ALCF I-TBox, and Œ∂ be
a safe role renaming for sig(C0 , T ) with dom(Œ∂) consisting of all inverse roles appearing
in C0 or T , and range(Œ∂) ‚à© NR+ = ‚àÖ. Then œÑI (C0 , T , Œ∂) is defined as the ALCF-TBox
œÑI1 (C0 , T , Œ∂) ‚à™ œÑI2 (C0 , T , Œ∂), where œÑI1 (C0 , T , Œ∂) = {> v ZŒ∂ (C) | > v C ‚àà T } and
œÑI2 (C0 , T , Œ∂) = {ZŒ∂ (¬¨C)
Àô
v ZŒ∂ (‚àÄR‚àí .‚àÉR.¬¨C)
Àô
| ‚àÄR.C ‚àà cl(C0 , T )}
Note that in the definition above, the signature of the resulting ALCF-TBox will not be
equal to the signature of the original ALCF I-TBox T if C0 or T contains inverse roles.
Proposition 3.18 establishes the correctness of this reduction for concept satisfiability w.r.t.
TBoxes. A full proof of this proposition is given by Seylan (2012).
Proposition 3.18. An ALCF I-concept C0 is satisfiable w.r.t. an ALCF I-TBox T if and
only if the ALCF-concept ZŒ∂ (C0 ) is satisfiable w.r.t. the ALCF-TBox œÑI (C0 , T , Œ∂), where Œ∂
is a safe role renaming for sig(C0 , T ) with dom(Œ∂) consisting of all inverse roles appearing
in C0 or T and range(Œ∂) ‚à© NR+ = ‚àÖ.
The following property of this reduction will be useful in our interpolation results.
Lemma 3.19. Let T1 , T2 be ALCF I-TBoxes and let C1 , C2 be ALCF I-concepts. Then
T1 ‚à™ T2 |= C1 v C2 iff œÑI (C1 , T1 , Œ∂) ‚à™ œÑI (¬¨C
Àô 2 , T2 , Œ∂) |= ZŒ∂ (C1 ) v ZŒ∂ (C2 )
where Œ∂ is a safe role renaming for sig(C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 ) with dom(Œ∂) consisting of all
inverse roles appearing in C1 u ¬¨C
Àô 2 or T1 ‚à™ T2 and range(Œ∂) ‚à© NR+ = ‚àÖ.
Proof. The following claims can be shown analogously to Claim 3.15 and Claim 3.16, respectively.
Claim 3.20. œÑI (C1 u ¬¨C
Àô 2 , T1 ‚à™ T2 , Œ∂) = œÑI (C1 u ¬¨C
Àô 2 , T1 , Œ∂) ‚à™ œÑI (C1 u ¬¨C
Àô 2 , T2 , Œ∂).
Claim 3.21. œÑI (C1 u ¬¨C
Àô 2 , T1 , Œ∂) ‚à™ œÑI (C1 u ¬¨C
Àô 2 , T2 , Œ∂) = œÑI (C1 , T1 , Œ∂) ‚à™ œÑI (¬¨C
Àô 2 , T2 , Œ∂).
367

Ten Cate, Franconi, & Seylan

Then the argument is the same as the last step in the proof of Lemma 3.14.
Theorem 3.22. Let L be ALC or any of its extensions with constructors from {S, I, F}.
For all L -concepts C1 , C2 and all L -TBoxes T1 , T2 , if T1 ‚à™ T2 |= C1 v C2 , then there exists
an interpolant of C1 and C2 under hT1 , T2 i that can be computed in time double exponential
in |T1 | + |T2 | + |C1 | + |C2 |.
Proof. Theorem 3.10 already covers the case for L = ALCF.
For L = ALC. The tableau algorithm for ALCF (with which we proved Theorem 3.10)
can be used without modification to decide concept satisfiability w.r.t. a TBox in ALC.
In other words, given ALC-concepts C1 , C2 and an ALC-TBox T = T1 ‚à™ T2 , we can check
if T |= C1 v C2 using the same algorithm. Observe that during the execution of the
algorithm, R‚â§1 will never be applied and there will be no clashes involving a concept of the
form ‚â§ 1R. If the algorithm constructs a closed hC1 v C2 , T i-tableau, then the interpolant
calculation algorithm will calculate an interpolant in ALCF. Since R‚â§1 was never applied
in the first phase and there is no clash involving a concept of the form ‚â§ 1R in the resulting
tableau, the interpolant calculation rules producing concepts of the form ‚â§ 1R or ‚â• 2R,
rR
namely ClR
‚â§1 , C‚â§1 , and the ones in Figure 2, will never be applied in the second phase. Hence
the resulting interpolant is actually an ALC-concept. That there is always an interpolant
if T1 ‚à™ T2 |= C1 v C2 and the double exponential upper bound on its computation time can
be shown as in Theorem 3.10.
For L ‚àà {ALCI, ALCF I}. Let C1 , C2 be L -concepts and T1 , T2 be L -TBoxes such
that T1 ‚à™ T2 |= C1 v C2 . Let Œ∂ be a role renaming as specified in Lemma 3.19: such a role
renaming always exists. Then by Lemma 3.19, œÑI (C1 , T1 , Œ∂) ‚à™ œÑI (¬¨C
Àô 2 , T2 , Œ∂) |= ZŒ∂ (C1 ) v
ZŒ∂ (C2 ), where C1 , C2 are ALC-concepts (ALCF-concepts) and œÑI (C1 , T1 , Œ∂), œÑI (¬¨C
Àô 2 , T2 , Œ∂)
are ALC-TBoxes (respectively ALCF-TBoxes). We compute an interpolant I of ZŒ∂ (C1 )
and ZŒ∂ (C2 ) under hœÑI (C1 , T1 , Œ∂), œÑI (¬¨C
Àô 2 , T2 , Œ∂)i in time that is at most double exponential
in the size of the input. We have
1. sig(I) ‚äÜ sig(ZŒ∂ (C1 ), œÑI (C1 , T1 , Œ∂)) ‚à© sig(ZŒ∂ (C2 ), œÑI (¬¨C
Àô 2 , T2 , Œ∂)),
2. œÑI (C1 , T1 , Œ∂) ‚à™ œÑI (¬¨C
Àô 2 , T2 , Œ∂) |= ZŒ∂ (C1 ) v I,
3. œÑI (C1 , T1 , Œ∂) ‚à™ œÑI (¬¨C
Àô 2 , T2 , Œ∂) |= I v ZŒ∂ (C2 ).
Let Œ∂1 be the restriction of Œ∂ to rol(C1 , T1 ) and Œ∂2 be the restriction of Œ∂ to rol(¬¨C
Àô 2 , T2 );
and set Œ£1 = range(Œ∂1 ) and Œ£2 = range(Œ∂2 ). Intuitively, Œ£1 and Œ£2 are exactly the sets of
new role names we introduced in œÑI (C1 , T1 , Œ∂) and œÑI (¬¨C
Àô 2 , T2 , Œ∂), respectively. It is easy
to see that sig(ZŒ∂ (C1 ), œÑI (C1 , T1 , Œ∂)) ‚äÜ sig(C1 , T1 ) ‚à™ Œ£1 , and sig(ZŒ∂ (C2 ), œÑI (¬¨C
Àô 2 , T2 , Œ∂)) ‚äÜ
sig(C2 , T2 ) ‚à™ Œ£2 . Then by item 1 above, we have
sig(I) ‚äÜ (sig(C1 , T1 ) ‚à™ Œ£1 ) ‚à© (sig(C2 , T2 ) ‚à™ Œ£2 )
By a simple distributivity argument, we obtain
sig(I) ‚äÜ (sig(C1 , T1 ) ‚à© sig(C2 , T2 )) ‚à™ (Œ£1 ‚à© Œ£2 ) ‚à™
(sig(C1 , T1 ) ‚à© Œ£2 ) ‚à™ (sig(C2 , T2 ) ‚à© Œ£1 )
368

Beth Definability in Expressive Description Logics

Since sig(C1 , T1 ) ‚à© Œ£2 = ‚àÖ and sig(C2 , T2 ) ‚à© Œ£1 = ‚àÖ,
sig(I) ‚äÜ (sig(C1 , T1 ) ‚à© sig(C2 , T2 )) ‚à™ (Œ£1 ‚à© Œ£2 )
Now let D be the L -concept that is obtained from I by replacing all occurrences of each
role name P ‚àà Œ£1 ‚à© Œ£2 by the only role R‚àí such that Œ∂(R‚àí ) = P . Since Œ∂ is injective, this
is well defined. Moreover, we have ZŒ∂ (D) = I.
We claim that for every P ‚àà Œ£1 ‚à© Œ£2 , the role name R with Œ∂(R‚àí ) = P is in sig(C1 , T1 ) ‚à©
sig(C2 , T2 ). Suppose P ‚àà Œ£1 ‚à© Œ£2 . Then P ‚àà range(Œ∂1 ) ‚à© range(Œ∂2 ). Since Œ∂1 and Œ∂2
are defined as restrictions of Œ∂ to rol(C1 , T1 ) and rol(C2 , T2 ), respectively, there is some
R‚àí ‚àà rol(C1 , T1 ) ‚à© rol(C2 , T2 ) such that Œ∂(R‚àí ) = P . But then R ‚àà sig(C1 , T1 ) ‚à© sig(C2 , T2 ).
Now by the claim we have just shown, sig(I) ‚äÜ (sig(C1 , T1 ) ‚à© sig(C2 , T2 )) ‚à™ (Œ£1 ‚à© Œ£2 ), and
the construction of D, we have sig(D) ‚äÜ sig(C1 , T1 ) ‚à© sig(C2 , T2 ). Moreover, by ZŒ∂ (D) = I,
items 2 and 3 above, and Lemma 3.19, we obtain T1 ‚à™ T2 |= C1 v D and T1 ‚à™ T2 |= D v C2 .
Hence D is an interpolant of C1 and C2 under hT1 , T2 i. It is easy to see that the time
required to compute D is as stated in the theorem.
For L ‚àà {S, SI, SF, SIF}. In what follows, let L 0 be L without the transitive role
constructor, e.g., if L = SIF, then L 0 = ALCF I. We know by now that L 0 satisfies what
is stated in the theorem. Suppose that C1 , C2 are L -concepts and T1 , T2 are L -TBoxes
such that T1 ‚à™ T2 |= C1 v C2 . The proof proceeds analogously to the inverse role case,
except of course we use Lemma 3.14.
To conclude, we have shown for each logic L stated in the theorem a constructive way
to compute an interpolant, if one exists, in time double exponential in the size of the input.
Hence the theorem follows.
3.3 Shorter First-Order Interpolants
We will now show that our interpolation algorithm can be adapted to compute first-order
interpolants in single exponential time. The proof will proceed along the following lines.
First we will show that the double exponential size of the interpolants is only due to the
repeated occurrence of subformulas and that our algorithm yields single exponential size
interpolants using a succinct (DAG-shaped as opposed to tree-shaped) concept representation. Next we apply an idea implicit in the work of Avigad (2003), namely that succinctly
represented first-order formulas can be transformed in polynomial time into equivalent ordinary tree-shaped first-order formulas over structures with at least two elements. This
allows us to compute single exponential first-order interpolants over structures with at least
two elements. After that, we show that single exponential interpolants over structures with
one element can be constructed by a reduction to propositional logic. By combining the interpolants obtained via these two methods, we finally obtain the desired single exponential
first-order interpolant over arbitrary structures.
Step 1: Singly-exponential interpolants via succinct representation We start by
defining the notions that will allow us to represent DAG-shaped concepts.
Definition 3.23. Fix a description logic L . An axiom of the form A ‚â° C, where A ‚àà NC
and C is an L -concept, is called a concept definition axiom in L (or, an L -CDA). Let Œ£
369

Ten Cate, Franconi, & Seylan

be a signature. An acyclic terminology over Œ£ in L is a set of L -CDAs
T = {A1 ‚â° C1 , . . . , An ‚â° Cn }
where {A1 , . . . , An } ‚à© Œ£ = ‚àÖ and sig(Ci ) ‚äÜ Œ£ ‚à™ {A1 , . . . , Ai‚àí1 } for i ‚àà {1, . . . , n}.
A succinct-L -concept over Œ£ is a pair hA, T i, where T is an acyclic terminology over
Œ£ in L and A is a concept name belonging to sig(T ) \ Œ£. The unfolding of a succinct-L concept hA, T i is the L -concept over Œ£ that is obtained from A by repeatedly ‚Äúapplying‚Äù
the CDAs in T , i.e., replacing occurrences of their left-hand side by their right-hand side,
until no more CDA can be applied.
Note that acyclic terminologies are well-known in the DL literature (Baader & Nutt,
2003).
Example 3.24. Let T consist of the following.
Woman ‚â° Person u Female
Man ‚â° Person u Male
Human ‚â° Woman t Man
Then T is an acyclic terminology over {Person, Female, Male}. The unfolding of the succinctconcept hHuman, T i is
(Person u Female) t (Person u Male).
The unfolding of a succinct-concept is in general exponentially longer.
Proposition 3.25. Let L be any description logic. For each succinct-L -concept hA, T i
O(1)
with unfolding C, |C| ‚àà 2|T | .
Theorem 3.26. Let L be ALC or any of its extensions with constructors from {S, I, F}.
For all L -concepts C1 , C2 and all L -TBoxes T1 , T2 , if T1 ‚à™ T2 |= C1 v C2 , then there exists
a succinct-L -concept hA, T i over sig(C1 , T1 ) ‚à© sig(C2 , T2 ) such that
‚Ä¢ the unfolding of hA, T i is an interpolant of C1 and C2 under hT1 , T2 i, and
‚Ä¢ hA, T i can be computed in time single exponential in |T1 | + |T2 | + |C1 | + |C2 |.
Proof. Let L be one of the DLs mentioned in the theorem, let T1 ‚à™ T2 |= C1 v C2 , where
T1 , T2 are L -TBoxes and C1 , C2 are L -concepts, and let m = |T1 | + |T2 | + |C1 | + |C2 |. As
in the proof of Theorem 3.22, we first reduce T1 ‚à™ T2 |= C1 v C2 to T10 ‚à™ T20 |= D1 v D2 ,
where T10 , T20 are ALC-TBoxes (ALCF-TBoxes) and D1 , D2 are ALC-concepts (resp. ALCFconcepts).
We show that the interpolant calculation step in Algorithm 1 for ALCF (and thus ALC,
see Figures 2, 3, 4) can be modified to compute a succinct-concept of single exponential size
as an interpolant, instead of a concept.
We associate to every node g in the tableau a distinct fresh concept name Xg . The
new algorithm still uses the same interpolation calculation rules but instead of directly
assigning an interpolant to every node g with g.status = unsat, we construct an acyclic
terminology T 0 over sig(D1 , T10 ) ‚à© sig(D2 , T20 ), where the acyclic terminology makes use of
370

Beth Definability in Expressive Description Logics

the new concept names Xg , and such that the unfolding of the succinct-concept hXg , T 0 i is
an interpolant for g.content whenever g.status = unsat. The set T 0 is initialized as an empty
set, and throughout the computation of the algorithm, T 0 is extended in the natural way.
For instance, suppose Clt is applied to g. Then Clt adds to T 0 the CDA Xg ‚â° Xg1 t Xg2 ,
where g1 and g2 are the successors of the node g in the tableau. Another example is a
l Àô
r } ‚äÜ g.content. Then Clr adds to
clash rule. Suppose Clr
¬¨ is applied to g for some {C , (¬¨C)
¬¨
0
0
T the CDA Xg ‚â° C. By Lemma 3.5, it follows that |T | ‚â§ 2O(m) ; and by the definition
of Algorithm 1, it follows that T 0 is an acyclic terminology over sig(D1 , T10 ) ‚à© sig(D2 , T20 ).
Moreover, by T10 ‚à™ T20 |= D1 v D2 , there is some Xg0 ‚â° C ‚àà T 0 . Then hXg0 , T 0 i is a
succinct-concept over sig(D1 , T10 ) ‚à© sig(D2 , T20 ) and its unfolding can easily be shown to be
an interpolant of D1 and D2 under T10 ‚à™ T20 .
In a way similar to the proof of Theorem 3.22, i.e., by replacing back the newly introduced role names for inverse and transitive roles in T 0 with the originals, we obtain a new
terminology T 00 . Then the unfolding of hXg0 , T 00 i is guaranteed to be an interpolant of C1
and C2 under hT1 , T2 i. Moreover, hXg0 , T 00 i is of size single exponential in m.
For the rest of the section, our purpose is to obtain an equivalent first-order formula from
a given succinct-concept in polynomial time. We will make use of the standard translation
(see Definition 2.2). In the following, we will not distinguish between DL interpretations
and first-order structures (we choose the unary and binary predicates of our first-order
language to be the symbols in NC and NR , respectively).
Step 2: Singly-exponential FO interpolants for interpretations with two elements For a first-order formula œï(x) and an interpretation I = h‚àÜI , ¬∑I i with s ‚àà ‚àÜI , we
write I, s |= œï(x) if and only if there is some first-order assignment Œ± such that Œ±(x) = s
and I, Œ± |= œï(x). By |=‚â•2 , we denote the restriction of the relation |= that only considers
interpretations I = h‚àÜI , ¬∑I i where |‚àÜI | ‚â• 2. Similarly, by |==1 , we denote the restriction
of the relation |= that only considers interpretations I = h‚àÜI , ¬∑I i where |‚àÜI | = 1.
The proof of the following theorem is inspired by a result of Avigad (2003), which
states that, over structures with at least two elements, one can efficiently eliminate acyclic
definitions from proofs. Theorem 3.27 can be viewed as an adaptation of this result to the
first-order translation of succinct-concepts in description logic.
Theorem 3.27. Given a succinct-SHIF-concept hB, T i over a signature Œ£, we can construct in polynomial time a first-order formula œà(x) over Œ£, such that |=‚â•2 œà(x) ‚Üî œÄx (C),
where C is the unfolding of hB, T i.
Our proof of Theorem 3.27 will be based on a lemma that we state next. For expository
reasons, it is more convenient to state the lemma in terms of structures with constant
symbols. These constant symbols are not needed for Theorem 3.27. They are only used to
make the statement and proof of the following lemma more readable.
Lemma 3.28. Given an acyclic terminology T = {A1 ‚â° C1 , . . . , An ‚â° Cn } in SHIF, we
can construct in polynomial time a first-order formula œïT (x, y1 , . . . , yn , z) with additional
constant symbols 0 and 1, such that, for all interpretations I satisfying 0I 6= 1I , and for
all elements a, ~b, c ‚àà ‚àÜI (where ~b = b1 , . . . , bn ),
371

Ten Cate, Franconi, & Seylan

I |= œïT

(
1I
[a, ~b, c] if and only if ~b = k for some k ‚àà {1, . . . , n}, and c =
0I

if a ‚àà CkI
otherwise

I
¬∑ ¬∑ 0I} 1I |0I ¬∑{z
where k = 0
¬∑ ¬∑ 0I} and Ck is the unfolding of the succinct-concept hAk , T i.
| ¬∑{z
k‚àí1 times

n‚àík times

Proof. We define œïT by induction on the number n of CDAs in T . If n = 1, then we can
simply define œïT (x, y, z) as
œïT (x, y, z) = (y = 1) ‚àß ((œÄx (C1 ) ‚àß z = 1) ‚à® (¬¨œÄx (C1 ) ‚àß z = 0))
Now, let n > 1 and let T 0 be obtained from T by removing the last CDA. In other words,
let T = T 0 ‚à™ {An ‚â° Cn }. By induction hypothesis, there is a formula œïT 0 (u, ~v , w) satisfying
the required conditions w.r.t. T 0 (where ~v = v1 , . . . , vn‚àí1 ). We can distinguish the following
cases:
1. Cn is an atomic concept or functionality restriction over the signature Œ£. In this case,
we can define œïT as follows, where ~y = y1 . . . yn and ~v = v1 . . . vn‚àí1 .
œïT (x, ~y , z) = ‚àÉu, ~v , w(œïT 0 (u, ~v , w) ‚àß x = u ‚àß ~y = ~v 0 ‚àß z = w) ‚à®
(~y = 0 ¬∑ ¬∑ ¬∑ 01 ‚àß ((œÄx (Cn ) ‚àß z = 1) ‚à® (¬¨œÄx (Cn ) ‚àß z = 0))))
V
Here, ~y = ~v 0 is a shorthand for the formula
i<n yi = vi ‚àß yn = 0, and, similarly,
V
~y = 0 ¬∑ ¬∑ ¬∑ 01 is shorthand for the formula i<n yi = 0 ‚àß yn = 1.
2. Cn is of the form ¬¨Ai with i < n. In this case, we can define œïT as follows:
œïT (x, ~y , z) = ‚àÉu, ~v , w œïT 0 (u, ~v , w) ‚àß
((x = u ‚àß ~y = ~v 0 ‚àß z = w) ‚à®

(~y = 0 ¬∑ ¬∑ ¬∑ 01 ‚àß u = x ‚àß ~v = i ‚àß ((w = 1 ‚àß z = 0) ‚à® (w = 0 ‚àß z = 1))))
Here, the same notation conventions apply as in V
the previous item. In addition, ~v = i
is used as a shorthand for the formula vi = 1 ‚àß j6=i vj = 0. The notations will also
be used in the following items.
3. Cn is of the form Ai uAj with i, j < n. As a first attempt, define œïT (x, ~y , z) as follows:
œïT (x, ~y , z) = ‚àÉu, ~v , w ‚àÉu0 , ~v 0 , w0 œïT 0 (u, ~v , w) ‚àß œïT 0 (u0 , ~v 0 , w0 ) ‚àß
((x = u ‚àß ~y = ~v 0 ‚àß z = w) ‚à®
(~y = 0 ¬∑ ¬∑ ¬∑ 01 ‚àß u = u0 = x ‚àß ~v = i ‚àß ~v 0 = j ‚àß

(w = w0 = z = 1 ‚à® ((w = 0 ‚à® w0 = 0) ‚àß z = 0))))
This works, except for the fact that œïT 0 occurs twice in the formula, which may
result in an exponential blowup. We solve this problem by replacing the conjunction
œïT 0 (u, ~v , w) ‚àß œïT 0 (u0 , ~v 0 , w0 ) by
‚àÄu00 , ~v 00 , w00 ((u00 = u‚àß~v 00 = v‚àßw00 = w)‚à®(u00 = u0 ‚àß~v 00 = v 0 ‚àßw00 = w0 ) ‚Üí œïT 0 (u00 , ~v 00 , w00 ))
372

Beth Definability in Expressive Description Logics

4. Cn is of the form ‚àÉP.Ai with i < n. This is the most difficult case. The following
formula expresses the required property:
œïT (x, ~y , z) = ‚àÉu, ~v , w œïT 0 (u, ~v , w) ‚àß
((x = u ‚àß ~y = ~v 0 ‚àß z = w) ‚à®
(~y = 0 ¬∑ ¬∑ ¬∑ 01 ‚àß z = 1 ‚àß P xu ‚àß ~v = i ‚àß w = 1) ‚à®
(~y = 0 ¬∑ ¬∑ ¬∑ 01 ‚àß z = 0‚àß

‚àÄu0 , ~v 0 , w0 (œïT 0 (u0 , ~v 0 , w0 ) ‚àß P xu0 ‚àß ~v 0 = i ‚Üí w0 = 0)))
However, as before, this formula still has the problem that it contains two copies of
œïT 0 . We fix this in two steps. First, we bring the universal quantifiers to the front,
and transform the above formula into the following equivalent formula:
‚àÉu, ~v , w ‚àÄu0 , ~v 0 , w0 œïT 0 (u, ~v , w) ‚àß œïT 0 (u0 , ~v 0 , w0 ) ‚Üí
((x = u ‚àß ~y = ~v 0 ‚àß z = w) ‚à®
(~y = 0 ¬∑ ¬∑ ¬∑ 01 ‚àß z = 1 ‚àß P xu ‚àß ~v = i ‚àß w = 1) ‚à® 
(~y = 0 ¬∑ ¬∑ ¬∑ 01 ‚àß z = 0 ‚àß (P xu0 ‚àß ~v 0 = i ‚Üí w0 = 0)))
Finally, as before, we replace the conjunction œïT 0 (u, ~v , w) ‚àß œïT 0 (u0 , ~v 00 , w0 ) by
‚àÄu00 , ~v 00 , w00 ((u00 = u‚àß~v 00 = v‚àßw00 = w)‚à®(u00 = u0 ‚àß~v 00 = v 0 ‚àßw00 = w0 ) ‚Üí œïT 0 (u00 , ~v 00 , w00 ))
5. Cn is of the form ‚àÉP ‚àí .Ai with i < n. This case is handled like the previous one.
Note that, in general, Cn could be a complex concept in which various Ai with i < n occur.
However, such complex CDAs can always be decomposed into multiple simpler CDAs of
the above kinds, at the cost of a polynomial increase in the size of the terminology.
It is clear from the construction that the formula œïT obtained as above satisfies the
conditions stated in the lemma. That œïT is obtained from T in polynomial-time follows
from the fact that, in the above inductive definition of œïT , the previously constructed
formula œïT 0 occurs only once.
We are now ready for the proof of Theorem 3.27.
Proof of Theorem 3.27. Let a succinct-concept hAi , T i be given, where T = {A1 ‚â° C1 , . . . ,
An ‚â° Cn }. Let œï(x) = œïT (x, i, 1) and let œà(x) = ‚àÉu, v(u 6= v ‚àß œï0 (x)), where œï0 (x) is
obtained from œï(x) by replacing 0 and 1 by u and v, respectively. Then we have that, for
every interpretation I with a domain of at least two elements, and for every a ‚àà ‚àÜI , the
following conditions are all equivalent:
1. I, a |= œà(x)
2. I 0 , a |= œï(x), for some interpretation I 0 that extends I by mapping the constant
symbols 0 and 1 to distinct elements of ‚àÜI .
3. I 0 , a |= C, where C is the unfolding of hAi , T i.
4. I, a |= C, where C is the unfolding of hAi , T i.
373

Ten Cate, Franconi, & Seylan

The equivalence of 1 and 2 is immediate from the construction of œà. The equivalence of 2
and 3 follows from Lemma 3.28. The equivalence of 3 and 4 is immediate, since 0 and 1 do
not occur in C. This concludes the proof.
Definition 3.29. Let C, D be L -concepts and let T1 , T2 be L -TBoxes such that T1 ‚à™ T2 |=
C v D. A first-order formula œï(x) is called a FO interpolant of C and D under hT1 , T2 i if
the following conditions hold:
‚Ä¢ sig(œï(x)) ‚äÜ sig(C, T1 ) ‚à© sig(D, T2 ),
‚Ä¢ œÄ(T1 ) ‚à™ œÄ(T2 ) |= ‚àÄx.œÄx (C) ‚Üí œï(x), and
‚Ä¢ œÄ(T1 ) ‚à™ œÄ(T2 ) |= ‚àÄx.œï(x) ‚Üí œÄx (D).
FO |=‚â•2 -interpolant and FO |==1 -interpolant are defined in the same way as above, except
that we replace all occurrences of |= by |=‚â•2 and |==1 , respectively.
Proposition 3.30. Let L be ALC or any of its extensions with constructors from {S, I, F}.
For all L -concepts C1 , C2 and all L -TBoxes T1 , T2 , if T1 ‚à™ T2 |= C1 v C2 , then there exists
a FO |=‚â•2 -interpolant of C1 and C2 under hT1 , T2 i that can be computed in time single
exponential in |T1 | + |T2 | + |C1 | + |C2 |.
Proof. Suppose T1 ‚à™ T2 |= C1 v C2 . By Theorem 3.26, there is some succinct-concept
hA, T i over sig(C1 , T1 ) ‚à© sig(C2 , T2 ) such that the unfolding I of hA, T i is an interpolant
of C1 and C2 under hT1 , T2 i, and hA, T i can be computed in time single exponential in
|T1 |+|T2 |+|C1 |+|C2 |. Then by Theorem 3.27, there is some first-order formula œï(x) that can
be constructed in time polynomial in |T | (hence single exponential in |T1 |+|T2 |+|C1 |+|C2 |)
such that
‚Ä¢ sig(œï(x)) ‚äÜ sig(I),
‚Ä¢ |=‚â•2 œï(x) ‚Üî œÄx (I).
It follows that œï(x) is a FO |=‚â•2 -interpolant of C1 and C2 under hT1 , T2 i whose size is single
exponential in |T1 | + |T2 | + |C1 | + |C2 |.
Step 3: Singly-exponential FO interpolants for interpretations with one element
We still have to obtain interpolants over structures with only one element. We will show
how to do this in Proposition 3.35. The essential idea is that interpolants over structures
with singleton domains are not much different from propositional interpolants. First, we
give a reduction from concept subsumption w.r.t. TBoxes over interpretations with singleton
domains to entailment in propositional logic.
Definition 3.31. Let C be a SHIF-concept. Then the mapping œÑPL (C) is defined inductively as follows.
œÑPL (>) = >,
œÑPL (A) = A,
œÑPL (¬¨C) = ¬¨œÑPL (C),
œÑPL (C u D) = œÑPL (C) u œÑPL (D),
œÑPL (‚àÉR.C) = AR u œÑPL (C),
œÑPL (‚â§ 1R) = >,
374

Beth Definability in Expressive Description Logics

where AP = AP ‚àí is a fresh concept name for every role name P ‚àà NR . For a SHIF-TBox
T , we define
œÑPL (T ) = {œÑPL (C) v œÑPL (D) | C v D ‚àà T } ‚à™ {AR v AS | R v S ‚àà T }.
Here, the concept name AP , intuitively, expresses the non-emptiness of the role P .
Note that all transitive roles are ignored in the above translation, as their semantics is
trivially satisfied in interpretations whose domain is a singleton set. For a SHIF-concept
C, œÑPL (C) is an ALC-concept without role constructors. We view œÑPL (C) as a propositional
formula (where the concept names are the propositions, and we identify u and t with the
propositional connectives ‚àß and ‚à®, respectively). Similarly, for a SHIF-TBox T , œÑPL (T )
is a set of ALC CIAs without role constructors, which we view as a set of propositional
formulae.
Proposition 3.32. Let T be a SHIF-TBox and let C, D be SHIF-concepts. Then
T |==1 C v D

if and only if

œÑPL (T ) |= œÑPL (C) v œÑPL (D).

Proof. (‚áí) Let T |==1 C v D, and suppose I |= œÑPL (T ), and s ‚àà œÑPL (C)I . We need to
show that s ‚àà œÑPL (D)I . Let J be obtained by restricting the domain of I to the element
s and ‚Äúreading off‚Äù the interpretation of each role name P from the concept name AP .
Formally,
‚Ä¢ ‚àÜJ = {s};
‚Ä¢ for all A ‚àà NC , s ‚àà AJ iff s ‚àà AI ;
‚Ä¢ for all P ‚àà NR , P J = {hs, si} if s ‚àà AIP , and P J = ‚àÖ, otherwise.
By the definition above, it trivially follows for every P ‚àà NR+ that P J is transitive. Moreover, for every role R, we have
hs, si ‚àà RJ if and only if s ‚àà AIR .

(1)

To see this, suppose first hs, si ‚àà RJ . If R = P for some P ‚àà NR , then s ‚àà AIP , i.e., s ‚àà AIR ;
and if R = P ‚àí for some P ‚àà NR , then again s ‚àà AIP and by the fact that AP = AP ‚àí
(see Definition 3.31), we obtain s ‚àà AIR . Hence s ‚àà AIR . For the other direction, suppose
s ‚àà AIR . If R = P for some P ‚àà NR , then hs, si ‚àà P J , i.e., hs, si ‚àà RJ ; and if R = P ‚àí for
some P ‚àà NR , then by the fact that AP = AP ‚àí , we have hs, si ‚àà P J and thus, hs, si ‚àà RJ .
Hence (1) follows.
Claim 3.33. For every SHIF-concept C 0 , we have s ‚àà œÑPL (C 0 )I if and only if s ‚àà (C 0 )J .
Proof of claim. The proof is by induction on the structure of C 0 . The base case, where
C 0 = A or C 0 = >, is trivial, and the boolean cases follow immediately by the inductive
hypothesis. For C 0 = ‚àÉR.D0 , we have the following equivalences:
‚Ä¢ s ‚àà œÑPL (C 0 )I ;
‚Ä¢ s ‚àà AIR and s ‚àà œÑPL (D0 )I (by semantics);
375

Ten Cate, Franconi, & Seylan

‚Ä¢ hs, si ‚àà RJ and s ‚àà (D0 )J (by (1) and the inductive hypothesis);
‚Ä¢ s ‚àà (C 0 )J (by semantics).
Finally, for C 0 =‚â§ 1R, since œÑPL (C 0 ) = > and s ‚àà ‚àÜI , we have s ‚àà œÑPL (C 0 )I . Moreover, by
the definition of J , we have s ‚àà (C 0 )J . But then s ‚àà œÑPL (C 0 )I iff s ‚àà (C 0 )J , which is what
we wanted to show.
a
We now show that J |= T , i.e., J satisfies every CIA and RIA in T . That J satisfies
every CIA in T is a direct consequence of the previous claim; so we proceed with the case
for RIAs. Let R v S ‚àà T and hs, ti ‚àà RJ . By the definition of J , we have s = t. Hence
w.l.o.g. suppose that hs, si ‚àà RJ . Then by (1), s ‚àà AIR . Since AR v AS ‚àà œÑPL (T ) and
I |= œÑPL (T ), we then have s ‚àà AIS . By (1) again, this implies hs, si ‚àà S J . Hence J satisfies
R v S.
Now we proceed towards our goal s ‚àà œÑPL (D)I as follows. By I |= œÑPL (T ), s ‚àà œÑPL (C)I ,
and the previous claim, we obtain s ‚àà C J . Since J |= T , it follows by T |= C v D that
s ‚àà DJ . Then using the previous claim, we conclude that s ‚àà œÑPL (D)I .
(‚áê) Let œÑPL (T ) |= œÑPL (C) v œÑPL (D), and suppose I |= T , and s ‚àà C I , where ‚àÜI = {s}.
We need to show that s ‚àà DI . Define the interpretation J as follows:
‚Ä¢ ‚àÜJ = {s};
‚Ä¢ for all A ‚àà NC , AJ = AI
‚Ä¢ for all P ‚àà NR , (AP )J = {s} if P I = {hs, si}, and (AP )J = ‚àÖ otherwise
We first show for every role R that
I
s ‚àà AJ
R if and only if hs, si ‚àà R .

(2)

I
For left-to-right, suppose s ‚àà AJ
R . If R = P for some P ‚àà NR , then hs, si ‚àà P , i.e.,
hs, si ‚àà RI ; and if R = P ‚àí for some P ‚àà NR , then by the fact that AP = AP ‚àí , we have
I
I
s ‚àà AJ
P , which implies hs, si ‚àà R . Hence hs, si ‚àà R . For the other direction, suppose
J
‚àí for some
hs, si ‚àà RI . If R = P for some P ‚àà NR , then s ‚àà AP , i.e., s ‚àà AJ
R ; and if R = P
J
I
P ‚àà NR , then hs, si ‚àà P , which implies by AP = AP ‚àí that s ‚àà AR . Hence (2) follows.

Claim 3.34. For every SHIF-concept C 0 , we have s ‚àà (C 0 )I if and only if s ‚àà œÑPL (C 0 )J .
Proof of claim. The proof is by induction on the structure of C 0 . The base case, where
C 0 = A or C 0 = >, is trivial, and the boolean cases follow immediately by the inductive
hypothesis. For C 0 = ‚àÉR.D0 , we have the following equivalences
‚Ä¢ s ‚àà (C 0 )I ;
‚Ä¢ hs, si ‚àà RI and s ‚àà (D0 )I (by semantics and ‚àÜI = {s});
0 J
‚Ä¢ s ‚àà AJ
R and s ‚àà œÑPL (D ) (by (2) and the inductive hypothesis).

‚Ä¢ s ‚àà œÑPL (C 0 )J (by semantics).
376

Beth Definability in Expressive Description Logics

Finally, for C 0 =‚â§ 1R, since ‚àÜI = {s}, we have I |= > v‚â§ 1R, and thus, s ‚àà (C 0 )I .
Moreover, by œÑPL (C 0 ) = >, we have s ‚àà œÑPL (C 0 )J . But then s ‚àà (C 0 )I iff s ‚àà œÑPL (C 0 )J . a
We now show that J |= œÑPL (T ). By definition, every CIA in œÑPL (T ) is of the form (i)
œÑPL (C 0 ) v œÑPL (D0 ), where C 0 v D0 ‚àà T ; or of the form (ii) AR v AS , where R v S ‚àà T .
That J satisfies CIAs of the form (i) is a direct consequence of the previous claim; so
we focus on CIAs of the form (ii). Let AR v AS ‚àà œÑPL (T ) and s ‚àà AJ
R . Then by (2),
hs, si ‚àà RI . Since I |= T and R v S ‚àà T , we then have hs, si ‚àà S I . Then by (2) again,
s ‚àà AJ
S . Hence J satisfies AR v AS .
Now we proceed towards our goal s ‚àà DI as follows. By s ‚àà C I and the previous claim,
we have s ‚àà œÑPL (C)J . Then by J |= œÑPL (T ) and œÑPL (T ) |= œÑPL (C) v œÑPL (D), we obtain
s ‚àà œÑPL (D)J . Using the previous claim again, we conclude that s ‚àà DI .
Proposition 3.35. Let L be ALC or any of its extensions with constructors from {S, H, I, F}.
For all L -concepts C1 , C2 and all L -TBoxes T1 , T2 , if T1 ‚à™ T2 |= C1 v C2 , then there exists
a FO |==1 -interpolant of C1 and C2 under hT1 , T2 i that can be computed in time single
exponential in |T1 | + |T2 | + |C1 | + |C2 |.
Proof. Let L be one of the DLs mentioned in the theorem and let C1 , C2 be L -concepts
and let T1 , T2 be L -TBoxes such that T1 ‚à™ T2 |= C1 v C2 . Then it immediately follows
that T1 ‚à™ T2 |==1 C1 v C2 . By Proposition 3.32, T1 ‚à™ T2 |==1 C1 v C2 implies œÑPL (T1 ) ‚à™
œÑPL (T2 ) |= œÑPL (C1 ) v œÑPL (C2 ). Now by Theorem 3.10, there is some interpolant I of œÑPL (C1 )
and œÑPL (C2 ) under hœÑPL (T1 ), œÑPL (T2 )i that can be computed in time double exponential in
|T1 |+|T2 |+|C1 |+|C2 |. However, in this case we are only dealing with propositional formulae
and the tableau algorithm can easily be modified to construct a tree-shaped proof instead of
a general graph-shaped one by eliminating the use of proxies. In fact, we have just described
a standard tableau algorithm for propositional logic. It is well-known that each node in
the tree has a polynomial out-degree in the size of the input and the height of the tree is
polynominal in the size of the input. By inspecting the proof of Theorem 3.10, one can easily
see that in this case I can be computed in time single exponential in |T1 | + |T2 | + |C1 | + |C2 |.
Finally let D be the concept obtained from I by replacing each occurrence of a concept name
AR by ‚àÉR.>. We have that œÄx (D) is a FO |==1 -interpolant of C1 and C2 under hT1 , T2 i. It
is easy to see that the time required to compute œÄx (D) is as stated in the proposition.
Step 4: Putting it all together The result that we were after now follows, by putting
the FO |==1 -interpolants and the FO |=‚â•2 -interpolants together:
Theorem 3.36. Let L be ALC or any of its extensions with constructors from {S, I, F}.
For all L -concepts C, D and L -TBoxes T1 , T2 , if T1 ‚à™ T2 |= C v D, then there exists an
FO interpolant œï(x) of C and D under hT1 , T2 i and œï(x) can be computed in time single
exponential in |T1 | + |T2 | + |C| + |D|.
Proof. Let L be one of the DLs mentioned in the theorem, let C, D be L -concepts,
and let T1 , T2 be L -TBoxes such that T1 ‚à™ T2 |= C v D. By Proposition 3.35, there is
some FO |==1 -interpolant œà(x) of C and D under hT1 , T2 i that can be computed in time
single exponential in |T1 | + |T2 | + |C| + |D|; and by Proposition 3.30, there is some FO |=‚â•2 interpolant œï(x) of C and D under hT1 , T2 i that can be computed in time single exponential
377

Ten Cate, Franconi, & Seylan

in |T1 | + |T2 | + |C| + |D|. Let
œë(x) = (‚àÉy‚àÉz(y 6= z) ‚Üí œï(x)) ‚àß (‚àÄy‚àÄz(y = z) ‚Üí œà(x)).
Claim 3.37. œÄ(T1 ) ‚à™ œÄ(T2 ) |= ‚àÄx.œÄx (C) ‚Üí œë(x)

and

œÄ(T1 ) ‚à™ œÄ(T2 ) |= ‚àÄx.œë(x) ‚Üí œÄx (D).

Proof of claim. We prove the first part. The proof of the second part is analogous.
Let I = h‚àÜI , ¬∑I i be a model of T1 ‚à™ T2 , i.e., of œÄ(T1 ) ‚à™ œÄ(T2 ), and Œ± be a first-order
variable assignment with I, Œ± |= œÄx (C). We need to show that I, Œ± |= œë(x). To this aim,
we show I, Œ± |= (‚àÉy‚àÉz(y 6= z) ‚Üí œï(x)) and I, Œ± |= (‚àÄy‚àÄz(y = z) ‚Üí œà(x)).
First suppose that I, Œ± |= ‚àÉy‚àÉz(y 6= z). We are done if we prove that I, Œ± |= œï(x).
I, Œ± |= ‚àÉy‚àÉz(y 6= z) implies |‚àÜI | ‚â• 2. Then by I, Œ± |= œÄx (C) and œÄ(T1 ) ‚à™ œÄ(T2 ) |=‚â•2
‚àÄx.œÄx (C) ‚Üí œï(x), we obtain I, Œ± |= œï(x), and we are done.
Now suppose that I, Œ± |= ‚àÄy‚àÄz(y = z). We are done if we prove that I, Œ± |= œà(x).
I, Œ± |= ‚àÄy‚àÄz(y = z) implies |‚àÜI | = 1. Then by I, Œ± |= œÄx (C) and œÄ(T1 ) ‚à™ œÄ(T2 ) |==1
‚àÄx.œÄx (C) ‚Üí œà(x), we obtain I, Œ± |= œà(x), and we are done.
Thus, both of the conjuncts of œë(x) are satisfied by I, Œ±. But then I, Œ± |= œë(x).
a
By assumption we have that sig(œï(x)), sig(œà(x)) ‚äÜ sig(C, T1 ) ‚à© sig(D, T2 ). Since the
formulas ‚àÉy‚àÉz(y 6= z) and ‚àÄy‚àÄz(y = z) do not introduce new predicates, we have that
sig(œë(x)) ‚äÜ sig(C, T1 ) ‚à© sig(D, T2 ). Therefore, œë(x) is a FO interpolant for C and D under
hT1 , T2 i. Moreover, since both of its conjuncts can be computed in single exponential time,
so can œë(x). Hence the theorem follows.

4. Results on Beth Definability
In this section, we present the main technical contributions of the paper. We first introduce
the notions of implicit and explicit definability for concepts and define the (projective) Beth
definability property, which are in fact the primary notions of interest in this paper. In what
follows, L denotes any of the description logics ALCX with X ‚äÜ {S, H, I, F}.
Definition 4.1 (Implicit definability). Let C be an L -concept, T an L -TBox, and Œ£ ‚äÜ
sig(C, T ). C is implicitly definable from Œ£ under T if, for every two models I and J of T
satisfying ‚àÜI = ‚àÜJ and, for all P ‚àà Œ£, P I = P J , it holds that C I = C J .
In other words, given a TBox, a concept C is implicitly definable if the set of all its
instances depends only on the extension of the predicates in Œ£ and the domain of discourse.
Deciding implicit definability in L means, given an L -concept C, L -TBox T , and a set of
predicates Œ£ ‚äÜ sig(C, T ), to check whether C is implicitly definable from Œ£ under T . For
every predicate P ‚àà sig(C, T ) \ Œ£, introduce a new predicate P 0 which is not in sig(C, T ).
e (respectively, Te ) be the concept (respectively, TBox) obtained by replacing every
Now let C
occurrence of a predicate P 6‚àà Œ£ in C (respectively, in T ) by P 0 . Lemma 4.2, whose proof is
a routine adaptation of an analogous result for first-order logic (Boolos, Burgess, & Jeffrey,
2007), provides a characterization of implicit definability in terms of entailment. This wellknown characterization is often used as a definition of implicit definability (Hoogland &
Marx, 2002; Conradie, 2002).
Lemma 4.2. Let C be an L -concept, T be an L -TBox, and Œ£ ‚äÜ sig(C, T ). Then C is
e
implicitly definable from Œ£ under T if and only if T ‚à™ Te |= C ‚â° C.
378

Beth Definability in Expressive Description Logics

In particular, Lemma 4.2 reduces implicit definability in L to the concept subsumption
problem in L w.r.t. TBoxes. It is also possible to reduce the concept subsumption problem
in L w.r.t. TBoxes to the problem of deciding implicit definability in L .
Lemma 4.3. Let C v D be an L -CIA, T be an L -TBox, Œ£ = sig(C u D, T ), and
A0 ‚àà NC \ Œ£. Then T |= C v D if and only if A0 is implicitly definable from Œ£ under
T ‚à™ {A0 v C u ¬¨D}.
Proof. (‚áí) Suppose T |= C v D. Let I and J be models of T ‚à™ {A0 v C u ¬¨D} such that
‚àÜI = ‚àÜJ and for all P ‚àà Œ£, we have P I = P J . Obviously, I and J are also models of T .
Then by T |= C v D, we have that (C u ¬¨D)I = (C u ¬¨D)J = ‚àÖ. But then AI0 = AJ
0 = ‚àÖ.
Hence, A0 is implicitly definable from Œ£ under T ‚à™ {A0 v C u ¬¨D}.
(‚áê) We show the contrapositive, i.e., if T 6|= C v D, then A0 is not implicitly definable
from Œ£ under T ‚à™ {A0 v C u ¬¨D}. Suppose T 6|= C v D. Then there is some model I of
T and some s ‚àà ‚àÜI such that s ‚àà (C u ¬¨D)I . Let I1 = h‚àÜI1 , ¬∑I1 i and I2 = h‚àÜI2 , ¬∑I2 i be
such that
‚Ä¢ ‚àÜI1 = ‚àÜI2 = ‚àÜI ;
‚Ä¢ AI1 = AI2 = AI , for all A ‚àà (NC \ A0 );
‚Ä¢ RI1 = RI2 = RI , for all R ‚àà NR ;
‚Ä¢ AI0 1 = {s} and AI0 2 = ‚àÖ.
It is easy to see that I1 and I2 are models of T ‚à™ {A0 v C u ¬¨D}. Also observe that I1
and I2 are two interpretations with the same domain and they agree on what they assign
to predicates in Œ£. But AI0 1 6= AI0 2 . Hence A0 is not implicitly definable from Œ£ under
T ‚à™ {A0 v C u ¬¨D}.
Using Lemma 4.2 (for the upper bound) and Lemma 4.3 (for the lower bound), the following theorem follows immediately, since the concept subsumption problem w.r.t. TBoxes
is ExpTime-complete for the description logics in question (Tobies, 2001).
Theorem 4.4. In ALC and any of its extensions with constructors from {S, H, I, F},
implicit definability is ExpTime-complete.
Explicit definability is the syntactic counterpart of implicit definability. Given a concept
C, signature Œ£, and TBox T , it asks for the existence of a concept D formulated over Œ£
such that the C and D denote the same set in every model of T .
Definition 4.5 (Explicit definability). Let C be an L -concept, T a L -TBox, and Œ£ ‚äÜ
sig(C, T ). We say that C is explicitly definable from Œ£ under T if there is some L -concept
D such that T |= C ‚â° D and sig(D) ‚äÜ Œ£. Such a concept D is called an explicit definition
of C from Œ£ under T .
Proposition 4.6. Let C be an L -concept, T an L -TBox, and Œ£ ‚äÜ sig(C, T ). If C is
explicitly definable from Œ£ under T , then C is implicitly definable from Œ£ under T .
379

Ten Cate, Franconi, & Seylan

Proof. Suppose C is explicitly definable from Œ£ under T . Then there is some concept D
e and sig(D) ‚äÜ Œ£ that
such that T |= C ‚â° D. This implies by the definition of Te and C,
e
e
e
e
e
T |= C ‚â° D. Then we have T ‚à™ T |= C ‚â° D and T ‚à™ T |= C ‚â° D by the monotonicity
e Then by Lemma 4.2, C is implicitly definable from Œ£
of |=. These yield T ‚à™ Te |= C ‚â° C.
under T .
Definition 4.7 (Beth definability property). L has the Beth definability property (BP) if
for all L -concepts C, all L -TBoxes T , and all signatures Œ£ ‚äÜ sig(C, T ), if C is implicitly
definable from Œ£ under T , then C is explicitly definable from Œ£ under T .
Observe that, in the above definition, Œ£ restricts the concept names and the role names
that are allowed to appear in the explicit definition. We can obtain a weaker version of the
Beth definability property by restricting only the concept names occurring in the explicit
definition. This is called the concept-name Beth definability property (CBP). In other words,
the CBP refers to the existence of explicit definitions over signatures of the form Œ£ ‚à™ NR .
As we will explain later, we also have reasons to be interested in whether description
logics satisfy the Beth definability property over the restricted class of finite interpretations. It is known that the Beth definability property, when restricted to finite structures,
fails for first-order logic (see e.g., Hoogland, 2001), in spite of the fact that it holds in the
unrestricted case. We will specifically investigate Beth definability for description logics
restricted to finite interpretations. We call this the Beth definability property in the finite
(BPF). Formally, BPF is defined in the same way as BP, except that we replace, in the
definition, all occurrences of the word ‚Äòinterpretation‚Äô or ‚Äòmodel‚Äô by ‚Äòfinite interpretation‚Äô or
‚Äòfinite model‚Äô, and we replace the symbol |= by |=f , where |=f considers only finite interpretations. In addition, we will speak about f-implicit definability and f-explicit definability.
It follows from Lemma 4.2 that, if L has FMP, then BP are BPF are equivalent for L .
Hence it only makes sense to specifically study BPF for logics without FMP.
4.1 Bounds on the Size of Explicit Definitions
We start by a positive result on BP which is a direct application of the interpolation theorem,
i.e., Theorem 3.22.
Theorem 4.8 (BP). Let L be ALC or any of its extensions with constructors from
{S, I, F}. Then for all L -concepts C, all L -TBoxes T , and all signatures Œ£ ‚äÜ sig(C, T ),
if C is implicitly definable from Œ£ under T , then C is explicitly definable from Œ£ under T ,
and the explicit definition of C can be computed in time double exponential in |T | + |C|.
Proof. Let L be one of the DLs stated in the theorem, C be an L -concept, T be an
L -TBox, and Œ£ ‚äÜ sig(C, T ) such that C is implicitly definable from Œ£ under T . By
e (where Te and C
e are obtained from T and C,
Lemma 4.2, we have that T ‚à™ Te |= C ‚â° C
respectively, by replacing all occurrences of predicates P 6‚àà Œ£ by fresh predicates P 0 that
e under
are not in sig(C, T )). Now by Theorem 3.22, there is an interpolant I of C and C
e
e
e
hT , T i that can be computed in time double exponential in |T | + |T | + |C| + |C|. Since it
e Te ) = Œ£, and both (a) T ‚à™ Te |= C v I and
is an interpolant, sig(I) ‚äÜ sig(C, T ) ‚à© sig(C,
e By (b) and T ‚à™ Te |= C
e v C, we have T ‚à™ Te |= I v C, from which
(b) T ‚à™ Te |= I v C.
e
T ‚à™ T |= C ‚â° I follows by (a). From the structure of Te , it now straightforwardly follows
that T |= C ‚â° I.
380

Beth Definability in Expressive Description Logics

e = 2 ¬∑ (|T | + |C|).
As for the time needed to compute I, observe that |T | + |Te | + |C| + |C|
Hence I can be computed in time double exponential in |T | + |C|.
The proof of Theorem 4.8 uses Theorem 3.22. Similarly, if we use Theorem 3.36 instead, we can show that first-order explicit definitions of implicitly defined concepts can
be computed in single exponential time. Note that Theorem 4.8 also establishes a double
exponential upper bound on the size explicit definitions in the considered logics. This upper
bound is optimal because we show in Theorem 4.11 below that explicit definitions in L
may need to be double exponentially big.
An essential tool in the proof of Theorem 4.11, will be the path-set construction that
was previously used by Lutz (2006) to characterize the succinctness of public announcement
logic compared to epistemic logic. The path-set construction has also been used by Ghilardi
et al. (2006) to establish a lower bound on the size of concepts ‚Äòwitnessing‚Äô that a TBox is
not a conservative extension of another TBox.
Definition 4.9. If C is an ALC-concept, then the path-set PC of C is defined by structural
induction as follows, where Œµ denotes the empty sequence and ¬∑ denotes concatenation of
finite sequences:
‚Ä¢ P> = PA = {Œµ}, for A ‚àà NC ;
‚Ä¢ P¬¨C = PC ;
‚Ä¢ PCuD = PC ‚à™ PD ;
‚Ä¢ P‚àÉR.C = {Œµ} ‚à™ {R ¬∑ p | p ‚àà PC }.
Intuitively, PC describes the nestings of role constructors in C. We will use PC as a tool
for establishing lower bounds on the size of concepts.
Lemma 4.10. For every ALC-concept C, we have |C| ‚â• |PC |.
Proof. The proof is by induction on the structure of C.
If C is an atomic concept of the form > or A (with A ‚àà NC ), then, by definition, |C| = 1
and |PC | = 1 since PC = {Œµ}. Hence |C| ‚â• |PC |.
Next, let C = ¬¨D. By the inductive hypothesis, we have |D| ‚â• |PD |. Then by |P¬¨D | =
|PD |, we obtain |D| ‚â• |P¬¨D |. Finally, by the fact that |¬¨D| = |D| + 1, we obtain |¬¨D| ‚â•
|P¬¨D |. Hence |C| ‚â• |PC |.
Next, let C = C1 u C2 . By the inductive hypothesis, we have |C1 | ‚â• |PC1 | and |C2 | ‚â•
|PC2 |. This implies |C1 |+|C2 | ‚â• |PC1 |+|PC2 |. Then by the fact that |C1 uC2 | = |C1 |+|C2 |+1,
we obtain |C1 uC2 | ‚â• |PC1 |+|PC2 |. Finally, by |PC1 |+|PC2 | ‚â• |PC1 uC2 |, we have |C1 uC2 | ‚â•
|PC1 uC2 |. Hence |C| ‚â• |PC |.
Finally, let C = ‚àÉR.D. By the inductive hypothesis, we have |D| ‚â• |PD |. This implies
|D| + 2 ‚â• |PD | + 2. Then by the fact that |‚àÉR.D| = |D| + 2, we obtain |‚àÉR.D| ‚â• |PD | + 2.
Finally, by |PD | + 1 = |P‚àÉR.D |, we have |‚àÉR.D| ‚â• |P‚àÉR.D |. Hence |C| ‚â• |PC |.
Theorem 4.11 (Explicit definition lower bound). Let Œ£ = {R, S} ‚äÜ NR . Then for every
n ‚àà N, there is an ALC-concept Cn and an ALC-TBox Tn such that Œ£ ‚äÜ sig(Cn , Tn ), |Tn |
and |Cn | are polynomial in n, Cn is implicitly definable from Œ£ under Tn , and the smallest
explicit definition of Cn from Œ£ under Tn is double exponentially long in n.
381

Ten Cate, Franconi, & Seylan

Proof. Fix an n ‚àà N. Let A1 , . . . , An be pairwise distinct concept names. We use these
concept names and their negations to represent in binary format a number in {0, . . . , 2n ‚àí1}.
More precisely, ¬¨An u . . . u ¬¨A1 represents 0, ¬¨An u ¬¨An‚àí1 . . . u A1 represents 1, and
so on. Obviously, this implies that the least significant bit is at position 1. For every
i ‚àà {0, . . . , 2n ‚àí 1}, we denote the concept that represents i by Ci . Note that in each Ci ,
either Aj or ¬¨Aj is a conjunct of Ci , for all j ‚àà {1, . . . , n}.
For k ‚àà {1, . . . , n},
‚Ä¢ let Xk = ¬¨A1 u . . . u ¬¨Ak‚àí1 u Ak and
‚Ä¢ let Yk = A1 u . . . u Ak‚àí1 u ¬¨Ak .
Note that Xk and Yk are not concept names and we will use them only to abbreviate our
CIAs. We define Tn as the ALC-TBox consisting of the following CIAs.
‚Ä¢ ¬¨An u . . . u ¬¨A1 v ‚àÄR.‚ä• u ‚àÄS.‚ä•
‚Ä¢ A1 t . . . t An v ‚àÉR.> t ‚àÉS.>
‚Ä¢ For every k ‚àà {1, . . . , n} and œÉ ‚àà Œ£,
Xk v ‚àÄœÉ.Yk u
l
((Al u ‚àÄœÉ.Al ) t (¬¨Al u ‚àÄœÉ.¬¨Al ))
k<l‚â§n

Intuitively, the last item above allows us to decrease the counter value by one by flipping
the respective bits. Note that |Tn | is polynomial in n and that Tn is satisfiable. In fact, we
present models of Tn in Claim 4.14. If I is a model of Tn , we have for every s ‚àà ‚àÜI and
every i ‚àà {1, . . . , n}, either s ‚àà AIi or s ‚àà (¬¨Ai )I by the virtue of I being an interpretation.
Therefore, for every s ‚àà ‚àÜI there is exactly one i ‚àà {0, . . . , 2n ‚àí 1} such that s ‚àà CiI .
Claim 4.12. Let i ‚àà {1, . . . , 2n ‚àí 1}. Then
1. Tn |= Ci v ‚àÄR.Ci‚àí1 u ‚àÄS.Ci‚àí1
2. Tn |= Ci ‚â° ‚àÉR.Ci‚àí1 t ‚àÉS.Ci‚àí1
Proof of claim. For 1, suppose I = h‚àÜI , ¬∑I i is a model of Tn , s ‚àà ‚àÜI with s ‚àà CiI , and
œÉ ‚àà {R, S} = Œ£. It suffices to show that s ‚àà (‚àÄœÉ.Ci‚àí1 )I . If there is no t ‚àà ‚àÜI such that
hs, ti ‚àà œÉ I then we are done immediately; therefore, suppose hs, ti ‚àà œÉ I . We need to show
I .
t ‚àà Ci‚àí1
We have that Ci = Bn u . . . u B1 , where Bj = Aj or Bj = ¬¨Aj , for each j ‚àà {1, . . . , n}.
Denote by B j the concept ¬¨Aj if Bj = Aj , or else the concept Aj if Bj = ¬¨Aj . Since
s ‚àà CiI , there is exactly one k ‚àà {1, . . . , n} such that s ‚àà XkI . Then by the CIA
Xk v ‚àÄœÉ.Yk u
l
((Al u ‚àÄœÉ.Al ) t (¬¨Al u ‚àÄœÉ.¬¨Al ))
k<l‚â§n

382

Beth Definability in Expressive Description Logics

in Tn , we have that t ‚àà (Bn u . . . u Bk+1 u B k u . . . u B 1 )I . It is not hard to see that
Ci‚àí1 = Bn u . . . u Bk+1 u B k u . . . u B 1 .
I , which is what we wanted to show.
Hence we conclude that t ‚àà Ci‚àí1

For 2. (‚áí) Suppose I = h‚àÜI , ¬∑I i is a model of Tn and s ‚àà ‚àÜI with s ‚àà CiI . Since i 6= 0,
by A1 t . . . t An v ‚àÉR.> t ‚àÉS.> ‚àà Tn , Ci ‚àà (‚àÉR.>)I or Ci ‚àà (‚àÉS.>)I . That is, there is
I
some t ‚àà ‚àÜI such that either hs, ti ‚àà RI or hs, ti ‚àà S I . In both cases, t ‚àà Ci‚àí1
by 1. Hence
I
s ‚àà (‚àÉR.Ci‚àí1 t ‚àÉS.Ci‚àí1 ) .
(‚áê) Suppose I = h‚àÜI , ¬∑I i is a model of Tn and s ‚àà ‚àÜI with s ‚àà (‚àÉR.Ci‚àí1 t ‚àÉS.Ci‚àí1 )I .
I
This means there is some t ‚àà ‚àÜI such that t ‚àà Ci‚àí1
and either hs, ti ‚àà RI or hs, ti ‚àà S I .
We proceed towards a contradiction so further suppose that s 6‚àà CiI , i.e., s ‚àà (¬¨Ci )I . Then
by the definition of an interpretation, s ‚àà CjI , where j 6= i and j ‚àà {0, . . . , 2n ‚àí 1}. If j = 0,
then by ¬¨An u . . . u ¬¨A1 v ‚àÄR.‚ä• u ‚àÄS.‚ä• ‚àà Tn , we immediately get a contradiction. If j 6= 0,
I . Since i 6= j, we have (i ‚àí 1) 6= (j ‚àí 1). Thus, the binary representation
then by 1, t ‚àà Cj‚àí1
I
I
of i ‚àí 1 and j ‚àí 1 must differ in at least one bit. This implies by t ‚àà Cj‚àí1
and t ‚àà Ci‚àí1
that
I
I
a
there is some k ‚àà {1, . . . , n} such that t ‚àà Ak and t 6‚àà Ak . Hence a contradiction.
Now define concepts D0 . . . D2n ‚àí1 inductively as follows.
D0 = ‚àÄR.‚ä• u ‚àÄS.‚ä•
Di = ‚àÉR.Di‚àí1 t ‚àÉS.Di‚àí1
Intuitively, Di has the shape of a binary tree (due to role names R, S) and the height of the
tree is O(i). This implies |C2n ‚àí1 | is double exponential in n.
Claim 4.13. For every i ‚àà {0, . . . , 2n ‚àí 1}, we have Tn |= Ci ‚â° Di .
Proof of claim. The proof is by induction on i. The base case is when i = 0. Then by the
axioms in Tn , it trivially follows that Tn |= ¬¨A1 u . . . ¬¨An ‚â° ‚àÄR.‚ä• u ‚àÄS.‚ä•. In other words,
Tn |= C0 ‚â° D0 . Hence the claim holds in the base case.
For the inductive step, suppose i > 0. By the previous claim, Tn |= Ci ‚â° ‚àÉR.Ci‚àí1 t
‚àÉS.Ci‚àí1 ; and by the inductive hypothesis, Tn |= Ci‚àí1 ‚â° Di‚àí1 . But then Tn |= Ci ‚â°
‚àÉR.Di‚àí1 t ‚àÉS.Di‚àí1 which is what we wanted to show.
a
By the previous claim, we have that for all i ‚àà {0, . . . , 2n ‚àí1}, Di is an explicit definition
of Ci from Œ£ = {R, S} under Tn . Then by Proposition 4.6, Ci is implicitly definable from Œ£
under Tn . In the rest of the proof, we show that each explicit definition of Ci from Œ£ under
Tn is at least double exponentially long. To this aim, we introduce interpretations that are
based on some elements of Œ£‚àó , where Œ£‚àó denotes the set of all strings over the symbols in
Œ£. More precisely, for every p ‚àà Œ£‚àó with 0 ‚â§ |p| ‚â§ 2n ‚àí 1, we define the interpretation Ip
as follows.
‚Ä¢ ‚àÜIp = {p0 ‚àà Œ£‚àó | p0 is a prefix of p};
‚Ä¢ for all A ‚àà NC ,
383

Ten Cate, Franconi, & Seylan

‚Äì if A = Aj for some j ‚àà {1, . . . , n}, then
AIp = {p0 ‚àà ‚àÜIp | A is a conjunct of C|p|‚àí|p0 | },
‚Äì if A 6= Aj for all j ‚àà {1, . . . , n}, then AIp = ‚àÖ;
‚Ä¢ for all T ‚àà NR ,
‚Äì T Ip = {hp1 , p2 i ‚àà ‚àÜIp √ó ‚àÜIp | p2 = p1 ¬∑ T }, if T ‚àà Œ£,
‚Äì T Ip = ‚àÖ, if T ‚àà NR \ Œ£.
The following claim is easy to show.
Claim 4.14. For every p ‚àà Œ£‚àó with 0 ‚â§ |p| ‚â§ 2n ‚àí 1, we have
‚Ä¢ Ip |= Tn , and
I

‚Ä¢ Œµ ‚àà C|p|p .
Denote for every i ‚àà {0, . . . , 2n ‚àí 1}, the set of all p ‚àà Œ£‚àó such that |p| = i by Œ£i .
Claim 4.15. Let i ‚àà {0, . . . , 2n ‚àí 1} and let C be an ALC-concept such that sig(C) ‚äÜ Œ£ =
{R, S} and Tn |= Ci ‚â° C. Then Œ£i ‚äÜ PC .
Proof of claim. Suppose first i = 0. Then Œ£i = {Œµ}. Moreover, by definition we have
Œµ ‚àà PC . Hence Œ£i ‚äÜ PC , which is what we wanted to show.
Now suppose i > 0. We proceed towards a contradiction. Suppose that there is some
pa ‚àà Œ£i \ PC . Let pb be the prefix of pa with |pb | = i ‚àí 1. Since i > 0, pb is well-defined.
We claim that for all s ‚àà ‚àÜIpb ‚äÜ ‚àÜIpa and D ‚àà sub(C) such that {s ¬∑ p | p ‚àà PD } ‚äÜ PC ,
s ‚àà DIpb if and only if s ‚àà DIpa .

(3)

The proof is by induction on the structure of D. Since the base and the boolean cases are
trivial, we only treat the case D = ‚àÉœÉ.E, where œÉ ‚àà Œ£.
‚Ä¢ (‚áí). Suppose s ‚àà DIpb . Then there is a t ‚àà ‚àÜIpb such that hs, ti ‚àà œÉ Ipb and t ‚àà E Ipb .
Since t is in ‚àÜIpa as well, the former yields hs, ti ‚àà œÉ Ipa . It thus remains to show
that t ‚àà E Ipa . By definition, t = s ¬∑ œÉ and PD = {Œµ} ‚à™ {œÉ ¬∑ p | p ‚àà PE }. Thus, our
assumption {s ¬∑ p | p ‚àà PD } ‚äÜ PC yields {s} ‚à™ {t ¬∑ p | p ‚àà PE } ‚äÜ PC . This implies
{t ¬∑ p | p ‚àà PE } ‚äÜ PC . Then by the induction hypothesis and t ‚àà E Ipb , we obtain
t ‚àà E Ipa , which is what we wanted to show for this direction of the proof.
‚Ä¢ (‚áê). Suppose s ‚àà DIpa . Then there is a t ‚àà ‚àÜIpa such that hs, ti ‚àà œÉ Ipa and
t ‚àà E Ipa . By definition, t = s ¬∑ œÉ and PD = {Œµ} ‚à™ {œÉ ¬∑ p | p ‚àà PE }. Thus, our
assumption {s ¬∑ p | p ‚àà PD } ‚äÜ PC yields {s} ‚à™ {t ¬∑ p | p ‚àà PE } ‚äÜ PC . This implies
{t ¬∑ p | p ‚àà PE } ‚äÜ PC .

(4)

By (4) and Œµ ‚àà PE , we obtain t ‚àà PC . Since pa 6‚àà PC , this means t 6= pa . But then
t ‚àà ‚àÜIpb and hs, ti ‚àà œÉ Ipb . By (4), t ‚àà E Ipa , and the induction hypothesis, we have
t ‚àà E Ipb . Hence s ‚àà (‚àÉœÉ.E)Ipb .
384

Beth Definability in Expressive Description Logics

Thus, we have shown that (3) holds. Now we arrive at a contradiction as follows. By
Ip
I
Claim 4.14, we have Œµ ‚àà Ci pa and Œµ ‚àà Ci‚àí1b , since |pa | = i and |pb | = i ‚àí 1, respectively.
Ip

Ip

Œµ ‚àà Ci‚àí1b implies by the definition of Ci that Œµ 6‚àà Ci b . Then by Tn |= Ci ‚â° C and Claim 4.14,
we obtain Œµ ‚àà C Ipa and Œµ 6‚àà C Ipb . But this contradicts with an immediate consequence of
(3), namely Œµ ‚àà C Ipb iff Œµ ‚àà C Ipa . Hence a contradiction. Thus, we conclude that Œ£i ‚äÜ PC
for i > 0.
a
To show the theorem, we argue as follows. Suppose that C is an ALC-concept such
n
that Tn |= C2n ‚àí1 ‚â° C and sig(C) ‚äÜ Œ£. Then by the previous claim Œ£2 ‚àí1 ‚äÜ PC . By its
n
n
n
n
definition, |Œ£2 ‚àí1 | = 22 ‚àí1 and thus, 22 ‚àí1 ‚â§ |PC |. Then by Lemma 4.10, 22 ‚àí1 ‚â§ |C|.
Hence the theorem follows.
Remark 4.16. With the role disjunction constructor, which is not present in ALC, Cn
would admit a single exponentially long explicit definition from Œ£ under Tn in Theorem 4.11.
Remark 4.17. The lower bound argument in Theorem 4.11 works for CBP as well by just
setting Œ£ = ‚àÖ.
Combined with Theorem 4.8, Theorem 4.11 implies that implicit definitions using general TBoxes are exactly double exponentially more succinct than explicit definitions using
acyclic terminologies. This closes the open problem of ten Cate et al. (2006) about the size
of explicit definitions. Moreover, the same theorems establish an exact bound on the size of
equivalent rewritings of concept queries as considered by Seylan et al. (2009). Theorem 4.11
also shows that Theorem 1 by Seylan et al. (2010), which claims a single exponential upper
bound on the size of explicit definitions in ALC, is wrong. The source of the problem in
the proof of Theorem 1 is Lemma 1, which claims a single exponential upper bound on the
size of interpolants in ALC.
4.2 Failure of Beth Definability in the Presence of Role Hierarchies
We now show that BP fails in the description logics that we consider that include role
hierarchies (H). This shows that BP is indeed a stronger property than CBP because the
same logics have CBP (ten Cate et al., 2006).
Theorem 4.18. Let L be ALCH or any of its extensions with constructors from {S, I, F}.
Then L does not have BP.
Proof. Let Œ£ = {R1 , R2 } and consider the ALCH-TBox T that consists of
S v R1
S v R2
‚àÉR1 .A u ‚àÄS.‚ä• v ‚àÄR2 .¬¨A
‚àÉR1 .¬¨A u ‚àÄS.‚ä• v ‚àÄR2 .A
It is easy to see that T is satisfiable. In fact, we will present two models of T below.
Claim 4.19. ‚àÉS.> is implicitly definable from Œ£ under T .
385

Ten Cate, Franconi, & Seylan

R1
s

S

R1

a

w

t

R2

R2

R2
v

b

R1

Figure 5: Interpretations I and J that are used for disproving BP for ALCH
Proof of claim. Define XI = {s ‚àà ‚àÜI | ‚àÉt ‚àà ‚àÜI .hs, ti ‚àà R1I ‚à© R2I }. We will show that,
whenever I |= T , then (‚àÉS.>)I = XI . This establishes the claim, since XI depends only
on R1I and R2I .
First, we show (‚àÉS.>)I ‚äÜ XI . Suppose that s ‚àà (‚àÉS.>)I . Then there is some t ‚àà ‚àÜI
such that hs, ti ‚àà S I . By the RIAs in T , we then have that hs, ti ‚àà R1I ‚à© R2I . Hence s ‚àà XI .
Next, we show XI ‚äÜ (‚àÉS.>)I . For contradiction, suppose that s ‚àà XI and s 6‚àà (‚àÉS.>)I ,
i.e., s ‚àà (‚àÄS.‚ä•)I . Then there is some t ‚àà ‚àÜI such that hs, ti ‚àà R1I ‚à© R2I and hs, ti 6‚àà S I .
By the definition of an interpretation, either (i) t ‚àà AI or (ii) t ‚àà (¬¨A)I . If (i), then
by ‚àÉR1 .A u ‚àÄS.‚ä• v ‚àÄR2 .¬¨A ‚àà T , we have t ‚àà (¬¨A)I , which is a contradiction. If (ii),
then by ‚àÉR1 .¬¨A u ‚àÄS.‚ä• v ‚àÄR2 .A ‚àà T , we have t ‚àà AI , which is a contradiction. Hence
XI ‚äÜ (‚àÉS.>)I .
a
Let I = h‚àÜI , ¬∑I i be the interpretation where
‚Ä¢ ‚àÜI = {s, t},
‚Ä¢ R1I = R2I = S I = {hs, ti};
‚Ä¢ RI = ‚àÖ, for all R ‚àà NR \ (Œ£ ‚à™ {S});
‚Ä¢ B I = ‚àÖ, for all B ‚àà NC .
Let J = h‚àÜJ , ¬∑J i be the interpretation where
‚Ä¢ ‚àÜJ = {w, v, a, b},
‚Ä¢ R1J = {hw, ai, hv, bi}, R2J = {hw, bi, hv, ai};
‚Ä¢ RJ = ‚àÖ, for all R ‚àà NR \ Œ£;
‚Ä¢ AJ = {a};
‚Ä¢ B J = ‚àÖ, for all B ‚àà (NC \ {A}).
The interpretations I and J are depicted in Figure 5. It is not hard to see that I and J
are models of T . Furthermore, the two structures are indistinguishable by concepts in the
signature Œ£, in the following sense:
Claim 4.20. For all SHIF-concepts C with sig(C) ‚äÜ Œ£ = {R1 , R2 }, we have
1. s ‚àà C I if and only if w ‚àà C J ;
386

Beth Definability in Expressive Description Logics

2. s ‚àà C I if and only if v ‚àà C J ;
3. t ‚àà C I if and only if a ‚àà C J ;
4. t ‚àà C I if and only if b ‚àà C J
The proof of this claim is straightforward, by simultaneous induction on the structure
of the concept C (alternatively, bisimulations can be used to establish the same result).
Since s ‚àà (‚àÉS.>)I and w 6‚àà (‚àÉS.>)J , it follows that there is no SHIF-concept C such
that sig(C) ‚äÜ Œ£ and T |= ‚àÉS.> ‚â° C. In summary, we have that the ALCH-concept ‚àÉS.> is
implicitly definable from Œ£ under the ALCH-TBox T , but ‚àÉS.> is not explicitly definable
from Œ£ under T in SHIF. We can conclude that BP fails for every description logic that
includes ALCH and that is included in SHIF.
Theorem 4.18 shows that Theorem 10 by Seylan et al. (2010), which claims that ALCH
and its extensions with S and/or I have BP, is incorrect. The mistake in the proof is
that Theorem 9, which presents a reduction from the concept satisfiability problem w.r.t.
TBoxes in SHI to the same problem in ALC, can not actually be used for computing
SHI-interpolants.
4.3 Failure of Beth Definability in the Finite
We now consider BPF (the analogue of Beth Definability over finite structures). Before
we start, we explain our motivations. Seylan et al. (2009) consider an ontology-based data
access setting, where traditional ABoxes are replaced by DBoxes. Syntactically, DBoxes
are defined in the same way as ABoxes, but their semantics is different: while an ABox
is merely assumed to express true facts, a DBox is assumed to list all true facts for some
specified subset of the signature (known as the set of data predicates). Thus, for example,
D = {A(a), R(a, b)} is a DBox for data predicates A and R, and, by the definition of the
semantics of DBoxes, we have that, in every model I of D, AI = {aI } and RI = {haI , bI i}.
In this setting, the TBox may contain other predicates than the data predicates and the
authors use BP to determine whether a concept query over the signature of the TBox can be
rewritten to an equivalent first-order query over the data predicates. When this is possible,
computing the certain answers of the original query can then be reduced to computing
the answers of the rewriting over the DBox, viewed as a database. In the setting we have
described here, and for DLs without FMP, it is more natural to consider BPF than BP. The
reason is that, in every interpretation of a DBox, the data predicates are, by definition, finite
relations. In fact, the appropriate analogue of BP in this setting is one that is restricted
to interpretations in which the data predicates are finite and the rest of the signature is
unrestricted. This variant of BP can be viewed as a common generalization of BP and BFP.
We do not study it here, but the negative results that we will present below for BFP apply
to it as well.
Theorem 4.21 below establishes that BPF fails in L , where L is any DL (among the
ones we consider) lacking FMP. More precisely, we show that there is an L -TBox T , L concept C, and signature Œ£ such that C is f-implicitly definable from Œ£ under T , and that
there is no f-explicit definition in L , i.e., there is no L -concept D such that sig(D) ‚äÜ Œ£
and T |=f C ‚â° D. Intuitively, the reason for the failure of BPF in these logics will be that
387

Ten Cate, Franconi, & Seylan

they can not express the transitive closure of a role (see also the discussion below after the
proof of Theorem 4.21).
Theorem 4.21. Let L be ALCF I or any of its extensions with constructors from {S, H}.
Then L does not have BPF.
Proof. We will, in fact, prove something stronger: we will construct an implicit definition
for which there is no corresponding explicit definition even in full first-order logic.
Let A, B, X be concept names and let R be a role name. Suppose Œ£ = {R, A}. Consider
the ALCF I-TBox T that consists of the following.
> v ‚â§ 1R u ‚â§ 1R‚àí
B v ‚àÉR.B
A v X
‚àÉR.(A u ¬¨B) v ¬¨X
‚àÉR.¬¨X v ¬¨X
We will show that some concept is f-implicitly definable from Œ£ under T but it is not
f-explicitly definable from Œ£ under T . The concept in question is A u B. Note that this
concept is finitely satisfiable w.r.t. T , i.e., there is some finite model I of T such that
(A u B)I 6= ‚àÖ. In fact, we provide such a model In below.
For an interpretation I = h‚àÜI , ¬∑I i. A sequence s0 , . . . , sn of elements of ‚àÜI is called
a finite R-path if n > 0 and hsi , si+1 i ‚àà RI for all i < n. An infinite R-path is defined
analogously. An R-path such that the start and the end nodes are the same is called an
R-cycle. Now we will show two claims that will be useful for the proof of the theorem.
Claim 4.22. Let I be a finite model of T . If s ‚àà B I , then hs, si ‚àà (RI )+ , where (RI )+ is
the transitive closure of RI .
Proof of claim. Suppose that s ‚àà B I . Then the axiom B v ‚àÉR.B ‚àà T implies the existence
of the following infinite R-path:
p = s0 , s1 , . . .
where s0 = s and for all i ‚â• 0, we have si ‚àà B I .
Since I is finite, there is some 0 ‚â§ n < m such that sn = sm . If n = 0, we immediately
have that hs, si ‚àà (RI )+ . Otherwise, we claim that for all pairs hsi , sj i in the sequence
hsn , sm i, hsn‚àí1 , sm‚àí1 i, . . . , hs0 , sm‚àín i, we have si = sj . The base case follows immediately
from sn = sm . For the inductive step, we have by the inductive hypothesis that sn‚àíi =
sm‚àíi = t, for some t ‚àà ‚àÜI . Then by the definition of p, hsn‚àíi‚àí1 , ti ‚àà RI and hsm‚àíi‚àí1 , ti ‚àà
RI , which imply by the axiom > v‚â§ 1R‚àí ‚àà T and I |= T that sn‚àíi‚àí1 = sm‚àíi‚àí1 . Hence
we have that s = s0 = sm‚àín . But then hs, si ‚àà (RI )+ , which is what we wanted to show. a
Claim 4.23. A u B is f-implicitly definable from Œ£ under T .
Proof of claim. For all interpretations I, define
YI = {s ‚àà ‚àÜI | hs, si ‚àà (RI )+ ‚àß s ‚àà AI }.
388

Beth Definability in Expressive Description Logics

We will show that, for all finite models I of T , (A u B)I = YI . This implies the claim, since
YI depends only on RI and AI .
(‚áí) Suppose s ‚àà (A u B)I . By Claim 4.22, we know that hs, si ‚àà (RI )+ . But then
s ‚àà YI .
(‚áê) Suppose s ‚àà YI . Then s ‚àà AI and hs, si ‚àà (RI )+ . Since s ‚àà AI , it is enough to
show that s ‚àà B I . By the definition of an interpretation, either s ‚àà B I or s ‚àà (¬¨B)I . If
s ‚àà (¬¨B)I , then by hs, si ‚àà (RI )+ , s ‚àà (A u ¬¨B)I , and the axioms ‚àÉR.(A u ¬¨B) v ¬¨X ‚àà T
and ‚àÉR.¬¨X v ¬¨X ‚àà T , we have s ‚àà (¬¨X)I which would be a contradiction by s ‚àà AI and
A v X ‚àà T . So it must be that s ‚àà B I .
a
The rest of the proof is all about showing that there is no f-explicit definition of A u B
from Œ£ under T . To this aim, we start by defining an interpretation In , parameterized by
a natural number n > 0.
‚Ä¢ ‚àÜIn = {s0 , . . . , s2n+1 } ‚à™ {t0 , . . . , t2n+1 }
‚Ä¢ RIn = {hsi , si+1 i | 0 ‚â§ i ‚â§ 2n} ‚à™ {hti , ti+1 i | 0 ‚â§ i ‚â§ 2n} ‚à™ {ht2n+1 , t0 , }i
‚Ä¢ AIn = {sn , tn }
‚Ä¢ B In = X In = {ti | 0 ‚â§ i ‚â§ 2n + 1}
Claim 4.24. For every first-order formula œï(x) there is an n > 0 such that In |= œï [sn ] if
and only if In |= œï [tn ].
Proof. We apply the Gaifman locality theorem (cf. Libkin, 2004). In the present setting,
where we only have unary and binary relations, and we are concerned with formulas in a
single free variable, the Gaifman locality theorem is particularly easy to state. Given an
interpretation I and elements a, b ‚àà ‚àÜI , we say that a and b have distance at most n relative
to a signature Œ£, if there is a sequence s0 , . . . , sm with 0 ‚â§ m ‚â§ n such that s0 = a, sm = b,
and for all 0 ‚â§ i < m, pair hsi , si+1 i belongs to P I ‚à™ (P I )‚àí for some binary relation (i.e.,
role name) P ‚àà Œ£. For any interpretation I, element a ‚àà ‚àÜI , and natural number n ‚â• 0,
we denote by I a,n the interpretation whose domain consists of the elements from ‚àÜI that
have distance at most n from a, and whose relations are the ones from I restricted to this
subset of the domain. The Gaifman locality theorem can then be stated as follows: for
every first-order formula œï(x), there is a natural number n > 0 such that, for all structures
I and elements a, b ‚àà ‚àÜI , if I a,n is isomorphic to I b,n , via an isomorphism that maps a
to b, then I |= œï [a] if and only if I |= œï [b].
Now, let œï(x) be any first-order formula, and let n > 0 be the natural number given by
the Gaifman locality theorem. Consider the instance In that we constructed earlier. It is
immediately clear from the construction of In that In sn ,n is isomorphic to In tn ,n , via an
isomorphism that maps sn to tn . Therefore, In |= œï [sn ] if and only if In |= œï [tn ].
Claim 4.25. There is no SHIF-concept C such that sig(C) ‚äÜ Œ£ and T |=f (A u B) ‚â° C.
Proof of claim. We proceed towards a contradiction. Suppose C is an ALCF I-concept such
that sig(C) ‚äÜ Œ£ = {R, A} and T |=f A u B ‚â° C. Let œï(x) = œÄx (C). Since sn ‚àà (A u B)In ,
T |=f A u B ‚â° C, and the fact that In is a finite model of T , we have In 6|= œï [sn ]; and
389

Ten Cate, Franconi, & Seylan

by the same reasoning, we have In |= œï [tn ]. But by the previous claim, In |= œï [sn ] if and
only if In |= œï [tn ], which is a contradiction.
a
In summary, we have that the ALCF I-concept A u B is f-implicitly definable from Œ£
under the ALCF I-TBox T , but A u B is not f-explicitly definable from Œ£ under T even in
SHIF (or in first-order logic, for that matter). It follows that, if L is any proper extension
of ALCF I with constructors from {S, H}, then L does not have BPF.
We point out that the specific counterexample to BPF described in the proof of Theorem 4.21 actually admits an explicit definition if one were to allow the use of transitive
closure. Specifically, it can be shown that A u (‚àÉR.>) u (¬¨‚àÉR+ .¬¨‚àÉR.>) is an explicit
definition, where R+ denotes the transitive closure of the role R.
4.4 The Transitive Closure Operator
The proof of Theorem 4.21 suggests that the failure of BPF in the considered logics may
be caused by the fact that they can not express transitive closure. This raises the question
whether one can regain BPF by adding the transitive closure constructor to ALCF I. In
this section, we show that ALCF I extended with the transitive closure constructor still
lacks BPF.
In the following, we denote by L+ the language obtained from L by additionally allowing R+ as a role for every role R in L . This allows us to include such roles in the
inductive definition of concepts. However, if L includes functionality restrictions, then, as
usual, we forbid the use of transitive closure inside these functionality restrictions. In other
words, in concepts of the form ‚â§ 1R, R is not allowed to make use of the transitive closure
constructor.
The semantics of the transitive closure construct is as expected, namely, (R+ )I is the
relation
{hs, ti | there are s1 , . . . , sn (n > 1) with s1 = s, sn = t, and hsi , si+1 i ‚àà RI for 1 ‚â§ i < n}.
Theorem 4.26. ALCF I + does not have BPF.
Proof. Consider the following ALCF I + -TBox T .
> v ‚â§ 1R‚àí
> v ‚àÉR.>
> v ‚àÉR+ .A

A v ¬¨B
‚àÉR.B v ¬¨B
‚àÉR.¬¨B v B

It is easy to see that T is finitely satisfiable, i.e., T has a finite model. In fact, we provide
finite models In , for n > 0, of T below. We first show that the concept name B is f-implicitly
definable from Œ£ = {R, A} under T and then show that there is no f-explicit definition of
this concept from Œ£ in the language. For an interpretation I, an R-path and R-cycle in I
are defined as in the proof of Theorem 4.21.
Claim 4.27. Let I be a finite model of T . Then for all s ‚àà ‚àÜI , we have hs, si ‚àà (R+ )I .
Proof of claim. Identical to the proof of Claim 4.22 in the proof of Theorem 4.21.

390

a

Beth Definability in Expressive Description Logics

Claim 4.28. We have
(a) T |=f > v ‚àÉR‚àí .>, and
(b) T |=f > v‚â§ 1R.
Proof of claim. Part (a) follows immediately from the previous claim.
To prove part (b), suppose, for the sake of a contradiction that T 6|=f > v ‚â§ 1R. Then
there is some finite model I of T and s, t, u ‚àà ‚àÜI such that t 6= u and hs, ti, hs, ui ‚àà RI .
Since > v ‚â§ 1R‚àí ‚àà T and I |= T and by part (a) of our claim, we have that (R‚àí )I is
the graph of a total function on ‚àÜI . Since t 6= u and hs, ti, hs, ui ‚àà RI , we also know that
the cardinality of the image Y of this function must be strictly smaller than the cardinality
of the domain, i.e., |Y | < |‚àÜI |. This implies that Y ( ‚àÜI . But this contradicts with
> v ‚àÉR.> ‚àà T and I |= T . Hence we conclude that T |=f > v ‚â§ 1R.
a
For s, t ‚àà ‚àÜI , we write odd(s, t) if there is an R-path of odd length from s to t, that is,
an R-path s0 , . . . , sn such that s = s0 , t = sn , and n is odd. Note that in an R-path like
s0 , . . . , sn , we always have n > 0.
Claim 4.29. For all finite models I of T , we have
B I = {s ‚àà ‚àÜI | ‚àÉt ‚àà ‚àÜI .odd(s, t) ‚àß t ‚àà AI }.
Proof of claim. (‚áí) Suppose s ‚àà B I . By the first claim, there is some R-cycle p = s0 , . . . , sn ,
where s0 = sn = s and n > 0. Since > v ‚àÉR+ .A ‚àà T and I |= T , there is some t ‚àà ‚àÜI
such that hs, ti ‚àà (R+ )I and t ‚àà AI . We claim that t = si , for some i ‚àà {1, . . . , n ‚àí 1}. To
show this, we proceed towards a contradiction.
Suppose that our claim does not hold. Then there is some R-path t0 , . . . , tm , where
t0 = s and tm = t. Obviously, this path is different from the R-cycle p since t does not
occur in p. Now by using T |=f > v‚â§ 1R from the previous claim, we can show that every
individual ti actually appears in p, which contradicts with the fact that t does not appear
in p. Hence we conclude that there is some i ‚àà {1, . . . , n ‚àí 1} such that si = t.
We will now show that i is odd. By A v ¬¨B ‚àà T , I |= T , and t ‚àà AI , we have t 6‚àà B I .
Then by using s ‚àà B I and the axioms ‚àÉR.B v ¬¨B ‚àà T , ‚àÉR.¬¨B v B ‚àà T , one can easily
show by induction that i is odd. This implies odd(s, t).
Hence there is some t ‚àà ‚àÜI such that odd(s, t) and t ‚àà AI , which is what we wanted to
show.
(‚áê) Suppose s ‚àà ‚àÜI such that there is some t ‚àà ‚àÜI with odd(s, t) and t ‚àà AI . This implies
that there is some R-path s0 , . . . , sn such that s0 = s, sn = t, and n is odd. By t ‚àà AI ,
A v ¬¨B ‚àà T , and I |= T , we have t 6‚àà B I . Then by using the fact that n is odd, the axioms
‚àÉR.B v ¬¨B ‚àà T and ‚àÉR.¬¨B v B ‚àà T , one can easily show by induction that s ‚àà B I . a
Claim 4.29 implies that B is f-implicitly definable from Œ£ under T . The rest of the proof
shows that there is no f-explicit definition of B from Œ£ under T . For each n ‚â• 0, let In be
the following interpretation:
‚Ä¢ ‚àÜIn = {s0 , . . . , s2n+3 }
391

Ten Cate, Franconi, & Seylan

‚Ä¢ RIn = {hsi , si+1 i | 0 ‚â§ i < 2n + 3} ‚à™ {hs2n+3 , s0 i}
‚Ä¢ AIn = {sn+2 },
‚Ä¢ B In = {si | 0 ‚â§ i ‚â§ 2n + 3 and odd(si , sn+2 )}.
Intuitively, In is an R-cycle of (even) length 2n + 4, some of whose elements satisfy the
concept name A and/or B. Observe that In , for n ‚â• 0, is a model of T . Define the function
d : ‚àÜIn ‚Üí N as follows.

i ‚àí (n + 2) if i ‚â• n + 2
d(si ) =
(n + 2) ‚àí i if i < n + 2
In other words, d(s) is the distance between s and sn+2 .
For each ALCF I + -concept C, we will denote by md(C) the modal depth of C, that is,
the maximal nesting depth of role constructors in C. Formally,
‚Ä¢ md(A) = md(>) = md(‚â§ 1R) = 0
‚Ä¢ md(¬¨C) = md(C)
‚Ä¢ md(C u D) = max{md(C), md(D)}
‚Ä¢ md(‚àÉR.C) = md(‚àÉR+ .C) = md(C) + 1
where A ‚àà CA and R is of the form P or P ‚àí with P ‚àà NR .
Claim 4.30. For all i ‚àà {0, . . . , n} and all s, s0 ‚àà ‚àÜIn \ {s ‚àà ‚àÜIn | d(s) ‚â§ i}, we have
s ‚àà C In iff s0 ‚àà C In
for all ALCF I + -concepts with md(C) ‚â§ i and sig(C) ‚äÜ Œ£.
Proof of claim. Let i ‚àà {0, . . . , n}, s, s0 ‚àà ‚àÜIn \ {s ‚àà ‚àÜIn | d(s) ‚â§ i}, and C be an
ALCFI + -concept with md(C) ‚â§ i and sig(C) ‚äÜ Œ£. The proof is by induction on i.
For i = 0. Since md(C) = 0 and sig(C) ‚äÜ Œ£, C obeys the following grammar:
C ::= > | A |‚â§ 1S | ¬¨C | C u C
where S = R or S = R‚àí (recall that we forbid the use of transitive closure inside functionality restrictions).
By induction on the structure of C, we show that s ‚àà C In iff s0 ‚àà C In .
‚Ä¢ C = >. By the definition of an interpretation, we have s ‚àà >In and s0 ‚àà >In . Hence
s ‚àà >In iff s0 ‚àà >In .
‚Ä¢ C = A (recall that A is the only concept name in Œ£). By assumption, we have s 6= sn+2
and s0 6= sn+2 . Then by the definition of In , we obtain s 6‚àà AIn and s0 6‚àà AIn . Hence
s ‚àà AIn iff s0 ‚àà AIn .
‚Ä¢ C =‚â§ 1S. By the definition of In , we have for all t ‚àà ‚àÜIn that |S In (t)| = 1. Then in
particular, |S In (s)| = |S In (s0 )| = 1. Hence s ‚àà (‚â§ 1S)In iff s0 ‚àà (‚â§ 1S)In .
392

Beth Definability in Expressive Description Logics

‚Ä¢ C = ¬¨D. Follows easily by the inductive hypothesis for C.
‚Ä¢ C = C1 u C2 . Follows easily by the inductive hypothesis for C.
Hence we conclude that s ‚àà C In iff s0 ‚àà C In , for i = 0.
Next, consider the case that i > 0, and let md(C) ‚â§ i and sig(C) ‚äÜ Œ£. Then we have
that C obeys the following grammar:
C ::= ‚àÉS.E | ‚àÉS + .E | ¬¨C | C u C
where md(E) ‚â§ i ‚àí 1, and S = R or S = R‚àí . By induction on the structure of C, we show
that s ‚àà C In iff s0 ‚àà C In .
‚Ä¢ C = ‚àÉS.E with md(E) ‚â§ i ‚àí 1, and S = R or S = R‚àí . By the definition of In , we
have that there is exactly one t ‚àà ‚àÜIn with hs, ti ‚àà S In and exactly one t0 ‚àà ‚àÜIn with
hs0 , t0 i ‚àà S In . Moreover, t, t0 ‚àà ‚àÜIn \ {s ‚àà ‚àÜIn | d(s) ‚â§ i ‚àí 1}. We have that the
following are equivalent:
‚Äì s ‚àà (‚àÉS.E)In
‚Äì t ‚àà E In (since t is the only individual with hs, ti ‚àà S In )
‚Äì t0 ‚àà E In (by the inductive hypothesis for i)
‚Äì s0 ‚àà (‚àÉS.E)In (since t is the only individual with hs0 , t0 i ‚àà S In ).
‚Ä¢ D = ‚àÉS + .E with md(E) = i ‚àí 1, and S = R or S = R‚àí . Suppose first s ‚àà (‚àÉS + .E)In .
Then there is some t ‚àà ‚àÜI such that hs, ti ‚àà (S In )+ and t ‚àà E In . We distinguish the
following cases:
‚Äì t 6= s0 . Then by the definition of In , we immediately obtain hs0 , ti ‚àà (S In )+ ; and
by t ‚àà E In this implies s0 ‚àà (‚àÉS + .E)In .
‚Äì t = s0 . By the definition of In , we have hs0 , si ‚àà (S In )+ . Moreover, s, s0 ‚àà
‚àÜIn \ {s ‚àà ‚àÜIn | d(s) ‚â§ i ‚àí 1}. Then by the inductive hypothesis on i and
s0 ‚àà E In , we have s ‚àà E In , which implies by hs0 , si ‚àà (S In )+ that s0 ‚àà (‚àÉS + .E)In .
Hence s0 ‚àà (‚àÉS + .E)In in both cases, which is what we wanted to show. The direction
from right to left can be shown analogously.
‚Ä¢ The other cases can be shown easily by the inductive hypothesis on C.
a

Hence the claim follows.

Claim 4.31. There is no ALCF I + -concept C such that sig(C) ‚äÜ {A, R} and T |=f B ‚â° C.
Proof of claim. We proceed towards a contradiction so suppose the existence of such a
concept C. By definition, md(C) = n, for some n ‚â• 0; and s0 , s1 ‚àà ‚àÜIn \ {s ‚àà ‚àÜIn | d(s) ‚â§
n}. Then by the previous claim, we have s0 ‚àà C In iff s1 ‚àà C In . Then by the fact that In
is a finite model of T and T |=f B ‚â° C, we have s0 ‚àà B In iff s1 ‚àà B In . This implies by the
definition of In and Claim 4.29 that odd(s0 , sn+2 ) iff odd(s1 , sn+2 ), which is a contradiction.
Hence we conclude that there exists no ALCF I + -concept C such that sig(C) ‚äÜ {A, R} and
T |= B ‚â° C.
a
393

Ten Cate, Franconi, & Seylan

Now the proof of the theorem is as follows. By Claim 4.29, B is f-implicitly definable
from Œ£ = {A, R} under T . But by Claim 4.31, B is not f-explicitly definable from Œ£ under
T . Hence ALCF I + does not have BPF.

5. Concluding Remarks
In this paper, we studied BP in expressive DLs with commonly used concept constructors.
All of these constructors appear in the Web Ontology Language OWL-Lite (Horrocks et al.,
2003). OWL-Lite is now superseded by OWL 2, which supports some other important constructors such as nominals, denoted by O in the language, and qualified number restrictions,
denoted by Q in the language. There are already some results available regarding BP in
logics having Q or O.
Q is a generalization of F and ten Cate et al. (2006) show via a model-theoretic argument
that CBP holds in ALCQ. We believe that BP can also be shown to hold for ALCQ and
ALCQI using a model-theoretic argument; although such an argument gives no upper
bound on the size of explicit definitions. Extending our upper bound results on the size of
explicit definitions to these logics appears to be more difficult because of the unavailability
of a natural and optimal tableau algorithm for these logics.
In logics with O, besides the concept and role names, we assume a set NI = {i, j, . . .}
of nominals. Syntactically, nominals are treated as atomic concepts but semantically each
nominal is interpreted as a singleton set. The presence of nominals gives rise to two different Beth definability properties. In the first one, we are allowed to restrict the nominals
appearing in implicit/explicit definitions by making them part of the signature Œ£; in the
second one, definitions are allowed to use any nominal from NI . Obviously, the first one
is a stronger property. Ten Cate et al. (2006) show that even the second property fails in
ALCO. They also observe that extending ALCO with concepts of the form @i C is enough
to regain CBP. Intuitively, @i C says that the point satisfying the nominal i also satisfies
the concept C.
In a similar way, one can try to identify an extension of ALCH that has BP. In the
proof of Theorem 4.18, our argument for the failure of BP in the considered logics was that
they can not express role conjunction. It remains open if ALCH extended with the role
conjunction constructor has BP. Another interesting open question is to identify a minimal
extension of ALCF I having BPF.
By Theorem 3.36, we know how to compute first-order explicit definitions of single
exponential size, given that a concept is implicitly defined under a TBox. We leave as
another open problem the existence of a matching lower bound, i.e., is there a family of
TBoxes implicitly defining a concept such that smallest explicit definitions in first-order
logic are single exponentially big?

Acknowledgments
We are grateful to Carsten Lutz and Maarten Marx for helpful discussions on the topic. A
substantial part of the research was carried out during an extended visit of IÃánancÃß Seylan to
394

Beth Definability in Expressive Description Logics

UC Santa Cruz in 2010, and we thank Phokion Kolaitis for his hospitality. We also thank
the anonymous reviewers for their extensive comments.
Balder ten Cate was supported by the NSF grants IIS-0905276 and IIS-1217869.

Appendix A. Quasimodels
Decision procedures based on semantic tableau do not construct a model of the given formula/concept, but a finite representation of a model from which the model can be unfolded.
In this paper, we will use the term ‚Äòquasimodel‚Äô to denote such a finite representation following AndreÃÅka, NeÃÅmeti, and van Benthem (1998). Various other names have been used in the
literature, including Hintikka structures (Schwendimann, 1998), model graph (GoreÃÅ, 1999),
and even tableau (Horrocks & Sattler, 2007). Modulo some differences, the building blocks
of these structures are sets of finite concepts each of which is a subset of a relevant concept
closure. We will be using the definition of concept closure cl(C, T ) given in Section 3.1.
Remark A.1. For the rest of the appendix, we assume that ALCF-concepts are defined
recursively as in Section 2.1 using also ‚ä•, t, ‚àÄR.C, and ‚â• 2R as primitives; all concepts
are in NNF; and ALCF-TBoxes consist only of axioms of the form > v C. For a discussion
of these assumptions, we refer the reader to the beginning of Section 3.1.
Not every subset of the concept closure is suitable to take part in a quasimodel. Depending on the logic at hand, these sets satisfy some basic consistency requirements. Following,
e.g., Lutz et al. (2005), we will use the term ‚Äòtype‚Äô to denote these sets satisfying these requirements. Note, however, that the non-membership of a concept in a type does not imply
the membership of the negation of the concept in the type. In this respect, our types are
similar to Hintikka sets, which are also called downward-saturated sets (cf. Fitting, 1996).
Definition A.2. Let C0 be an ALCF-concept and let T be an ALCF-TBox. A œÑ ‚äÜ
cl(C0 , T ) is called an hC0 , T i-type for ALCF if and only if for all A, C, C1 , C2 , ‚àÉR.C, ‚â•
2R, ‚â§ 1R ‚àà cl(C0 , T ),
(P‚ä• ) ‚ä• 6‚àà œÑ ;
(P¬¨ ) {A, ¬¨A} 6‚äÜ œÑ ;
(Pu ) if C1 u C2 ‚àà œÑ , then C1 ‚àà œÑ and C2 ‚àà œÑ ;
(Pt ) if C1 t C2 ‚àà œÑ , then C1 ‚àà œÑ or C2 ‚àà œÑ ;
(Pv ) if > v C ‚àà T , then C ‚àà œÑ ;
(P./ ) {‚â§ 1R, ‚â• 2R} 6‚äÜ œÑ ;
(P‚â§1 ) if {‚â§ 1R, ‚àÉR.C} ‚äÜ œÑ , then ‚àÄR.C ‚àà œÑ .
When a type belongs to a quasimodel, it may force some other type to also belong to
the quasimodel, for instance to witness an existential statement. In fact, a quasimodel is a
collection of types coherent with each other in this sense.
395

Ten Cate, Franconi, & Seylan

Definition A.3. Let C0 be an ALCF-concept, T an ALCF-TBox and œÑ, œÖ two hC0 , T itypes for ALCF.
‚àÉR.C

‚Ä¢ We write œÑ ===‚áí œÖ if ‚àÉR.C ‚àà œÑ and {C} ‚à™ {C 0 | ‚àÄR.C 0 ‚àà œÑ } ‚äÜ œÖ.
‚â•2R

‚Ä¢ We write œÑ ===‚áí œÖ if ‚â• 2R ‚àà œÑ and {C 0 | ‚àÄR.C 0 ‚àà œÑ } ‚äÜ œÖ.
‚Ä¢ A set Q of hC0 , T i-types for ALCF is a hC0 , T i-quasimodel for ALCF if it satisfies:
(a) there is some œÑ0 ‚àà Q such that C0 ‚àà œÑ0 ;
‚àÉR.C

(b) for every œÑ ‚àà Q and ‚àÉR.C ‚àà œÑ , there is a type œÖ ‚àà Q such that œÑ ===‚áí œÖ; and
‚â•2R

(c) for every œÑ ‚àà Q and ‚â• 2R ‚àà œÑ , there is a type œÖ ‚àà Q such that œÑ ===‚áí œÖ.
The following theorem will be useful in soundness and completeness proofs of the tableau
and interpolation algorithms. Its proof is inspired by Marx and Venema (2007).
Theorem A.4. An ALCF-concept C0 is satisfiable w.r.t. an ALCF-TBox T if and only if
there is some hC0 , T i-quasimodel for ALCF.
Proof. (‚áí) Given a model I = h‚àÜI , ¬∑I i of T with C0I 6= ‚àÖ, we carve out for all s ‚àà ‚àÜI , a
set of concepts L(s) ‚äÜ cl(C0 , T ) as follows.
L(s) = {C ‚àà cl(C0 , T ) | s ‚àà C I }.
Now let Q = {L(s) | s ‚àà ‚àÜI }.
Claim A.5. Each œÑ ‚àà Q is a hC0 , T i-type for ALCF.
Proof of claim. Suppose œÑ ‚àà Q. Then œÑ = L(s) for some s ‚àà ‚àÜI . We verify the conditions
in Definition A.2.
‚Ä¢ By definition, ‚ä•I = ‚àÖ and thus s 6‚àà ‚ä•I and thus ‚ä• 6‚àà L(s). Hence (P‚ä• ) is satisfied.
‚Ä¢ By the virtue of I being an interpretation, it is not the case that s ‚àà AI and s ‚àà (¬¨A)I .
Hence (P¬¨ ) is satisfied.
‚Ä¢ If C1 u C2 ‚àà L(s), then s ‚àà (C1 u C2 )I . Since I is an interpretation, s ‚àà C1I and
s ‚àà C2I . But then C1 , C2 ‚àà L(s). Hence (Pu ) is satisfied.
‚Ä¢ If C1 t C2 ‚àà L(s), then s ‚àà (C1 t C2 )I . Since I is an interpretation, s ‚àà C1I or s ‚àà C2I .
But then C1 ‚àà L(s) or C2 ‚àà L(s). Hence (Pt ) is satisfied.
‚Ä¢ If > v C ‚àà T , then ‚àÜI ‚äÜ C I and thus s ‚àà C I . But then C ‚àà L(s). Hence (Pv ) is
satisfied.
‚Ä¢ Suppose for a contradiction that (P./ ) does not hold. Then s ‚àà (‚â§ 1R)I and s ‚àà (‚â•
2R)I . But this is a contradiction. Hence (P./ ) is satisfied.
‚Ä¢ Suppose {‚â§ 1R, ‚àÉR.C} ‚äÜ œÑ . By assumption s ‚àà (‚â§ 1R)I and s ‚àà (‚àÉR.C)I . Then it
follows that there is exactly one t ‚àà ‚àÜI such that hs, ti ‚àà RI and t ‚àà C I . But then
s ‚àà (‚àÄR.C)I . Hence (P‚â§1 ) is satisfied.
396

Beth Definability in Expressive Description Logics

Since we have shown that all the conditions in Definition A.2 are satisfied, we conclude that
œÑ is a hC0 , T i-type for ALCF.
a
We claim that Q is a hC0 , T i-quasimodel. By Claim A.5, if œÑ ‚àà Q, then œÑ is a hC0 , T i-type
for ALCF. Thus it remains to show that condition (a), (b), and (c) from Definition A.3 are
satisfied.
For (a), since C0I 6= ‚àÖ, there is some s0 ‚àà ‚àÜI such that s0 ‚àà C0I and by the construction
of Q, L(s0 ) is in Q. Hence, condition (a) is satisfied.
For condition (b), suppose ‚àÉR.C ‚àà L(s) for some s ‚àà ‚àÜI . This means s ‚àà (‚àÉR.C)I ,
i.e., there is some individual t such that hs, ti ‚àà RI and t ‚àà C I . Then by the construction
of Q, we have C ‚àà L(t). Now let ‚àÄR.D ‚àà L(s). Then by the construction of Q, we have
s ‚àà (‚àÄR.D)I . This implies by hs, ti ‚àà RI that t ‚àà DI . By the construction of Q again, we
‚àÉR.C

obtain D ‚àà L(t). Hence, L(s) ===‚áí L(t); and we conclude that (b) is satisfied.
The proof for (c) is analogous.
(‚áê) Suppose that Q is a hC0 , T i-quasimodel for ALCF. The idea of the proof is to construct
an interpretation I inductively using Q and then show that I |= T and C0I 6= ‚àÖ. For this
construction, we need to introduce some notation first.
Let I be an interpretation and let L : ‚àÜI ‚Üí Q. A pair hs, Ci with s ‚àà ‚àÜI and
C ‚àà cl(C0 , T ) is called a defect of I w.r.t. L, if and only if,
‚Ä¢ ‚àÉR.C ‚àà L(s) and there is no t ‚àà ‚àÜI such that hs, ti ‚àà RI and C ‚àà L(t), or
‚Ä¢ ‚â• 2R ‚àà L(s) and |{t ‚àà ‚àÜI | hs, ti ‚àà RI }| < 2.
Fix a map f : cl(C0 , T ) ‚Üí N, and let  be any linear order on the Cartesian product N √ó N
of order type œâ (recall that a countably infinite linear order is said to have order type œâ if
for each element in the order there are only finitely many elements that are less than it; it
is well known that there are linear orders on N √ó N of order type œâ).
We are now ready to define by induction the interpretations Ii = h‚àÜIi , ¬∑Ii i with ‚àÜIi ‚äÜ N
and mappings Li : ‚àÜIi ‚Üí Q, for i ‚àà N.
Base case. By condition (a) from Definition A.3, there is some type œÑ0 ‚àà Q with C0 ‚àà œÑ0 .
Define the interpretation I0 as follows.
‚Ä¢ ‚àÜI0 = {s}, for some s ‚àà N;
‚Ä¢ for all A ‚àà NC ,
‚Äì if A ‚àà œÑ0 , then AI0 = {s},
‚Äì if A 6‚àà œÑ0 , then AI0 = ‚àÖ;
‚Ä¢ for all R ‚àà NR , RI0 = ‚àÖ.
Set L0 = {s 7‚Üí œÑ0 }.
Inductive step. If there is no defect of Ii w.r.t. Li , then set Ii+1 = Ii and Li+1 = Li ;
otherwise, let hs, Ci be the least defect of Ii w.r.t. Li , i.e., for every defect ht, Di of Ii w.r.t.
Li , we have hs, f (C)i  ht, f (D)i (using the fact that ‚â∫ has order type œâ). By Li (s) ‚àà Q
C

and conditions (b) and (c) from Definition A.3, there is some œÑ ‚àà Q such that Li (s) =
‚áí œÑ.
If C = ‚àÉR.D, then let t ‚àà N \ ‚àÜIi and define
397

Ten Cate, Franconi, & Seylan

‚Ä¢ ‚àÜIi+1 = ‚àÜIi ‚à™ {t},
‚Ä¢ for all A ‚àà NC ,
‚Äì if A ‚àà œÑ , then AIi+1 = AIi ‚à™ {t},
‚Äì if A 6‚àà œÑ , then AIi+1 = AIi ;
‚Ä¢ for all S ‚àà NR ,
‚Äì if S = R, then S Ii+1 = {hs, ti} ‚à™ S Ii ,
‚Äì if S 6= R, then S Ii+1 = S Ii .
Also set Li+1 = Li ‚à™ {t 7‚Üí œÑ }. If C =‚â• 2R, then let t1 , t2 ‚àà N \ ‚àÜIi with t1 6= t2 and define
‚Ä¢ ‚àÜIi+1 = ‚àÜIi ‚à™ {t1 , t2 },
‚Ä¢ for all A ‚àà NC ,
‚Äì if A ‚àà œÑ , then AIi+1 = AIi ‚à™ {t1 , t2 },
‚Äì if A 6‚àà œÑ , then AIi+1 = AIi ;
‚Ä¢ for all S ‚àà NR ,
‚Äì if S = R, then S Ii+1 = {hs, t1 i, hs, t2 i} ‚à™ S Ii ,
‚Äì if S 6= R, then S Ii+1 = S Ii .
Also set Li+1 = Li ‚à™ {t1 7‚Üí œÑ, t2 7‚Üí œÑ }. This finishes our inductive construction. Now define
the interpretation I as follows:
S
‚Ä¢ ‚àÜI = i‚â•0 ‚àÜIi ,
S
‚Ä¢ for all P ‚àà NC ‚à™ NR , P I = i‚â•0 P Ii .
S
Also set L = i‚â•0 Li . Observe that L is a total mapping from ‚àÜI to Q.
Claim A.6. For all concepts C ‚àà cl(C0 , T ) and all s ‚àà ‚àÜI , if C ‚àà L(s) then s ‚àà C I .
Proof of claim. Let s and C be as stated in the claim. Suppose C ‚àà L(s). Then by the
definition of L, there is some i ‚àà N such that C ‚àà Li (s); let i be the smallest natural number
satisfying C ‚àà Li (s), i.e., Ii is the interpretation that we introduced s. By induction on the
structure of C, we show that s ‚àà C I . Since for all œÑ ‚àà Q, we have ‚ä• 6‚àà œÑ by (P‚ä• ), it follows
that C 6= ‚ä•. Hence, we consider the remaining cases for C.
‚Ä¢ C = >. We have by assumption that s ‚àà ‚àÜI , i.e., s ‚àà >I .
‚Ä¢ C = A, for some A ‚àà NC . Then by the definition of Ii and A ‚àà Li (s), it immediately
follows that s ‚àà AIi . This implies by the definition of I that s ‚àà AI .
‚Ä¢ C = ¬¨A, for some A ‚àà NC . Since Li (s) ‚àà Q, Li (s) satisfies (P¬¨ ). Then by ¬¨A ‚àà Li (s),
we have A 6‚àà Li (s). One can now easily show by induction that for all k ‚â• i, we have
s 6‚àà AIk . This implies by our assumption about i that for all k ‚àà N, s 6‚àà AIk . Then
by the definition of I, we obtain s 6‚àà AI , i.e., s ‚àà (¬¨A)I .
398

Beth Definability in Expressive Description Logics

‚Ä¢ C = C1 u C2 . Follows easily by the inductive hypothesis and (Pu ).
‚Ä¢ C = C1 t C2 . Follows easily by the inductive hypothesis and (Pt ).
‚Ä¢ C = ‚àÄR.D. Let t ‚àà ‚àÜI such that hs, ti ‚àà RI . We need to show that t ‚àà DI . By
hs, ti ‚àà RI , there is some k ‚àà N such that hs, ti ‚àà RIk ; w.l.o.g. assume that Ik is the
interpretation that we introduced t. It follows that there is some E ‚àà cl(C0 , T ) such
E

that hs, Ei is a defect of Ik‚àí1 w.r.t. Lk‚àí1 and Lk (s) =
‚áí Lk (t). This implies D ‚àà Lk (t).
Then by the definition of L, we obtain D ‚àà L(t). By the inductive hypothesis, this
implies t ‚àà DI . Hence, s ‚àà (‚àÄR.D)I .
‚Ä¢ C = ‚àÉR.D. By our assumption about i, we have that hs, Ci is a defect of Ii w.r.t. Li .
By the definition of , there are finitely many pairs ht, Ei with t ‚àà N and E ‚àà cl(C0 , T )
such that ht, f (E)i  hs, f (C)i. This implies that there is some k > i such that we
‚Äòfix‚Äô the defect hs, Ci at step k. Then there is some t ‚àà ‚àÜIk such that hs, ti ‚àà RIk and
D ‚àà Lk (t). By the definition of I, we then have hs, ti ‚àà RI and D ‚àà L(t). By the
inductive hypothesis, the latter implies t ‚àà DI . Hence, s ‚àà (‚àÉR.D)I .
‚Ä¢ C =‚â§ 1R. Suppose for a contradiction that there are t1 , t2 ‚àà ‚àÜI such that t1 6= t2
and hs, t1 i, hs, t2 i ‚àà RI . Then there are k1 , k2 ‚àà N such that hs, ti i ‚àà RIki and Iki
is the interpretation that we introduced ti , for each i ‚àà {1, 2}. By our construction,
this implies that there are concepts C1 , C2 ‚àà cl(C0 , T ) such that hs, Ci i is a defect
C

i
of Iki ‚àí1 w.r.t. Lki ‚àí1 and Lki (s) =‚áí
Lki (ti ), for each i ‚àà {1, 2}. It follows that
Ci 6=‚â• 2R, for each i ‚àà {1, 2}; otherwise, we would obtain a contradiction by (P./ ).
Thus, C1 = ‚àÉR.D1 and C2 = ‚àÉR.D2 . Then by the definition of cl(C0 , T ), we have
‚àÄR.D1 , ‚àÄR.D2 ‚àà cl(C0 , T ); and by (P‚â§1 ), this implies ‚àÄR.D1 , ‚àÄR.D2 ‚àà Lk1 (s) =
Lk2 (s). Suppose w.l.o.g. that k1 < k2 . Then D2 ‚àà Lk1 (t1 ). But this contradicts with
the fact that hs, ‚àÉR.D2 i is a defect of Ik2 ‚àí1 w.r.t Lk2 ‚àí1 .

‚Ä¢ C =‚â• 2R. This case can be shown similarly to the case C = ‚àÉR.D.
Since we considered all the possible cases, we conclude that the claim holds.

a

Using Claim A.6, this direction of the Theorem can now be shown easily as follows. By
the base case of our inductive construction, there is some s ‚àà ‚àÜI0 such that C0 ‚àà L0 (s).
This implies C0 ‚àà L(s) and then by Claim A.6, we obtain s ‚àà C0I . Moreover, by Claim A.6
and (Pv ), we have I |= T . Hence C0 is satisfiable w.r.t. T .

Appendix B. Useful Lemmas for Tableau Correctness and Interpolation
For all Œ¶ ‚äÜ cll ‚à™ clr, we define
Œ¶(l) = {C | C l ‚àà Œ¶ ‚à© cll} and Œ¶(r) = {C | C r ‚àà Œ¶ ‚à© clr}.
Œ¶(Œª) is a shorthand for Œ¶(l) ‚à™ Œ¶(r). In the following
S the signature of a set of ALCFconcepts S will be of concern. We define sig(S) = C‚ààS sig(C). Let œÑ be a finite set of
ALCF-concepts
and T be an ALCF-TBox. We say that œÑ is satisfiable w.r.t. T if and only
d
if D‚ààœÑ D is satisfiable w.r.t. T . Moreover a Œ¶ ‚äÜ cll ‚à™ clr is satisfiable w.r.t. T if and only
if Œ¶(Œª) is satisfiable w.r.t. T .
399

Ten Cate, Franconi, & Seylan

Lemma B.1. Let Œ¶ ‚äÜ cll ‚à™ clr be satisfiable w.r.t. T . We have
‚Ä¢ if œá is an ?-burden of Œ¶ for ? ‚àà {u, ‚â§ 1, ‚àÉ, ‚â• 2} and Œ® is the œá-relief of Œ¶, then Œ® is
satisfiable w.r.t. T ;
‚Ä¢ if œá is an t-burden of Œ¶, then there is some œá-relief Œ® of Œ¶ such that Œ® is satisfiable
w.r.t. T .
Proof. Suppose that Œ¶ is as stated in the Theorem, i.e., it is satisfiable w.r.t. T . This
means Œ¶(Œª) is satisfiable w.r.t. T . By Theorem
A.4 we then have that there is some
d
hC, T i-quasimodel Q for ALCF, where C = D‚ààŒ¶(Œª) D. This means there is some œÑ ‚àà Q
such that Œ¶(Œª) ‚äÜ œÑ . We will also use the term hœÑ, T i-quasimodel for Q.
Assume that (C1 u C2 )Œª is an u-burden of Œ¶. Then the (C1 u C2 )Œª -relief of Œ¶ is Œ® =
Œ¶ ‚à™ {(C1 )Œª , (C2 )Œª }. By (Pu ), {C1 , C2 } ‚äÜ œÑ and thus Œ®(Œª) ‚äÜ œÑ . Hence Œ®(Œª) is satisfiable
w.r.t. T .
Assume that (‚â§ 1R)Œª is an ‚â§ 1-burden of Œ¶. Then the (‚â§ 1R)Œª -relief of Œ¶ is Œ® =
Œ¶ ‚à™ {(‚àÄR.C)Œ∫ | (‚àÉR.C)Œ∫ ‚àà Œ¶}. If (‚àÉR.C)Œ∫ ‚àà Œ¶, then ‚àÉR.C ‚àà œÑ and by (P‚â§1 ), ‚àÄR.C ‚àà œÑ .
Hence Œ®(Œª) ‚äÜ œÑ and Œ® is satisfiable w.r.t. T .
Assume that (‚àÉR.C)Œª is an ‚àÉ-burden of Œ¶. Œ¶(Œª) ‚äÜ œÑ so by condition (b) of Definition A.3, there is some œÖ ‚àà Q such that œÖ ‚äá {C} ‚à™ {D | ‚àÄR.D ‚àà Œ¶(Œª)}; and by (Pv ),
{E | > v E ‚àà T } ‚äÜ œÖ. Let Œ® be the (‚àÉR.C)Œª -relief of Œ¶. Then we have Œ®(Œª) ‚äÜ œÖ. Hence
Œ® is satisfiable w.r.t. T .
Assume that (‚â• 2R)Œª is an ‚â• 2-burden of Œ¶. Œ¶(Œª) ‚äÜ œÑ so by condition (b) of Definition A.3, there is some œÖ ‚àà Q such that œÖ ‚äá {D | ‚àÄR.D ‚àà Œ¶(Œª)}; and by (Pv ),
{E | > v E ‚àà T } ‚äÜ œÖ. Let Œ® be the ‚â• 2R-relief of Œ¶. Then we have Œ®(Œª) ‚äÜ œÖ.
Hence Œ® is satisfiable w.r.t. T .
Assume that (C1 t C2 )Œª is an t-burden Œ¶. Then for some (C1 t C2 )Œª -relief Œ® of Œ¶, we
have Œ®(Œª) ‚äÜ œÑ by (Pt ). Hence, there is some (C1 t C2 )Œª -relief of Œ¶ that is satisfiable w.r.t.
T.
Proposition B.2. Let T be an ALCF-TBox and C0 , C1 , . . . , Cn , D be ALCF-concepts.
1. If T |= C0 u C1 u . . . u Cn v D, then
T |= ‚àÉR.C0 u ‚àÄR.C1 u . . . u ‚àÄR.Cn v ‚àÉR.D.
2. If T |= D v C1 t . . . t Cn , then
T |= ‚àÉR.D v ‚àÉR.C1 t . . . t ‚àÉR.Cn .
3. If T |= C1 u . . . u Cn v D, then
T |=‚â• 2R u ‚àÄR.C1 u . . . u ‚àÄR.Cn v ‚àÉR.D.
Proof. For 1, we proceed towards a contradiction. Suppose T |= C0 u C1 u . . . u Cn v D
and T 6|= ‚àÉR.C0 u ‚àÄR.C1 u . . . u ‚àÄR.Cn v ‚àÉR.D. Then there is some model I of T such that
I |= C0 u C1 u . . . u Cn v D and I 6|= ‚àÉR.C0 u ‚àÄR.C1 u . . . u ‚àÄR.Cn v ‚àÉR.D. By the latter
400

Beth Definability in Expressive Description Logics

there is some s ‚àà ‚àÜI such that s ‚àà (‚àÉR.C0 u ‚àÄR.C1 u . . . u ‚àÄR.Cn )I and s 6‚àà (‚àÉR.D)I . That
is, there is some t ‚àà ‚àÜI such that hs, ti ‚àà RI , t ‚àà (C0 u C1 u . . . u Cn )I , and t ‚àà (¬¨D)I .
But this contradicts with I |= C0 u C1 u . . . u Cn v D.
For 2, we proceed towards a contradiction. Suppose T |= D v C1 t . . . t Cn and
T 6|= ‚àÉR.D v ‚àÉR.C1 t . . . t ‚àÉR.Cn . Then there is some model I of T such that I |= D v
C1 t . . . t Cn and I 6|= ‚àÉR.D v ‚àÉR.C1 t . . . t ‚àÉR.Cn . By the latter there is some s ‚àà ‚àÜI
such that s ‚àà (‚àÉR.D)I and s 6‚àà (‚àÉR.C1 t . . . t ‚àÉR.Cn )I . That is there is some t ‚àà ‚àÜI
such that hs, ti ‚àà RI , t ‚àà DI , and t ‚àà (¬¨C1 u . . . u ¬¨Cn )I . But this contradicts with
I |= D v C1 t . . . t Cn .
Proposition B.3. Let C be an ALCF-concept and R be a role name. Then
|=‚â§ 1R u ‚àÉR.C u ‚àÄR.C ‚â°‚â§ 1R u ‚àÉR.C.
Proof. That |=‚â§ 1R u ‚àÉR.C u ‚àÄR.C v‚â§ 1R u ‚àÉR.C is trivial. For the other direction,
suppose for a contradiction that 6|=‚â§ 1R u ‚àÉR.C v‚â§ 1R u ‚àÉR.C u ‚àÄR.C. This means there
is some interpretation I = h‚àÜI , ¬∑I i such that I 6|=‚â§ 1R u ‚àÉR.C v‚â§ 1R u ‚àÉR.C u ‚àÄR.C.
Thus there is some s ‚àà ‚àÜI such that s ‚àà (‚â§ 1R)I , s ‚àà (‚àÉR.C)I , and s ‚àà (‚àÉR.¬¨C)I . By
the last two there are t1 , t2 ‚àà ‚àÜI such that hs, t1 i, hs, t2 i ‚àà RI , t1 ‚àà C I , and t2 ‚àà (¬¨C)I .
But by s ‚àà (‚â§ 1R)I , t1 = t2 which is a contradiction.
Lemma B.4. Let Œ¶ ‚äÜ cll ‚à™ clr. We have
1. if ‚ä•l ‚àà Œ¶, then ‚ä• is an interpolant of Œ¶;
2. if ‚ä•r ‚àà Œ¶, then > is an interpolant of Œ¶;
3. for a concept C of the form A or ‚â§ 1R,
(a) if {C l , (¬¨C)
Àô l } ‚äÜ Œ¶, then ‚ä• is an interpolant of Œ¶;
(b) if {C r , (¬¨C)
Àô r } ‚äÜ Œ¶, then > is an interpolant of Œ¶;
(c) if {C l , (¬¨C)
Àô r } ‚äÜ Œ¶, then C is an interpolant of Œ¶;
(d) if {C r , (¬¨C)
Àô l } ‚äÜ Œ¶, then ¬¨C
Àô is an interpolant of Œ¶;
4. if Œ® is the (C1 u C2 )Œª -relief of Œ¶ and I is an interpolant of Œ®, then I is an interpolant
of Œ¶;
5. if Œ®1 and Œ®2 are (C1 t C2 )l -reliefs of Œ¶, and I1 , I2 are interpolants of Œ®1 , Œ®2 respectively, then I1 t I2 is an interpolant of Œ¶;
6. if Œ®1 and Œ®2 are (C1 t C2 )r -reliefs of Œ¶, and I1 , I2 are interpolants of Œ®1 , Œ®2 respectively, then I1 u I2 is an interpolant of Œ¶;
7. if Œ® is the (‚â§ 1R)l -relief of Œ¶, there is no biased concept of the form (‚àÉR.C)r ‚àà Œ¶,
and I is an interpolant of Œ®, then I is an interpolant of Œ¶;
8. if Œ® is the (‚â§ 1R)r -relief of Œ¶, there is no biased concept of the form (‚àÉR.C)l ‚àà Œ¶,
and I is an interpolant of Œ®, then I is an interpolant of Œ¶;
401

Ten Cate, Franconi, & Seylan

9. if Œ® is the (‚â§ 1R)l -relief of Œ¶, there is some biased concept of the form (‚àÉR.C)r ‚àà Œ¶,
and I is an interpolant of Œ®, then Iu ‚â§ 1R is an interpolant of Œ¶;
10. if Œ® is the (‚â§ 1R)r -relief of Œ¶, there is some biased concept of the form (‚àÉR.C)l ‚àà Œ¶,
and I is an interpolant of Œ®, then It ‚â• 2R is an interpolant of Œ¶;
11. if Œ® is the (‚àÉR.C)l -relief of Œ¶, I is an interpolant of Œ®, and there is no biased concept
of the form (‚àÄR.D)r ‚àà Œ¶, then ‚ä• is an interpolant of Œ¶;
12. if Œ® is the (‚àÉR.C)r -relief of Œ¶, I is an interpolant of Œ®, and there is no biased concept
of the form (‚àÄR.D)l ‚àà Œ¶, then > is an interpolant of Œ¶;
13. if Œ® is the (‚àÉR.C)l -relief of Œ¶, I is an interpolant of Œ®, and there is some biased
concept of the form (‚àÄR.D)r ‚àà Œ¶, then ‚àÉR.I is an interpolant of Œ¶;
14. if Œ® is the (‚àÉR.C)r -relief of Œ¶, I is an interpolant of Œ®, and there is some biased
concept of the form (‚àÄR.D)l ‚àà Œ¶, then ‚àÄR.I is an interpolant of Œ¶;
15. if Œ® is the (‚â• 2R)l -relief of Œ¶, I is an interpolant of Œ®, and there is no biased concept
of the form (‚àÄR.D)r ‚àà Œ¶, then ‚ä• is an interpolant of Œ¶;
16. if Œ® is the (‚â• 2R)r -relief of Œ¶, I is an interpolant of Œ®, and there is no biased concept
of the form (‚àÄR.D)l ‚àà Œ¶, then > is an interpolant of Œ¶;
17. if Œ® is the (‚â• 2R)l -relief of Œ¶, I is an interpolant of Œ®, and there is some biased
concept of the form (‚àÄR.D)r ‚àà Œ¶, then ‚àÉR.I is an interpolant of Œ¶;
18. if Œ® is the (‚â• 2R)r -relief of Œ¶, I is an interpolant of Œ®, and there is some biased
concept of the form (‚àÄR.D)l ‚àà Œ¶, then ‚àÄR.I is an interpolant of Œ¶.
Proof. For 1. Suppose Œ¶(l) = {X1 , . . . , Xn } ‚à™ {‚ä•} and Œ¶(r) = {Y1 , . . . , Ym }. But T |=
‚ä• u X1 u . . . , Xn v ‚ä• and T |= ‚ä• v ¬¨Y1 t . . . t ¬¨Ym hold trivially. Since ‚ä• is a logical
constant, ‚àÖ = sig(‚ä•) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)). Hence 1 is satisfied.
For 2. Suppose Œ¶(r) = {Y1 , . . . , Ym } ‚à™ {‚ä•} and Œ¶(l) = {X1 , . . . , Xn }. But T |=
X1 u . . . , Xn v > and T |= > v ¬¨Y1 t . . . t ¬¨Ym t > hold trivially. Since > is a logical
constant, ‚àÖ = sig(>) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)). Hence 2 is satisfied.
For 3a. Suppose Œ¶(l) = {X1 , . . . , Xn } ‚à™ {C, ¬¨C}
Àô
and Œ¶(r) = {Y1 , . . . , Ym }. But T |=
X1 u . . . , Xn u C u ¬¨C
Àô v ‚ä• and T |= ‚ä• v ¬¨Y1 t . . . t ¬¨Ym hold trivially. Since ‚ä• is a logical
constant, ‚àÖ = sig(‚ä•) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)). Hence 3a is satisfied.
The argument for 3b is analogous to the previous case.
For 3c. Suppose Œ¶(l) = {X1 , . . . , Xn } ‚à™ {C} and Œ¶(r) = {Y1 , . . . , Ym } ‚à™ {¬¨C}.
Àô
But T |=
X1 u . . . u Xn u C v C, T |= C v ¬¨Y1 t . . . t ¬¨Ym t ¬¨(¬¨C),
Àô
and sig(C) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r))
hold trivially. Hence 3c is satisfied.
The argument for 3d is analogous to the previous case.
For 4. Suppose Œ® is a (C1 uC2 )l -relief of Œ¶, I is an interpolant of Œ®, Œ¶(l) = {X1 , . . . , Xn }‚à™
{C1 uC2 }, and Œ¶(r) = {Y1 , . . . , Ym }. By assumption, T |= X1 u. . .uXn u(C1 uC2 )uC1 uC2 v
I, i.e., T |= X1 u. . .uXn u(C1 uC2 ) v I and T |= I v ¬¨Y1 t. . .t¬¨Ym . By assumption again,
sig(Œ®(l)) = sig(Œ¶(l)) and sig(Œ®(r)) = sig(Œ¶(r)), and thus sig(I) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)).
402

Beth Definability in Expressive Description Logics

Therefore I is an interpolant of Œ¶. The case for when Œ® is a (C1 u C2 )r -relief of Œ¶ and I is
an interpolant of Œ® can be shown analogously. Hence 4 is satisfied.
For 5. Suppose Œ®1 and Œ®2 are (C1 t C2 )l -reliefs of Œ¶, I1 , I2 are interpolants of Œ®1 , Œ®2
respectively, Œ¶(l) = {X1 , . . . , Xn } ‚à™ {C1 t C2 }, and Œ¶(r) = {Y1 , . . . , Ym }. By assumption,
T |= X1 u . . . u Xn u (C1 t C2 ) u C1 v I1 and T |= X1 u . . . u Xn u (C1 t C2 ) u C2 v I2 .
Then we have the following.
T |= I1 t I2 w (X1 u . . . u Xn u (C1 t C2 ) u C1 ) t
(X1 u . . . u Xn u (C1 t C2 ) u C2 )
T |= I1 t I2 w (X1 u . . . u Xn u (C1 t C2 )) u (C1 t C2 )
T |= I1 t I2 w X1 u . . . u Xn u (C1 t C2 )
For the other half, by assumption T |= I1 v ¬¨Y1 t . . . t ¬¨Ym and T |= I2 v ¬¨Y1 t . . . t ¬¨Ym .
But then T |= I1 t I2 v ¬¨Y1 t . . . t ¬¨Ym . Clearly, sig(I1 t I2 ) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)). Hence
5 is satisfied.
The argument for 6 is analogous to the previous case.
For 7. Suppose
‚Ä¢ Œ® is a (‚â§ 1R)l -relief of Œ¶,
‚Ä¢ I is an interpolant of Œ®,
‚Ä¢ Œ¶(l) = {X1 , . . . , Xn } ‚à™ {‚â§ 1R} ‚à™ {‚àÉR.C1 , . . . , ‚àÉR.Ck }, where {‚àÉR.C1 , . . . , ‚àÉR.Ck } =
{‚àÉR.C ‚àà Œ¶(l)},
‚Ä¢ Œ¶(r) = {Y1 , . . . , Ym },
‚Ä¢ there is no biased concept of the form (‚àÉR.C)r ‚àà Œ¶.
Let E = ‚àÄR.C1 u . . . u ‚àÄR.Ck . By assumption,
T |= X1 u . . . u Xn u ‚â§ 1R u ‚àÉR.C1 u . . . u ‚àÉR.Ck u E v I.
Then by Proposition B.3
T |= X1 u . . . u Xn u ‚â§ 1R u ‚àÉR.C1 u . . . u ‚àÉR.Ck v I
which is what we wanted to show. For the other half, since there is no biased concept of
the form (‚àÉR.C)r ‚àà Œ¶, we have Œ¶(r) = Œ®(r). But then
T |= I v ¬¨Y1 t . . . t ¬¨Ym
which is what we wanted to show. By assumption sig(Œ®(l)) = sig(Œ¶(l)) and sig(Œ®(r)) =
sig(Œ¶(r)), and thus sig(I) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)). Therefore I is an interpolant of Œ¶. Hence
7 is satisfied.
8 can be shown analogously to the previous case.
For 9. Suppose
‚Ä¢ Œ® is a (‚â§ 1R)l -relief of Œ¶,
403

Ten Cate, Franconi, & Seylan

‚Ä¢ I is an interpolant of Œ®,
‚Ä¢ Œ¶(l) = {X1 , . . . , Xn } ‚à™ {‚â§ 1R} ‚à™ {‚àÉR.C1 , . . . , ‚àÉR.Ck }, where {‚àÉR.C1 , . . . , ‚àÉR.Ck } =
{‚àÉR.C ‚àà Œ¶(l)},
‚Ä¢ Œ¶(r) = {Y1 , . . . , Ym } ‚à™ {‚àÉR.D1 , . . . , ‚àÉR.Dl }, where {‚àÉR.D1 , . . . , ‚àÉR.Dl } = {‚àÉR.C ‚àà
Œ¶(r)},
‚Ä¢ there is some biased concept of the form (‚àÉR.C)r ‚àà Œ¶.
Let E = ‚àÄR.C1 u . . . u ‚àÄR.Ck . By assumption,
T |= X1 u . . . u Xn u ‚â§ 1R u ‚àÉR.C1 u . . . u ‚àÉR.Ck u E v I.
Also, we trivially have the following.
T |= X1 u . . . u Xn u ‚â§ 1R u ‚àÉR.C1 u . . . u ‚àÉR.Ck u E v‚â§ 1R.
Combining these two, we get
T |= X1 u . . . u Xn u ‚â§ 1R u ‚àÉR.C1 u . . . u ‚àÉR.Ck u E v Iu ‚â§ 1R

which is what we wanted to show.
For the other half, let F = ‚àÉR.¬¨C1 t . . . t ‚àÉR.¬¨Cl . By the assumption about I,
T |= I v ¬¨Y1 t . . . t ¬¨Ym t ‚àÄR.¬¨C1 t . . . t ‚àÄR.¬¨Cl t F.
From this, we trivially get
T |= I v ¬¨Y1 t . . . t ¬¨Ym t ‚àÄR.¬¨C1 t . . . t ‚àÄR.¬¨Cl t F t ‚â• 2R.

Then by Proposition B.3,
T |= I v ¬¨Y1 t . . . t ¬¨Ym t ‚àÄR.¬¨C1 t . . . t ‚àÄR.¬¨Cl t ‚â• 2R,
which implies
T |= Iu ‚â§ 1R v ¬¨Y1 t . . . t ¬¨Ym t ‚àÄR.¬¨C1 t . . . t ‚àÄR.¬¨Cl ,
and this is what we wanted to show. By assumption sig(Œ®(l)) = sig(Œ¶(l)) and sig(Œ®(r)) =
sig(Œ¶(r)), and thus sig(I) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)). Moreover, since there is some biased
concept of the form (‚àÉR.C)r ‚àà Œ¶, R ‚àà sig(Œ¶(l)) ‚à© sig(Œ¶(r)). In conclusion, sig(Iu ‚â§ 1R) ‚àà
sig(Œ¶(l)) ‚à© sig(Œ¶(r)). Hence 9 is satisfied.
10 can be shown analogously to the previous case.
For 11. Suppose the following:
‚Ä¢ Œ® is the (‚àÉR.C)l -relief of Œ¶,
‚Ä¢ I is an interpolant of Œ®,
d
F
‚Ä¢ E = >vC‚ààTl C, F = >vC‚ààTr ¬¨C,
404

Beth Definability in Expressive Description Logics

‚Ä¢ Œ¶(l) = {X1 , . . . , Xn } ‚à™ {‚àÉR.C} ‚à™ {‚àÄR.D1 , . . . , ‚àÄR.Dk }, where {‚àÄR.D1 , . . . , ‚àÄR.Dk } =
{‚àÄR.D ‚àà Œ¶(l)},
‚Ä¢ there is no biased concept of the form (‚àÄR.D)r ‚àà Œ¶.
By the last assumption, Œ®(r) = {C | > v C ‚àà Tr }. By assumption, T |= I v F . Since
T |= F v ‚ä•, we have that T |= I ‚â° ‚ä• and thus T |= ‚àÉR.I ‚â° ‚ä•. By assumption again
T |= C u D1 u . . . u Dk u E v I. Since T |= > v E, we have that T |= C u D1 u . . . u Dk v I.
By Proposition B.2
T |= ‚àÉR.C u ‚àÄR.D1 u . . . u ‚àÄR.Dk v ‚àÉR.I.
However by T |= ‚àÉR.I ‚â° ‚ä• this means
T |= ‚àÉR.C u ‚àÄR.D1 u . . . u ‚àÄR.Dk v ‚ä•.
Hence,
T |= X1 u . . . u Xn u ‚àÉR.C u ‚àÄR.D1 u . . . u ‚àÄR.Dk v ‚ä•
which is what we wanted to show. For the other half, let Œ¶(r) = {Y1 , . . . , Ym }. Since
T |= I ‚â° ‚ä•, we have trivially
T |= ‚ä• v ¬¨Y1 t . . . t ¬¨Ym
As the final step, we need to show that
sig(‚ä•) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)).
But this follows easily since ‚ä• is a logical constant. Hence 11 is satisfied.
For 12. Suppose the following:
‚Ä¢ Œ® is the (‚àÉR.C)r -relief of Œ¶,
‚Ä¢ I is an interpolant of Œ®,
d
F
‚Ä¢ E = >vC‚ààTl C, F = >vC‚ààTr ¬¨C,
‚Ä¢ Œ¶(r) = {Y1 , . . . , Ym } ‚à™ {‚àÉR.C} ‚à™ {‚àÄR.D1 , . . . , ‚àÄR.Dk }, where {‚àÄR.D1 , . . . , ‚àÄR.Dk } =
{‚àÄR.D ‚àà Œ¶(r)},
‚Ä¢ there is no biased concept of the form (‚àÄR.D)l ‚àà Œ¶.
By the last assumption, Œ®(l) = {C | > v C ‚àà Tl }. By assumption, T |= E v I. Since
T |= > v E, we have that T |= I ‚â° > and thus T |= ‚àÄR.I ‚â° >. By assumption again T |=
I v ¬¨Ct¬¨D1 t. . .t¬¨Dk tF . Since T |= F v ‚ä•, we have that T |= I v ¬¨Ct¬¨D1 t. . .t¬¨Dk .
By Proposition B.2
T |= ‚àÄR.I v ‚àÄR.¬¨C t ‚àÉR.¬¨D1 t . . . t ‚àÉR.¬¨Dk .
However by T |= > ‚â° ‚àÄR.I, this means
T |= > v ‚àÄR.¬¨C t ‚àÉR.¬¨D1 t . . . t ‚àÉR.¬¨Dk .
405

Ten Cate, Franconi, & Seylan

Hence,
T |= > v ¬¨Y1 t . . . t ¬¨Ym t ‚àÄR.¬¨C t ‚àÉR.¬¨D1 t . . . t ‚àÉR.¬¨Dk
which is what we wanted to show. For the other half, let Œ¶(l) = {X1 , . . . , Xn }. Since
T |= I ‚â° >, we have trivially
T |= X1 u . . . u Xn v >
As the final step, we need to show that
sig(>) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)).
But this follows easily since > is a logical constant. Hence 12 is satisfied.
For 13. Suppose the following:
‚Ä¢ Œ® is the (‚àÉR.C)l -relief of Œ¶,
‚Ä¢ I is an interpolant of Œ®,
d
F
‚Ä¢ E = >vC‚ààTl C, F = >vC‚ààTr ¬¨C,
‚Ä¢ Œ¶(l) = {X1 , . . . , Xn } ‚à™ {‚àÉR.C} ‚à™ {‚àÄR.D1 , . . . , ‚àÄR.Dk }, where {‚àÄR.D1 , . . . , ‚àÄR.Dk } =
{‚àÄR.D ‚àà Œ¶(l)},
‚Ä¢ Œ¶(r) = {Y1 , . . . , Ym } ‚à™ {‚àÄR.C1 , . . . , ‚àÄR.Cl }, where l ‚â• 1 and {‚àÄR.C1 , . . . , ‚àÄR.Cl } =
{‚àÄR.C ‚àà Œ¶(r)}.
By assumption, T |= C u D1 u . . . u Dk u E v I. Since T |= > v E, we have that
T |= C u D1 u . . . u Dk v I. By Proposition B.2
T |= ‚àÉR.C u ‚àÄR.D1 u . . . u ‚àÄR.Dk v ‚àÉR.I

(5)

Now by (5), we have
T |= X1 u . . . u Xn u ‚àÉR.C u ‚àÄR.D1 u . . . u ‚àÄR.Dk v ‚àÉR.I
which is what we wanted to show. Now we argue for the other half. By assumption,
T |= I v ¬¨C1 t . . . t ¬¨Cl t F . Since T |= F v ‚ä•, we have that T |= I v ¬¨C1 t . . . t ¬¨Cl .
By Proposition B.2
T |= ‚àÉR.I v ¬¨‚àÄR.C1 t . . . t ¬¨‚àÄR.Cl
(6)
Now by (6), we have
T |= ‚àÉR.I v ¬¨Y1 t . . . t ¬¨Ym t ¬¨‚àÄR.C1 t . . . t ¬¨‚àÄR.Cl
which is what we wanted to show. As the final step, we need to show that
sig(‚àÉR.I) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)).
But this follows easily since by assumption sig(I) ‚äÜ sig(Œ¶(l)) ‚à© sig(Œ¶(r)) and R ‚àà sig(Œ¶(l)) ‚à©
sig(Œ¶(r)), where the latter is a consequence of l ‚â• 1.
The argument for 14 is analogous to the previous case. Moreover 15, 16, 17, 18 can be
shown similarly to 11, 12, 13, 14, respectively.
406

Beth Definability in Expressive Description Logics

Appendix C. Tableau Correctness, Termination, and Interpolation
Lemma C.1. Let T = hV, Ei be the output of the second phase. Then for every node g ‚àà V:
1. g.status is either sat or unsat.
2. If g.status = unsat, then either one of the following holds.
‚Ä¢ g is a sink node3 containing a clash;
‚Ä¢ there is exactly one successor of g 0 of g such that for some (C1 uC2 )Œª ‚àà g.content,
g 0 .content is a (C1 u C2 )Œª -relief of g.content and g 0 .status = unsat;
‚Ä¢ there is exactly one successor of g 0 of g such that for some (‚â§ 1R)Œª ‚àà g.content,
g 0 .content is a (‚â§ 1R)Œª -relief of g.content and g 0 .status = unsat;
‚Ä¢ there are exactly n successors g1 , . . . , gn of g, where n is the cardinality of the
set {(C1 )Œª1 , . . . , (Cn )Œªn } of all ‚àÉ- or ‚â• 2-burdens of g.content, gi .content is the
(Ci )Œªi -relief of g.content for i ‚àà {1, . . . , n}, and there is some i ‚àà {1, . . . , n} such
that gi .status = unsat; or
‚Ä¢ there are exactly two successors g1 , g2 of g such that for some (C1 t C2 )Œª ‚àà
g.content, gi .content is a (C1 tC2 )Œª -relief of g.content for i ‚àà {1, 2}, g1 .content 6=
g2 .content, and gi .status = unsat for i ‚àà {1, 2}.
3. If g.status = sat, then either one of the following holds.
‚Ä¢ g is a sink node not containing a clash,
‚Ä¢ there is exactly one successor of g 0 of g such that for some (C1 uC2 )Œª ‚àà g.content,
g 0 .content is a (C1 u C2 )Œª -relief of g.content and g 0 .status = sat;
‚Ä¢ there is exactly one successor of g 0 of g such that for some (‚â§ 1R)Œª ‚àà g.content,
g 0 .content is a (‚â§ 1R)Œª -relief of g.content and g 0 .status = sat;
‚Ä¢ there are exactly n successors g1 , . . . , gn of g, where n is the cardinality of the
set {(C1 )Œª1 , . . . , (Cn )Œªn } of all ‚àÉ- or ‚â• 2-burdens of g.content, gi .content is the
(Ci )Œªi -relief of g.content for i ‚àà {1, . . . , n}, and for all i ‚àà {1, . . . , n} we have
gi .status = sat; or
‚Ä¢ there are exactly two successors g1 , g2 of g such that for some (C1 t C2 )Œª ‚àà
g.content, gi .content is a (C1 tC2 )Œª -relief of g.content for i ‚àà {1, 2}, g1 .content 6=
g2 .content, and there is some i ‚àà {1, 2} such that gi .status = sat.
Proof. 1 clearly follows from the fact that every node that is not assigned the status unsat
during the Propagate step of Algorithm 1 gets the status sat at the end (Assign) of Algorithm 1.
Let g ‚àà V. By the definition of the tableau algorithm, g satisfies exactly one of the
following structural conditions:
‚Ä¢ g is a sink node;
3. a node with no outgoing edges

407

Ten Cate, Franconi, & Seylan

‚Ä¢ there are exactly two successors g1 , g2 of g such that for some (C1 t C2 )Œª ‚àà g.content,
gi .content is a (C1 t C2 )Œª -relief of g.content for i ‚àà {1, 2};
‚Ä¢ there is exactly one successor of g 0 of g such that for some (C1 u C2 )Œª ‚àà g.content,
g 0 .content is a (C1 u C2 )Œª -relief of g.content;
‚Ä¢ there is exactly one successor of g 0 of g such that for some (‚â§ 1R)Œª ‚àà g.content,
g 0 .content is a (‚â§ 1R)Œª -relief of g.content;
‚Ä¢ there are exactly n successors g1 , . . . , gn of g, where n is the cardinality of the set
{(C1 )Œª1 , . . . , (Cn )Œªn } of all ‚àÉ- or ‚â• 2-burdens of g.content, and gi .content is the (Ci )Œªn relief of g.content for i ‚àà {1, . . . , n}.
Suppose first g.status = unsat then g clearly respects 2 because these are the only ways
for a node to get status unsat in Propagate. Suppose now g.status = sat. Then g.status is
determined in Assign of Algorithm 1. We distinguish between the structural properties of
g above.
Suppose g is a sink node. This means that no rule is applied to g. Then by g.status =
sat, we immediately obtain that g.status does not contain a clash; because if g.status
contains a clash, we would have g.status = unsat and this contradicts with the fact that
for every node g ‚àà V, the value of g.status is only calculated once.
Suppose there are exactly two successors g1 , g2 of g such that for some (C1 t C2 )Œª ‚àà
g.content, gi .content is a (C1 t C2 )Œª -relief of g.content for i ‚àà {1, 2}. Since g.status = sat,
g.status was undefined right before Assign. This implies that there is some i ‚àà {1, 2}
such that gi .status was undefined because otherwise g.status = unsat. Then after Assign,
gi .status = sat. Hence, g satisfies 3.
Suppose there is exactly one successor of g 0 of g such that for some (C1 u C2 )Œª ‚àà
g.content, g 0 .content is a (C1 u C2 )Œª -relief of g.content. Since g.status = sat, g.status was
undefined right before Assign. This implies that, g 0 .status was undefined before Assign
because otherwise g.status = unsat. Then after Assign, g 0 .status = sat. Hence, g satisfies
3.
The remaining cases can be shown analogously. Hence the lemma follows.
Proof of Lemma 3.7. We start with some observations. Algorithm 1 assigns the status
unsat to nodes in V during the Propagate phase. These status assignment steps induce a
sequence 0, 1, 2. . . .. To each assignment step i, we can associate a set Vi such that Vi are
all the nodes with status unsat so far. Observe that from step i to step i + 1, we extend
Vi by a single node only. By induction on the number of status assignment steps, we first
show that for all g ‚àà Vi ,
‚Ä¢ g.content is unsatisfiable w.r.t. T ;
‚Ä¢ there is some ALCF-concept C such that
‚Äì int(g) = C,
‚Äì C is an interpolant of g.content,
‚Äì |int(g)| ‚â§ 2i+2 ‚àí 1.
408

Beth Definability in Expressive Description Logics

As the base case, we have that V0 = {g} for some sink node g ‚àà V containing a clash.
Obviously, g.content is unsatisfiable. The interpolant calculation rules of Figure 2 cover all
the cases for this clash and thus, some ALCF-concept is assigned to int(g). By Lemma B.4,
int(g) is an interpolant of g.content. We claim that |int(g)| ‚â§ 2. For int(g) of the form >,
‚ä•, A, or ¬¨A, this is clear; and for int(g) of the form ‚â§ 1R (or ‚â• 2R), we observe that
it can be encoded using one symbol for ‚â§ 1 (resp. ‚â• 2) and one symbol for R. Hence,
|int(g)| ‚â§ 2 ‚â§ 2i+2 ‚àí 1 and the inductive hypothesis holds for the base case.
For the inductive step, let Vi+1 = Vi ‚à™ {g}. The inductive hypothesis holds for every
g 0 ‚àà Vi , trivially; thus, we only consider the case for g. By Lemma C.1, we have five cases
to distinguish:
1. g is a sink node containing a clash. This can be shown analogously to the base case.
2. There is exactly one successor of g 0 of g such that for some (C1 u C2 )Œª ‚àà g.content,
g 0 .content is a (C1 u C2 )Œª -relief of g.content and g 0 .status = unsat. By the inductive
hypothesis, g 0 .content is unsatisfiable w.r.t. T , int(g 0 ) is an interpolant of g 0 , and
|int(g 0 )| ‚â§ 2i+2 ‚àí 1. Then by (the contrapositive version of) Lemma B.1, g.content
is unsatisfiable w.r.t. T . Moreover, Cu was applied to calculate int(g) and int(g) =
int(g 0 ). By Lemma B.4, int(g) is an interpolant of g.content. We have by int(g) =
int(g 0 ) and |int(g 0 )| ‚â§ 2i+2 ‚àí 1 that |int(g)| ‚â§ 2i+3 ‚àí 1. Hence the inductive hypothesis
holds for this case.
3. There are exactly two successors g1 , g2 of g such that for some (C1 t C2 )Œª ‚àà g.content,
gj .content is a (C1 t C2 )Œª -relief of g.content for j ‚àà {1, 2}, g1 .content 6= g2 .content,
and gj .status = unsat for j ‚àà {1, 2}. By the inductive hypothesis, gj .content is
unsatisfiable w.r.t. T , int(gj ) is an interpolant of gj , and |int(gj )| ‚â§ 2i+2 ‚àí 1, for j ‚àà
{1, 2}. Then by (the contrapositive version of) Lemma B.1, g.content is unsatisfiable
w.r.t. T . Moreover, depending on Œª, either Clt or Crt was applied to calculate int(g).
By Lemma B.4, int(g) is an interpolant of g.content. We have that |int(g)| = |int(g1 )|+
|int(g2 )| + 1. Then by the inductive hypothesis, we obtain
|int(g)| ‚â§ (2i+2 ‚àí 1) + (2i+2 ‚àí 1) + 1 = 2i+3 ‚àí 1.
Thus, the inductive hypothesis holds for this case.
4. The other cases can be shown similarly.
Hence, our claim follows.
Now, we use the claim that we have just shown to prove the lemma. Let g ‚àà V with
g.status = unsat. By Lemma 3.5, we have |V| ‚â§ 2n , where n = |cll ‚à™ clr|. Thus, in the
worst case, there are 2n status assignment steps in Propagate because then V2n = V. Since
g.status = unsat, it follows that g ‚àà V2n . Then by our claim, g.content is unsatisfiable w.r.t.
n
n
T , int(g) is defined and it is an interpolant of g.content, and |int(g)| ‚â§ 22 +2 ‚àí1 = 4¬∑22 ‚àí1.
n
But then int(g) ‚àà O(22 ). Hence the lemma follows.
Proof of Lemma 3.8. Algorithm 1 consists of two stages: Propagate and Assign.
In Assign, we make 2n assignments because by Lemma 3.5 the number of nodes in the
tableau is bounded by that number. Moreover, each assignment step takes a constant time.
So the whole Assign stage takes time O(2n ).
409

Ten Cate, Franconi, & Seylan

In Propagate, we have a for loop inside a do-while loop. The for loop iterates over 2n
nodes and assigns, if possible, the status unsat to a node by checking in the worst case n
direct successors of the node. If the algorithm assigns the status unsat to a node g, then it
n
also assigns a concept to int(g). By Lemma 3.7, |int(g)| ‚â§ O(22 ). Thus it spends most of
its time calculating int(g). Suppose the for loop finished its iteration over all nodes in the
tableau. Now if during its execution, none of the nodes got the status unsat, the do-while
loop terminates because done = true. In the worst case, a status will be assigned only to
one node in each iteration of the do-while loop. Hence the do-while loop iterates at most 2n
n
times and as we discussed each iteration takes time at most O(22 ) because of interpolation
calculation. Since this dominates the runtime of Algorithm 1, the lemma follows.
Lemma C.2 (Soundness). If T is a closed hC0 v D0 , T i-tableau, then T |= C0 v D0 .
Proof. Let T be a closed hC0 v D0 , T i-tableau. Since T is closed, g0 .content = unsat. By
g0 .content = {(C0 )l , (¬¨D
Àô 0 )r } ‚à™ {E l | > v E ‚àà Tl } ‚à™ {E r | > v E ‚àà Tr } and Lemma 3.7,
this implies
G
l
T |= C0 u
E v D0 t
¬¨E
>vE‚ààTl

>vE‚ààTr

But then T |= C0 v D0 .
Definition C.3. Let T = hV, Ei be the output of the second phase. We say that a node
g ‚àà V is saturated if and only if
‚Ä¢ g.status = sat and g is a sink node, or
‚Ä¢ g.status = sat and R‚àÉ was applied to g.
For g, g 0 ‚àà V , g 0 is called a saturation of g if and only if g 0 is saturated, and there is a path
g = g0 , g1 , . . . , gk = g 0 with k ‚â• 0 in T such that for each 0 ‚â§ i < k, we have gi .status = sat
and the edge hgi , gi+1 i was created by an application of a rule in {Ru , Rt , R‚â§1 }.
Lemma C.4. Let T = hV, Ei be a complete tableau for hC0 v D0 , T i. Then we have
1. If g ‚àà V is saturated, then g.content(Œª) is a hC0 u ¬¨D
Àô 0 , T i-type.
2. If g ‚àà V with g.status = sat, then there is some saturation g 0 of g with g 0 .content ‚äá
g.content.
Proof. For 1, suppose that g is saturated. We need to show that g.content(Œª) satisfies
Definition A.2. We start with g.content(Œª) ‚äÜ cl(C0 u ¬¨D
Àô 0 , T ). Let C ‚àà g.content(Œª). Then
it follows that C Œª ‚àà g.content, for some Œª ‚àà {l, r}. Since g.content ‚äÜ cll ‚à™ clr, we have that
C Œª ‚àà cll ‚à™ clr. This implies C ‚àà cl(C0 , Tl ) ‚à™ cl(¬¨D
Àô 0 , Tr ). But then C ‚àà cl(C0 u ¬¨D
Àô 0 , T ),
which is what we wanted to show.
Now we show that the properties in Definition A.2 are satisfied. By definition, g.status =
sat. g does not contain a clash because otherwise g.status = unsat which would contradict
our assumption. Hence, (P‚ä• ), (P¬¨ ), and (P./ ) are satisfied. By definition, g is a sink node
or R‚àÉ was applied to g. In both cases, we have that none of {Ru , Rt , R‚â§1 } is applicable
to g: for the former, this follows from the fact that no rule is applicable to g; and for the
410

Beth Definability in Expressive Description Logics

latter, this follows from our rule precedence. Hence, (Pu ), (Pt ), (P‚â§1 ) are satisfied. Finally,
we have {C | > v C ‚àà T } ‚äÜ g.content(Œª) as an easy consequence of the definition of the
tableau algorithm. This means (Pv ) is satisfied. Hence, we conclude that 1 holds.
For 2, suppose g ‚àà V with g.status = sat. That there is some saturation g 0 of g with
g 0 .content ‚äá g.content follows easily by Lemma C.1.
Lemma C.5 (Completeness). If T is an open hC0 v D0 , T i-tableau, then T 6|= C0 v D0 .
Proof. Suppose T = hV, Ei is an open hC0 v D0 , T i-tableau. Since T is open, we have
g0 .status = sat. Then by Lemma C.4, there is some saturation g? of g0 such that g? .content ‚äá
g0 .content. Since g? is saturated, it follows by Lemma C.4 that g? .content(Œª) is a hC0 u
¬¨D
Àô 0 , T i-type. Let œÑ0 = {C0 u ¬¨D
Àô 0 }‚à™g? .content(Œª). We claim that œÑ0 is also a hC0 u ¬¨D
Àô 0 , T itype. Suppose for a contradiction that it is not. Since g? .content(Œª) is such a type, it follows
that (Pu ) is violated for C0 u ¬¨D
Àô 0 ‚àà œÑ0 , i.e., {C0 , ¬¨D
Àô 0 } 6‚äÜ œÑ0 . Then by the definition of œÑ0 ,
this means {C0 , ¬¨D
Àô 0 } 6‚äÜ g? .content(Œª). But we know that {C0 , ¬¨D
Àô 0 } ‚äÜ g0 .content(Œª) and
by g? .content ‚äá g0 .content, this implies {C0 , ¬¨D
Àô 0 } ‚äÜ g? .content(Œª), i.e., a contradiction.
Hence we conclude that œÑ0 is a hC0 u ¬¨D
Àô 0 , T i-type. Define
Q = {œÑ0 } ‚à™ {g.content(Œª) | g ‚àà V is saturated}.
We show that Q is a hC0 u ¬¨D
Àô 0 , T i-quasimodel because then T 6|= C0 v D0 follows by
Theorem A.4. It is easy to see that Q is a set of hC0 u ¬¨D
Àô 0 , T i-types: we have already
shown that œÑ0 is such a type; and for g.content(Œª) with g ‚àà V is saturated, this fact
follows immediately by Lemma C.4. It remains to show that conditions (a), (b), (c) from
Definition A.3 hold.
Condition (a) holds since œÑ0 ‚àà Q and C0 u ¬¨D
Àô 0 ‚àà œÑ0 .
Suppose that ‚àÉR.C ‚àà œÑ for some œÑ ‚àà Q. We distinguish between œÑ = œÑ0 and œÑ =
g.content(Œª) for some saturated g ‚àà V. We first argue for the latter. Since g is saturated
and ‚àÉR.C ‚àà g.content(Œª), R‚àÉ was applied to g; since g is saturated, we have g.status = sat.
Then by Lemma C.1, there is some successor g 0 of g in T such that {C} ‚à™ {D | ‚àÄR.D ‚àà
œÑ } ‚äÜ g 0 .content(Œª) and g 0 .status = sat. Then by Lemma C.4, there is some saturation g 00 of
g 0 such that g 00 .content ‚äá g 0 .content. Since g 00 is saturated, we have that g 00 .content(Œª) ‚àà Q
‚àÉR.C

and g 00 .content(Œª) is a hC0 u ¬¨D
Àô 0 , T i-type. But then œÑ ===‚áí g 00 .content(Œª). The case for
œÑ = œÑ0 follows analogously by using the fact that there is some successor g 0 of g? in T such
that {C} ‚à™ {D | ‚àÄR.D ‚àà œÑ } ‚äÜ g 0 .content(Œª) and g 0 .status = sat. Hence condition (b) from
Definition A.3 is satisfied.
That condition (c) holds can be shown very similarly to the previous case; we leave it
to the reader to verify this. Hence, we conclude that Q is a hC0 u ¬¨D
Àô 0 , T i-quasimodel.
Proposition 3.9 now follows immediately from Lemma C.2 and Lemma C.5.

References
Afrati, F. N. (2011). Determinacy and query rewriting for conjunctive queries and views.
Theoretical Computer Science, 412 (11), 1005‚Äì1021.
AndreÃÅka, H., NeÃÅmeti, I., & van Benthem, J. (1998). Modal languages and bounded fragments
of predicate logic. Journal of Philosophical Logic, 27, 217‚Äì274.
411

Ten Cate, Franconi, & Seylan

Avigad, J. (2003). Eliminating definitions and skolem functions in first-order logic. ACM
Transactions on Computational Logic, 4, 402‚Äì415.
Baader, F., & Nutt, W. (2003). Basic description logics. In The Description Logic Handbook,
pp. 43‚Äì95. Cambridge University Press.
BaÃÅraÃÅny, V., Benedikt, M., & ten Cate, B. (2013). Rewriting guarded negation queries. In
MFCS13, pp. 98‚Äì110.
Beth, E. W. (1953). On Padoa‚Äôs methods in the theory of definitions. Indagationes Mathematicae, 15, 330‚Äì339.
Blackburn, P., de Rijke, M., & Venema, Y. (2001). Modal logic. Cambridge University
Press.
Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). Computability and Logic. Cambridge
University Press.
Calvanese, D., & Giacomo, G. D. (2003). Expressive description logics. In The Description
Logic Handbook, pp. 178‚Äì218. Cambridge University Press.
Calvanese, D., Giacomo, G. D., Lenzerini, M., & Nardi, D. (2001). Reasoning in expressive
description logics. In Handbook of Automated Reasoning, pp. 1581‚Äì1634.
Calvanese, D., Giacomo, G. D., & Rosati, R. (1998). A note on encoding inverse roles
and functional restrictions in ALC knowledge bases. In Description Logics, Vol. 11.
CEUR-WS.org.
ten Cate, B., Conradie, W., Marx, M., & Venema, Y. (2006). Definitorially complete description logics. In KR, pp. 79‚Äì89.
ten Cate, B., Franconi, E., & Seylan, IÃá. (2011). Beth definability in expressive description
logics. In IJCAI, pp. 1099‚Äì1106.
Conradie, W. (2002). Definability and changing perspectives: The beth property for three
extensions of modal logic. Master‚Äôs thesis, University of Amsterdam.
Craig, W. (1957). Three uses of the Herbrand-Gentzen theorem in relating model theory
and proof theory. The Journal of Symbolic Logic, 22 (3), 269‚Äì285.
De Giacomo, G. (1996). Eliminating ‚Äúconverse‚Äù from Converse PDL. Journal of Logic,
Language and Information, 5 (2), 193‚Äì208.
Donini, F. M. (2003). Complexity of reasoning. In The Description Logic Handbook, pp.
96‚Äì136. Cambridge University Press.
Duc, C. L., & Lamolle, M. (2010). Decidability of description logics with transitive closure
of roles in concept and role inclusion axioms. In Description Logics, Vol. 573, pp.
372‚Äì383. CEUR-WS.org.
Fitting, M. (1996). First-order logic and automated theorem proving (2nd ed.). SpringerVerlag.
Friedman, H. (1976). The complexity of explicit definitions. Advances in Mathematics,
20 (1), 18‚Äì29.
Gabbay, D. M., & Maksimova, L. (2005). Interpolation and Definability in Modal Logics
(Oxford Logic Guides). Clarendon Press.
412

Beth Definability in Expressive Description Logics

Ghilardi, S., Lutz, C., & Wolter, F. (2006). Did I damage my ontology? A case for conservative extensions in description logics. In KR, pp. 187‚Äì197.
GoreÃÅ, R. (1999). Tableau methods for modal and temporal logics. In Handbook of Tableau
Methods, pp. 297‚Äì396. Kluwer.
GoreÃÅ, R., & Nguyen, L. A. (2007). Exptime tableaux with global caching for description
logics with transitive roles, inverse roles and role hierarchies. In TABLEAUX, pp.
133‚Äì148.
Hoogland, E. (2001). Definability and Interpolation: Model-theoretic investigations. Ph.D.
thesis, University of Amsterdam.
Hoogland, E., & Marx, M. (2002). Interpolation and definability in guarded fragments.
Studia Logica, 70 (3), 373‚Äì409.
Horrocks, I., Patel-Schneider, P. F., & van Harmelen, F. (2003). From SHIQ and RDF
to OWL: The making of a web ontology language. Journal of Web Semantics, 1 (1),
7‚Äì26.
Horrocks, I., & Sattler, U. (2007). A tableau decision procedure for SHOIQ. Journal of
Automated Reasoning, 39 (3), 249‚Äì276.
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning for very expressive description logics. Logic Journal of the IGPL, 8 (3), 239‚Äì264.
Konev, B., Lutz, C., Ponomaryov, D., & Wolter, F. (2010). Decomposing description logic
ontologies. In KR, pp. 236‚Äì246.
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2009a). Formal properties of modularisation.
In Modular Ontologies, pp. 25‚Äì66. Springer.
Konev, B., Walther, D., & Wolter, F. (2009b). Forgetting and uniform interpolation in
large-scale description logic terminologies. In IJCAI, pp. 830‚Äì835.
Kracht, M. (2007). Modal consequence relations. In Handbook of Modal Logic, pp. 491‚Äì545.
Elsevier.
Lang, J., & Marquis, P. (2008). On propositional definability. Artificial Intelligence, 172,
991‚Äì1017.
Libkin, L. (2004). Elements of Finite Model Theory. Springer.
Lutz, C. (2006). Complexity and succinctness of public announcement logic. In AAMAS,
pp. 137‚Äì143.
Lutz, C., Areces, C., Horrocks, I., & Sattler, U. (2005). Keys, nominals, and concrete
domains. Journal of Artificial Intelligence Research, 23, 667‚Äì726.
Lutz, C., Piro, R., & Wolter, F. (2010). Enriching EL-concepts with greatest fixpoints. In
ECAI, pp. 41‚Äì46.
Lutz, C., Sattler, U., & Tendera, L. (2005). The complexity of finite model reasoning in
description logics. Information and Computation, 199 (1-2), 132‚Äì171.
Lutz, C., Seylan, IÃá., & Wolter, F. (2012a). An automata-theoretic approach to uniform
interpolation and approximation in the description logic EL. In KR.
413

Ten Cate, Franconi, & Seylan

Lutz, C., Seylan, IÃá., & Wolter, F. (2012b). Mixing open and closed world assumption in
ontology-based data access: Non-uniform data complexity. In Description Logics, Vol.
846, pp. 268‚Äì278. CEUR-WS.org.
Lutz, C., & Wolter, F. (2011). Foundations for uniform interpolation and forgetting in
expressive description logics. In IJCAI, pp. 989‚Äì995.
Marx, M. (2007). Queries determined by views: pack your views. In PODS, pp. 23‚Äì30.
Marx, M., & Venema, Y. (2007). Local variations on a loose theme: Modal logic and
decidability. In Finite Model Theory and Its Applications, pp. 371‚Äì426. Springer.
Nash, A., Segoufin, L., & Vianu, V. (2010). Views and queries: Determinacy and rewriting.
ACM Transactions on Database Systems, 35 (3).
Nikitina, N., & Rudolph, S. (2012). Expexpexplosion: Uniform interpolation in general EL
terminologies. In ECAI, pp. 618‚Äì623.
Pasaila, D. (2011). Conjunctive queries determinacy and rewriting. In ICDT, pp. 220‚Äì231.
Rautenberg, W. (1983). Modal tableau calculi and interpolation. Journal of Philosophical
Logic, 12 (4), 403‚Äì423.
Sattler, U., Calvanese, D., & Molitor, R. (2003). Relationships with other formalisms. In
The Description Logic Handbook, pp. 137‚Äì177. Cambridge University Press.
Schwendimann, S. (1998). A new one-pass tableau calculus for PLTL. In TABLEAUX, pp.
277‚Äì292.
Seylan, IÃá. (2012). DBoxes and Beth Definability in Description Logics. Ph.D. thesis, Free
University of Bozen-Bolzano.
Seylan, IÃá., Franconi, E., & de Bruijn, J. (2009). Effective query rewriting with ontologies
over DBoxes. In IJCAI, pp. 923‚Äì929.
Seylan, IÃá., Franconi, E., & de Bruijn, J. (2010). Optimal rewritings in definitorially complete
description logics. In Description Logics, Vol. 573, pp. 125‚Äì136. CEUR-WS.org.
Tobies, S. (2001). Complexity Results and Practical Algorithms for Logics in Knowledge
Representation. Ph.D. thesis, RWTH-Aachen.

414

Journal of Artificial Intelligence Research 48 (2013) 67-113

Submitted 3/13; published 10/13

A Survey of Multi-Objective Sequential Decision-Making
Diederik M. Roijers

d.m.roijers@uva.nl

Informatics Institute
University of Amsterdam
Amsterdam, The Netherlands

Peter Vamplew

p.vamplew@ballarat.edu.au

School of Science,
Information Technology and Engineering
University of Ballarat
Ballarat, Victoria, Australia

Shimon Whiteson

s.a.whiteson@uva.nl

Informatics Institute
University of Amsterdam
Amsterdam, The Netherlands

Richard Dazeley

r.dazeley@ballarat.edu.au

School of Science,
Information Technology and Engineering
University of Ballarat
Ballarat, Victoria, Australia

Abstract
Sequential decision-making problems with multiple objectives arise naturally in practice and pose unique challenges for research in decision-theoretic planning and learning,
which has largely focused on single-objective settings. This article surveys algorithms designed for sequential decision-making problems with multiple objectives. Though there is
a growing body of literature on this subject, little of it makes explicit under what circumstances special methods are needed to solve multi-objective problems. Therefore, we
identify three distinct scenarios in which converting such a problem to a single-objective
one is impossible, infeasible, or undesirable. Furthermore, we propose a taxonomy that
classifies multi-objective methods according to the applicable scenario, the nature of the
scalarization function (which projects multi-objective values to scalar ones), and the type
of policies considered. We show how these factors determine the nature of an optimal solution, which can be a single policy, a convex hull, or a Pareto front. Using this taxonomy,
we survey the literature on multi-objective methods for planning and learning. Finally, we
discuss key applications of such methods and outline opportunities for future work.

1. Introduction
Sequential decision problems, commonly modeled as Markov decision processes (MDPs)
(Bellman, 1957a), occur in a range of real-world tasks such as robot control (Kober &
Peters, 2012), game playing (Szita, 2012), clinical management of patients (Peek, 1999),
military planning (Aberdeen, ThieÃÅbaux, & Zhang, 2004), and control of elevators (Crites
& Barto, 1996), power systems (Ernst, Glavic, & Wehenkel, 2004), and water supplies
(Bhattacharya, Lobbrecht, & Solomantine, 2003). Therefore, the development of algorithms
c
2013
AI Access Foundation. All rights reserved.

Roijers, Vamplew, Whiteson & Dazeley

for automatically solving such problems, either by planning given a model of the MDP (e.g.,
via dynamic programming methods, Bellman, 1957b) or by learning through interaction
with an unknown MDP (e.g., via temporal-difference methods, Sutton & Barto, 1998), is
an important challenge in artificial intelligence.
In most research on these topics, the desirability or undesirability of actions and their
effects are codified in a single, scalar reward function. Typically, the objective of the
autonomous agent interacting with the MDP is then to maximize the expected (possibly
discounted) sum of these rewards over time. In many tasks, a scalar reward function is the
most natural, e.g., a financial trading agent could be rewarded based on the monetary gain
or loss in its holdings over the most recent time period. However, there are also many tasks
that are more naturally described in terms of multiple, possibly conflicting objectives, e.g.,
a traffic control system should minimize latency and maximize throughput; an autonomous
vehicle should minimize both travel time and fuel costs. Multi-objective problems have
been widely examined in many areas of decision-making (Zeleny & Cochrane, 1982; Vira &
Haimes, 1983; Stewart, 1992; Diehl & Haimes, 2004; Roijers, Whiteson, & Oliehoek, 2013)
and there is a growing, albeit fragmented, literature addressing multi-objective decisionmaking in sequential settings.
In this article, we present a survey of the algorithms that have been devised for such
settings. We begin in Section 2 by formalizing the problem as a multi-objective MDP
(MOMDP). Then, in Section 3, we motivate the multi-objective perspective on decisionmaking. Little of the existing literature on multi-objective algorithms makes explicit why a
multi-objective approach is beneficial and, crucially, which cases cannot be trivially reduced
to a single-objective problem and solved with standard algorithms. To address this, we
describe three motivating scenarios for multi-objective algorithms.
Then, in Section 4, we present a novel taxonomy that organizes multi-objective problems
in terms of their underlying assumptions and the nature of the resulting solutions. A key
difficulty with the existing literature is that authors have considered many different types
of problems, often without making explicit the assumptions involved, how these differ from
those of other authors, or the scope of applicability of the resulting methods. Our taxonomy
aims to fill this void.
Sections 5 and 6 survey MOMDP planning and learning methods, respectively, organizing them according to the taxonomy and identifying some key differences between the
approaches examined in the planning and learning areas. Section 7 surveys applications
of these methods, covering both specific applications and more general classes of problems
where MOMDP methods can be applied. Section 8 discusses future directions for the field
based on gaps in the literature identified in Sections 5 and 6, and Section 9 concludes.

2. Background
A finite single-objective Markov decision process (MDP) is a tuple hS, A, T, R, ¬µ, Œ≥i where:
‚Ä¢ S is a finite set of states,
‚Ä¢ A is a finite set of actions,
‚Ä¢ T : S √ó A √ó S ‚Üí [0, 1] is a transition function specifying, for each state, action, and
next state, the probability of that next state occurring,
68

A Survey of Multi-Objective Sequential Decision-Making

‚Ä¢ R : S √ó A √ó S ‚Üí ‚Ñú is a reward function, specifying, for each state, action, and next
state, the expected immediate reward,
‚Ä¢ ¬µ : S ‚Üí [0, 1] is a probability distribution over initial states, and
‚Ä¢ Œ≥ ‚àà [0, 1) is a discount factor specifying the relative importance of immediate rewards.
The goal of an agent that acts in this environment is to maximize the expected return
Rt , which is some function of the rewards received from timestep t and onwards. Typically,
the return is additive (Boutilier, Dean, & Hanks, 1999), i.e., it is a sum of these rewards. In
an infinite horizon MDP, the return is typically an infinite sum, with each term discounted
according to Œ≥:
‚àû
X
Œ≥ k rt+k+1 ,
Rt =
k=0

where rt is the reward obtained at time t. The parameter Œ≥ thus quantifies the relative
importance of short-term and long-term rewards.
In contrast, in a finite horizon MDP, the return is typically an undiscounted finite sum,
i.e., after a certain number of timesteps, the process terminates and no more reward can be
obtained. While single- and multi-objective methods have been developed for finite horizon,
discounted infinite horizon, and average reward settings (Puterman, 1994), for the sake of
brevity we formalize only infinite horizon discounted reward MDPs in this article.1
An agent‚Äôs policy œÄ determines which actions it selects at each timestep. In the broadest
sense, a policy can condition on everything that is known to the agent. A state-indepedent
value function V œÄ specifies the expected return when following œÄ from the initial state:
V œÄ = E[R0 | œÄ].

(1)

If the policy is stationary, i.e., it conditions only on the current state, then it can be
formalized as œÄ : S √ó A ‚Üí [0, 1]: it specifies, for each state and action, the probability of
taking that action in that state. We can then specify the state value function of a policy œÄ:
V œÄ (s) = E[Rt | œÄ, st = s],
for all t when st = s. The Bellman equation restates this expectation recursively for
stationary policies:
X
X
T (s, a, s‚Ä≤ )[R(s, a, s‚Ä≤ ) + Œ≥V œÄ (s‚Ä≤ )].
V œÄ (s) =
œÄ(s, a)
a

s‚Ä≤

Note that the Bellman equation, which forms the heart of most standard solution algorithms
such as dynamic programming (Bellman, 1957b) and temporal-difference methods (Sutton
& Barto, 1998), explicitly relies on the assumption of additive returns. This is important
because, as we explain in Section 4.2.2, some multi-objective settings can interfere with
this additivity property, making planning and learning methods that rely on the Bellman
equation inapplicable.
1. For formalizations of the other settings, see for example the overview by Van Otterlo and Wiering (2012).

69

Roijers, Vamplew, Whiteson & Dazeley

State value functions induce a partial ordering over policies, i.e., œÄ is better than or
equal to œÄ ‚Ä≤ if and only if its value is greater for all states:
‚Ä≤

œÄ  œÄ ‚Ä≤ ‚áî ‚àÄs, V œÄ (s) ‚â• V œÄ (s).
A special case of a stationary policy is a deterministic stationary policy, in which one
action is chosen with probability 1 for every state. A deterministic stationary policy can be
seen as a mapping from states to actions: œÄ : S ‚Üí A. For single-objective MDPs, there is
always at least one optimal policy œÄ, i.e., ‚àÄœÄ ‚Ä≤ : œÄ  œÄ ‚Ä≤ , that is stationary and deterministic.
Theorem 1. For any additive infinite-horizon single-objective MDP, there exists a deterministic stationary optimal policy (see e.g., Howard, 1960; Boutilier et al., 1999).
If more than one optimal policy exists, they share the same value function, known as
the optimal value function V ‚àó (s) = maxœÄ V œÄ (s). The Bellman optimality equation defines
the optimal value function recursively:
X
T (s, a, s‚Ä≤ )[R(s, a, s‚Ä≤ ) + Œ≥V ‚àó (s‚Ä≤ )].
V ‚àó (s) = max
a

s‚Ä≤

Note that, because it maximizes over actions, this equation makes use of the fact that there
is an optimal deterministic stationary policy. Because an optimal policy maximizes the
value for every state, such a policy is optimal regardless of the initial state distribution ¬µ.
However, the state-independent value (Equation 1) may very well be different for different
initial state distributions. Using ¬µ, the state value function can be translated back into the
state-independent value function (Equation 1):
X
VœÄ =
¬µ(s)V œÄ (s).
s‚ààS

A multi-objective MDP (MOMDP)2 is an MDP in which the reward function R : S √ó
A √ó S ‚Üí ‚Ñún describes a vector of n rewards, one for each objective, instead of a scalar.
Similarly, a value function VœÄ in an MOMDP specifies the expected cumulative discounted
reward vector:
‚àû
X
Œ≥ k rk+1 | œÄ],
(2)
VœÄ = E[
k=0

where rt is the vector of rewards received at time t. The only difference between the single
objective value (Equation 1) and the multi-objective value (Equation 2) of a policy is that
the return, and the underlying sum of rewards, is now a vector rather than a scalar. For
stationary policies, we can also define the multi-objective value of a state:
VœÄ (s) = E[

‚àû
X

Œ≥ k rt+k+1 | œÄ, st = s].

(3)

k=0

In a single-objective MDP, state value functions impose only a partial ordering because
‚Ä≤
policies are compared at different states, e.g., it is possible that V œÄ (s) > V œÄ (s) but V œÄ (s‚Ä≤ ) <
2. Multi-objective MDPs should not be confused with mixed-observability MDPs (Ong, Png, Hsu, & Lee,
2010), which are also sometimes abbreviated with ‚ÄòMOMDP‚Äô.

70

A Survey of Multi-Objective Sequential Decision-Making

‚Ä≤

V œÄ (s‚Ä≤ ). But for a given state, the ordering is complete, i.e., V œÄ (s) must be greater than,
‚Ä≤
equal to, or less than V œÄ (s). The same is true of state-independent value functions.
In contrast, in an MOMDP, the presence of multiple objectives means that the value
function VœÄ (s) for a state s is a vector of expected cumulative rewards instead of a scalar.
Such value functions supply only a partial ordering, even for a given state. For example,
‚Ä≤
‚Ä≤
it is possible that, for some state s, ViœÄ (s) > ViœÄ (s) but VjœÄ (s) < VjœÄ (s). Similarly, for
‚Ä≤
‚Ä≤
state-independent value functions, it may be that ViœÄ > ViœÄ but VjœÄ < VjœÄ . Consequently,
unlike in an MDP, we can no longer determine which values are optimal without additional
information about how to prioritize the objectives. Such information can be provided in
the form of a scalarization function, which we discuss in the following sections.
Though not the focus of this article, there are also MOMDP variants in which constraints
are specified on some objectives (see e.g., Feinberg & Shwartz, 1995; Altman, 1999). The
goal of the agent is then to maximize the regular objectives while meeting the constraints
on the other objectives. Constrained objectives are fundamentally different from regular
objectives because they are explicitly prioritized over the regular objectives, i.e., any policy
that fails to meet a constraint is inferior to any policy that meets all constraints, regardless
of how well the policies maximize the regular objectives.

3. Motivating Scenarios
While the MOMDP setting has received considerable attention, it is not immediately obvious why it is a useful addition to the standard MDP or why specialized algorithms for
it are needed. In fact, some researchers argue that modeling problems as explicitly multiobjective is not necessary, and that a scalar reward function is adequate for all sequential
decision-making tasks. The most direct formulation of this perspective is Sutton‚Äôs reward
hypothesis, which states ‚Äúthat all of what we mean by goals and purposes can be well
thought of as maximization of the expected value of the cumulative sum of a received scalar
signal (reward).‚Äù3
This view does not imply that multi-objective problems do not exist. Indeed, that
would be a difficult claim, since it is so easy to think of problems that naturally possess
multiple objectives. Instead, the implication of the reward hypothesis is that the resulting
MOMDPs can always be converted into single-objective MDPs with additive returns. Such
a conversion process would involve two steps. The first step is to specify a scalarization
function.
Definition 1. A scalarization function f , is a function that projects the multi-objective
value VœÄ to a scalar value.
VwœÄ (s) = f (VœÄ (s), w),
where w is a weight vector parameterizing f .
For example, f may compute a linear combination of the values, in which case each element
of w quantifies the relative importance of the corresponding objective (this setting is discussed further in Section 4.2.1). The second step is to define a single-objective MDP with
3. http://rlai.cs.ualberta.ca/RLAI/rewardhypothesis.html

71

Roijers, Vamplew, Whiteson & Dazeley

Figure 1: The three motivating scenarios for MOMDPs: (a) the unknown weights scenario,
(b) the decision support scenario, (c) the known weights scenario.

additive returns such that, for all œÄ and s, the expected return equals the scalarized value
VwœÄ (s).
Though it rarely, if ever, makes the issue explicit, all research on MOMDPs rests on the
premise that there exist tasks for which one or both of these conversion steps is impossible,
infeasible, or undesirable. In this section, we discuss three scenarios in which this can occur
(see Figure 1).
The first scenario, which we call the unknown weights scenario (Figure 1a), occurs when
w is unknown at the moment when planning or learning must occur. Consider for example
a public transport system that aims to minimize both latency (i.e., the time that commuters
need to reach their destinations) and pollution costs. In addition, assume that the resulting
MOMDP can be scalarized by converting each objective into monetary cost: economists
can compute the cost of lost productivity due to commuting and pollution incurs a tax that
must be paid in pollution credits purchased at a given price. Assume also that those credits
are traded on an open market and therefore the price constantly fluctuates. If the transport
system is complex, it may be infeasible to compute a new plan every day given the latest
prices. In such a scenario, it can be preferable to use a multi-objective planning method
that computes a set of policies such that, for any price, one of those policies is optimal
(see the planning or learning phase in Figure 1a). While doing so is more computationally
expensive than computing a single optimal policy for a given price, it needs to be done
only once and can be done in advance, when more computational resources are available.
Then, when it is time to select a policy, the current weights, i.e., the price of the pollution
72

A Survey of Multi-Objective Sequential Decision-Making

credits, are used to determine the best policy from the set (the selection phase). Finally,
the selected policy is employed in the task (the execution phase).
In the unknown weights scenario, scalarization is impossible before planning or learning
but trivial once a policy actually needs to be used because w is known by that time.
In contrast, in the second scenario, which we call the decision support scenario (Figure
1b), scalarization is infeasible throughout the entire decision-making process because of the
difficulty of specifying w, or even f . For example, economists may not be able to accurately
compute the cost of lost productivity due to commuting. The user may also have ‚Äúfuzzy‚Äù
preferences that defy meaningful quantification. For example, if the transport system could
be made more efficient by building a new train line that obstructs a beautiful view, then a
human designer may not be able to quantify the loss of beauty. The difficulty of specifying
the exact scalarization is especially apparent when the designer is not a single person but
a committee or legislative body whose members have different preferences and agendas.
In such a system, the MOMDP method is used to calculate an optimal solution set with
respect to the known constraints about f and w. As Figure 1b shows, the decision support
scenario proceeds similarly to the unknown weights scenario except that, in the selection
phase, the user or users select a policy from the set according to their arbitrary preferences,
rather than explicit scalarization according to given weights.
In all these cases, one can still argue that scalarization before planning or learning is
possible in principle. For example, the loss of beauty can be quantified by measuring the
resulting drop in housing prices in neighborhoods that previously enjoyed an unobstructed
view. However, the difficulty with scalarization is not only that doing so may be impractical
but, more importantly, that it forces the users to express their preferences in a way that may
be inconvenient and unnatural. This is because selecting w requires weighing hypothetical
trade-offs, which can be much harder than choosing from a set of actual alternatives. This
is a well understood phenomenon in the field of decision analysis (Clemen, 1997), where
the standard workflow involves presenting alternatives before soliciting preferences. That
is why subfields of decision analysis such as multiple criteria decision-making and multiattribute utility theory focus on multiple objectives (Dyer, Fishburn, Steuer, Wallenius, &
Zionts, 1992). For the same reasons, algorithms for MOMDPs can provide critical decision
support. Rather than forcing the users to specify w in advance, these algorithms just
prune policies that would not be optimal for any w. Then, they offer the users a range of
alternatives from which they can select according to preferences whose relative importance
is not easily quantified.
In the third scenario, which we call the known weights scenario (Figure 1c), we assume
that w is known at the time of planning or learning and thus scalarization is both possible
and feasible. However, it may be undesirable because of the difficulty of the second step
in the conversion. In particular, if f is nonlinear, then the resulting single-objective MDP
may not have additive returns (see Section 4.2.2). As a result, the optimal policy may be
non-stationary (see Section 4.3.2) or stochastic (see Section 4.3.3), which cannot occur in
single-objective, additive, infinite-horizon MDPs (see Theorem 1). Consequently, the MDP
can be difficult to solve, as standard methods are not applicable. Converting the MDP to
one with additive returns may not help either as it can cause a blowup in the state space,
73

Roijers, Vamplew, Whiteson & Dazeley

which also leaves the problem intractable.4 Therefore, even though scalarization is possible
when w is known, it may still be preferable to use methods specially designed for MOMDPs
rather than to convert the problem to a single-objective MDP. In contrast to the unknown
weights and the decision support scenarios, in the known weights scenario, the MOMDP
method only produces one policy, which is then executed, i.e., there is no separate selection
phase, as shown in Figure 1c.
Note that Figure 1 assumes an off-line scenario: planning or learning occurs only once,
before execution. However, multi-objective methods can also be employed in on-line settings
in which planning or learning are interleaved with execution. In the on-line version of the
unknown weights scenario, the weights are better characterized as dynamic, rather than
unknown. In an on-line scenario, the agent must already have seen weights in all timesteps
t > 1 since this is a prerequisite for execution in timesteps 1, . . . , t ‚àí 1. However, if the
weights change over time, the agent may not yet know the weights that will be used in
timestep t when it is in the planning or learning phase of that timestep.

4. Problem Taxonomy
So far, we have described the MOMDP formalism and proposed three motivating scenarios
for it. In this section, we discuss what constitutes an optimal solution. Unfortunately, there
is no simple answer to this question, as it depends on several critical factors. Therefore,
we propose a problem taxonomy, shown in Table 1, that categorizes MOMDPs according
to these factors and describes the nature of an optimal solution in each category. Our
taxonomy is based on what we call the utility-based approach, in contrast to many other
multi-objective papers that follow an axiomatic approach to optimality in MOMDPs.
The utility-based approach rests on the following premise: before the execution phases
of the scenarios in Section 3, one policy is selected by collapsing the value vector of a policy
to a scalar utility, using the scalarization function. The application of the scalarization
function may be implicit and hidden, e.g., it may be embedded in the thought-process of
the user, but it nonetheless occurs. The scalarization function is part of the notion of utility,
i.e., what the agent should maximize. Therefore, if we find a set with an optimal solution
for each possible weight setting of the scalarization function, we have solved the MOMDP.
The utility-based approach derives the optimal solution set from the assumptions that are
made about the scalarization function, which policies the user allows, and whether we need
one or multiple policies.
By contrast, the axiomatic approach begins with the axiom that the optimal solution set
is the Pareto front (see Section 4.2.2).5 This approach is limiting because, as we demonstrate
in this section, there are some settings for which other solution concepts are more suitable.
Thus, we take a utility-based approach because it makes it possible to derive the solution
concept, rather than just assuming it. When the Pareto front is in fact the correct solution
4. Since non-additive returns can depend on the agent‚Äôs entire history, the immediate reward function in
the converted MDP may also depend on that history and thus the state representation in the converted
MDP must be augmented to include it.
5. For an example of an axiomatic approach to multi-objective reinforcement learning, see the survey by
Liu, Xu, and Hu (2013).

74

A Survey of Multi-Objective Sequential Decision-Making

single policy
(known weights)
deterministic
linear
scalarization

multiple policies
(unknown weights or decision support)

stochastic

one deterministic stationary
policy (1)

monotonically one
increasing
deterministic
scalarization
non-stationary
policy (3)

deterministic

stochastic

convex coverage set of
deterministic stationary policies
(2)

one mixture
policy of two
or more
deterministic
stationary
policies (4)

Pareto
coverage set of
deterministic
non-stationary
policies (5)

convex
coverage set of
deterministic
stationary
policies (6)

Table 1: The MOMDP problem taxonomy showing the critical factors in the problem and
the nature of the resulting optimal solution. The columns describe whether the
problem necessitates a single policy or multiple ones, and whether those policies
must be deterministic (by specification) or are allowed to be stochastic. The rows
describe whether the scalarization function is a linear combination of the rewards
or, whether this cannot be assumed and the scalarization function is merely a
monotonically increasing function of them. The contents of each cell describe
what an optimal solution for the given setting looks like.

concept, the utility-based approach provides a justification for it. When it is not, it allows
for a more appropriate solution concept to be derived instead.
Our taxonomy categorizes problem classes based on the assumptions about the scalarization function, which policies the user allows, and whether one or multiple policies are
required. We show that this leads different solution concepts, underscoring the importance
of carefully considering the choice of solution concept based on all the available information.
We discuss the three factors that constitute our taxonomy in the following order. In
Section 4.1, we discuss the first factor: whether one or multiple policies are sought, a choice
that follows directly from which motivating scenario is applicable. The known weights
scenario (Figure 1c) implies a single-policy approach while the unknown weights and decision
support scenarios (Figure 1a and 1b) imply a multiple-policy approach. In Section 4.2, we
discuss the second factor: whether the scalarization function is a linear combination of the
rewards or merely a monotonically increasing function of them. In Section 4.3, we discuss
the third factor: whether stochastic or only deterministic policies are permitted.
The goal of the taxonomy is to cover most research on MOMDPs while remaining simple
and intuitive. However, due to the diversity of research on MOMDPs, some research does
not fit neatly in our taxonomy. We note these discrepancies when discussing such research
in Sections 5 and 6.
75

Roijers, Vamplew, Whiteson & Dazeley

4.1 Single versus Multiple Policies
Following the approach of Vamplew et al. (2011), we first distinguish problems in which
only one policy is sought from ones in which multiple policies are sought. Which case holds
depends on which of the three motivating scenarios discussed in Section 3 applies.
In the unknown weights and decision support scenarios, the solution to an MOMDP
consists of multiple policies. Though these two scenarios are conceptually quite different,
from an algorithmic perspective they are identical. The reason is that they are both characterized by a strict separation of the decision-making process into two phases: the planning
or learning phase and the execution phase (though in on-line settings, the agent may go
back and forth between the two).
In the planning or learning phase, w is unavailable. Consequently, the planning or learning algorithm must return not a single policy but a set of policies (and the corresponding
multi-objective values). This set should not contain any policies that are suboptimal for all
scalarizations, i.e. we are only interested in undominated policies.
Definition 2. For an MOMDP m and a scalarization function f , the set of undominated
policies, U (Œ†m ), is the subset of all possible policies Œ†m for m for which there exists a w
for which the scalarized value is maximal:
‚Ä≤

U (Œ†m ) = {œÄ : œÄ ‚àà Œ†m ‚àß ‚àÉw‚àÄ(œÄ ‚Ä≤ ‚àà Œ†m ) VwœÄ ‚â• VwœÄ }.

(4)

U (Œ†m ) is sufficient to solve m, i.e., for each w, it contains a policy with the optimal
scalarized value. However, it may contain redundant policies that, while optimal for some
weights, are not the only optimal policy in the set for w. Such policies can be removed
while still ensuring the set contains an optimal policy for all w. In fact, in order to solve
m, we need only a subset of the undominated policies such that, for any possible w, at
least one policy in the set is optimal. This is sometimes called a coverage set (CS) (Becker,
Zilberstein, Lesser, & Goldman, 2003).
Definition 3. For an MOMDP m and a scalarization function f , a set CS(Œ†m ) is a
coverage set if it is a subset of U (Œ†m ) and if, for every w, it contains a policy with maximal
scalarized value, i.e., if:


m
m
m
‚Ä≤
m
œÄ
œÄ‚Ä≤
CS(Œ† ) ‚äÜ U (Œ† ) ‚àß (‚àÄw)(‚àÉœÄ) œÄ ‚àà CS(Œ† ) ‚àß ‚àÄ(œÄ ‚àà Œ† ) Vw ‚â• Vw .
(5)
Note that U (Œ†m ) is automatically a coverage set. However, while U (Œ†m ) is unique, CS(Œ†m )
need not be. When there are multiple policies with the same value, U (Œ†m ) contains all of
them, while a coverage set need contain only one. In addition, for a given CS(Œ†m ), there
‚Ä≤
may exist a policy œÄ ‚Ä≤ ‚àà
/ CS(Œ†m ) for which VœÄ is different from VœÄ for all œÄ ‚àà CS(Œ†m )
but which has the same scalarized value as a œÄ ‚àà CS(Œ†m ) for all w at which œÄ ‚Ä≤ is optimal.
In contrast to single-objective MDPs, in MOMDPs whether or not a policy is in a CS(Œ†m )
can depend on the initial state distribution ¬µ. It is thus important to accurately specify ¬µ
when formulating an MOMDP.
Ideally, an MOMDP algorithm should find the smallest CS(Œ†m ). However, doing so
might be harder than just finding one smaller than U (Œ†m ). In Section 4.2, we specialize
the coverage set for two classes of scalarization functions.
76

A Survey of Multi-Objective Sequential Decision-Making

In the execution phase, a single policy is chosen from the set returned in the planning or
learning phase and executed. In the unknown weights scenario, we assume that w is revealed
after planning or learning is complete but before execution begins. Selecting a policy then
requires only maximizing over the scalarized value of each policy in the returned set:
œÄ ‚àó = argmax VwœÄ .
œÄ‚ààCS(Œ†m )

In the decision support scenario, this set is manually inspected by the user(s), who select a
policy for execution informally, making an implicit trade-off between the objectives.
In the known weights scenario, w is known before planning or learning begins. Therefore,
returning multiple policies is unnecessary. However, as mentioned in Section 3 and discussed
further in Section 4.2.2, scalarization can yield a single-objective MDP that is difficult to
solve.
4.2 Linear versus Monotonically Increasing Scalarization Functions
The second critical factor affecting what constitutes an optimal solution to an MOMDP is
the nature of the scalarization function. In this section, we discuss two types of scalarization
function: those that are linear combinations of the rewards and those that are merely
monotonically increasing functions of them.
4.2.1 Linear Scalarization Functions
A common assumption about the scalarization function (e.g., Natarajan & Tadepalli, 2005;
Barrett & Narayanan, 2008), is that f is linear, i.e., it computes the weighted sum of the
values for each objective.
Definition 4. A linear scalarization function computes the inner product of a weight vector
w and a value vector VœÄ
VwœÄ = w ¬∑ VœÄ .
(6)
Each element of w specifies how much one unit of value for the corresponding objective
contributes to the scalarized value. The elements of the weight vector w are all positive real
numbers and constrained to sum to 1.
Linear scalarization functions are a simple and intuitive way to scalarize. One common
situation in which they are applicable is when rewards can be easily translated into monetary
value. For example, consider a mining task in which different policies yield different expected
quantities of various minerals. If the prices per kilo of those minerals fluctuate daily, then
the task can be formulated as an MOMDP, with each objective corresponding to a different
mineral. Each element of VœÄ then reflects the expected number of kilos of that mineral
that are mined under œÄ and the scalarized value VwœÄ corresponds to the monetary value
of everything that is mined. VwœÄ can be computed only when w, corresponding to the
(normalized) current price per kilo of each mineral, becomes known.
In the single-policy setting, where w is known, the presence of multiple objectives poses
no difficulties given a linear f . Instead, f can simply be applied to each reward vector in the
77

Roijers, Vamplew, Whiteson & Dazeley

MOMDP. Because the inner product computed by f distributes over addition, the result is
a single-objective MDP with additive returns. In the infinite horizon setting this leads to:
VwœÄ = w ¬∑ VœÄ = w ¬∑ E[

‚àû
X

Œ≥ k rt+k+1 ] = E[

‚àû
X

Œ≥ k (w ¬∑ rt+k+1 )].

(7)

k=0

k=0

Since this single-objective MDP has additive returns, it can be solved with standard methods, yielding a single policy, as reflected in the box labeled (1) in Table 1. Due to Theorem
1, a determinstic stationary policy suffices. However, a multi-objective approach can still
be preferable in this case, e.g., VœÄ may be easier to estimate than VwœÄ in large or continuous
MOMDPs where function approximation is required (see Section 6.1).
In the multiple policy setting, however, we do not know w during planning or learning
and therefore want to find a coverage set. If f is linear, then U (Œ†m ), which is automatically
a coverage set, consists of the convex hull. Substituting Equation 6 in the definition of the
undominated set (Definition 2), we obtain the definition of the convex hull:
Definition 5. For an MOMDP m, the convex hull (CH) is the subset of Œ†m for which
there exists a w for which the linearly scalarized value is maximal:
‚Ä≤

CH(Œ†m ) = {œÄ : œÄ ‚àà Œ†m ‚àß ‚àÉw‚àÄ(œÄ ‚Ä≤ ‚àà Œ†m ) w ¬∑ VœÄ ‚â• w ¬∑ VœÄ }.

(8)

Figure 2a illustrates the concept of a convex hull for stationary deterministic policies. Each
point in the plot represents the multi-objective value of a given policy for a two-objective
MOMDP. The axes represent the reward dimensions. The convex hull is shown as a set
of filled circles, connected by lines that form a convex surface.6 Given a linear f , the
scalarized value of each policy is a linear function of the weights. This is illustrated in
Figure 2b, where the x-axis represents the weight for dimension 0 (w[1] = 1 ‚àí w[0]), and
the y-axis the scalarized value of the policies. To select a policy, we need only know the
values of the convex hull policies, which form the upper surface of the scalarized value,
as illustrated by the black solid lines, and correspond to the three convex hull policies in
Figure 2a. The upper surface forms a piecewise linear and convex function. Such functions
are also well-known from the literature on partially-observable Markov decision processes
(POMDPs), whose relationship to MOMDPs we discuss in Section 5.2.
Like any U (Œ†m ), CH(Œ†m ) can contain superfluous policies. However, we can also define
the convex coverage set (CCS) as the specification of the coverage set when f is linear. This
is reflected in box (2) in Table 1 (we explain why the policies in this set are deterministic
and stationary in Section 4.3.1).
Definition 6. For an MOMDP m, a set CCS(Œ†m ) is a convex coverage set if it is a
subset of CH(Œ†m ) and if, for every w, it contains a policy whose linearly scalarized value
is maximal, i.e., if:


‚Ä≤
CCS(Œ†m ) ‚äÜ CH(Œ†m ) ‚àß (‚àÄw)(‚àÉœÄ) œÄ ‚àà CCS(Œ†m ) ‚àß ‚àÄ(œÄ ‚Ä≤ ‚àà Œ†m ) w ¬∑ VœÄ ‚â• w ¬∑ VœÄ . (9)
6. Note that the term ‚Äúconvex hull‚Äù has a slightly different meaning in the multi-objective literature than
its standard geometric definition. In geometry, the convex hull of a finite set S of points in Euclidean
space is the minimal subset of S so that each of the other points in S can be expressed as a convex
combination of the points in the convex hull. In a multi-objective setting, we are only interested in a
particular subset of the geometric convex hull; those points of which its convex combinations are strictly
bigger (in all dimensions) than any other point in S, i.e., all points that are optimal for some weight.

78

A Survey of Multi-Objective Sequential Decision-Making

(a)

(b)

Figure 2: Example of the convex hull and Pareto front. Each point in (a) represents the
multi-objective value of a given policy and each line in (b) represents the linearly
scalarized value of a policy across values of w. The convex hull is shown as black
filled circles in (a), and black lines in (b). The Pareto front consists of all filled
points (circles and squares) in (a), and both the dashed and solid black lines in
(b). The unfilled points in (a) (grey lines in (b)) are dominated.

For deterministic stationary policies, the difference between CH(Œ†m ) and CCS(Œ†m ) may
often be small. Therefore, the terms are often used interchangeably. However, in the case
of non-stationary or stochastic policies, the difference is quite significant, as the CH can
contain infinitely many policies, while it is possible to construct a finite CCS, as we show
in Section 4.3.1.
4.2.2 Monotonically Increasing Scalarization Functions
While linear scalarization functions are intuitive and simple, they are not always adequate
for expressing the user‚Äôs preferences. For example, suppose in the mining task mentioned
above, there are two minerals that can be mined and only three policies are available: œÄ1
sends the mining equipment to a location where only the first mineral can be mined, œÄ2 to
a location where only the second mineral can be mined, and œÄ3 to a location where both
minerals can be mined. Suppose the owner of the equipment prefers œÄ3 , e.g., because it at
least partially appeases clients with different interests. However, it may be the case that,
because the location corresponding to œÄ3 has fewer minerals, the convex hull contains only
œÄ1 and œÄ2 . Thus, the owner‚Äôs preference of œÄ3 implies that he or she, implicitly or explicitly,
employs a nonlinear scalarization function.
Here, we consider the case in which f can be nonlinear, and corresponds to a common
notion of the relationship between reward and utility. This class of possibly nonlinear scalarizations are the strictly monotonically increasing scalarization functions. These functions
adhere to the constraint that if a policy is changed in such a way that its value increases in
79

Roijers, Vamplew, Whiteson & Dazeley

one or more of the objectives, without decreasing in any other objectives, then the scalarized
value also increases.
Definition 7. A scalarization function f is strictly monotonically increasing if:
‚Ä≤

‚Ä≤

‚Ä≤

(‚àÄi, ViœÄ ‚â• ViœÄ ‚àß ‚àÉi, ViœÄ > ViœÄ ) ‚áí (‚àÄw, VwœÄ > VwœÄ ).

(10)

Linear scalarization functions (with non-zero positive weights) are included in this class
of functions. The condition on the left-hand side of Equation 10 is more commonly known
as Pareto dominance (Pareto, 1896).
Definition 8. A policy œÄ Pareto-dominates another policy œÄ ‚Ä≤ when its value is at least as
high in all objectives and strictly higher in at least one objective:
‚Ä≤

‚Ä≤

‚Ä≤

VœÄ ‚âªP VœÄ ‚áî ‚àÄi, ViœÄ ‚â• ViœÄ ‚àß ‚àÉi, ViœÄ > ViœÄ .

(11)

Demanding that f is strictly monotonically increasing is quite a minimal constraint, as it
requires only that, all other things being equal, getting more reward for a certain objective
is always better. In fact, it is difficult to think of any f that violates this constraint without
employing a highly unnatural notion of reward.7
Three observations are in order about strictly monotonically increasing scalarization
functions and the related concept of Pareto dominance. First, unlike in the linear case, we
do not necessarily know the exact shape of f . Instead, we know only that it belongs to a
particular class of functions. The solution concept that follows thus applies to any strictly
monotonically increasing f . In cases where stronger assumptions about f can be made,
more specific solution concepts are possible. However, except for linearity, we are not aware
of any such properties of f that have been exploited in solving MOMDPs.
Second, the notions of optimality introduced in Section 4.2.1 are no longer appropriate.
The reason is that, even though the vector-valued returns are still additive (Equation 2), the
scalarized returns may not be because f may no longer be linear. As an example, consider
the well-known Tchebycheff scalarization function (Perny & Weng, 2010)8 :
X
œà(VœÄ , p, w) = ‚àí max wi |pi ‚àí ViœÄ | ‚àí «´
wi |pi ‚àí ViœÄ |,
(12)
i‚àà1...n

i‚àà1...n

where p is an optimistic reference point, w are weights, and «´ is an arbitrarily small positive
constant greater than 0. Note that the sum on the righthand side is what makes the function
strictly monotonically increasing. Now, if p = (3, 3),P«´ = 0.01, r1 = (0, 3), r2 = (3, 0),
k
w = (0.5, 0.5) and Œ≥ = 1, then f (VœÄ , w) = 0 but E[ ‚àû
k=0 Œ≥ f (rt+k+1 , w)] = (‚àí1.515) +
(‚àí1.515) = ‚àí3.03. This loss of additivity of the scalarized returns when applying a nonlinear
f has important consequences for which methods can be applied, as we show in Section 4.3.2.
Third, we can still identify and prune policies that are not optimal for any w for any
strictly monotonically increasing f , even though it may be nonlinear. Consider the three
7. In addition, if f is not strictly monotonically increasing and no other assumptions are made, then no
policies can be pruned from the coverage set. Thus, computing the value of every policy in this coverage
set, which is required by the selection phase, is likely to be intractable.
8. Our definition differs slightly from that of Perny and Weng (2010): it is multiplied by ‚àí1 to express
maximization instead of minimization, for the sake of consistency with the rest of this article.

80

A Survey of Multi-Objective Sequential Decision-Making

labeled policies in Figure 2a (note that Figure 2b does not apply, because the scalarization
function is no longer linear). B has a higher value than A in one objective, but a lower
value in the other. We therefore cannot tell whether A or B ought to be preferred without
knowing w. However, C has a lower value than A in both objectives, and thus A Paretodominates C: A ‚âªP C. Because f is strictly monotonically increasing, the scalarized value
of A is greater than that of C for all w and thus we can discard C.
For now, we defer a full discussion of what constitutes an optimal solution for an
MOMDP with a strictly monotonically increasing scalarization function (i.e., boxes (3)-(6)
in Table 1) because this depends, not only on whether the single or multiple policy setting
applies, but also on whether only deterministic or also stochastic policies are considered,
which is addressed in Section 4.3.
However, we can already observe that, given any strictly monotonically increasing f , we
can use the Pareto front as a set of viable policies. The Pareto front consists of all policies
that are not Pareto dominated.
Definition 9. For an MOMDP m, the Pareto front is the set of all policies that are not
Pareto dominated by any other policy in Œ†m :
‚Ä≤

P F (Œ†m ) = {œÄ : œÄ ‚àà Œ†m ‚àß ¬¨‚àÉ(œÄ ‚Ä≤ ‚àà Œ†m ), VœÄ ‚âªP VœÄ }.

(13)

Note that P F (Œ†m ) is not the set of undominated policies U (Œ†m ) for all specific strictly
monotonically increasing f . We have already seen that for the special case of linear f ,
U (Œ†m ) = CH(Œ†m ), which is a subset of P F (Œ†m ). (For example, in Figure 2, the Pareto
front consists of the convex hull plus B.) However, for any strictly monotonically increasing
f , we know that a policy that is not in the P F (Œ†m ) is dominated with respect to f , i.e.,
œÄ 6‚àà P F (Œ†m ) ‚áí œÄ 6‚àà U (Œ†m ). This is because, for strictly monotonically increasing f and
œÄ‚àà
/ P F (Œ†m ), there cannot exist a w for which œÄ is optimal, since by definition there exists
‚Ä≤
a œÄ ‚Ä≤ such that VœÄ ‚âªP VœÄ and, since f is strictly monotonically increasing, this implies
‚Ä≤
that VwœÄ > VwœÄ .
However, if we know only that f is strictly monotonically increasing, we cannot settle
for a subset of P F (Œ†m ) either, because there exist strictly monotonically increasing f for
which U (Œ†m ) = P F (Œ†m ). Perny and Weng (2010) show that U (Œ†m ) = P F (Œ†m ) for the
Tchebycheff function (Equation 12), which is strictly monotonically increasing. Therefore,
we cannot discard policies from the P F (Œ†m ) and retain an undominated set U (Œ†m ) for all
strictly monotonically increasing f .
A Pareto coverage set (PCS) of minimal size can be constructed by retaining only one
policy of the policies with identical vector values in the P F (Œ†m ). We can formally define
the PCS as follows:
Definition 10. For an MOMDP m, a set P CS(Œ†m ) is a Pareto coverage set if it is a subset
of P F (Œ†m ) and if, for every policy œÄ ‚Ä≤ ‚àà Œ†m , it contains a policy that either dominates œÄ ‚Ä≤
or has equal value to œÄ ‚Ä≤ , i.e., if:


‚Ä≤
‚Ä≤
P CS(Œ†m ) ‚äÜ P F (Œ†m ) ‚àß ‚àÄ(œÄ ‚Ä≤ ‚àà Œ†m )(‚àÉœÄ) œÄ ‚àà P CS(Œ†m ) ‚àß (VœÄ ‚âªP VœÄ ‚à® VœÄ = VœÄ ) . (14)
Again, for deterministic stationary policies the difference between a P CS(Œ†m ) and P F (Œ†m )
may be minor. Note that P F (Œ†m ) is automatically a P CS(Œ†m ). Most papers in the
literature therefore take P F (Œ†m ) as the solution.
81

Roijers, Vamplew, Whiteson & Dazeley

We can also slightly relax the constraint on f , without having to change which policies
are in the P CS(Œ†m ). Specifically, we can define a monotonically increasing scalarization
‚Ä≤
function as a function for which the following property holds: (‚àÄi, ViœÄ ‚â• ViœÄ ) ‚áí (‚àÄw, VwœÄ ‚â•
‚Ä≤
VwœÄ ). This relaxation influences the set of undominated policies: while policies that are not
in the P F (Œ†m ) are always dominated under a strictly monotonically increasing f , they need
not be under any monotonically increasing f . Consider for example f (VœÄ , w) = 0, which
is monotonically increasing but not strictly monotonically increasing. For this function
there are no dominated policies, as every policy has the same scalarized value. However,
because the scalarized value of a policy œÄ ‚Ä≤ 6‚àà P F (Œ†m ) cannot be greater than the scalarized
function of a policy œÄ ‚àà P CS(Œ†m ), we can use the P CS(Œ†m ) for (non-strict) monotonically
increasing f . Therefore, in this article, we focus on monotonically increasing f , as this is
the broader class of functions.
Because the P F (Œ†m ), and even a P CS(Œ†m ), may be prohibitively large and contain
many policies whose values differ by negligible amounts, Chatterjee et al. (2006) and BraÃÅzdil
et al. (2011) introduce a slack parameter «´, and use this to define an «´-approximate Pareto
front, P F«´ (Œ†m ). P F«´ (Œ†m ) contains all values of policies such that for every possible policy
‚Ä≤
œÄ ‚Ä≤ ‚àà Œ†m there is a policy œÄ ‚àà P F«´ (Œ†m ) such that ‚àÄi ViœÄ (s) + «´ ‚â• ViœÄ (s). By weakening
the requirements for domination, this approach yields a smaller set that can be calculated
more efficiently.
Another option for finding a smaller set than P F (Œ†m ) is making additional assumptions
about the scalarization function. For example, Perny, Weng, Goldsmith, and Hanna (2013)
introduce the notion of fairness between objectives, leading to Lorentz optimality. The
additional assumption is that if the sum of the values over all objectives stays the same,
making the difference between two objectives smaller yields a higher scalarized value. This is
of course a strong assumption that does not apply as broadly as Pareto optimality. However,
when it does apply, it can help reduce the size of the optimal solution set.
4.3 Deterministic versus Stochastic Policies
The third critical factor affecting what constitutes an optimal solution to an MOMDP is
whether only deterministic polices are considered or stochastic ones are also allowed. While
in most applications there is no reason to exclude stochastic policies a priori, there can be
cases when stochastic policies are clearly undesirable or even unethical. For example, if the
policy determines the clinical treatment of a patient, e.g., as in work of Lizotte, Bowling,
and Murphy (2010) and Shortreed, Laber, Lizotte, Stroup, Pineau, and Murphy (2011),
then flipping a coin to determine the course of action may be inappropriate. We denote the
m
set of deterministic policies Œ†m
D and the set of stationary policies Œ†S . Both sets are subsets
m
m
m
m
of all policies: Œ†D ‚äÜ Œ† ‚àß Œ†S ‚äÜ Œ† . Finally the set of policies that are both deterministic
m
m
and stationary is the intersection of both these sets, denoted Œ†m
DS = Œ†D ‚à© Œ†S .
In single-objective MDPs, this factor is not critical because, due to Theorem 1, we can
restrict our search to deterministic stationary policies, i.e. the optimal attainable value
‚Ä≤
V œÄ . However, the
is attainable with a deterministic stationary policy: maxm V œÄ = ‚Ä≤max
m
œÄ‚ààŒ†

œÄ ‚ààŒ†DS

situation is more complex in MOMDPs. In this section, we discuss how the focus on
stochastic or deterministic policies affects each setting considered in our taxonomy.
82

A Survey of Multi-Objective Sequential Decision-Making

4.3.1 Deterministic and Stochastic Policies with Linear Scalarization
Functions
When f is linear, a result similar to Theorem 1 holds for MOMDPs due to the following
corollary:
m
Corollary 1. For an MOMDP m, any CCS(Œ†m
DS ) is also a CCS(Œ† ).

Proof. If f is linear, we can translate the MOMDP to a single-objective MDP, for each
possible w. This is done by treating the inner product of the reward vector and w as the
new rewards, and leaving the rest of the problem as is. Since the inner product distributes
over addition, the scalarized returns remain additive (Equation 7). Thus, for every w
there exists a translation to a single-objective MDP, for which an optimal deterministic and
stationary policy must exist, due to Theorem 1. Hence, for each w there exists an optimal
deterministic stationary policy. Therefore, there exists a œÄ ‚àà CCS(Œ†m
DS ) that ‚Ä≤ is optimal
‚Ä≤
m
m
for that w. Consequently, there cannot exist a œÄ ‚àà Œ† \ Œ†DS such that w ¬∑ VœÄ > w ¬∑ VœÄ
m
and thus CCS(Œ†m
DS ) is also a CCS(Œ† ).
Any CCS(Œ†m
DS ) is thus sufficient for solving MOMDPs with linear f , even when stochastic and non-stationary policies are allowed. This is reflected in box (2) in Table 1. It also
applies to box (1) since the optimal policy in that case is just a member of this CCS(Œ†m
DS ),
i.e., the one that is best for the given known w.
Unfortunately, no result analogous to Corollary 1 holds for MOMDPs with monotonically increasing f . In the rest of this section, we discuss why this is so and the consequences
for the nature of an optimal MOMDP solution for boxes (3)-(6) in Table 1.
4.3.2 Multiple Deterministic Policies with Monotonically Increasing
Scalarization Functions
In the multiple-policy setting when only deterministic policies are allowed and f is nonlinear,
non-stationary policies may be better than the best stationary ones.
Theorem 2. In infinite-horizon MOMDPs, deterministic non-stationary policies can Paretodominate deterministic stationary policies that are undominated by other deterministic stationary policies (White, 1982).
To see why, consider the following MOMDP, denoted m1, adapted from an example by
White (1982). There is only one state and three actions a1 , a2 , and a3 , which yield rewards
(3, 0), (0, 3), and (1, 1), respectively. If we allow only deterministic stationary policies,
then there are three possible policies œÄ1 , œÄ2 , œÄ3 ‚àà Œ†m1
DS , each corresponding to always taking
one of the actions, all of which are Pareto optimal. These policies have the following
state-independent values (Equation 2): VœÄ1 = (3/(1 ‚àí Œ≥), 0), VœÄ2 = (0, 3/(1 ‚àí Œ≥)), and
VœÄ3 = (1/(1 ‚àí Œ≥), 1/(1 ‚àí Œ≥)). However, if we now consider the set of possibly non-stationary
m1
m1
policies Œ†m1
D (including non-stationary ones), we can construct a policy œÄns ‚àà Œ†D \ Œ†DS
that alternates between a1 and a2 , starting with a1 , and whose value is VœÄns = (3/(1 ‚àí
Œ≥ 2 ), 3Œ≥/(1 ‚àí Œ≥ 2 )). Consequently, œÄns ‚âªP œÄ3 when Œ≥ > 0.5 and thus we cannot restrict our
83

Roijers, Vamplew, Whiteson & Dazeley

attention to stationary policies.9 Consequently, in the multiple deterministic policies case
with monotonically increasing f , we need to find a P CS(Œ†m
D ), which includes non-stationary
policies, as shown in box (5) of Table 1.
In addition to having to consider a broader class of policies, another consequence is
that defining a policy indirectly via the value function is no longer possible. In standard
single-objective methods, the optimal policy can be found by doing local action selection
with respect to the value function: i.e., for every state, the policy selects the action that
maximizes the expected value. However, for local selection to yield a non-stationary policy, the value function must also be non-stationary, i.e., it must condition on the current
timestep. While this is standard in the finite-horizon setting, where a different value function is computed for each timestep, it is not possible in the infinite-horizon setting. We
discuss how to address this difficulty in Sections 5 and 6.
4.3.3 Multiple Stochastic Policies with Monotonically Increasing
Scalarization Functions
In the multiple policy setting where stochastic non-stationary policies, i.e., the full set Œ†m ,
are allowed, we again cannot consider only deterministic stationary policies. However, we
can employ stochastic stationary policies instead of deterministic non-stationary ones. In
particular, we can employ a mixture policy (Vamplew, Dazeley, Barker, & Kelarev, 2009)
œÄm that takes a set of N deterministic
policies, and selects the i-th policy from this set, œÄi
P
with probability pi , where N
p
=
1.
This leads to values that are a linear combination
i=0 i
of the values of the constituent policies. In our previous example, we can replace œÄns by a
policy œÄm that chooses œÄ1 with probability p1 and œÄ2 otherwise, resulting in the following
values:


3p1 3(1 ‚àí p1 )
œÄm
œÄ1
œÄ2
V = p1 V + (1 ‚àí p1 )V =
,
.
1‚àíŒ≥
1‚àíŒ≥
Fortunately, it is not necessary to explicitly represent an entire P CS(Œ†m ) explicitly.
Instead, it is sufficient to compute a CCS(Œ†m
DS ). The necessary stochastic policies to
create a P CS(Œ†m ) can then be easily constructed by making mixture policies from those
policies on the CCS(Œ†m
DS ).
Corollary 2. In an infinite horizon discounted MOMDP, an infinite set of mixture policies
PM can be constructed from policies that are on a CCS(Œ†m
DS ), such that this set PM , is a
m
P CS(Œ† ) (Vamplew et al., 2009).
Proof. We can construct a policy with any value vector on the convex surface, e.g., the
10 Thereblack lines in Figure 2a, by mixing policies on a CCS(Œ†m
DS ), e.g., the black dots.
fore, we can always construct a mixture policy that dominates a policy with a value under
this surface, e.g., B. We can show by contradiction that there cannot be any policy above
9. White (1982) shows this in an infinite-horizon discounted setting, but the arguments hold also for the
finite-horizon and average-reward settings.
10. Note that we should always mix policies that are ‚Äúadjacent‚Äù; the line between any pair of the policies
we mix should be on the convex surface. E.g. mixing the policy represented by the leftmost black dot
in Figure 2a and the policy represented by the rightmost black dot does not lead to optimal policies, as
the line connecting these two points is under the convex surface.

84

A Survey of Multi-Objective Sequential Decision-Making

the convex surface. If there was, it would be optimal for some w if f was linear. Consequently, by Corollary 1, there would be a deterministic stationary policy with at least
equal value. But since the convex surface spans the values on the CCS(Œ†m
DS ), this leads
to a contradiction. Thus, no policy can Pareto-dominate a mixture policy on the convex
surface.
Thanks to Corollary 2, it is sufficient to compute a CCS(Œ†m
DS ) to solve an MOMDP, as
reflected in box (6) of Table 1. A surprising consequence of this fact, which to our knowledge
is not made explicit in the literature, is that Pareto optimality, though the most common
solution concept associated with multi-objective problems, is actually only necessary in one
specific problem setting:
Observation 1. The multiple policy setting when f is monotonically increasing and only
deterministic policies are considered (box (5) of Table 1), requires computing a Pareto coverage set. When either f is linear or stochastic policies are allowed, a CCS(Œ†m
DS ) suffices.
Wakuta (1999) proves the sufficiency of a CCS(Œ†m
DS ) for monotonically increasing
scalarizations with multiple stochastic policies (box (6) of Table 1) in infinite horizon
MOMDPs, but in a different way. Instead of the mixture policies in Corollary 2, he uses stationary randomizations over deterministic stationary policies. Wakuta and Togawa (1998)
provide a similar proof for the average reward case.
Note that, while it is common to consider non-stationary or stochastic policies when f
is nonlinear, such policies typically condition only on the current state, or the current state
and time, not the agent‚Äôs reward history. However, in this setting, policies that condition
on that reward history can dominate those that do not. For example, suppose there are two
objectives which can take only positive values and f simply selects the smaller of the two, i.e.,
f (VœÄ , w) = mini ViœÄ . Suppose also that, in a given state, two actions are available, which
yields rewards of (4, 4) and (0, 5) respectively. Finally, suppose that the agent can arrive at
that state with one of two reward histories, whose discounted sums are either (5, 0) or (3, 3).
A policy that conditions on these discounted reward histories can outperform policies that
do not, i.e., the optimal policy selects the action yielding (4, 4) when the reward history sums
to (3, 3) and the action yielding (0, 5) when the reward history sums to (5, 0). So, while for
single objective MDPs the Markov property and additive returns are sufficient to restrict our
attention to policies that ignore history, in the multi-objective case, the scalarized returns
are no longer additive and therefore the optimal policy can depend on the history. Examples
of methods that exploit this fact are the ‚Äòsteering‚Äô approach (Mannor & Shimkin, 2001) and
the reward-augmented-state thresholded lexicographic ordering method by Geibel (2006),
which are discussed in Section 6.1.
4.3.4 Single Deterministic and Stochastic Policies with Monotonically
Increasing Scalarization Functions
All that remains to address is the single-policy setting with monotonically increasing f .
The nature of the optimal solution in this case follows directly from the reasoning given for
the multiple-policy setting.
If only deterministic policies are considered, then the single policy that is sought may
be non-stationary, as reflected in box (3) of Table 1, for the reasons elucidated by White‚Äôs
85

Roijers, Vamplew, Whiteson & Dazeley

example. Again, it is hard to define such a non-stationary policy by local action selection,
due to the risk of circular dependencies in the Q-values.
If stochastic policies are allowed, then the optimal policy may be stochastic, but this
can be represented as a mixture policy of two or more deterministic stationary policies, as
reflected in box (4) of Table 1, for the same reasons given in Corollary 2. In both cases,
policies can potentially benefit from conditioning on the reward history.

5. Planning in MOMDPs
In this section, we survey some key approaches to planning in MOMDPs, i.e., computing
an optimal policy or the coverage set of undominated policies given a complete model of
the MOMDP. Following the taxonomy presented in Section 4, we first consider single-policy
methods and then turn to multiple-policy methods for linear and monotonically increasing
scalarization functions.
5.1 Single-Policy Planning
In the known weights scenario, w is known before planning begins, and so only a single
policy, optimal for w, must be discovered. Since the MOMDP can be transformed to a
single-objective MDP when f is linear (see Section 4.2.1), we focus here on single-policy
planning for nonlinear f .
As discussed in Section 4.2.2, nonlinear f can cause the scalarized return to be nonadditive. Consequently, single-objective dynamic programming and linear programming
methods, which exploit the assumption of additive returns by employing the Bellman equation, are not applicable. However, different linear programming formulations for singlepolicy planning in MOMDPs are possible. A key feature of such methods is that they
can produce stochastic policies, which, as discussed in Section 4, can be optimal when the
scalarization function is nonlinear. While we are not aware of any single-policy planning
methods that work for arbitrary nonlinear f , methods have been developed for two special
cases. In particular, Perny and Weng (2010) propose a linear programming method for
MOMDPs scalarized using the Tchebycheff function mentioned in Section 4.2.2. Because
the Tchebycheff function always has a w for which any Pareto-optimal policy is optimal,
this approach can find any (single) policy on the Pareto front. In addition, Ogryczak, Perny,
and Weng (2011) propose an analogous method for the ordered weighted regret metric. This
metric calculates the regret of each objective with respect to an estimated ideal reference
point, sorts these into descending order, and calculates a weighted sum in which the weights
are also in descending order.
Other researchers have proposed single-policy methods for MOMDPs with constraints.
Feinberg and Shwartz (1995) consider MOMDPs with one regular objective and M objectives with inequality constraints. They show that if a feasible policy exists for this setting,
it can be deterministic and stationary after some finite number of timesteps N and that,
prior to timestep N , at most M random actions must be performed. They call this a (M, N )
policy, show that all Pareto-optimal values can be achieved by (M, N ) policies, and propose
a linear programming algorithm that finds «´-approximate policies for this setting. More
general MOMDPs with constraints have also been considered. In particular, Altman (1999)
proposes several linear programming approaches for such settings.
86

A Survey of Multi-Objective Sequential Decision-Making

FuÃàrnkranz, HuÃàllermeier, Cheng, and Park (2012) propose a framework for MDPs with
qualitative reward signals, which are related to MOMDPs but do not fit neatly in our
taxonomy. Qualitative reward signals indicate a preference between policies or actions
without directly ascribing a numeric value to them. Since such preferences induce a partial
ordering between policies, the policy iteration method the authors propose for this setting
may be applicable to MOMDPs with nonlinear f , as Pareto dominance also induces partial
orderings. However, the authors note that multi-objective tasks generally do have numeric
feedback that can be exploited. Thus, they suggest that quantitative MOMDPs can be
viewed as a subset of preference-based MDPs, and as such methods designed specifically
for MOMDPs may be more efficient than general preference-based methods.
5.2 Multiple-Policy Planning with Linear Scalarization Functions
In the multiple-policy setting with linear f , we seek a CCS(Œ†m
DS ). Note however, the
distinction between the convex hull and a convex coverage set is usually not made in the
literature.
One might argue that explicitly multi-objective methods are not necessary in this setting, because one could repeatedly run single-objective methods to obtain a CCS(Œ†m
DS ).
However, since there are infinitely many possible w, it is not obvious that all possible values for w can be covered. It might be possible to devise a way to run the single-objective
methods a finite number times and still guarantee that a CCS(Œ†m
DS ) is produced. However,
this would be a nontrivial result and the corresponding algorithm would in essence be a
multi-objective method that happens to use single-objective methods as subroutines.
One approach that has been attempted to find a minimally sized CCS(Œ†m
D ), i.e., a convex
coverage set of deterministic but not necessarily stationary policies, originally proposed by
White and Kim (1980), is to translate the MOMDP into a partially observable Markov
decision process (POMDP) (Sondik, 1971). An intuitive way to think about this translation
is to imagine that there is in fact only one true objective but the agent is unaware which of
the objectives in the MOMDP it is. This is modeled in the POMDP by defining the state
as a tuple hs1 , s2 i where s1 is the state in the MOMDP and s2 ‚àà {1 . . . n} indicates which is
the true objective. The observations thus identify s1 exactly but give no information about
s2 . Note that this translation from MOMDPs to POMDPs is one-way only. Not every
POMDP can be translated to an equivalent MOMDP.
Typically, an agent interacting with a POMDP maintains a belief, i.e., a probability
distribution over states. In a POMDP derived from an MOMDP, this belief can be decomposed into a belief about s1 and a belief about s2 . The former is degenerative because s1 is
known. The latter is a vector of size n in which the i-th element specifies the probability
that the i-th objective is the true one. This vector is analogous to w for a linear f . In
fact, this is the reason why Figure 2b resembles the piecewise linear value functions often
depicted for POMDPs; the only difference is whether the x-axis is interpreted as w or as a
belief.
White and Kim (1980) show that, in the finite horizon case, the solution for every belief
is exactly the solution for each w, and that the solutions for the resulting POMDP are
exactly those for the original MOMDP. The infinite horizon case is more difficult because
infinite horizon POMDPs are undecidable (Madani, Hanks, & Condon, 1999). However,
87

Roijers, Vamplew, Whiteson & Dazeley

for a sufficiently large horizon, the solution to a finite horizon POMDP can be used as an
approximate solution to an infinite horizon MOMDP.
To solve the resulting POMDP, White and Kim (1980) propose a combination of Sondik‚Äôs
one-pass algorithm (Smallwood & Sondik, 1973) and policy iteration for POMDPs (Sondik,
1978). However, any POMDP planning method can be used as long as it (1) does not
require an initial belief about the POMDP state (which would correspond to initializing
not only the MOMDP state but also w) and (2) computes the optimal policy for every
possible belief. More recently developed exact methods, e.g., Cassandra, Littman, and
Zhang (1997) and Kaelbling, Littman, and Cassandra (1998), meet these conditions and
could thus be employed. Approximate point-based POMDP methods (Spaan & Vlassis,
2005; Pineau, Gordon, & Thrun, 2006) do not meet conditions (1) and (2) but could be
adapted to compute an approximate convex hull, by choosing a prior distribution for the
weights from which they could sample. Online POMDP planning methods (Ross, Pineau,
Paquet, & Chaib-draa, 2008) are not applicable because they plan only for a given belief.
Converting to a POMDP thus allows the use of some but not all POMDP methods for
solving MOMDPs with linear f . However, this approach can be inefficient because it does
not exploit the characteristics that distinguish such MOMDPs from general POMDPs, i.e.,
that part of the state, s1 , is known and that no observations give any information about
s2 . For example, methods that compute policies trees, e.g., (Kaelbling et al., 1998) do not
exploit the fact that only deterministic policies that are stationary functions of the state
are needed for MOMDPs with linear f . Furthermore, as mentioned before, general infinite
horizon POMDPs are undecidable, but for MOMDPs it is in fact possible to compute the
CCS(Œ†m
DS ) exactly.
For these reasons, researchers have also developed specialized planning methods for this
setting. Viswanathan, Aggarwal, and Nair (1977) propose a linear programming approach
for episodic MOMDPs. Wakuta and Togawa (1998) propose a policy iteration approach
that has three phases. The first phase uses policy iteration to narrow down the set of
possibly optimal policies. The second phase uses linear programs to check for optimality.
Since this does not necessarily give a definitive answer, the third phase uses another linear
program to handle any undetermined solutions left after the second phase.
Barrett and Narayanan (2008) propose convex hull value iteration (CHVI), which computes the CH(Œ†m
), in every state. CHVI extends conventional value iteration by storing a
‚ó¶ DS
set of vectors, Q (s, a) for each state-action pair, representing the convex hull of policies involving that action. These sets of vectors correspond to the Q-values in the single-objective
setting; they contain the optimal Q-values for all possible w. When a backup operation is
performed, the Q-hulls at the next state s‚Ä≤ are propagated back to s. For each possible next
S ‚ó¶
state s‚Ä≤ , all possible actions a‚Ä≤ are considered (i.e. the union of convex hulls a‚Ä≤ Q (s‚Ä≤ , a‚Ä≤ ) is
taken), and weighted by the probability of s‚Ä≤ occurring when taking action a in state s. This
procedure is very similar to the witness algorithm (Kaelbling et al., 1998) for POMDPs.
Lizotte et al. (2010) propose a value-iteration approach for the finite-horizon setting
that computes a different value function for each timestep. In addition, it uses a piecewise
linear spline representation of the value functions. The authors prove this offers asymptotic
time and space complexity improvements over the representation used by CHVI and also
enables application of this algorithm to MOMDPs with continuous states. However, the
88

A Survey of Multi-Objective Sequential Decision-Making

algorithm is only applicable to problems with two objectives. This limitation is addressed
in the authors‚Äô subsequent work (Lizotte, Bowling, & Murphy, 2012) which extends the
algorithm to an arbitrary number of objectives and provides a detailed implementation for
the case of three objectives.
5.3 Multiple-Policy Planning with Monotonically Increasing Scalarization
Functions
In this section, we consider planning in MOMDPs with monotonically increasing f . As discussed in Section 4.3, when stochastic policies are allowed, mixture policies of deterministic
stationary policies are sufficient. Therefore, we focus on the case when only deterministic
policies are allowed and consider methods that compute a P CS(Œ†m
D ), which can include
non-stationary policies. The distinction between the P F (Œ†m
)
and
P
CS(Œ†m
D
D ) is usually not
made in the literature.
As in the linear case, scalarizing for every w and obtaining a P CS(Œ†m
D ) by the singleobjective methods is problematic. Again there are infinitely many w to consider but, unlike
the linear case, there is the additional difficulty that the scalarized returns may no longer
be additive, which can make single-objective methods inapplicable.
Daellenbach and Kluyver (1980) present an algorithm for multi-objective routing tasks
(essentially deterministic MOMDPs). Their approach uses dynamic programming in conjunction with an augmented state space to find all non-Pareto-dominated policies iteratively,
where the number of iterations equals the maximum number of steps in the route. The algorithm finds undominated sub-policies in parallel. The authors use two alternative explicit
scalarization functions, which they call the weighted minsum and weighted minmax operators. First, the values of all solutions are translated : for each objective, the new value
becomes the fractional difference between the optimal values for that objective across all
solutions. Then, the value for that objective is multiplied by a positive weight. Finally,
either the minimum of the sum (minsum) or the minimum of the maximal value (minmax )
of these new weighted fractional differences is chosen as the scalarization. Note that both
scalarization functions are monotonically increasing in all objectives, as the optimal value
for each objective individually does not depend on the scalarization function.
White (1982) extends this work by proposing a dynamic programming method that
approximately solves infinite horizon MOMDPs. It does so by repeatedly backing up according to a multi-objective version of the Bellman equation. Since the policies can be
non-stationary, the size of the Pareto front grows rapidly in the number of backups applied.
However, White notes that this number ‚Äúneed not be too large before acceptable approximations are reached‚Äù. Nonetheless, this approach is feasible only for small MOMDPs.
Wiering and De Jong (2007) address this difficulty with a dynamic programming method
called CON-MODP for deterministic MOMDPs that computes optimal stationary policies.
CON-MODP works by enforcing consistency during DP updates: a policy is consistent if
it suggests the same action at all timesteps for a given state. If an inconsistent policy is
inconsistent only in one state-action pair, CON-MODP makes it consistent by forcing the
current action to be taken each time the current state is visited. If the inconsistency runs
deeper, the policy is discarded.
89

Roijers, Vamplew, Whiteson & Dazeley

By contrast, Gong (1992) proposes a linear programming approach that finds the Paretofront of stationary policies. However, as the authors note, this approach is also suitable
only to small MOMDPs because the number of constraints and decision variables in the
linear program increase rapidly as the state space grows.
As mentioned in Section 4.2.2, one way to cope with intractably large Pareto fronts is
to compute instead an «´-approximate Pareto front, which can be much smaller. Chatterjee
et al. (2006) propose a linear programming method that computes the «´-approximate front
for an infinite horizon MOMDP, while Chatterjee (2007) propose an analogous algorithm
for the average reward setting. In both cases, stationary stochastic policies are shown to be
sufficient.
Another way to improve scalability in this setting is to give up on planning for the whole
state space and instead plan on-line for the agent‚Äôs current state, using a Monte Carlo tree
search approach (Kocsis & SzepesvaÃÅri, 2006). Such approaches, which have proven very
successful, e.g., in the game of Go (Gelly & Silver, 2011), are increasingly popular for
single-objective MDPs. Wang and Sebag (2013) propose a Monte Carlo tree search method
for deterministic MOMDPs. Single-objective tree search methods typically optimistically
explore the tree by selecting actions that maximize the upper confidence bound of their
value estimates. The multi-objective variant does the same, but with respect to a scalar
multi-objective value function whose definition is based on the hypervolume indicator induced by the proposed action together with the set of Pareto optimal policies computed so
far. The hypervolume indicator (Zitzler, Thiele, Laumanns, Fonseca, & da Fonseca, 2003)
measures the hypervolume that is Pareto-dominated by a set of points. Since the Pareto
front maximizes the hypervolume indicator, this optimistic action selection strategy focuses
the tree search on the branches most likely to compliment the existing archive.

6. Learning in MOMDPs
The methods reviewed in Section 5 assume that a model of the transition and reward
dynamics of the MOMDP are known. In cases where such a model is not directly available,
multi-objective reinforcement learning (MORL) can be used instead.
One way to carry out MORL is to take a model-based approach, i.e., use the agent‚Äôs
interaction with the environment to learn a model of the transition and reward function of
the MOMDP and then apply multi-objective planning methods such as those described in
Section 5. Though such an approach seems well suited to MORL, only a few papers have
considered it, (e.g., Lizotte et al., 2010, 2012). We discuss opportunities for future work
in model-based MORL in Section 8.1. Instead, most of the work in MORL has focused on
model-free methods, where a model of the transition and reward function is never explicitly
learned.
In this section, we survey some key MORL approaches. While the majority of these
methods are for the single-policy setting, multiple-policy methods have also been developed. At first glance, it may seem that multiple-policy methods are unlikely to be effective
in the learning setting, since finding more policies would increase sample costs, not just
computational costs, and the former is typically a much scarcer resource. However, modelbased methods can obviate this issue: once enough samples have been gathered to learn a
useful model, finding policies optimal for more weights requires only computation. Model90

A Survey of Multi-Objective Sequential Decision-Making

free methods can also be practical for the multiple-policy setting if they employ off-policy
learning (Sutton & Barto, 1998; Precup, Sutton, & Dasgupta, 2001), which makes it possible to learn about one policy using data gathered by another. In this way, policies for
multiple weight settings can be optimized using the same data.
6.1 Single-Policy Learning Methods
In the known weights scenario, a MORL algorithm aims to learn a single policy that is
optimal for the given weights. As discussed in Section 5.1, under linear scalarization this
is equivalent to learning the optimal policy for a single-objective MDP and so standard
temporal-difference (TD) methods (Sutton, 1988) such as Q-learning (Watkins, 1989) can
easily be applied.
However, even though no specialized methods are needed to address this setting, it
is nonetheless the most commonly studied setting for MORL. Linear scalarization with
uniform weights, i.e., all the elements of w are equal, forms the basis of the work of Karlsson
(1997), Ferreira, Bianchi, and Ribeiro (2012), Aissani, Beldjilali, and Trentesaux (2008) and
Shabani (2009) amongst others, while non-uniform weights have been used by authors such
as Castelletti et al. (2002), Guo et al. (2009) and Perez et al. (2009). The majority of this
work uses TD methods, which work on-line, although Castelletti et al. (2010) extend off-line
Fitted Q-Iteration (Ernst, Geurts, & Wehenkel, 2005) to multiple objectives.
In most cases, the only change made to the underlying RL algorithm is that, rather than
scalarizing the reward function and then learning a scalar value function in the resulting
single-objective MDP, a vector-valued value function is learned in the original MOMDP and
then scalarized only when selecting actions. The argument for this approach is that the
values of individual objectives may be easier to learn than the scalarized value, particularly
when function approximation is employed (Tesauro et al., 2007). For example, each function
approximator can ignore any state variables that are irrelevant to its objective, reducing
the size of the state space and thereby speeding learning.
As discussed in Section 4.2.2, linear scalarization may not be appropriate for some scenarios. Vamplew, Yearwood, Dazeley, and Berry (2008) demonstrate empirically that this
can have practical consequences for MORL. Therefore, MORL methods that can work with
nonlinear scalarization functions are of substantial importance. Unfortunately, as illustrated
in Section 4.2.2, coping with this setting is especially challenging, since algorithms such as
TD methods that are based on the Bellman equation are inherently incompatible with
nonlinear scalarization functions due to the non-additive nature of the scalarized returns.
Four main classes of single-policy MORL methods using non-linear scalarization have
arisen, which differ in how they deal with this issue. The first class simply applies TD
methods without modification. These approaches either resign themselves to being heuristics that are not guaranteed to converge or impose restrictions on the environment to ensure
convergence. The second class modifies either the TD algorithm or the state representation
such that the issue of non-additive returns is avoided. The third class uses TD methods
to learn multiple policies using linear scalarization with different values for w, and then
forms a stochastic or non-stationary ‚Äòmeta-policy‚Äô from them that is optimal with respect
to a nonlinear scalarization. The fourth class uses policy-search methods, which do not
91

Roijers, Vamplew, Whiteson & Dazeley

make use of the Bellman equation and hence can be directly applied in combination with
nonlinear scalarizations.
The first class includes methods that model the problem as a multi-agent system, with
one agent per objective. Each agent learns and recommends actions on the basis of the
return for its own objective. A global switch then selects a winning agent, whose recommended action is followed for the current state. Examples include a simple ‚Äòwinner-takes-all‚Äô
approach in which the agent whose recommended action has the highest Q-value is selected,
or more sophisticated approaches such as W-learning (Humphrys, 1996) where the selected
action is the one that will incur the most loss if it is not followed. One key weakness of
such approaches was pointed out by Russell and Zimdars (2003): they do not allow for the
selection of actions that, while not optimal for any single objective, offer a good compromise
between multiple objectives. Another key weakness is that, since the actions selected at
different timesteps may be recommended by different agents, the resulting behavior corresponds to a policy that combines elements of those learned by each agent. This combination
may not be optimal even for a single objective, i.e., it may be Pareto dominated and perform
arbitrarily poorly.
TD has also been used directly with nonlinear scalarization functions that do allow for
the consideration of all actions, not just those which are optimal with regards to individual
objectives. Scalarization functions based on fuzzy logic have been proposed for problems
with discrete actions by Zhao, Chen, and Hu (2010) and for problems with continuous
actions by Lin and Chung (1999). A widely cited approach to nonlinear scalarization is
that of Gabor, Kalmar, and Szepesvari (1998), which is designed for tasks where constraints
must be satisfied for some objectives. A lexicographic ordering of the objectives is defined
and a threshold value is specified for all objectives except the last. State-action values for
each objective that exceed the corresponding threshold are clamped to that threshold value
prior to applying the lexicographic ordering. Thus, this thresholded lexicographic ordering
(TLO) approach to scalarization maximizes performance on the last objective subject to
meeting constraints on the other objectives as specified by the thresholds.
While methods combining TD with nonlinear scalarization may converge to a suitable
policy under certain conditions, they can also converge to a suboptimal policy or even fail
to converge under other conditions. For example, Issabekov and Vamplew (2012) demonstrate empirically that TLO can fail to converge to a suitable policy for episodic tasks if a
constrained objective receives non-zero rewards at any timestep other than the end of the
episode. In general, methods based on the combination of TD and nonlinear scalarization
must be regarded as heuristic in nature, or applicable only to restricted classes of problems.
The second class avoids the problems caused by non-additive scalarized returns by modifying either the TD algorithm or the state representation. To our knowledge, two approaches
proposed by Geibel (2006) to address the limitations of TLO are the only members of this
class. Both require that the reward accumulated for each objective over the current episode
be stored. In the first algorithm, local decision-making is based on the scalarized value of
the sum of the cumulative reward and the current state-action values. This eliminates the
problem of non-additive returns, but yields a policy that is non-stationary with respect to
the observed state, meaning the algorithm may not converge. The second approach augments the state representation with the cumulative reward. This approach converges to the
correct policy but learns slowly, due to the increase in the size of the state space.
92

A Survey of Multi-Objective Sequential Decision-Making

The third class uses TD methods only to learn policies based on linear scalarizations.
A policy selection mechanism based on a nonlinear scalarization is then used to form a
‚Äòmeta-policy‚Äô from these base policies. The Multiple Directions Reinforcement Learning
(MDRL) algorithm of Mannor and Shimkin (2001, 2004) uses such an approach in the
context of on-line learning for non-episodic tasks. The user specifies a target region within
which the long-term average reward should lie. An initial active policy is chosen arbitrarily
and followed until the average reward moves outside of the target region and the agent is
in a specified reference state. At this point, the direction from the current average reward
vector to the closest point of the target set is calculated, and the policy whose direction best
matches this target direction is selected as the active policy. In this way, the average reward
is ‚Äòsteered‚Äô towards the user‚Äôs specified target region. While the underlying base policies
utilize linear scalarization, the nature of the policy-selection mechanism means that the
overall non-stationary policy formed from these base policies is optimal for the nonlinear
scalarization specified by the user‚Äôs defined target set. Vamplew et al. (2009) suggest a
similar approach for episodic tasks, with TD used first to learn policies that are optimal
under linear scalarization for a range of different w, before a stochastic mixture policy is
constructed that is optimal with regards to a nonlinear scalarization.
The fourth class uses policy-search algorithms that directly learn a policy without learning a value function. For single-policy MORL, research on policy-search approaches has
focused on policy-gradient methods (Sutton, McAllester, Singh, & Mansour, 2000; Kohl &
Stone, 2004; Kober & Peters, 2011). In such methods, a policy is iteratively adjusted in the
direction of the gradient of the value with respect to the parameters (usually probability
distributions over actions per state) of a policy. Shelton (2001) proposes an algorithm that
first learns the optimal policy for each individual objective. These are used as base policies to form an initial mixture policy that stochastically selects a base policy at the start
of each episode. A hill-climbing method based on a weighted convex combination of the
normalized objective gradients iteratively improves the mixture policy. This approach does
not directly fit our taxonomy because the returns themselves are never scalarized. Instead,
the weights are used to find a step direction relative to the current policy parameters. From
a practical perspective, its behavior is akin to that of single-policy RL using a nonlinear
scalarization function, as it converges to a single Pareto-optimal policy that need not lie
on the convex hull. Uchibe and Doya (2009) also propose a policy-gradient method for
MORL called Constrained Policy Gradient RL (CPGRL) which uses a gradient projection technique to find policies whose average reward satisfies constraints on one or more of
the objectives. Like Shelton‚Äôs approach, CPGRL learns stochastic policies and works with
nonlinear scalarization functions.
6.2 Multiple-Policy Learning with Linear Scalarization Functions
In the unknown weights and decision support scenarios, if f is linear, then MORL algorithms
aim to learn a CCS of the possible policies. A simple but inefficient approach used by
Castelletti et al. (2002) is to run TD multiple times with different values of w. In the
simplest case, the runs are conducted sequentially to gradually build up an approximate
CCS. Natarajan and Tadepalli (2005) showed that this approach can be made more efficient
by reusing the policies learned on the earlier runs for the most similar w. They show that
93

Roijers, Vamplew, Whiteson & Dazeley

this improves greatly on sample costs when learning a policy for w similar to those already
visited in previous runs. However, many samples are typically still required before a good
approximate CCS is obtained.
A more sophisticated approach to approximating a convex coverage set is to learn multiple policies in parallel. Several algorithms have been proposed to achieve this within a
TD learning framework. The approach of Hiraoka, Yoshida, and Mishima (2009) is similar
to the CHVI planning algorithm of Barrett and Narayanan (2008) (see Section 5.2) in that
it learns in parallel the optimal value function for all w, using a convex hull representation.
This approach is prone to infinite growth in the number of vertices in convex hull polygons,
and so a threshold margin is applied to the hull representations on each iteration, eliminating points that contribute little to the hull‚Äôs hypervolume. Hiraoka et al. (2009) present an
algorithm to adapt the margins during learning to improve efficiency, but note that many
parameters must be tuned for effective performance. Mukai, Kuroe, and Iima (2012) present
a similar extension of CHVI to a learning context. They address the problematic growth
in the number of values stored by pruning vectors after each Q-value update: a vector is
selected at random from the set of vectors stored for the given state-action pair and all
others lying within a threshold distance of it are deleted.
The approaches of both Hiraoka et al. (2009) and Mukai et al. (2012) are designed for
on-line learning. By contrast, Multi-Objective Fitted Q-Iteration (MOFQI) (Castelletti,
Pianosi, & Restelli, 2011, 2012) is an off-line approach to learning multiple policies. MOFQI
is a multi-objective extension of the Fitted Q-Iteration (FQI) algorithm (Ernst et al., 2005)
which uses a combination of historical data about the single-step transition dynamics of the
environment, an initial function approximator, and the Q-learning update rule to construct
a dataset that maps state-action pairs to their expected return. This dataset is then used
to train an improved function approximator and the process repeats until the values of the
function approximator converge. MOFQI provides a computationally efficient extension of
FQI to multiple objectives by including w in the input to the function approximator and
constructing an expanded training data set containing training instances with randomly
generated w‚Äôs. Since the learned function generalizes across weight space in addition to
state-action space, it can be used to construct a policy for any w.
As discussed in Section 5.3, Lizotte et al. (2010) and Lizotte et al. (2012) describe a valueiteration algorithm to find the convex hull of policies for finite horizon tasks. They note that
this method can be applied in a learning context by estimating a model of the state transition
probabilities and immediate rewards on the basis of experience of the environment. This
approach is demonstrated for the task of analyzing randomized drug trial data by producing
these estimates from the historical data gathered during the clinical trials.
6.3 Multiple-Policy Learning with Monotonically Increasing Scalarization
Functions
If f is nonlinear, then MORL algorithms for the unknown weights and decision support scenarios should aim to learn a PCS. As in the linear scalarization case, the simplest approach
is to run single-objective algorithms multiple times with varying w. Shelton (2001) demonstrates this approach with a policy-gradient algorithm, while Vamplew et al. (2011) do the
same with the TLO method of Gabor et al. (1998). This approach however, requires that
94

A Survey of Multi-Objective Sequential Decision-Making

f is explicitly known to the learning algorithm, which may be undesirable in the decision
support scenario.
To our knowledge, there are currently no methods for learning multiple policies with
nonlinear f using a value-function approach. While it might seem possible to adapt convex
hull methods such as CHVI by using Pareto-dominance operators in place of convex-hull
calculations, doing so is not straightforward. Because the scalarized values of policies in a
certain state are non-additive, we cannot restrict ourselves to stationary policies if we want
to find all deterministic Pareto-optimal policies (as mentioned in Section 4.3.2). However,
for the Bellman equation from CHVI to work, additivity, and the resulting sufficiency of
deterministic policies, is required. We discuss options for developing multiple-policy learning
methods for nonlinear f in Sections 8.1 and 8.2.
Given the extensive research on both multi-objective evolutionary algorithms (MOEAs)
(Coello Coello, Lamont, & Van Veldhuizen, 2002; Tan, Khor, Lee, & Sathikannan, 2003;
Drugan & Thierens, 2012) and evolutionary methods for RL (Whiteson, 2012), there is surprisingly little work on evolutionary approaches to MORL. As these methods are populationbased, they are well suited to approximating Pareto fronts, and would thus seem a natural
fit when f is nonlinear. To our knowledge, Handa (2009b) was the first to apply MOEAs
to MORL, by extending Estimation of Distribution (EDA) evolutionary algorithms to handle multiple objectives. EDA-RL (Handa, 2009a) uses Conditional Random Fields (CRF)
to represent probabilistic policies. An initial set of policies are used to generate a set of
episodes. The best episodes from this set are selected and CRFs that are likely to produce these trajectories are generated. The policies formed from these CRFs then constitute
the next generation. Handa (2009b) extends EDA-RL to MOMDPs by using a Paretodominance based fitness metric to select the ‚Äòbest‚Äô episodes.
Soh and Demiris (2011) also apply MOEAs to MORL. Policies are represented as
Stochastic Finite State Controllers (SFSC) and are optimized using two different MOEAs:
NSGA2, a standard evolutionary algorithm, and MCMA, an EDA. The use of SFSCs gives
rise to a large search space, necessitating the addition of a local search operator. The local
search generates a random w, uses it to scalarize the rewards, and performs gradient-based
search on the SFSC. Empirical comparisons on multi-objective variants of three POMDP
benchmarks demonstrate that the evolutionary methods are generally superior to the purely
local-search approach, and that local search combined with evolution usually outperforms
the purely evolutionary methods. This is one of very few papers to directly consider partially
observable MOMDPs.

7. MOMDP Applications
Multi-objective methods for planning and learning have been employed in a wide range
of applications, both in simulation and real-world settings. In this section, we survey
these applications. For the sake of brevity, this list is not comprehensive but instead aims
to provide an illustrative range of examples. First, we discuss the use of multi-objective
methods in specific applications. Second, we discuss research that has identified broader
classes of problems in which multi-objective methods can play a useful role.
95

Roijers, Vamplew, Whiteson & Dazeley

7.1 Specific Applications
An important factor driving interest in multi-objective decision-making is the increasing
social and political emphasis on environmental concerns. More and more, decisions must
be made that trade off economic, social, and environmental objectives. This is reflected in
the fact that a substantial proportion of applications of multi-objective methods have an
environmental component.
Perhaps the most extensively researched application is the water reservoir control problem considered by Castelletti et al. (2002), Castelletti, Pianosi, and Soncini-Sessa (2008),
Castelletti et al. (2011, 2012) and Castelletti, Pianosi, and Restelli (2013). The general
task is to find a control policy for releasing water from a dam while balancing multiple uses
of the reservoir, including hydroelectric production and flood mitigation. Management of
hydroelectric power production has also been examined by Shabani (2009). Another environmental application is that of forest management to balance the economic benefits of
timber harvesting with environmental or aesthetic objectives, which has been demonstrated
in simulation by both Gong (1992) and Bone and Dragicevic (2009).
Several researchers have also considered environmentally-motivated applications concerning the management of energy consumption. The SAVES system developed by Kwak
et al. (2012) controls various aspects of a commercial building (lighting, heating, airconditioning, and computer systems) to provide a suitable trade-off between energy consumption and the comfort of the building‚Äôs occupants. Simulation results indicate that
SAVES can reduce energy consumption approximately 30% compared to a manual control
system, while maintaining or slightly improving occupant comfort. Both Tesauro et al.
(2007) and Liu et al. (2010) consider the problem of controlling a computing server, with
the objectives of minimizing both response time to user requests and power consumption.
Guo et al. (2009) apply MORL to develop a broker agent in the electricity market. The
broker sets caps for a group of agents that sit below it in a hierarchy and manage energy
consumption at a device level, and must balance energy cost and system stability.
Shelton (2001) also examines the application of MORL to developing broker agents.
However, in this case the agent‚Äôs task is financial rather than environmental, acting as a
market maker that sets buy and sell prices for resources in a market. The aim is to balance
the objectives of maximizing profit and minimizing spread (the difference between the buy
and sell prices) as that will lead to a larger volume of trades11 .
Computing and communications applications have also been widely considered. Perez
et al. (2009) apply MORL to the allocation of resources to jobs in a cloud computing scenario, with the objectives of maximizing system responsiveness, utilization of resources, and
fairness amongst different classes of user. Comsa et al. (2012) consider how to maximize
system throughput and ensure user equity in the context of a Long Term Evolution mobile
communications packet scheduling protocol. Tong and Brown (2002) use constraint-based
scalarization to address the tasks of call access control and routing in a broadband multimedia network. Their system aims to maximize profit (a function of throughput) while
satisfying constraints on quality of service metrics (capacity constraints and fairness constraints), and uses methods similar to that of Gabor et al. (1998). Zheng, Li, Qiu, and Gong
11. Shelton‚Äôs model of the market does not directly model trading volume, and so spread is used as a proxy
for volume.

96

A Survey of Multi-Objective Sequential Decision-Making

(2012) also use constrained MORL methods to make routing decisions in a cognitive radio
network, aiming to minimize average transmission delay while maintaining an acceptably
low packet loss rate.
Industrial and mechanical control, an important application for single-objective MDP
methods, has also been explored by MOMDP researchers. Aoki, Kimura, and Kobayashi
(2004) apply distributed RL to control a sewage flow system, exploiting the system‚Äôs hierarchical structure to find a solution that minimizes violation of stock levels at each node
in the flow system, while smoothing variation in flow at the source. Aissani et al. (2008)
apply MORL to maintenance scheduling within a manufacturing plant to minimize the time
taken to complete all maintenance tasks and machine downtime. Aissani, Beldjilali, and
Trentesaux (2009) build on this work by applying it to a simulation of a real petroleum refinery and demonstrating the ability to adapt to unscheduled corrective maintenance required
due to equipment failures. The control of a wet clutch in heavy-duty transmission systems
is examined by Van Vaerenbergh et al. (2012). There are twin objectives of minimizing
engagement time, while also making the transition smooth.
Robotics are also a popular application for MOMDPs, though most work so far has been
in simulation rather than on real robots. Maravall and de Lope (2002) consider the control
of a two-limbed brachiating robot, with the objectives of moving in a desired direction
while avoiding collisions12 . Nojima, Kojima, and Kubota (2003) also attempt to balance
the objectives of progress to a target and collision avoidance. Their agent makes use of
predefined behavioral modules for target tracing, collision avoidance, and wall following,
with MORL used to dynamically adjust the weighting of the modules. Meisner (2009)
identifies social robots as a promising application of MOMDP methods: their behavior is
inherently multi-objective because they must carry out a task without causing anxiety or
discomfort for humans.
MORL has also been applied to the control of traffic infrastructure. Yang and Wen
(2010) apply it to the control of freeway on-ramps and vehicle management systems, aiming
to maximize both the throughput and equity of a freeway system. Multiple agents with
shared policies are used, with action selection occurring via negotiation between agents.
Similarly, Dusparic and Cahill (2009) apply MORL to control traffic lights at intersections
in an urban environment to minimize waiting time of two different classes of vehicles. Yin,
Duan, Li, and Zhang (2010) and Houli, Zhiheng, and Yi (2010) also apply MORL to traffic
light control. The novelty of their approach lies in considering different objectives based
on the current state of the road system; minimizing vehicle stops is prioritized when traffic
is free-flowing; minimizing waiting time is emphasized when the system is at medium load;
and minimizing queue length at intersections is targeted when the system is congested.
Lizotte et al. (2010, 2012) consider a medical application: prescribing an appropriate
drug regime for a patient so as to achieve an acceptable trade-off between the drugs‚Äô effectiveness and the severity of its side effects. Their system learns multiple policies based on
12. In many robotic applications it may be ideal to avoid collisions completely, but in some environments
this may not be possible (e.g., in the presence of moving obstacles whose velocity is both faster than that
of the robot, and difficult to predict, such as may be the case for humans or human-controlled vehicles)
and so reducing both the likelihood and impact of collisions may be more reasonable than attempting
to find a collision-free policy. See for example Holenstein and Badreddin (1991) and Pervez and Ryu
(2008).

97

Roijers, Vamplew, Whiteson & Dazeley

static data produced during randomized controlled drug trials. The selection of the best
treatment for a specific patient is then made by a doctor based on that patient‚Äôs individual circumstances. This application is an excellent example of a problem where stochastic
approaches like mixture policies are inappropriate. A policy that maximizes both symptom relief and also side effects for one patient and then minimizes side effects but also
symptom relief for the next patient may appear to give excellent results when averaged
across episodes. However, the experience of each individual patient will likely be regarded
as undesirable.
7.2 Applications within Broader Planning and Learning Tasks
In addition to the specific applications discussed above, several authors have identified more
general classes of tasks in which multi-objective sequential decision-making can be applied.
7.2.1 Probabilistic and Risk-Aware Planning
Cheng, Subrahmanian, and Westerberg (2005) argue that decision-making under uncertainty is inherently multi-objective in nature. Even if there is only a single reward to be
considered (such as profit), the environmental uncertainty means that the expected value
alone is insufficient to support good decision-making; the decision-maker must also consider
the variance of the return. Similarly, Bryce (2008) states that probabilistic planning is
inherently multi-objective due to the need to optimize both the cost and the probability of
success of the plan. He criticizes approaches that either aggregate these factors or bound one
and then optimize the other, arguing in favor of explicitly multi-objective methods. The
aptly named ‚ÄúProbabilistic Planning is Multi-objective!‚Äù paper by Bryce, Cushing, and
Kambhampati (2007) demonstrates how this might be achieved, describing a method based
on multi-objective dynamic programming over belief states, and a multi-objective extension
of the Looping AO* search algorithm to find the set of Pareto-optimal plans. Recent work
by Kolobov, Mausam, and Weld (2012) and Teichteil-KoÃànigsbuch (2012b) examine the extension of stochastic shortest path (SSP) methods to problems where dead-end states exist.
SSP methods assume that at least one policy exists which is guaranteed to reach the goal;
in the presence of dead-ends no such policy exists, and so the authors propose algorithms
which aim to both maximize the probability of reaching the goal and minimize the cost of
the paths found to that goal.
Bryce (2008) notes that a probabilistic plan fails when the environment enters a non-goal
absorbing state. Hence, multi-objective probabilistic planning has strong parallels with the
research into risk-aware RL carried out by Geibel (2001) and Geibel and Wysotzki (2005),
which add a second reward signal indicating the transition of the environment into an error
state. Defourny, Ernst, and Wehenkel (2008) also provide useful insights into the incorporation of risk-awareness into MDP methods. They review a range of criteria proposed
for constraining risk, and note that many of these are nonlinear and produce non-additive
scalarized returns that are incompatible with the local decision-making of methods based
on the Bellman equation. They recommend that custom risk-control requirements should
be mostly enforced heuristically, by altering policy optimization procedures and checking
the compliance of the policies with the initial requirements. Multi-policy MOMDP methods treating risk as an additional objective would satisfy this requirement: having iden98

A Survey of Multi-Objective Sequential Decision-Making

tified the coverage set, any risk-aware metric can then be used to select the best policy.
However, some measures of risk may not be expressed directly as discounted cumulative
rewards. For example, an agent may wish to minimize the variance in the expected return for a particular reward signal rather than its discounted cumulative value. Methods
based on multi-objective probabilistic model checking (Courcoubetis & Yannakakis, 1998;
Forejt, Kwiatkowska, Norman, Parker, & Qu, 2011; Forejt, Kwiatkowska, & Parker, 2012;
Teichteil-KoÃànigsbuch, 2012a), which evaluate whether a system modelled as an MDP satisfies multiple, possibly conflicting, properties, may be suitable for such tasks.
7.2.2 Multi-Agent Systems
The use of MDPs within multi-agent systems has been widely explored (Bosoniu, Babuska,
& Schutter, 2008), and several authors have proposed approaches that are strongly related
to MOMDPs. In a multi-agent system, each agent has its own objective, but for effective
overall performance must also consider how its actions will affect the other agents. If the
agents are not completely self-interested, then this problem can be framed as an MOMDP by
treating the effects on other agents as additional objectives. For example, Mouaddib (2006)
uses multi-objective dynamic programming to facilitate cooperation between multiple agents
whose underlying goals may be conflicting. For each state-action pair, each agent stores
three values: its local utility, the gain other agents receive, and the penalty it inflicts on
other agents. The policy for each agent is then established by converting these vector values
to regret ratios and applying a leximin ordering to these ratios.
Dusparic and Cahill (2010) compare the application of MORL to multi-agent tasks with
other multi-agent methods such as evolutionary and ant-colony algorithms. Dusparic and
Cahill (2009) extend the W-Learning algorithm of Humphrys (1996). Each agent learns
both local policies (one for each of its own objectives) and remote policies (one for each
local policy of each of its neighboring agents). At each timestep, all local policies and all
active remote policies of each agent nominate actions, and a winning action is selected by
combining action values across all nominating policies. A weighting term is applied to the
values of remote policies to determine the level of cooperation each agent offers its neighbor.
Experimental results in an urban traffic control simulator show substantial improvement
when the level of cooperation is non-zero. This work is similar to that of Schneider, Wong,
Moore, and Riedmiller (1999), which addresses the use of multiple agents in a distributed
network such as a power distribution grid, where the aim is to maximize a global reward
formed from a combination of each agent‚Äôs local reward. They demonstrate that if each
agent focuses only on its own local reward, the policies learned may not maximize the global
reward, and that performance is improved by having each agent perform linearly scalarized
learning using both its own local reward and the rewards of its neighboring agents.
7.2.3 Multi-Objective Optimization using Reinforcement Learning
Reinforcement learning is primarily applied to sequential decision-making tasks in a dynamic
environment. However it can also be employed to control search mechanisms for static optimization tasks such as scheduling (Carchrae & Beck, 2005). Multi-objective optimization
for static tasks such as design is a well-established field and, while the majority of this work
99

Roijers, Vamplew, Whiteson & Dazeley

has employed mathematical or evolutionary approaches (Coello Coello et al., 2002), a few
authors have explored the application of reinforcement learning in such contexts.
Mariano and Morales (1999, 2000b, 2000a) investigate the use of RL methods (Ant-Q
and Q-learning) as a search mechanism for optimization of multi-objective design tasks. The
values of the decision variables are considered as the current state, and actions are defined
that alter the values of those variables. Multiple agents explore the state space in parallel.
Agents are divided into ‚Äòfamilies‚Äô, where each family focuses on a single objective. At the
end of an episode, the final states found by each agent are evaluated. Undominated solutions are kept in an archive and the agents that discovered those solutions are rewarded,
increasing the likelihood of similar policies being followed in the future. The method is
shown to work on a small number of test problems from the evolutionary multi-objective
optimization literature. Liao, Wu, and Jiang (2010) apply RL to search for static control
settings for a power generation system with the objectives of reducing fuel usage and ensuring voltage stability. They propose an RL algorithm that is formulated specifically for tasks
with high-dimensional state spaces, and compare its performance against an evolutionary
multi-objective algorithm, finding that the RL method discovers fronts that are both more
accurate and better distributed, while also improving the speed of search.
Note that to effectively apply RL to multi-objective optimization, assumptions are usually made about the nature of the environment. For example, Liao et al. (2010) require
that each action increases or decreases the value of precisely one state variable. As a result,
these methods are likely to have limited applicability to the more general MORL problems
described earlier.

8. Future Work
In this section, we enumerate some of the possibilities for future research in multi-objective
planning and learning.
8.1 Model-Based Methods
As mentioned in Section 6, there has been very little work on model-based approaches to
MORL. Given the breadth of planning methods for MOMDPs, which could be employed in
model-based MORL methods as subroutines, this is surprising. To our knowledge, the only
work in this area is that of Lizotte et al. (2010, 2012), where a model of the MOMDP‚Äôs
transition probabilities and reward function is derived from historical data, and then a
spline-based multi-objective value iteration approach is applied to that model. In general,
learning such models seems only negligibly harder than in the single-objective setting, since
estimates of each reward function can just be learned separately. The problem of learning
the transition function, generally considered the hard part of model learning, is identical to
the single-objective setting. Especially in multiple-policy scenarios, model-based approaches
to MORL could greatly reduce sample costs: once the model has been learned, an entire
CCS or PCS can be computed off-line, without requiring additional samples.
100

A Survey of Multi-Objective Sequential Decision-Making

8.2 Learning Multiple Policies with Monotonically Increasing Scalarization
Functions using Value Functions
As mentioned in Section 6.3, we are not aware of any methods that use a value function
approach to learn multiple policies on the PCS. When stochastic policies are permitted,
the problem is easier because we can learn CCS(Œ†m
DS ), and use either mixture policies
(Vamplew et al., 2009) or stationary randomizations (Wakuta, 1999) of the policies on
this CCS (see Section 4.3.3). However, when only deterministic policies are permitted, the
problem is more difficult. One option could be to use a finite-horizon approximation to the
infinite horizon problem. By planning backwards from the planning horizon, the expected
reward of t timesteps to go approximates the infinite-horizon value better and better as
t ‚Üí ‚àû. As mentioned in Section 5.2, similar approaches have been used in the POMDP
setting. Another way to find good approximations to non-stationary policies could be to
learn stationary policies (perhaps by extending CON-MDP (Wiering & De Jong, 2007) to
the learning setting), and prefix them by t timesteps of non-stationary policy.
8.3 Many-Objective Sequential Decision-Making
The majority of the research reviewed in this article, both theoretical and applied, deals with
MOMDPs with only a few objectives. This mirrors the state of early evolutionary multiobjective research, which focused almost exclusively on problems with two or at most three
objectives. However, over the last decade there has been growing interest in evolutionary
methods for so-called many-objective problems, which have at least four and sometimes
more than fifty objectives (Ishibuchi, Tsukamoto, & Nojima, 2008). This research has
shown that many algorithms that perform well for a few objectives scale poorly in the
number of objectives, necessitating special algorithms for the many-objective setting.
While many-objective MDPs have received little consideration so far, there are numerous real-world control problems that can be naturally modeled in this way. For example,
Fleming et al. (2005) point out that many-objective control problems commonly arise in
engineering, and give the example of a jet engine control system with eight objectives. As
with the many-objective problems considered in evolutionary computation, it seems likely
that at least some of the methods explored so far will scale poorly in the number of objectives. For example, the multi-policy MOMDP planning algorithm described by Lizotte
et al. (2010) is limited to problems with two objectives.
A key challenge posed by many-objective problems is that the number of undominated
solutions typically grows exponentially in the number of objectives. This is particularly
problematic for multiple-policy MOMDP methods. Fleming et al. (2005) note that one
of the most effective approaches used in many-objective evolutionary computation is to
incorporate user preferences to restrict the search space to a small region of interest. In
particular, they recommend interactive preference articulation in which the user interactively steers the system towards a desirable solution during optimization. While Vamplew
et al. (2011) raise the possibility of incorporating such an approach into MORL, we are not
aware of any research that has actually done so.
101

Roijers, Vamplew, Whiteson & Dazeley

(3,0)

(0,3)

B

C
A

(1,1)

D
Figure 3: An MOMDP with two objectives and four states.
8.4 Expectation of Scalarized Return
In Section 3, we defined the scalarized value VwœÄ (s) to be the result of applying the scalarization function f to the multi-objective value VœÄ (s) according to w, i.e., VwœÄ (s) = f (VœÄ (s), w).
Since VœÄ (s) is itself an expectation, this means that the scalarization function is applied
after the expectation is computed, i.e.,
VwœÄ (s) = f (VœÄ (s), w) = f (E[

‚àû
X

Œ≥ k rk | œÄ, s0 = s], w).

k=0

This formulation, which we refer to as the scalarization of the expected return (SER) is
standard in the literature. However, it is not the only option. It is also possible to define
VwœÄ (s) as the expectation of the scalarized return (ESR):
VwœÄ (s) = E[f (

‚àû
X

Œ≥ k rk , w) | œÄ, s0 = s]

k=0

Which definition is used can critically affect which policies are preferred. For example,
consider the following MOMDP, illustrated in Figure 3. There are four states (A, B, C, and
D) and two objectives. The agent starts in state A and has two possible actions: a1 transits
to state B or C, each with probability of 0.5, and a2 transits to state D with probability 1.
Both actions lead to a (0, 0) reward. In states B, C and D there is only one action, which
leads to a deterministic reward of (3, 0) for B, (0, 3) for C, and (1, 1) for D.
The scalarization function just multiplies the two objectives together. Thus, under SER,
VwœÄ (s) = V1œÄ (s)V2œÄ (s),
and under ESR,
VwœÄ (s) = E[

‚àû
X
k=0

Œ≥ k rk1

‚àû
 X
k=0

102


Œ≥ k rk2 | œÄ, s0 = s],

A Survey of Multi-Objective Sequential Decision-Making

where rki is the reward for the i-th objective on timestep k (w is not needed in this example
since f involves no constants). If œÄ1 (A) = a1 and œÄ2 (A) = a2 , then the multi-objective
values are VœÄ1 (A) = (1.5Œ≥/(1 ‚àí Œ≥), 1.5Œ≥/(1 ‚àí Œ≥)) and VœÄ2 (A) = (Œ≥/(1 ‚àí Œ≥), Œ≥/(1 ‚àí Œ≥)).
Under SER, this leads to scalarized values of V œÄ1 (A) = (1.5Œ≥/(1 ‚àí Œ≥))2 and V œÄ2 (A) =
(Œ≥/(1 ‚àí Œ≥))2 and consequently œÄ1 is preferred. Under ESR, however, we have V œÄ1 (A) = 0
and V œÄ2 (A) = (Œ≥/(1 ‚àí Œ≥))2 and thus œÄ2 is preferred.
Intuitively, the SER formulation is appropriate when the policy will be used many times
and return accumulates across episodes, e.g., because the same user is using the policy each
time. Then, scalarizing the expected reward makes sense and œÄ1 is preferable because in
expectation it will accumulate more return in both objectives. However, if the policy will
only be used a few times or the return does not accumulate across episodes, e.g., because
each episode is conducted for a different user, then the ESR formulation is more appropriate.
In this case, the expected return before scalarization is not of interest and œÄ2 is preferable
because œÄ1 will always yield zero scalarized return on any given episode.
To our knowledge, there is no literature on MOMDPs that employs the ESR formulation,
even though there are many real-world scenarios in which it seems more appropriate. For
example, in the medical application of Lizotte et al. (2010) mentioned in Section 7, each
patient gets only one episode to treat his or her illness, and is thus clearly interested in
maximizing ESR, not SER. Thus, we believe that developing methods for MOMDPs under
the ESR formulation is a critical direction for future research.

9. Conclusions
This article presented a survey of algorithms designed for sequential decision-making problems with multiple objectives.
In order to make explicit under what circumstances special methods are needed to
solve multi-objective problems, we identified three distinct scenarios in which converting
such a problem to a single-objective one is impossible, infeasible, or undesirable. As well as
providing motivation for the need for multi-objective methods, these scenarios also represent
the three main ways these methods are applied in practice.
We proposed a taxonomy that classifies multi-objective methods according to the applicable scenario, the scalarization function (which projects multi-objective values to scalar
ones), and the type of policies considered. We showed how these factors determine the
nature of an optimal solution, which can be a single policy, or a coverage set (convex or
Pareto). Our taxonomy is based on a utility-based approach, which sees the scalarization
function as part of the utility, and thus part of the problem definition. This contrasts with
the so-called axiomatic approach, which usually assumes the Pareto front is the appropriate
solution. We showed that the utility-based approach can be used to justify the choice for
a solution set. Following this line of thought, we observed (Observation 1) that computing
the Pareto front is often not necessary, and that in many cases a convex coverage set of
deterministic stationary policies is sufficient.
Using our taxonomy, we surveyed the literature on multi-objective methods for planning
and learning. An interesting observation is that most of the learning methods use a modelfree rather than a model based approach, identifying the latter as an understudied class of
103

Roijers, Vamplew, Whiteson & Dazeley

methods. Another part of the taxonomy which has not yet been widely studied is learning
in the case of monotonically increasing scalarization functions.
We discussed key applications of MOMDP methods as motivation for the importance
of such methods. Applications were identified in a diverse range of fields including environmental management, financial markets, information and communications technology, and
control of industrial processes, robotic systems and traffic infrastructure. In addition connections were identified between multi-objective sequential decision-making and other broad
areas of research such as probabilistic planning and model-checking, multi-agent systems
and more general multi-objective optimization.
Finally, we outlined several opportunities for future work, which include understudied
areas (model-based methods, learning in monotonically increasing scalarization settings,
and many-objective sequential decision-making), and a reformulation of the objective for
MOMDPs ‚Äì the Expectation of Scalarized Return ‚Äì which is particularly important to
optimize when a policy can be executed only once.

Acknowledgments
We would like to thank Matthijs Spaan, Frans Oliehoek, Matthijs Snel, Marie D. Manner
and Samy SaÃÅ, as well as the anonymous reviewers, for their valuable feedback. This work
is supported by the Netherlands Organisation for Scientific Research (NWO): DecisionTheoretic Control for Network Capacity Allocation Problems (#612.001.109) project.

References
Aberdeen, D., ThieÃÅbaux, S., & Zhang, L. (2004). Decision-theoretic military operations
planning. In Proc. ICAPS, Vol. 14, pp. 402‚Äì411.
Aissani, N., Beldjilali, B., & Trentesaux, D. (2008). Efficient and effective reactive scheduling of manufacturing system using Sarsa-multi-objective agents. In MOSIM‚Äô08: 7th
Conference Internationale de Modelisation et Simulation, pp. 698‚Äì707.
Aissani, N., Beldjilali, B., & Trentesaux, D. (2009). Dynamic scheduling of maintenance
tasks in the pretroleum industry: A reinforcement approach. Engineering Applications
of Artificial Intelligence, 22, 1089‚Äì1103.
Altman, E. (1999). Constrained Markov Decision Processes. Chapman and Hall/CRC,
London.
Aoki, K., Kimura, H., & Kobayashi, S. (2004). Distributed reinforcement learning using
bi-directional decision making for multi-criteria control of multi-stage flow systems.
In The 8th Conference on Intelligent Autonomous Systems, Vol. 2004.03, pp. 281‚Äì290.
Barrett, L., & Narayanan, S. (2008). Learning all optimal policies with multiple criteria.
In Proceedings of the 25th International Conference on Machine Learning, pp. 41‚Äì47,
New York, NY, USA. ACM.
Becker, R., Zilberstein, S., Lesser, V., & Goldman, C. V. (2003). Transition-Independent
Decentralized Markov Decision Processes. In Proc. of the 2nd Int‚Äôl Joint Conf. on
Autonomous Agents & Multi-Agent Systems.
104

A Survey of Multi-Objective Sequential Decision-Making

Bellman, R. E. (1957a). A Markov decision process. Journal of Mathematical Mech., 6,
679‚Äì684.
Bellman, R. (1957b). Dynamic Programming. Princeton University Press.
Bhattacharya, B., Lobbrecht, A. H., & Solomantine, D. P. (2003). Neural networks and reinforcement learning in control of water systems. Journal of Water Resources Planning
and Management, 129 (6), 458‚Äì465.
Bone, C., & Dragicevic, S. (2009). GIS and intelligent agents for multiobjective natural
resource allocation: A reinforcement learning approach. Transactions in GIS, 13 (3),
253‚Äì272.
Bosoniu, L., Babuska, R., & Schutter, B. D. (2008). A comprehensive survey of multiagent
reinforcement learning. IEEE Transactions on Systems, Man, and Cybernetics - Part
C: Applications and Reviews, 38 (2), 156‚Äì172.
Boutilier, C., Dean, T., & Hanks, S. (1999). Decision-theoretic planning: Structural assumptions and computational leverage. Journal of Artificial Intelligence Research,
11, 1‚Äì94.
BraÃÅzdil, T., Brozek, V., Chatterjee, K., Forejt, V., & Kucera, A. (2011). Two views on
multiple mean-payoff objectives in Markov decision processes. CoRR, abs/1104.3489.
Bryce, D. (2008). The value(s) of probabilistic plans. In Workshop on a Reality Check for
Planning and Scheduling under Uncertainty, ICAPS-08.
Bryce, D., Cushing, W., & Kambhampati, S. (2007). Probabilistic planning is multiobjective!. Technical report 08-006, Arizona State University.
Carchrae, T., & Beck, J. C. (2005). Applying machine learning to low-knowledge control of
optimization algorithms. Computational Intelligence, 21 (4), 372‚Äì387.
Cassandra, A., Littman, M. L., & Zhang, N. L. (1997). Incremental pruning: A simple, fast,
exact method for partially observable markov decision processes. In Proceedings of
the Thirteenth conference on Uncertainty in artificial intelligence, pp. 54‚Äì61.
Castelletti, A., Pianosi, F., & Restelli, M. (2013). A multiobjective reinforcement learning
approach to water resources systems operation: Pareto frontier approximation in a
single run. Water Resources Research.
Castelletti, A., Corani, G., Rizzolli, A., Soncini-Sessa, R., & Weber, E. (2002). Reinforcement learning in the operational management of a water system. In IFAC Workshop
on Modeling and Control in Environmental Issues, pp. 325‚Äì330.
Castelletti, A., Galelli, S., Restelli, M., & Soncini-Sessa, R. (2010). Tree-based reinforcement learning for optimal water reservoir operation. Water Resources Research,
46 (W09507).
Castelletti, A., Pianosi, F., & Restelli, M. (2011). Multi-objective Fitted Q-Iteration: Pareto
frontier approximation in one single run. In International Conference on Networking,
Sensing and Control, pp. 260‚Äì265.
Castelletti, A., Pianosi, F., & Restelli, M. (2012). Tree-based Fitted Q-iteration for multiobjective Markov decision processes. In IEEE World Congress on Computational
Intelligence.
105

Roijers, Vamplew, Whiteson & Dazeley

Castelletti, A., Pianosi, F., & Soncini-Sessa, R. (2008). Water reservoir control under economic, social and environmental constraints. Automatica, 44, 1595‚Äì1607.
Chatterjee, K. (2007). Markov decision processes with multiple long-run average objectives.
In FSTTCS, Vol. LNCS 4855, pp. 473‚Äì484.
Chatterjee, K., Majumdar, R., & Henzinger, T. A. (2006). Markov decision processes with
multiple objectives. In Proceedings of the 23rd Annual conference on Theoretical
Aspects of Computer Science, STACS‚Äô06, pp. 325‚Äì336, Berlin, Heidelberg. SpringerVerlag.
Cheng, L., Subrahmanian, E., & Westerberg, A. (2005). Multiobjective decision processes
under uncertainty: Applications, formulations and solution strategies. Industrial and
Engineering Chemistry Research, 44 (8), 2405‚Äì2415.
Clemen, R. T. (1997). Making Hard Decisions: An Introduction to Decision Analysis (2
edition). South-Western College Pub.
Coello Coello, C. A., Lamont, G. B., & Van Veldhuizen, D. A. (2002). Evolutionary Algorithms for Solving Multi-Objective Problems. Kluwer Academic Publishers.
Comsa, I., Aydin, M., Zhang, S., Kuonen, P., & Wagen, J.-F. (2012). Multi objective resource scheduling in LTE networks using reinforcement learning. International Journal
of Distributed Systems and Technologies, 3 (2), 39‚Äì57.
Courcoubetis, C., & Yannakakis, M. (1998). Markov decision processes and regular events.
IEEE Transactions on Automatic Control, 43 (10), 1399‚Äì1418.
Crites, R. H., & Barto, A. G. (1996). Improving elevator performance using reinforcement
learning. In Touretzky, D. S., Mozer, M. C., & Hasselmo, M. E. (Eds.), Advances in
Neural Information Processing Systems 8, pp. 1017‚Äì1023. MIT Press.
Daellenbach, H. G., & Kluyver, C. A. D. (1980). Note on multiple objective dynamic
programming. Journal of the Operational Research Society, 31, 591‚Äì594.
Defourny, B., Ernst, D., & Wehenkel, L. (2008). Risk-aware decision making and dynamic
programming. In NIPS 2008 Workshop on Model Uncertainty and Risk in RL.
Diehl, M., & Haimes, Y. Y. (2004). Influence diagrams with multiple objectives and tradeoff analysis. Systems, Man and Cybernetics, Part A: Systems and Humans, IEEE
Transactions on, 34 (3), 293‚Äì304.
Drugan, M. M., & Thierens, D. (2012). Stochastic pareto local search: Pareto neighbourhood
exploration and perturbation strategies. Journal of Heuristics, 18 (5), 727‚Äì766.
Dusparic, I., & Cahill, V. (2009). Distributed W-learning: Multi-policy optimization in selforganizing systems. In Third IEEE International Conference on Self-Adaptive and
Self-Organizing Systems, pp. 20‚Äì29.
Dusparic, I., & Cahill, V. (2010). Multi-policy optimization in self-organizing systems. In
SOAR 2009, LNCS 6090, pp. 101‚Äì126.
Dyer, J. S., Fishburn, P. C., Steuer, R. E., Wallenius, J., & Zionts, S. (1992). Multiple criteria decision making, multiattribute utility theory: The next ten years. Management
Science, 38 (5), 645‚Äì654.
106

A Survey of Multi-Objective Sequential Decision-Making

Ernst, D., Geurts, P., & Wehenkel, L. (2005). Tree-based batch mode reinforcement learning.
Journal of Machine Learning Research, 6, 503‚Äì556.
Ernst, D., Glavic, M., & Wehenkel, L. (2004). Power systems stability control: Reinforcement learning framework. IEEE Transactions on Power Systems, 19 (1), 427‚Äì435.
Feinberg, E. A., & Shwartz, A. (1995). Constrained Markov decision models with weighted
discounted rewards. Mathematics of Operations Research, 20 (2), 302‚Äì320.
Ferreira, L., Bianchi, R., & Ribeiro, C. (2012). Multi-agent multi-objective reinforcement
learning using heuristically accelerated reinforcement learning. In 2012 Brazilian
Robotics Symposium and Latin American Robotics Symposium, pp. 14‚Äì20.
Fleming, P., Purshouse, R., & Lygoe, R. (2005). Many-objective optimization: An engineering design perspective. In Evolutionary Multi-Criterion Optimization: Lecture Notes
in Computer Science, Vol. 3410, pp. 14‚Äì32.
Forejt, V., Kwiatkowska, M., Norman, G., Parker, D., & Qu, H. (2011). Quantitative
multi-objective verification for probabilistic systems. In Tools and Algorithms for the
Construction and Analysis of Systems, pp. 112‚Äì127. Springer Berlin Heidelberg.
Forejt, V., Kwiatkowska, M., & Parker, D. (2012). Pareto curves for probabilistic model
checking. In Automated Technology for Verification and Analysis, pp. 317‚Äì332.
Springer Berlin Heidelberg.
FuÃàrnkranz, J., HuÃàllermeier, E., Cheng, W., & Park, S.-H. (2012). Preference-based reinforcement learning: a formal framework and a policy iteration algorithm. Machine
Learning, 89 (1-2), 123‚Äì156.
Gabor, Z., Kalmar, Z., & Szepesvari, C. (1998). Multi-criteria reinforcement learning. In
The Fifteenth International Conference on Machine Learning, pp. 197‚Äì205.
Geibel, P., & Wysotzki, F. (2005). Risk-sensitive reinforcement learning applied to control
under constraints. Journal of Artificial Intelligence Research, 24, 81‚Äì108.
Geibel, P. (2001). Reinforcement learning with bounded risk. In Proceeding of the 18th
International Conference on Machine Learning, pp. 162‚Äì169.
Geibel, P. (2006). Reinforcement learning for MDPs with constraints. In European Conference on Machine Learning, Vol. 4212, pp. 646‚Äì653.
Gelly, S., & Silver, D. (2011). Monte-carlo tree search and rapid action value estimation in
computer go. Artificial Intelligence, 175 (11), 1856‚Äì1875.
Gong, P. (1992). Multiobjective dynamic programming for forest resource management.
Forest Ecology and Management, 48, 43‚Äì54.
Guo, Y., Zeman, A., & Li, R. (2009). A reinforcement learning approach to setting multiobjective goals for energy demand management. International Journal of Agent Technologies and Systems, 1 (2), 55‚Äì70.
Handa, H. (2009a). EDA-RL: Estimation of distribution algorithms for reinforcement learning problems. In ACM/SIGEVO Genetic and Evolutionary Computation Conference,
pp. 405‚Äì412.
107

Roijers, Vamplew, Whiteson & Dazeley

Handa, H. (2009b). Solving multi-objective reinforcement learning problems by EDA-RL acquisition of various strategies. In Proceedings of the Ninth Internatonal Conference
on Intelligent Sysems Design and Applications, pp. 426‚Äì431.
Hiraoka, K., Yoshida, M., & Mishima, T. (2009). Parallel reinforcement learning for weighted
multi-criteria model with adaptive margin. Cognitive Neurodynamics, 3, 17‚Äì24.
Holenstein, A. A., & Badreddin, E. (1991). Collision avoidance in a behavior-based mobile
robot design. In Robotics and Automation, 1991. Proceedings., 1991 IEEE International Conference on, pp. 898‚Äì903. IEEE.
Houli, D., Zhiheng, L., & Yi, Z. (2010). Multiobjective reinforcement learning for traffic
signal control using vehicular ad hoc network. EURASIP Journal on Advances in
Signal Processing.
Howard, R. A. (1960). Dynamic programming and Markov decision processes. MIT Press.
Humphrys, M. (1996). Action selection methods using reinforcement learning. In Proceedings of the Fourth International Conference on Simulation of Adaptive Behavior, pp.
135‚Äì144.
Ishibuchi, H., Tsukamoto, N., & Nojima, Y. (2008). Evolutionary many-objective optimisation: A short review. In IEEE Congress on Evolutionary Computation, pp. 2419‚Äì2426.
Issabekov, R., & Vamplew, P. (2012). An empirical comparison of two common multiobjective reinforcement learning algorithms. In AI2012: The 25th Australasian Joint
Conference on Artificial Intelligence, pp. 626‚Äì636.
Kaelbling, L. P., Littman, M. L., & Cassandra, A. R. (1998). Planning and acting in
partially observable stochastic domains. Artificial Intelligence, 101, 99‚Äì134.
Karlsson, J. (1997). Learning to Solve Multiple Goals. Ph.D. thesis, University of Rochester.
Kober, J., & Peters, J. (2011). Policy search for motor primitives in robotics. Machine
Learning, 1‚Äì2, 171‚Äì203.
Kober, J., & Peters, J. (2012). Reinforcement learning in robotics: A survey. In Wiering,
M., & Otterlo, M. (Eds.), Reinforcement Learning, Vol. 12 of Adaptation, Learning,
and Optimization, pp. 579‚Äì610. Springer Berlin Heidelberg.
Kocsis, L., & SzepesvaÃÅri, C. (2006). Bandit based monte-carlo planning. In 17th European
Conference on Machine Learning, pp. 282‚Äì293. Springer.
Kohl, N., & Stone, P. (2004). Policy gradient reinforcement learning for fast quadrupedal
locomotion. In Proceedings of the IEEE International Conference on Robotics and
Automation, pp. 2619‚Äì2624.
Kolobov, A., Mausam, & Weld, D. S. (2012). A theory of goal-oriented mdps with dead
ends. In Proceedings of the Twenty-Eighth Conference on Uncertainty in Artificial
Intelligence.
Kwak, J., Varakantham, P., Maheswarn, R., Tambe, M., Jazizadeh, F., Kavulya, G., Klein,
L., Becerik-Gerber, B., Hayes, T., & Wood, W. (2012). SAVES: A sustainable multiagent application to conserve building energy considering occupants. In 11th International Conference on Autonomous Agents and Multiagent Systems, pp. 21‚Äì28.
108

A Survey of Multi-Objective Sequential Decision-Making

Liao, H., Wu, Q., & Jiang, L. (2010). Multi-objective optimization by reinforcement learning
for power system dispatch and voltage stability. In Innovative Smart Grid Technologies
Conference Europe.
Lin, C.-T., & Chung, I.-F. (1999). A reinforcement neuro-fuzzy combiner for multiobjective
control. IEEE Transactions on Systems, Man and Cyberbetics - Part B, 29 (6), 726‚Äì
744.
Liu, C., Xu, X., & Hu, D. (2013). Multiobjective reinforcement learning: A comprehensive
overview. Systems, Man, and Cybernetics, Part C: Applications and Reviews, IEEE
Transactions on, PP (99), 1‚Äì13.
Liu, W., Tan, Y., & Qiu, Q. (2010). Enhanced q-learning algorithm for dynamic power
management with performance constraints. In DATE‚Äô10, pp. 602‚Äì605.
Lizotte, D. J., Bowling, M., & Murphy, S. A. (2010). Efficient reinforcement learning with
multiple reward functions for randomized clinical trial analysis. In 27th International
Conference on Machine Learning, pp. 695‚Äì702.
Lizotte, D. J., Bowling, M., & Murphy, S. A. (2012). Linear fitted-q iteration with multiple
reward functions. Journal of Machine Learning Research, 13, 3253‚Äì3295.
Madani, O., Hanks, S., & Condon, A. (1999). On the undecidability of probabilistic planning
and infinite-horizon partially observable Markov decision problems. In Proceedings of
the National Conference on Artificial Intelligence (AAAI), pp. 541‚Äì548.
Mannor, S., & Shimkin, N. (2001). The steering approach for multi-criteria reinforcement
learning. In Neural Information Processing Systems, pp. 1563‚Äì1570.
Mannor, S., & Shimkin, N. (2004). A geometric approach to multi-criterion reinforcement
learning. Journal of Machine Learning Research, 5, 325‚Äì360.
Maravall, D., & de Lope, J. (2002). A reinforcement learning method for dynamic obstacle
avoidance in robotic mechanisms. In Computational Intelligent Systems for Applied
Research: Proceedings of the 5th International FLINS Conference, pp. 485‚Äì494, Singapore. World Scientific.
Mariano, C., & Morales, E. (1999). MOAQ an Ant-Q algorithm for multiple objective
optimization problems. In GECCO-99: Proceedings of the Genetic and Evolutionary
Computation Conference, pp. 894‚Äì901.
Mariano, C., & Morales, E. (2000a). A new approach for the solution of multiple objective
optimization problems based on reinforcement learning. In Advances in Artificial
Intelligence, International Joint Conference, 7th Ibero-American Conference on AI,
15th Brazilian Symposium. Springer.
Mariano, C., & Morales, E. (2000b). A new distributed reinforcement learning algorithm for
multiple objective optimisation problems. In Lecture Notes in AI Vol 1952: Proceedings of the Mexican International Conference on Artficial Intelligence, pp. 212‚Äì223.
Springer.
Meisner, E. M. (2009). Learning Controllers for Human-Robot Interaction. Ph.D. thesis,
Rensselaer Polytechnic Institute.
109

Roijers, Vamplew, Whiteson & Dazeley

Mouaddib, A.-I. (2006). Collective multi-objective planning. In Proceedings of the IEEE
Workshop on Distributed Intelligent Systems: Collective Intelligence and Its Applications (DIS‚Äô06), pp. 43‚Äì48, Washington, DC, USA. IEEE Computer Society.
Mukai, Y., Kuroe, Y., & Iima, H. (2012). Multi-objective reinforcement learning method
for acquiring all Pareto optimal policies simultaneously. In IEEE International Conference on Systems, Man and Cybernetics, pp. 1917‚Äì1923.
Natarajan, S., & Tadepalli, P. (2005). Dynamic preferences in multi-criteria reinforcement
learning. In International Conference on Machine Learning, pp. 601‚Äì608.
Nojima, Y., Kojima, F., & Kubota, N. (2003). Local episode-based learning of multiobjective behavior coordination for a mobile robot in dynamic environments. In The
12th IEEE International Conference on Fuzzy Systems, Vol. 1, pp. 307‚Äì312.
Ogryczak, W., Perny, P., & Weng, P. (2011). On minimizing ordered weighted regrets
in multiobjective Markov decision processes. In 2nd International Conference on
Algorithmic Decision Theory, pp. 190‚Äì204.
Ong, S. C., Png, S. W., Hsu, D., & Lee, W. S. (2010). Planning under uncertainty for robotic
tasks with mixed observability. The International Journal of Robotics Research, 29 (8),
1053‚Äì1068.
Pareto, V. (1896). Manuel d‚ÄôEconomie Politique. Giard, Paris.
Peek, N. B. (1999). Explicit temporal models for decision‚Äìtheoretic planning of clinical
management. Artificial Intelligence in Medicine, 15 (2), 135‚Äì154.
Perez, J., Germain-Renaud, C., Kegl, B., & Loomis, C. (2009). Responsive elastic computing. In International Conference on Autonomic Computing, pp. 55‚Äì64.
Perny, P., & Weng, P. (2010). On finding compromise solutions in multiobjective Markov
decision processes. In ECAI Multidisciplinary Workshop on Advances in Preference
Handling, pp. 55‚Äì60.
Perny, P., Weng, P., Goldsmith, J., & Hanna, J. P. (2013). Approximation of lorenz-optimal
solutions in multiobjective markov decision processes. In Workshops at the TwentySeventh AAAI Conference on Artificial Intelligence.
Pervez, A., & Ryu, J. (2008). Safe physical human robot interaction-past, present and
future. Journal of Mechanical Science and Technology, 22 (3), 469‚Äì483.
Pineau, J., Gordon, G., & Thrun, S. (2006). Anytime point-based approximations for large
POMDPs. Journal of Artificial Intelligence Research, 27 (1), 335‚Äì380.
Precup, D., Sutton, R. S., & Dasgupta, S. (2001). Off-policy temporal-difference learning
with function approximation. In Proceedings of the 18th International Conference on
Machine Learning, pp. 417‚Äì424.
Puterman, M. L. (1994). Markov decision processes: Discrete stochastic dynamic programming. John Wiley & Sons, Inc.
Roijers, D. M., Whiteson, S., & Oliehoek, F. A. (2013). Computing convex coverage sets
for multi-objective coordination graphs. In ADT 2013: Proceedings of the Third International Conference on Algorithmic Decision Theory. To appear.
110

A Survey of Multi-Objective Sequential Decision-Making

Ross, S., Pineau, J., Paquet, S., & Chaib-draa, B. (2008). Online planning algorithms for
POMDPs. Journal of Artificial Intelligence Research, 32, 663‚Äì704.
Russell, S., & Zimdars, A. L. (2003). Q-decomposition for reinforcement learning agents. In
Proceedings of the 20th International Conference on Machine Learning, pp. 656‚Äì663.
Schneider, J., Wong, W.-K., Moore, A., & Riedmiller, M. (1999). Distributed value functions. In Proceedings of the 16th International Conference on Machine Learning, pp.
371‚Äì378, San Francisco, CA. Morgan Kaufmann.
Shabani, N. (2009). Incorporating flood control rule curves of the Columbia River hydroelectric system in a multireservoir reinforcement learning optimization model. Master‚Äôs
thesis, University of British Columbia.
Shelton, C. R. (2001). Importance sampling for reinforcement learning with multiple objectives. AI Technical Report 2001-003, MIT.
Shortreed, S., Laber, E., Lizotte, D., Stroup, T., Pineau, J., & Murphy, S. (2011). Informing
sequential clinical decision-making through reinforcement learning: an empirical study.
Machine Learning, 84, 109‚Äì136.
Smallwood, R., & Sondik, E. (1973). The optimal control of partially observable Markov
processes over a finite horizon. Operations Research, 21 (5), 1071‚Äì1088.
Soh, H., & Demiris, Y. (2011). Evolving policies for multi-reward partially observable
Markov decision processes (MR-POMDPs). In GECCO‚Äô11 Proceedings of the 13th
Annual Conference on Genetic and Evolutionary Computation, pp. 713‚Äì720.
Sondik, E. (1971). The optimal control of partially observable processes over a finite horizon.
Ph.D. thesis, Stanford University, Stanford, California.
Sondik, E. (1978). The optimal control of partially observable Markov processes over the
infinite horizon: Discounted costs. Operations Research, 26 (2), 282‚Äì304.
Spaan, M., & Vlassis, N. (2005). Perseus: Randomized point-based value iteration for
POMDPs. Journal of Artificial Intelligence Research, 24 (1), 195‚Äì220.
Stewart, T. J. (1992). A critical survey on the status of multiple criteria decision making
theory and practice. Omega, 20 (5), 569‚Äì586.
Sutton, R. S. (1988). Learning to predict by the methods of temporal differences. Machine
Learning, 3 (1), 9‚Äì44.
Sutton, R. S., & Barto, A. G. (1998). Introduction to Reinforcement Learning (1st edition).
MIT Press, Cambridge, MA, USA.
Sutton, R., McAllester, D., Singh, S., & Mansour, Y. (2000). Policy gradient methods for
reinforcement learning with function approximation. In NIPS, pp. 1057‚Äì1063.
Szita, I. (2012). Reinforcement learning in games. In Wiering, M., & Otterlo, M. (Eds.),
Reinforcement Learning, Vol. 12 of Adaptation, Learning, and Optimization, pp. 539‚Äì
577. Springer Berlin Heidelberg.
Tan, K. C., Khor, E. F., Lee, T. H., & Sathikannan, R. (2003). An evolutionary algorithm
with advanced goal and priority specification for multi-objective optimization. Journal
of Artificial Intelligence Research, 18, 183‚Äì215.
111

Roijers, Vamplew, Whiteson & Dazeley

Teichteil-KoÃànigsbuch, F. (2012a). Path-constrained markov decision processes: bridging the
gap. In Proceedings of the Twentieth European Conference on Artificial Intelligence.
Teichteil-KoÃànigsbuch, F. (2012b). Stochastic safest and shortest path problems. In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence.
Tesauro, G., Das, R., Chan, H., Kephart, J. O., Lefurgy, C., Levine, D. W., & Rawson, F.
(2007). Managing power consumption and performance of computing systems using
reinforcement learning. In Neural Information Processing Systems.
Tong, H., & Brown, T. X. (2002). Reinforcement learning for call admission control and
routing under quality of service constraints in multimedia networks. Machine Learning, 49, 111‚Äì139.
Uchibe, E., & Doya, K. (2009). Constrained Reinforcement Learning from Intrinsic and
Extrinsic Rewards, pp. 155‚Äì166. Theory and Novel Applications of Machine Learning.
I-Tech, Vienna, Austria.
Vamplew, P., Dazeley, R., Barker, E., & Kelarev, A. (2009). Constructing stochastic mixture
policies for episodic multiobjective reinforcement learning tasks. In AI‚Äô09: The 22nd
Australasian Conference on Artificial Intelligence, pp. 340‚Äì349.
Vamplew, P., Dazeley, R., Berry, A., Dekker, E., & Issabekov, R. (2011). Empirical evaluation methods for multiobjective reinforcement learning algorithms. Machine Learning,
84 (1-2), 51‚Äì80.
Vamplew, P., Yearwood, J., Dazeley, R., & Berry, A. (2008). On the limitations of scalarisation for multi-objective reinforcement learning of Pareto fronts. In AI‚Äô08: The 21st
Australasian Joint Conference on Artificial Intelligence, pp. 372‚Äì378. Springer.
Van Otterlo, M., & Wiering, M. (2012). Reinforcement learning and markov decision processes. In Reinforcement Learning: State of the Art, chap. 1, pp. 3‚Äì42. Springer.
Van Vaerenbergh, K., Rodriguez, A., Gagliolo, M., Vrancx, P., NoweÃÅ, A., Stoev, J.,
Goossens, S., Pinte, G., & Symens, W. (2012). Improving wet clutch engagement
with reinforcement learning. In International Joint Conference on Neural Networks,
IJCNN 2012.
Vira, C., & Haimes, Y. Y. (1983). Multiobjective decision making: theory and methodology.
No. 8. North-Holland.
Viswanathan, B., Aggarwal, V. V., & Nair, K. P. K. (1977). Multiple criteria Markov
decision processes. TIMS Studies Management Science, 6, 263‚Äì272.
Wakuta, K., & Togawa, K. (1998). Solution procedures for Markov decision processes. Optimization: A Journal of Mathematical Programming and Operations Research, 43 (1),
29‚Äì46.
Wakuta, K. (1999). A note on the structure of value spaces in vector-valued Markov decision
processes.. Mathematical Methods of Operations Research, 49 (1), 77‚Äì85.
Wang, W., & Sebag, M. (2013). Hypervolume indicator and dominance reward based multiobjective monte-carlo tree search. Machine Learning, 1‚Äì27.
Watkins, C. J. C. H. (1989). Learning from Delayed Rewards. Ph.D. thesis, Cambridge
University.
112

A Survey of Multi-Objective Sequential Decision-Making

White, C. C., & Kim, K. M. (1980). Solution procedures for solving vector criterion Markov
decision processes. Large Scale Systems, 1, 129‚Äì140.
White, D. (1982). Multi-objective infinite-horizon discounted Markov decision processes.
Journal of Mathematical Analysis and Applications, 89 (2), 639 ‚Äì 647.
Whiteson, S. (2012). Evolutionary computation for reinforcement learning. In Wiering,
M. A., & van Otterlo, M. (Eds.), Reinforcement Learning: State of the Art, chap. 10,
pp. 325‚Äì352. Springer, Berlin.
Wiering, M., & De Jong, E. (2007). Computing optimal stationary policies for multiobjective Markov decision processes. In IEEE International Symposium on Approximate Dynamic Programming and Reinforcement Learning, pp. 158‚Äì165. IEEE.
Yang, Z., & Wen, K. (2010). Multi-objective optimization of freeway traffic flow via a
fuzzy reinforcement learning method. In 3rd International Conference on Advanced
Computer Theory and Engineering, Vol. 5, pp. 530‚Äì534.
Yin, S., Duan, H., Li, Z., & Zhang, Y. (2010). Multi-objective reinforcement learning for
traffic signal coordinate control. In 1th World Conference on Transport Research.
Zeleny, M., & Cochrane, J. L. (1982). Multiple criteria decision making, Vol. 25. McGrawHill New York.
Zhao, Y., Chen, Q., & Hu, W. (2010). Multi-objective reinforcement learning algorithm for
MOSDMP in unknown environment. In Proceedings of the 8th World Congress on
Intelligent Control and Automation, pp. 3190‚Äì3194.
Zheng, K., Li, H., Qiu, R. C., & Gong, S. (2012). Multi-objective reinforcement learning
based routing in cognitive radio networks: Walking in a random maze. In International
Conference on Computing, Networking and Communications, pp. 359‚Äì363.
Zitzler, E., Thiele, L., Laumanns, M., Fonseca, C. M., & da Fonseca, V. G. (2003). Performance assessment of multiobjective optimizers: An analysis and review. Evolutionary
Computation, IEEE Transactions on, 7 (2), 117‚Äì132.

113

Journal of Artificial Intelligence Research 48 (2013) 231 ‚Äì 252

Submitted 4/2013; published 10/2013

Optimal Implementation of Watched Literals
and More General Techniques
Ian P. Gent

ian.gent@st-andrews.ac.uk

School of Computer Science, St Andrews University
St Andrews, Fife KY16 9SX, UK

Abstract
I prove that an implementation technique for scanning lists in backtracking search
algorithms is optimal. The result applies to a simple general framework, which I present:
applications include watched literal unit propagation in SAT and a number of examples
in constraint satisfaction. Techniques like watched literals are known to be highly space
efficient and effective in practice. When implemented in the ‚Äòcircular‚Äô approach described
here, these techniques also have optimal run time per branch in big-O terms when amortized
across a search tree. This also applies when multiple list elements must be found. The
constant factor overhead of the worst case is only 2. Replacing the existing non-optimal
implementation of unit propagation in MiniSat speeds up propagation by 29%, though this
is not enough to improve overall run time significantly.

1. Introduction
In many backtrack search procedures, a given list must contain an element satisfying some
property. I call this an ‚Äúacceptable element‚Äù. If no acceptable element exists in the list,
some relevant action is triggered, such as assigning a unit clause in SAT (Boolean Satisfiability). This paper considers only monotonic acceptability properties: i.e. if an element is
unacceptable at a node in the search tree, it remains unacceptable at all descendant nodes.
This description is general, but applies to vital components in modern search techniques.
As well as unit propagation in SAT, a typical application in CSP (Constraint Satisfaction
Problem) is support for a variable-value pair in a general purpose arc consistency algorithm,
e.g. MGAC2001/3.1 (BessieÃÄre, ReÃÅgin, Yap, & Zhang, 2005). Once no acceptable element
(support) is available, the triggered action is that the variable-value pair must be pruned.
A common technique for maintaining acceptability is to keep a pointer to a known
acceptable element. If this element becomes unacceptable during the search process, we
scan the list for a new acceptable element. If we find one we change the pointer. If not, we
can trigger the necessary action. After backtracking, we must guarantee that the pointer
points to an acceptable element. There are several methods for achieving this. One is
to reset the pointer before each list scan. A second is to store the current value of the
pointer and to restore this value on backtracking. This paper focuses on a third method,
the ‚Äúbacktrack-stable‚Äù approach, as used in watched literals in SAT.
The backtrack-stable approach is very simple: no changes are made to the pointer except
when we are scanning the list for a new acceptable element. Watched literals in SAT, the
classic example of this approach, have proven to be highly effective in practice (Moskewicz,
Madigan, Zhao, Zhang, & Malik, 2001). Its correctness depends on acceptability being
monotonic. If we move the pointer to a new acceptable element at a particular node, the
c
2013
AI Access Foundation. All rights reserved.

Gent

new element must be acceptable at all ancestor nodes. When we backtrack we thus still
have an acceptable element, even if it is different to the one we entered the node with.
Unfortunately, down any branch (i.e. sequence of nodes from root to leaf node), we can no
longer guarantee that a single pass of the list is enough. At a given node the pointer may
move due to moves at children nodes, meaning we may have missed elements. Indeed, on a
single branch we may need to check every value of the list many times.
This paper shows that a simple, ‚Äòcircular‚Äô, implementation of the backtrack-stable approach is optimal in big-O terms when amortised across all branches of a tree, a significantly
better theoretical property than has previously been suggested. The amortisation applies to
any search tree explored in a depth-first style, independent of the size of the search tree. The
constant increase in worst case complexity is only 2. Applicability to existing code depends
on low-level implementation details. I discuss some such cases in detail. In some cases existing implementations are shown to be optimal, while in others an optimal implementation of
watched literals was not used. For example I show empirically that implementing watched
literals optimally speeds up unit propagation in MiniSat by 29%, although the effect does
not lead to a statistically significant improvement in overall MiniSat solution time.
Section 2 describes a simple framework for scanning lists in backtracking search and
gives pseudocode for the three methods compared in this paper, and gives a worked example to motivate the proof that the circular approach is optimal. Section 3 gives that proof
and related results, including detailed comparisons with the state restoration method. Section 4 generalises the result to multiple acceptable elements. Later sections discuss applications to constraint satisfaction, and to watched literal unit propagation in SAT, including
experiments on MiniSat. Appendices gives proofs omitted from the main text, detailed
methodology of the SAT experiments, results on another method of list scanning, and a
summary of the Online Appendix for this paper.

2. Simple Framework for List Scanning Algorithms
We have a list list of length N .1 We assume there is a boolean function acceptable(list,i)
to check list elements, returning true if list[i] is acceptable and false if not. Throughout
this paper, this function is required to be monotonic, in the following sense.
Definition 1 (Monotonicity of Acceptability). Acceptability is monotonic if, whenever
acceptable(list,i) fails at a node, then acceptable(list,i) would also fail if called for
the remainder of the search process at that node and at all its descendant nodes.
Note that this definition allows elements in list to be moved, as long as unacceptability at each index is maintained: this flexibility will be important in Section 4. When
unacceptability is detected we must find a new acceptable element, or guarantee that none
exists. This is achieved by one of three variants of a function findNewElement (sometimes abbreviated to FNE). Each variant updates the value of a pointer last, and either
succeeds with an acceptable value of list[last], or fails with a guarantee that no acceptable value in list exists. The execution environment is assumed to guarantee that, at any
1. In this paper I assume a computational model in which the word size is at least log N bits, and that
standard operations on words take O(1) time. This is not ideal from a complexity-theoretic point of
view, but is a standard assumption in the literature, although unfortunately not usually clearly stated.

232

Optimal Implementation of Watched Literals

node of the search tree, if list[last] changes from being acceptable to unacceptable, then
findNewElement(list) will be called before the next node is visited, except when backtracking occurs from this node before any descendant node is visited. For the purposes of
this paper, detection of unacceptability is not counted as a call to acceptable: whatever
cost this detection has is the same for each approach studied here. We assume an initialisation phase in which O(N ) calls to acceptable are made to find the initial value of last:
these calls are considered as preprocessing and not charged to any node in the search tree.
We also assume that calls to findNewElement are only made during initialisation and
after unacceptability has been detected.
Each variant of findNewElement has to ensure the following invariant is maintained.
Note that this invariant means when one of the first two cases holds, the value list[last] is
unacceptable iff there is no acceptable element in the list.
Invariant 2. At all times at least one of the following is true:
‚Ä¢ the value list[last] is acceptable; or
‚Ä¢ there is no acceptable element in list; or
‚Ä¢ the initialisation process has not completed; or
‚Ä¢ the value list[last] has become unacceptable at the current node but findNewElement has not yet been called and completed.
Many calls to findNewElement may happen at a single node, because facts about
acceptability may not become known at the same time. For example, in the case of unit
propagations in SAT, the current watched literal (i.e. list[last]) may become unsatisfiable
(unacceptable), so we have to scan for a new watched literal (value of last). But later
propagations at the same node can make this new value unsatisfiable, leading to new scans.
This paper compares three implementations of findNewElement and shows the good
properties of the last one. The differences arise from how last is dealt with in between
invocations of findNewElement. The simplest variant is shown in Procedure 1: each
time it is called the previous value of last is discarded and the list searched from the
beginning.
Procedure 1: FNE-NoState(list)
1: last := -1
2: repeat
3:
last := last + 1
4:
if acceptable(list,last) then return true
5: until last = N
6: return false
Procedure 1 is simple, certainly maintains Invariant 2, and is highly space-efficient. It
has a significant disadvantage in that its worst case is to require Œò(N 2 ) calls to acceptable
at every leaf node, stated here as Proposition 3 and proved in Appendix E. (Appendix E is
omitted from the main text but is available online, see Appendix D.)
233

Gent

Proposition 3. The procedure FNE-NoState maintains Invariant 2. It makes O(N 2 )
calls to acceptable per branch of a search tree, but requires Œò(N 2 ) in the worst case.
(Proof in Appendix E online.)
The remaining two variants both use FNE-NoState to initialise last, but make different
calls thereafter. The second variant is based on state restoration. Each call continues search
from the most recent value of last found at the current node or any of its ancestors. Since
the value of last may be changed by descendent nodes, some mechanism of the backtracking
search solver must be exploited to restore the value of last when backtracking occurs. What
this method is will vary between solvers, and is not critical for this paper. Given this, this
method is shown as Procedure 2.
Procedure 2: FNE-RestoreState(list)
1: repeat
2:
last := last + 1
3:
if acceptable(list,last) then return true
4: until last = N
5: return false
Since acceptability is monotonic and last is always restored to the value it had previously,
the invariant is guaranteed. We have the following, for which no proof should be necessary.
Proposition 4. The procedure FNE-RestoreState maintains Invariant 2. On any given
branch of the search tree from root to leaf node, at most N calls to acceptable are made.
In the final, ‚Äúbacktrack-stable‚Äù, variant, we do not restore former values of last on
backtracking. We now have the problem that down a branch, or even at a single node, the
value of last can be moved by later nodes and not restored when we return to the current
node. To deal with this correctly, we have to allow every element of list to be checked
even if some may have already been checked higher on the current branch or even at the
same node. The focus of this paper is the ‚Äúcircular‚Äù method for checking all elements: at
the end of the list we circle around from the end of the list to zero, and continue checking
until we hit the value that last had when the call was made. For initialisation we call the
above procedure FNE-NoState. All subsequent calls are to the following.
Procedure 3: FNE-Circular(list)
1: last-cache := last
2: repeat
3:
last := last + 1
4:
if last = N then last := 0
5:
if acceptable(list,last) then return true
6: until last = last-cache
7: return false
No claim is made for originality of the circular method: it was used by Gent, Jefferson,
and Miguel (2006b) and probably by earlier authors. Unlike the previous variants, the
invariant does not hold for all search algorithms. Correctness will be proved in Section 3
below, in the context of ‚Äòdownwards-explored search trees‚Äô, as defined in Definition 5.
234

Optimal Implementation of Watched Literals

.
One difference between Procedures 2 and 3 should be noted. At a given node of the
search tree, Procedure 2 can make at most N calls to acceptable. However, Procedure
3 can, perhaps counterintuitively, require almost 2N calls at a single node. For example,
suppose at a given node we have last = 0. If this value becomes unacceptable and the only
other acceptable value is N ‚àí 1, this requires N ‚àí 1 calls to set last = N ‚àí 1. Further
propagation may later make N ‚àí 1 unacceptable also. The resulting new call to Procedure
3 cannot find an acceptable value, but must still check all values from 0 to N ‚àí2 as it has no
memory of the previous call. (The variable last-cache is local to each call of the Procedure.)
This is a further N ‚àí 1 calls to acceptable, for a total of 2N ‚àí 2 at the node.
2.1 Worked Example
I present a worked example of Procedure 3, showing how we can amortize the count of calls
to acceptable in a way which will form the basis of the optimality results of this paper.
Figure 1 shows an example search using the circular approach. In the example we assume
node id = 0 :last=14, cost = 14X
last=17

8 :14, 17X

1 :14, 0
last=19

2 :17, 3X

last=16

5 :17, 18X

9 :16, 21X√ó

12 :14, 18X

last=18

3 :17, 19√ó

P

= 36

0,1,2,3

4 :19, 2X

P
0,1,2,4

= 19

6 :18, 20X√ó

P
0,1,5,6

= 52

last=15

7 :17, 19X

P
0,1,5,7

10 :16, 0

P

= 51

0,8,9,10

= 52

11 :16, 0

P
0,8,9,11

= 52

13 :15, 1X

P
0,8,12,13

= 50

14 :14, 38X√ó

P

= 87

0,8,12,14

Figure 1: A search using the circular approach. See main text for description.
that the list being searched has 20 elements, indexed from 0 to 19. and that initialisation
sets last = 0. The box at a node indicates the node number (italics), the value of last
after any calls to FNE-Circular (bold), and the cost of those calls in total at the node
(measured as number of calls to acceptable), including a failed call if there is one. A X
indicates a successful call was made, while a √ó indicates an unsuccessful call. Both can occur
at the same node, if the value of last is moved by a successful call, while that value later
becomes unacceptable, and another call to FNE-Circular fails. A branch is annotated
with a value of last if the search to the left changed the value of last. For example, at node
5 the value of last was 17, but the left child set it to 18, meaning that it had changed when
we branched right. The total cost for each branch is listed, e.g. 87 for the last branch.
In the example, the first 14 elements become unacceptable at the root, so calls to FNE
must check 14 elements in order to set last = 14. If we restored last the maximum cost
235

Gent

down any branch would be the number of elements in the list, in this case 20. If we used
FNE-Circular, but searched only one branch, the maximum cost would be almost double,
38. This could happen if we eventually settle on last = 19, this becomes unacceptable and
we do a failed call which costs 19. By contrast, the extreme right hand branch costs
14 + 17 + 18 + 38 = 87, more than twice the maximum if search took only a single branch.
Summing the number of checks in FNE on each branch, we get 36 + 19 + 52 + 51 + 52 +
52 + 50 + 87 = 399, almost 50 times the number of branches, 8. However, this counts
many costs twice. By summing at each node, the total number of checks across the tree is
14 + 0 + 3 + 19 + 2 + 18 + 20 + 19 + 17 + 21 + 0 + 0 + 18 + 1 + 38 = 190. This is more than 20
times the number of branches, but less than 40 times the number of branches. I will show
that the latter bound is always true: we can never look at more list elements than 2kN , if
N is the number of list elements and k is the number of branches.
A left branch segment (LBS) is a segment of a branch with all left branching decisions
ending at a leaf node. In this paper, the left child of a given internal node is taken to mean
whichever child node is explored first.2 Figure 2 shows the same search tree as Figure 1,
but showing the LBSs and the cost across each LBS. Crucial points to note are: each
left branch segment contains consecutively numbered nodes; the cost of each left branch
segment is never more than 38 = 2N ‚àí 2; and the total cost summed over left branch
segments (36 + 2 + 38 + 19 + 38 + 0 + 19 + 38 = 190) is identical to the total cost across the
tree as calculated earlier. All of these observations about the tree are provable in general.

3. Formal Results
While the worked example showed binary branching, this is not necessary. After the left
hand child of a node there may be any number of later nodes (including zero at a unary
node.) A leaf node is simply a node with no children. I will prove correctness and optimality
of FNE-Circular when search algorithms build trees of the following type:
Definition 5 (Downwards-Explored Search Tree). A search tree is Downwards-Explored
if: for any node n0 in the tree, all nodes descending from n0 are visited later than n0 , and
for any node n1 not descended from n0 and visited later than n0 , all nodes in the tree that
descend from n0 are visited after n0 but before n1 .
Depth-first search certainly defines a downwards-explored tree, but so do many variants
such as conflict-directed backjumping (Prosser, 1993). A less obvious case is a single restart
of a modern Conflict-Driven Clause Learning (CDCL) SAT solver (Marques-Silva, Lynce, &
Malik, 2009). When backtracking, search returns to the level of the tree chosen by conflictanalysis, and it is guaranteed that all intermediate parts of the search tree are unsatisfiable,
and will never be visited again, resulting in a downwards-explored search tree. CDCL solvers
undertake restarts, as do other major algorithms such as Iterative Deepening (Korf, 1985)
and Limited Discrepancy Search (Harvey & Ginsberg, 1995; Prosser & Unsworth, 2011). In
all three of these examples each iteration considered separately gives a downward-explored
tree. The results of the current paper therefore apply to a single iteration or restart of each
algorithm. They will also apply to multiple restarts or iterations if one counts separately
2. An algorithm may regard its first branching choice as the right branch, e.g. limited discrepancy search
going against its heuristic, but for this paper the left child is defined as whichever one is explored first.

236

Optimal Implementation of Watched Literals

node id = 0 : last=14, cost = 14X
last=17

8 :14, 17X

1 :14, 0
last=19

2 :17, 3X

last=16

5 :17, 18X

9 :16, 21X√ó

12 :14, 18X

last=18

3 :17, 19√ó

P
0,1,2,3

= 36

4 :19, 2X

P
4

=2

6 :18, 20X√ó

P
5,6

= 38

last=15

7 :17, 19X

P
7

= 19

10 :16, 0

11 :16, 0

P

P

8,9,10

= 38

11

=0

13 :15, 1X

P
12,13

= 19

14 :14, 38X√ó

P

= 38

14

Figure 2: The example from Figure 1 with additional annotations. A double line indicates
a left hand branch, while a wavy line the right hand branch. A sequence of double
lines indicates a left branch segment. A solid box around a node indicates the
start of a left branch segment. Finally, the sums of costs are made only over the
left branch segment ending at each leaf node.

for each iteration, i.e. counting a branch twice even if it is a duplicate of a branch from
a previous iteration. Some major algorithms do not explore downwards: e.g. breadth-first
or best-first search. In such algorithms, at consecutive nodes last, which is not contained
in the search state, moves from pointing to an acceptable to an unacceptable value. The
results of this paper therefore do not apply in any way to such algorithms.
The first result is correctness of the FNE-circular method, slightly generalised so
that it will also apply to the ‚Äúmiddle-out‚Äù Procedure 5 in Appendix B.
Definition 6 (Locally Correct). A findNewElement procedure is locally correct iff:
1. if any element of list is acceptable then the procedure sets last to point at an acceptable
value and succeeds;
2. if no element of list is acceptable then the procedure fails and exits with last set to
the same value it had on entry.
Specifically, FNE-Circular is locally correct by design, and therefore its global correctness is a corollary of the following theorem.
Theorem 7. (Correctness) If the search algorithm defines a downwards-explored search
tree, and if procedure findNewElement is locally correct, Invariant 2 is true at all times.
(Proof in Appendix E online.)
Definition 8 (LBS). The left branch segment ending at a leaf node n LBS(n) is defined
recursively as follows:
237

Gent

‚Ä¢ n ‚àà LBS(n)
‚Ä¢ if m1 ‚àà LBS(n) and m1 is the left hand child of a parent node m2 , then m2 ‚àà LBS(n).
For convenience, if a parent node has only one child we call this the left hand child.
‚Ä¢ LBS(n) is the minimal set of nodes satisfying the above properties.
Note that for a leaf node m which is not the left hand child of its parent, the definitions
trivially give LBS(m) = {m}. Every internal node has exactly one left child, so we can
proceed as follows.
Lemma 9. Every node in the tree is contained in exactly one left branch segment. In
a downwards-explored search tree, nodes in a left branch segment are visited consecutively
without search visiting any other nodes. (Proof in Appendix E online.)
Theorem 10. In a downwards-explored search tree, there are no more than N ‚àí 1 calls to
acceptable made by successful calls to FNE-Circular in a left branch segment.
Proof. The proof relies on the monotonicity of acceptability down the tree. Because all
nodes in an LBS are explored sequentially without interruption, from Lemma 9, all calls to
FNE-Circular and therefore changes to last, are consecutive. The definition of FNECircular means that to check more than N ‚àí 1 elements on a single LBS, last must be
incremented at least N times, meaning that every value is checked at least once in the LBS,
including the original value last at entry to LBS. Call this value i. Say the root of the LBS is
m1 , and the element i is checked again at node m2 with either m1 = m2 or m1 an ancestor
of m2 . Between entry to m1 and the call to acceptable(list, i) at m2 , every list element
must have been checked. Furthermore, for each value j, either the check of j in FNECircular failed, or it succeeded and later on the value had become unacceptable causing
another call to FNE-Circular. If this was not the case then the value of last would not
have moved on from j. Therefore, for any j, the list element j cannot be acceptable when
the check of i was made at node m2 . Therefore, the call to FNE-Circular which makes
the second check of i must fail. As required, we have shown that if there are more than
N ‚àí 1 calls to acceptable in an LBS, there is an unsuccessful call to FNE-Circular.
Corollary 11. In a downwards-explored search tree, calls to FNE-Circular in an LBS
make no more than 2N ‚àí 2 calls to acceptable.
Proof. By Theorem 10, the maximum number of list elements checked in successful calls
in any LBS is N ‚àí 1. The first unsuccessful call to FNE-Circular will check N ‚àí 1: all
elements of the list except list[last]. No more calls are necessary in the LBS, since no
element can become acceptable again. So the total cost is bounded above by 2N ‚àí 2.
Theorem 12. For a downwards-explored search tree containing k branches, calls to FNECircular make at most k(2N ‚àí 2) calls to acceptable.
Proof. Any call to FNE-Circular occurs at some node in the search tree. Each node in
the search tree is in exactly one LBS. Therefore every call to FNE-Circular occurs in
exactly one LBS. There are at most 2N ‚àí 2 acceptability checks in each LBS. In a tree
with k branches there are exactly k LBSs, meaning that the total number of list elements
checked in the tree is bounded above by k(2N ‚àí 2).
238

Optimal Implementation of Watched Literals

We therefore have optimality in the following sense:
Theorem 13. (Optimality) In any downwards-explored search tree, the circular approach
requires space for one last pointer and has a worst case of O(N ) calls to acceptable per
branch of the tree, and no algorithm can require o(N ) calls per branch. (Proof in Appendix E
online.)
While these results show that restoring state and circular are equivalent in worst case
time complexity in big-O terms across a tree, we can compare them more precisely.
Proposition 14. For circular, there can be as many as 2k(N ‚àí 2) calls to acceptable in
a downwards-explored search tree. For state restoration, the number of calls to acceptable
is bounded above by kN and there can be k(N ‚àí 1) calls to acceptable in a tree. (Proof
in Appendix E online.)
Thus we have that the worst case number of list element checks where we do not backtrack last is twice the worst case number of list checks where we do backtrack it. But this
does not apply on an instance by instance basis, as the following result shows.
Proposition 15. (Non Dominance) Both techniques can check less than the other across
a downwards-explored search tree. The circular method can take ‚Ñ¶(k) times fewer calls to
acceptable across the tree than state restoration, while state restoration can need ‚Ñ¶(N )
times fewer calls than circular. (Proof in Appendix E online.)
In the language of Likitvivatanavong, Zhang, Shannon, Bowen, and Freuder (2007), in
any LBS, circular can have no ‚Äúpositive repeats‚Äù (duplicate successful calls to acceptable).
It can have ‚Äúnegative repeats‚Äù (duplicate failed calls) only if the last call to FNE-Circular
fails, so there will be no failed call to FNE when there is an acceptable element at a leaf
node. This reduces significantly the chance of more than N calls in an LBS. For example,
in SAT, consider a clause with r literals. Under a random boolean assignment, there is a 21r
chance of no literals being valid under a full assignment, and 2rr of exactly one literal being
valid. With two or more valid literals, there can be no failed call. So the chance of a call to
FNE failing is no more than r+1
2r on any LBS. If clauses have 10 literals then under random
assignments there is a maximum of a just over 1% chance of negative repeats in each LBS.

4. Generalisation to Multiple Acceptable Elements
An important case is that we need to maintain multiple acceptable elements in a list.
Specifically, we must ensure that at least W different elements of list are acceptable, or
trigger some action if less than W are. The classic example is watched literals in SAT,
where W = 2 and the action is unit propagation, but examples arise in constraints with
higher W as discussed in Section 5. Not only can the circular approach be generalised, but
the bound on number of calls to acceptable per branch is independent of W .
The implementation technique is to maintain two lists. The first, called watched, is of
length W ‚àí 1, and the second list, unwatched, is of length N . The union of these two lists
is the original list list of length N + W ‚àí 1. Initialisation is assumed to either make all
elements in watched plus unwatched[last] acceptable, or (if that is not possible) to trigger
the necessary action. The solver infrastructure is assumed to ensure correct notification of
239

Gent

findNewElement: we must maintain the position of each element in watched, but this
can be done in O(1) time per move of an element using O(N + W ) space. We now assume
that if any element in watched changes from being acceptable to unacceptable, or the single
value unwatched[last] does, then FNE-Circular-W will be called with the appropriate
parameters before the next node is visited, unless backtracking occurs before then. We also
assume that if more than one such event happens at a node, a separate call happens for
each event. Given these assumptions, implementation is almost trivial, as follows.
FNE-Circular-W(list,elt,i)
1:
// elt is the value in list which is newly unacceptable
2:
// i is the index of elt in watched unless elt = unwatched[last ]
3: if elt 6= watched[i] then
4:
watched[i] := unwatched[last]
5:
unwatched[last] := elt
6: return FNE-Circular(unwatched)
Everything that follows depends on the fact that, despite swapping elements, acceptability is monotonic in the list unwatched.
Procedure 4:

Proposition 16. Acceptability in unwatched is monotonic if acceptability in list is.
Proof. Because acceptability in list is monotonic, the only way nonmonotonicity could
occur is when an element of unwatched is replaced with one from watched. This can
only happen in FNE-Circular-W at Line 5. But the value unwatched[last] is replaced
by elt, and elt becoming unacceptable is the reason that FNE-Circular-W was called.
Therefore, a call to acceptable(list,last) must return false, whether or not it would have
succeeded before the replacement. By Definition 1, monotonicity is therefore respected.
Proposition 16 and Corollary 11 make the following immediate. It is remarkable that
the bound in Corollary 17 is independent of W , the number of acceptable elements required.
Initialisation does need O(N + W ) calls to acceptable, but this is done only once.
Corollary 17. In a downwards-explored search tree, calls to FNE-Circular-W in an
LBS make no more than 2N ‚àí 2 calls to acceptable.
We must also show correctness, and this is done with a revised invariant. If the first
clause holds, we have the W required acceptable elements, while if the second does, there
can be no more than W ‚àí 1 acceptable elements so we can trigger the necessary action.
Invariant 18. At all times at least one of the following is true:
‚Ä¢ all elements in watched ‚à™ {unwatched[last]} are acceptable; or
‚Ä¢ there is no acceptable element in unwatched; or
‚Ä¢ the initialisation process has not completed; or
‚Ä¢ at the current node, at least one element in watched‚à™{unwatched[last]} has become
unacceptable but the corresponding call to findNewElement has not yet completed.

240

Optimal Implementation of Watched Literals

Lemma 19. In a downwards-explored search tree, each call to FNE-Circular-W either
returns false or reduces by one the number of unacceptable elements in the set watched ‚à™
{unwatched[last]}. (Proof in Appendix E online.)
Theorem 20. (Correctness) In a downwards-explored search tree, FNE-Circular-W
maintains Invariant 18. (Proof in Appendix E online.)
Chai and Kuehlmann (2003) described multiple watches for a pseudo-boolean solver,
although the current results do not apply because the number of watches varied during
search. Chai and Kuehlmann did not give implementation details: the implementation
described here follows Gent et al. (2006b) for a sum of boolean variables.

5. Application to Constraint Satisfaction
The first application is in constraint propagation, specifically maintaining generalised arc
consistency. The optimal algorithm GAC2001/3.1 can easily be turned into the algorithm
MGAC2001/3.1 which maintains GAC during search (BessieÃÄre et al., 2005).
Corollary 21. For a constraint of arity r where each variable is domain size d, in a
downwards-explored search tree the circular approach to maintaining the last pointer in
MGAC2001/3.1 can be achieved using space to store O(dr) last pointers (beyond the storage
space for the constraint itself ), and requires time to check O(rdr ) tuples per branch. (Proof
in Appendix E online.)
A reasonable assumption is that it takes time O(r) to check a tuple since it is arity
r (BessieÃÄre et al., 2005).3 On this basis we get time O(r2 dr ) per branch. BessieÃÄre et al.
report the same time complexity O(r2 dr ) for GAC2001/3.1 and require the same number
of last pointers. This shows that the amortized worst case big-O time per branch for
MGAC2001/3.1 is the same as that needed simply for the one-off algorithm GAC2001/3.1,
and using the same space. Bessiere (2004) reports using state restoration techniques in
his implementation of MAC2001 (BessieÃÄre & ReÃÅgin, 2001). This therefore used additional
space, since many copies of last must be stored instead of just one.
My results improve on those given by van Dongen (2004). For binary constraints (r = 2),
he gives an upper bound for space complexity of O(d min (n, d)) per constraint for a time
optimal implementation using time O(d2 ) per branch, where d is domain size and n is the
number of variables in a problem. Corollary 21 gives the same O(d2 ) time and improved
O(d) space, although van Dongen‚Äôs results remain valid as they were given as upper bounds.
There are several studies of the time complexity of maintaining arc consistency down
a branch, but no suggestion that leaving last pointers alone can be so good theoretically.
Some existing circular implementations can now be seen to be optimal. For example, Gent
et al. (2006b, p. 185) wrote: ‚ÄúThere is one general disadvantage that should be mentioned
with watched triggers, . . . it is often not possible to use a propagation algorithm which is
optimal in the worst case in terms of propagation work performed down a single branch. An
3. If constraints are stored extensionally, then this will be true, and space requirement to store the constraint
will be O(rdr ). However constraints may also be stored intensionally or procedurally, in which case
checking time can be either larger or smaller, and space requirement can be arbitrarily small.

241

Gent

example is our variant of GAC-2001/3.1 below.‚Äù In fact, this implementation of MGAC2001/3.1 was time optimal amortized across branches and had better space complexity than
van Dongen (2004) reports for optimal implementations of MAC-2001/3.1.
ReÃÅgin (2005) studied maintaining arc consistency during search without backtracking
the last pointer. He writes: ‚ÄúIf the last values are not restored after backtracking then
the time complexity of AC-6 and AC-7 algorithms is in O(d3 )‚Äù (ReÃÅgin, 2005, p. 528), and
he gives an example similar to the right hand branch of Figure 1. In this context d is
domain size and constraints are binary so the maximum length of list N = d2 . ReÃÅgin is
entirely correct. My contribution is to show that the lack of optimality down a branch is
compensated by amortization by a factor of d. ReÃÅgin writes also: ‚ÄúCurrently [i.e. before
his paper], there is no MAC version of these algorithms capable to keep the optimal time
complexity on every branch of the tree search (O(d2 ) per constraint, where d is the size of
the largest domain), without sacrificing the space complexity‚Äù. His method can recompute
a correct value of last on backtracking without storing it, by comparing the current value of
last with values restored to domain on backtracking. This is elegant but does not generalise
in an obvious way to non-binary constraints as the number of combinations of restored
values can be exponential.
Likitvivatanavong et al. (2007) discuss the cost of Arc Consistency during search. They
give ACS-resOpt, which uses an instance of the list scanning framework given here, and
report that while it is optimal at a given node, it is not optimal down the branch of a
tree (which they call ‚Äúpath-forward complexity‚Äù). By reordering domains during search,
‚ÄúAdaptive Domain Ordering‚Äù (ADO) enforces MAC for binary constraints with the optimal
property of O(ed2 ) worst-case time complexity on any branch of the search tree (Likitvivatanavong, Zhang, Bowen, & Freuder, 2005). Unfortunately it did not perform well in
empirical tests (Likitvivatanavong et al., 2007), and combined with its reordering of domains during search, this militates against widespread adoption in constraint solvers.
There are other applications in constraints. Nightingale, Gent, Jefferson, and Miguel
(2013) use the circular technique to avoid restoring state in GAC algorithms exploiting
short supports. Jefferson, Moore, Nightingale, and Petrie (2010) use it for a propagator for
a generalised ‚Äòor‚Äô constraint. Gent et al. (2006b) used the circular approach for propagating
the element constraint. They also used the generalisation to W literals for a sum of booleans
constraint. All these examples can be seen in the code for the Minion constraint solver
(Gent, Jefferson, & Miguel, 2006a), version 0.15, as can some not described in papers such
as the constraint ‚Äòlitsumgeq‚Äô. All are now seen to have excellent theoretical properties.

6. Application to Satisfiability
The second application is watched literal unit propagation in SAT (Moskewicz et al., 2001).
A clause is a list of literals. An acceptable element is one that represents either an unassigned
or a satisfied literal. In standard two-literal watching we must maintain two acceptable elements. Modern CDCL SAT solvers quickly learn large numbers of large clauses, and thus
benefit greatly from having to maintain only two pointers in a clause. The approach of Section 4 can be applied easily. However, this is not normally done in SAT solvers.4 Successful
solvers often implement the search for new watches in a non-optimal way. To see this, we
4. I am grateful to a reviewer of this paper for pointing this fact out to me.

242

Optimal Implementation of Watched Literals

must examine their code, because the necessary level of implementation detail is not given
in papers. For example MiniSat (EeÃÅn & SoÃàrensson, 2003) and tinisat (Huang, 2007) implement watched literals in the following non-optimal way. The core of the implementation is
shown as Procedure 5: a key change is that all watched elements are in the list watched
instead of all but one in Procedure 4. Some details of MiniSat‚Äôs implementation are not
in Procedure 5: the most important is the maintenance of ‚Äúblocked‚Äù literals, which I will
discuss further below. Proposition 3 does not technically apply, but nevertheless I state
without proof that this approach leads to ‚Ñ¶(N 2 ) calls to acceptable per branch in the
worst case.
FNE-NoState-W(list,elt,i)
// elt is the value in list which is newly unacceptable
// i is the index of elt in watched
result = FNE-NoState(unwatched)
if result then
watched[i] := unwatched[last]
unwatched[last] := elt
return result

Procedure 5:
1:
2:
3:
4:
5:
6:
7:

To compare practical performance, I adapted MiniSat version 2.2.0 with optimal unit
propagation using Procedure 4. I call this ‚ÄúCircular‚Äù MiniSat and the original ‚ÄúStock‚Äù
MiniSat. Appendix A gives full methodology and more detailed results. The key results
are as follows. First, Circular unit propagates notably faster than Stock when features of
MiniSat not related to unit propagation were removed. For searching 594 instances up to
10 million conflicts, Circular‚Äôs mean time was 141.6s, compared to a mean 182.6s for Stock,
so Stock takes 29.1% more time. Median performance is much closer, 73.1s for Circular
compared to 78.1s for Stock. The larger disparity in mean is because Stock is never more
than 15% faster, but Circular can be as much as 9.5 times faster than Stock. Second, when
all features of MiniSat were restored, the improved propagation speed of Circular did not
translate into improved performance. On 330 instances, there was no statistical support to
reject the null hypothesis that the two solvers have equivalent performance.
It is interesting to look at how many watched literal scans are ‚Äòblocked‚Äô, a term used in
MiniSat‚Äôs code. A clause scan is ‚Äòblocked‚Äô if the other watched literal (at the time this watch
was set up) is a valid literal now, so the clause is satisfied and no new watch is needed. This
saves accessing the memory relating to the clause. For each instance I measured the ratio
b/u between blocked and unblocked watched scans. A higher b/u is better since it results in
less watched scans. I computed the ratio œÅ between the b/u values obtained for Circular and
Stock MiniSat, œÅ = (bc /uc )/(bs /us ). Figure 3 shows œÅ plotted against obtained speedup.
Behaviour is very different in two regions. For œÅ ‚â• 1.2 (123 instances) the median speedup
is 1.48 and mean is 1.86. There is a high correlation between œÅ and speedup, r2 = 0.88. For
œÅ < 1.2 (471 instances) we get no correlation between œÅ and speedup, r2 = 0.01. Compared
to Stock MiniSat the median speedup is 0.97 and mean of 0.98, i.e. slight slowdowns. This
analysis indicates that most of the speedup occurs in instances where Circular is much
better than Stock MiniSat at setting watches on literals which are likely to be valid later
in search and thus block watched literal scans. It would be interesting to investigate this
result theoretically, since it does not follow from the results of this paper. It may be related
243

Gent

10
8
6
5
4
3
2

1
0.8
Circular:Stock
0.548x + 0.523

0.6
0.5
0.5 0.6

0.8

1

1.2

2

3

4

5

6

8

10

20

Figure 3: Scatterplot of œÅ (x-axis) against speedup ratio in conflicts per second of Circular
over Stock MiniSat (y-axis). The vertical line shows œÅ = 1.2. The line 0.548x +
0.523 is the best-fit line in the region œÅ ‚â• 1.2.

to the fact that Circular sets watches to arbitrary literals in a clause, while Stock MiniSat
will tend to set watches to literals appearing early in a clause. Therefore if a good blocking
literal is late in a clause, Circular has more chance of watching it.
Head-tail lists were an important advance in implementation of unit propagation in
SAT (Zhang & Stickel, 2000). Pointers to the first unassigned literal in a clause (head) and
the last (tail) are maintained by state-restoration. Head-tail lists led to ‚Äúwatched literals‚Äù
(Moskewicz et al., 2001), in which there are two pointers to arbitrary (but different) unassigned literals. Watched literals (or variants thereof) have become the standard technique
for efficient implementation of unit propagation in SAT solvers. When implemented as described in this paper, the theoretical properties of watched literals are now seen to be very
nearly as good as head-tail lists in time, with much reduced space overheads.
A variant implementation of watched literals is in JQuest (Lynce & Marques-Silva,
2005). Scans go from last to the end of the list, but restart from last backwards to 0. This
‚Äúmiddle-out‚Äù search can be big-O optimal provided that the current direction of search is
persistent between calls. However, if the direction of search is always initially in one direction, it can require ‚Ñ¶(N 2 ) checks per branch, and this is the case in JQuest. Full algorithmic
details and proofs of these statements are in Appendix B. Lynce and Marques-Silva (2005)
also introduced literal sifting to attempt to get the best of both worlds: literals in a clause
are reordered during search to avoid repeating checks and backtracking pointers. Lynce and
Marques-Silva report slightly better empirical performance with literal sifting (although as
just noted the comparison was with a non-optimal watched literal implementation). Generalising literal sifting to arbitrary number of acceptable elements and performing further
theoretical and experimental comparisons with the circular approach is open as future work.
244

Optimal Implementation of Watched Literals

Another application which is now seen to be optimal, if implemented in a circular style,
is Van Gelder‚Äôs (2002) three literal watching to detect binary clauses.

7. Conclusions
I have shown that the circular approach to scanning lists in backtracking search has desirable
theoretical properties. It is big-O optimal in time (measured as number of acceptability
checks) when amortized across a search tree. The worst case constant is only a factor of
two. The results are not an average case but apply to every search tree with any number of
branches. The results generalise to maintaining multiple acceptable elements in a single list,
and the complexity is independent of the number of elements required. This result is relevant
to practically important algorithms in applications such as SAT and CSP. Techniques like
watched literals in SAT are known to be successful in practice, and certainly have reduced
space overheads compared to state restoration methods. When implemented appropriately,
they can be newly understood to have essentially no theoretical disadvantages in time
either. Some existing implementations are now seen to be optimal even though this was not
realised by their implementers. Some implementations of unit propagations in real world
SAT solvers are not optimal, e.g. MiniSat. Replacing with an optimal implementation in
MiniSat can improve propagation speed by a mean of 29%. Experiments suggested that the
circular approach was better able to find watched literals likely to be true at future nodes.
However, improved propagation speed did not result in improved speed in the full solver.

Acknowledgments
I thank Chris Jefferson and Peter Nightingale for help with this paper in many ways, for
example C++ coding advice and suggestions on how to implement variants of watched
literals in MiniSat. I thank the JAIR editor of this paper, Holger Hoos, and anonymous
reviewers for suggestions leading to the comparison with MiniSat and study of the ‚Äúmiddleout‚Äù approach, and for requiring much more precise presentation of my results. I thank
authors of MiniSat, tinisat, and JQuest for making their code available for study.

Appendix A. Experiments in MiniSat
This appendix describes methodology and gives detailed results for experiments on watched
literal implementation in MiniSat version 2.2.0. Two variants of MiniSat were implemented.
The first, Circular, implements two literal watching algorithm using the approach described
in Section 4. The second, TwoPointer, is a variant in which two independent pointers are
maintained, based on an method in a preprint of this paper. Since it has worse properties
both in practice and theory, TwoPointer is described further only in Appendix C.
Timings reported here were performed on a single Apple MacPro (MacPro4,1), with
two Quad-Core Intel Xeon chips 2.26GHz, L2 Cache 256KB per core, L3 Cache 8MB per
processor, 32GB DDR3 RAM 1066MHz, 7200 RPM hard drive, MacOS 10.6. MiniSat 2.2.0
was used as the codebase, with compile time flags as in the distribution. Instances from the
245

Gent

100

Circular ratio
TwoPointer ratio

10

1

0.1

0.01
0.01

0.1

1

10

100

1000

Figure 4: Scatterplot of relative performance of Circular and TwoPointer variants compared
with Stock MiniSat. The x-axis gives run time of Stock MiniSat in seconds. The
y-axis gives ratio of Stock time to Circular/TwoPointer time. Ratios above 1
mean that the alternative was faster, and below 1 that Stock MiniSat was faster.

SAT 2005 competition (Le Berre & Simon, 2006) were used.5 The reasons for this choice
were that MiniSat did very well in that competition, so is unlikely to be a straw man, and
that it provides a large but manageable set of benchmarks: by using the entire available
set there is no chance of selection bias. While there have been significant advances in SAT
solvers since 2005, I am not aware of major changes in propagation, which are the focus of
the current paper. Code and results are available online, see Appendix D.
In the first experiment, most features of MiniSat were cut out, e.g. clause learning,
conflict analysis, heuristics. By eliminating all other aspects of the solver, each variant
searches identical spaces and the differences in speed must be due to differing speeds of
propagation. No optimisations were applied to exploit the cut-down solver, so that the
propagators being tested are the same as those used in the second experiment. However,
since they must be propagated when running full MiniSat, a set of learnt clauses should
be included. To do this, standard MiniSat was run on each instance for 60s (on a different
Linux machine). For the 594 instances unsolved after 60s, the clause set was saved to give
a realistic but static instance for the cut-down versions of MiniSat. Two versions of each
propagator were created: one in which all instrumentation was switched off, to maximise
speed; and one in which several additional counters were added to provide more metrics on
the nature of the search for watched literals. For reporting cpu times the first version was
used (with times being the median of three runs). Search was performed until a limit of
107 conflicts was reached (excepting one instance solved in 7.75 √ó 106 conflicts).
For tests of unrestricted MiniSat, three runs were performed for each algorithm-instance
combination. MiniSat default settings were used with a cpu timeout of 1200s and memory5. http://www.lri.fr/~simon/contest/results/download/distrib-benchs-random-sat2005.tar.bz2,
distrib-benchs-crafted-sat2005.tar.bz2, and distrib-benchs-industrial-sat2005.tar.bz2.

246

Optimal Implementation of Watched Literals

out of 1GB. For 87 instances, taking more than 0.01s and max-to-min deviation for some
algorithm more than 10% of its median, another 18 runs were performed for each algorithm,
and the median of all 21 runs used. Instances which no algorithm solved within the timeout,
or all did in less than 0.01s, were discarded. 330 instances remained. Results are shown
for both Circular and TwoPointer in Figure 4. There is huge variation between runtimes
on the same instance, up to almost 100 times. Each propagation method can find different
conflicting clauses, leading to different sets of learnt clauses and heuristics. The instances
vertically above and diagonally below x = 1200 are those where one method timed-out and
the other did not. A paired t-test was performed between Circular and Stock MiniSat,
with null hypothesis that the distributions have the same mean. This gave t = ‚àí0.127,
p = 0.899, i.e. a highly insignificant result. Because the assumption of normality is invalid,
the t-test was randomised 100,000 times (Cohen, 1995). Of these, 48.3% gave a lower tvalue and 51.7% a higher value. Similar results were obtained with TwoPointer and Stock
MiniSat. The conclusion must be that there is no statistical evidence that either Circular
or TwoPointer is either better or worse than Stock MiniSat in the fully featured solver.

Appendix B. Middle-Out List Scanning
This appendix gives formal presentation of algorithms and proofs for middle-out scanning
for watched literals as discussed in Section 6.
Procedure 5: FNE-MiddleOut-Helper(list,delta)
Require: delta equals ‚àí1 or +1
1: last-cache := last
2: repeat
3:
last := last + delta
4:
if acceptable(list,last) then return true
5: until last = 0 or last = N
6: last:= last-cache
7: return false
Procedure 6: FNE-MiddleOut(list)
Require: delta is persistent between calls and equals ‚àí1 or +1, initialised to either
1: if FNE-MiddleOut-Helper(delta) then
2:
return true
3: else
4:
delta := ‚àídelta
5:
if FNE-Helper(delta) then
6:
return true
7:
else
8:
return false
First, note that FNE-MiddleOut is locally correct (Definition 6). Therefore by Theorem 7, FNE-MiddleOut maintains Invariant 2 at all times. FNE-MiddleOut turns out
to be optimal in big-O terms, as follows from the analogue of Theorem 10.

247

Gent

Theorem 22. In a downwards-explored search tree, the total number of calls to acceptable made by successful calls to FNE-MiddleOut in an LBS is no more than 2N . (Proof
in Appendix E online.)
From this result we can follow similar development as for circular, with analogous results,
I omit these results except for the most important, which I state without proof.
Theorem 23. (Optimality) In any downwards-explored search tree, the Middle-Out approach requires space for one last pointer and has a worst case of O(N ) calls to acceptable
per branch of the tree.
The persistence of delta between executions is critical. If we add a line 0 : delta = +1
to Procedure 6 to give FNE-MiddleOut-Fixed, we get the following worse result.
Proposition 24. In a downwards-explored search tree, the total number of calls to acceptable made by FNE-MiddleOut-Fixed can be ‚Ñ¶(N 2 ) per branch of the search tree.
(Proof in Appendix E online.)
The solver JQuest by Lynce and Marques-Silva (2005) implements watched literals in
the style of FNE-MiddleOut-Fixed, so is non-optimal. This cannot be deduced from the
cited paper but can be seen from http://sat.inesc.pt/sat/soft/jquest/jquest-src.
tgz in file ClauseSCImplWL.java: a flag controls which direction to move first in, but this
is swapped at most once in a search for the first watch in a clause and never for the second.

Appendix C. Maintaining Multiple Pointers: Theory and Experiment
Compared with that described in Section 4, a more naive approach to implementing multiple
watches is to have a separate last pointer for each one. To unit propagate correctly in SAT
we have two watched literals. Crucially, we cannot allow two pointers to settle on the same
element. A correct method to achieve this for unit propagation is as follows. If a pointer
becomes unacceptable, then store its current value i and call FNE-Circular. If it fails the
clause is entirely false. If it succeeds with a different value to the other pointer do nothing.
If it succeeds with the value of the other pointer then call FNE-Circular again. If this
second call fails then we must reset the value of the first pointer to the stored value i and
unit propagate with the literal represented by the second pointer. To prove the optimality
of this approach I need a more general version of Theorem 10.
Theorem 25. Suppose that W pointers last1 , last2 , . . . lastW to the same list are maintained
simultaneously, with the same definition of acceptability, and that calls to FNE for a pointer
lasti are made only when it points to an unacceptable element or to the same value as another
pointer currently has. Then: if more than cN calls to acceptable are made in any LBS
in a downwards-explored search tree, either at least one of the calls to FNE-Circular fails
or at least two of the pointers take the same value. (Proof in Appendix E online.)
Theorem 25 leads to the correctness of the unit propagation procedure described above.
It guarantees that when only one satisfiable literal remains in a clause, both pointers will
settle on it and so unit propagation can be performed. The space requirement is O(1) per
last pointer. Detection of unacceptability can also be done in O(1) time by maintaining a
list of all occurrences of literals, to be consulted when a literal is set false. This gives:
248

Optimal Implementation of Watched Literals

Corollary 26. Unit propagation using watched literals in a clause with N literals can be
implemented in O(1) space using O(N ) time per branch of a search tree.

10
8
6
5
4
3
2

1
0.8
TwoPointer:Stock
0.437x + 0.572

0.6
0.5
0.5 0.6

0.8

1

1.2

2

3

4

5

6

8

10

20

Figure 5: Scatterplot of œÅ (x-axis) against speedup ratio of conflicts per second of TwoPointer over Stock MiniSat (y-axis). The line 0.437x + 0.572 is the best-fit line
in the region œÅ ‚â• 1.2. The vertical line shows œÅ = 1.2.

The development following Theorem 10 now follows as before. I state without proof:
Theorem 27. In the conditions of Theorem 25, for a search tree containing k branches,
calls to FNE-Circular make at most k((c + 1)N ‚àí 1) calls to acceptable.
TwoPointer unit propagates faster than Stock. When searching 594 instances in cutdown MiniSat up to 10 million conflicts, TwoPointer took a mean of 155.9s against 182.6s
for Stock, so Stock takes 17.1% more time. This was about 10% slower than Circular‚Äôs
mean time of 141.6s. Circular is never more than 13% slower than TwoPointer or more
than 35% faster. Both mean and median speedups of Circular over TwoPointer are 1.10.
The median performance of Stock was slightly better than TwoPointer (78.1s to 81.1s) but
Stock is never more than 22% faster while TwoPointer can be as much as 7.7 times faster.
We see similar results on the effect of blocked watches as with Circular. Results for
Circular and definition of œÅ are given in the main paper in Section 6. Where œÅ ‚â• 1.2 (122
instances), œÅ correlates very strongly with speedup in conflicts per second, with correlation
coefficient r2 = 0.86. Median speedup in this region is 1.32 and mean is 1.65. The best fit
line is shown in Figure 5. For œÅ < 1.2 (472 instances), there is no correlation between œÅ and
speedup, with r2 = 0.07. Median and mean speedups are 0.88 and 0.90 (so are slowdowns
not speedups.) In all regions, there is an extremely high correlation between TwoPointer
and Circular, r2 > 0.996. As with Circular, this analysis indicates that most of the speedup
occurs in instances where TwoPointer is much better than Stock MiniSat at setting watches
on literals which are likely to be valid later in search and thus block watched literal search.
249

Gent

Results for TwoPointer in the full version of MiniSat were similar to those with Circular.
Under the methodology described in Appendix A, the raw t-value is ‚àí1.54, p = 0.124.
Randomisation 100,000 times gave 26.2% lower t-values and 73.8% higher values.

Appendix D. Description of Online Appendices
Two Online Appendices are available. The first is a textual Appendix E with proofs omitted
from the main text (Gent13a-appendix1.pdf).6 The second contains the results tables, full
MiniSat outputs, and graphs used for this paper (Gent13a-appendix2.tgz).7 A fuller version
of this appendix, including code for each variant of MiniSat and scripts to run and analyse
experiments, is available separately.8 The file is about 4MB and unpacks to about 12MB.
Separately, a 2.4GB compressed tar file is available containing the clausesets written out
after 60s failed search.9

References
BessieÃÄre, C., ReÃÅgin, J.-C., Yap, R., & Zhang, Y. (2005). An optimal coarse-grained arc
consistency algorithm. Artificial Intelligence, 165, 165‚Äì185.
Bessiere, C. (2004). Personal communication to Marc van Dongen.. Described by (van
Dongen, 2004).
BessieÃÄre, C., & ReÃÅgin, J.-C. (2001). Refining the basic constraint propagation algorithm.
In Nebel, B. (Ed.), Proceedings of the Seventeenth International Joint Conference on
Artificial Intelligence, IJCAI 2001, Seattle, Washington, USA, August 4-10, 2001, pp.
309‚Äì315. Morgan Kaufmann.
Chai, D., & Kuehlmann, A. (2003). A fast pseudo-boolean constraint solver. In Proceedings
of the 40th Design Automation Conference, DAC 2003, Anaheim, CA, USA, June
2-6, 2003, pp. 830‚Äì835. ACM.
Cohen, P. R. (1995). Empirical methods for artificial intelligence. MIT Press.
EeÃÅn, N., & SoÃàrensson, N. (2003). An extensible SAT-solver. In Giunchiglia, E., & Tacchella, A. (Eds.), SAT, Vol. 2919 of Lecture Notes in Computer Science, pp. 502‚Äì518.
Springer.
Gent, I. P., Jefferson, C., & Miguel, I. (2006a). Minion: A fast scalable constraint solver.
In Brewka, G., Coradeschi, S., Perini, A., & Traverso, P. (Eds.), ECAI, Vol. 141 of
Frontiers in Artificial Intelligence and Applications, pp. 98‚Äì102. IOS Press.
Gent, I. P., Jefferson, C., & Miguel, I. (2006b). Watched literals for constraint propagation
in Minion. In Benhamou, F. (Ed.), CP, Vol. 4204 of Lecture Notes in Computer
Science, pp. 182‚Äì197. Springer.
Harvey, W. D., & Ginsberg, M. L. (1995). Limited discrepancy search. In Proceedings
of the Fourteenth International Joint Conference on Artificial Intelligence, IJCAI 95,
6.
7.
8.
9.

Also available at http://ipg.host.cs.st-andrews.ac.uk/JAIR/Gent13a-appendix1.pdf
Also available at http://ipg.host.cs.st-andrews.ac.uk/JAIR/Gent13a-appendix2.tgz
http://ipg.host.cs.st-andrews.ac.uk/JAIR/Gent13a-appendix2-full.tgz
http://ipg.host.cs.st-andrews.ac.uk/JAIR/writtenclausesets.tgz

250

Optimal Implementation of Watched Literals

MontreÃÅal QueÃÅbec, Canada, August 20-25 1995, 2 Volumes, Vol. 1, pp. 607‚Äì615. Morgan
Kaufmann.
Huang, J. (2007). A case for simple SAT solvers. In Bessiere, C. (Ed.), Principles and
Practice of Constraint Programming - CP 2007, 13th International Conference, CP
2007, Providence, RI, USA, September 23-27, 2007, Proceedings, Vol. 4741 of Lecture
Notes in Computer Science, pp. 839‚Äì846. Springer.
Jefferson, C., Moore, N. C. A., Nightingale, P., & Petrie, K. E. (2010). Implementing logical
connectives in constraint programming. Artificial Intelligence, 174 (16-17), 1407‚Äì1429.
Korf, R. E. (1985). Depth-first iterative-deepening: An optimal admissible tree search.
Artificial Intelligence, 27 (1), 97‚Äì109.
Le Berre, D., & Simon, L. (2006). Special volume on the SAT 2005 competitions and
evaluations. JSAT, 2 (1-4).
Likitvivatanavong, C., Zhang, Y., Bowen, J., & Freuder, E. C. (2005). Maintaining arc consistency using adaptive domain ordering. In Kaelbling, L. P., & Saffiotti, A. (Eds.),
IJCAI-05, Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence, Edinburgh, Scotland, UK, July 30-August 5, 2005, pp. 1527‚Äì1528.
Professional Book Center.
Likitvivatanavong, C., Zhang, Y., Shannon, S., Bowen, J., & Freuder, E. C. (2007). Arc
consistency during search. In Veloso, M. M. (Ed.), IJCAI 2007, Proceedings of the 20th
International Joint Conference on Artificial Intelligence, Hyderabad, India, January
6-12, 2007, pp. 137‚Äì142.
Lynce, I., & Marques-Silva, J. P. (2005). Efficient data structures for backtrack search SAT
solvers. Ann. Math. Artif. Intell., 43 (1), 137‚Äì152.
Marques-Silva, J. P., Lynce, I., & Malik, S. (2009). Conflict-driven clause learning sat
solvers. In Biere, A., Heule, M., van Maaren, H., & Walsh, T. (Eds.), Handbook
of Satisfiability, Vol. 185 of Frontiers in Artificial Intelligence and Applications, pp.
131‚Äì153. IOS Press.
Moskewicz, M. W., Madigan, C. F., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: engineering an efficient SAT solver. In Proceedings of the 38th annual Design Automation
Conference, DAC ‚Äô01, pp. 530‚Äì535, New York, NY, USA. ACM.
Nightingale, P., Gent, I. P., Jefferson, C., & Miguel, I. (2013). Short and long supports for
constraint propagation. J. Artif. Intell. Res. (JAIR), 46, 1‚Äì45.
Prosser, P. (1993). Hybrid algorithms for the constraint satisfaction problem. Computational
Intelligence, 9(3), 268‚Äì299.
Prosser, P., & Unsworth, C. (2011). Limited discrepancy search revisited. J. Exp. Algorithmics, 16, 1.6:1.1‚Äì1.6:1.18.
ReÃÅgin, J.-C. (2005). MAC algorithms during the search without additional space cost. In
Proc. 11th Principles and Practice of Constraint Programming (CP 2005), pp. 520‚Äì
533.
van Dongen, M. R. C. (2004). Saving support-checks does not always save time. Artif.
Intell. Rev., 21 (3-4), 317‚Äì334.
251

Gent

Van Gelder, A. (2002). Generalizations of watched literals for backtracking search. In
Seventh Intl Symposium on AI and Mathematics.
Zhang, H., & Stickel, M. E. (2000). Implementing the Davis-Putnam method. J. Autom.
Reasoning, 24 (1/2), 277‚Äì296.

252

Journal of Artificial Intelligence Research 48 (2013) 513-582

Submitted 12/12; published 11/13

AI Methods in Algorithmic Composition:
A Comprehensive Survey
Jose David Fern√°ndez
Francisco Vico

josedavid@geb.uma.es
fjv@geb.uma.es

Universidad de M√°laga, Calle Severo Ochoa, 4, 119
Campanillas, M√°laga, 29590 Spain

Abstract
Algorithmic composition is the partial or total automation of the process of music composition by using computers. Since the 1950s, different computational techniques related to
Artificial Intelligence have been used for algorithmic composition, including grammatical
representations, probabilistic methods, neural networks, symbolic rule-based systems, constraint programming and evolutionary algorithms. This survey aims to be a comprehensive
account of research on algorithmic composition, presenting a thorough view of the field for
researchers in Artificial Intelligence.

1. Introduction
Many overly optimistic, but ultimately unfulfilled predictions were made in the early days
of Artificial Intelligence, when computers able to pass the Turing test seemed a few decades
away. However, the field of Artificial Intelligence has grown and got matured, developing
from academic research and reaching many industrial applications. At the same time, key
projects and challenges have captivated public attention, such as driverless cars, natural
language and speech processing, and computer players for board games.
The introduction of formal methods have been instrumental in the consolidation of many
areas of Artificial Intelligence. However, this presents a disadvantage for areas whose subject
matter is difficult to define in formal terms, which naturally tend to become marginalized.
That is the case of Computational Creativity (also known as Artificial Creativity), which
can be loosely defined as the computational analysis and/or synthesis of works of art, in a
partially or fully automated way. Compounding the problem of marginalization, the two
communities naturally interested in this field (AI and the arts) speak different languages
(sometimes very different!) and have different methods and goals1 , creating great difficulties in the collaboration and exchange of ideas between them. In spite of this, small
and sometimes fragmented communities are active in the research of different aspects of
Computational Creativity.
The purpose of this survey is to review and bring together existing research on a specific
style of Computational Creativity: algorithmic composition. Interpreted literally, algorithmic composition is a self-explanatory term: the use of algorithms to compose music. This
is a very broad definition, because for centuries musicians have been proposing methods
that can be considered as algorithmic in some sense, even if human creativity plays a key
1. Related to this problem, it is not uncommon for engineering concepts to become bent in strange ways
when interpreted by artists. See Footnote 28 in page 550 for a particularly remarkable example.
c
2013
AI Access Foundation. All rights reserved.

Fern√°ndez & Vico

role. Some commonly cited examples include d‚ÄôArezzo‚Äôs Micrologus, species counterpoint,
Mozart‚Äôs dice games, Schoenberg‚Äôs twelve-tone technique, or Cage‚Äôs aleatoric music. Readers interested in these and other pre-computer examples of algorithmic composition are
referred to the introductory chapters of almost any thesis or book on the subject, such as
D√≠az-Jerez‚Äôs (2000), Aschauer‚Äôs (2008) or Nierhaus‚Äôs (2009). In this survey, we will use the
term algorithmic composition in a more restricted way, as the partial or total automation
of music composition by formal, computational means. Of course, pre-computer examples
of algorithmic composition can be implemented on a computer, and some of the approaches
reviewed in this survey implement a classical methodology. In general, the focus will be
on AI techniques, but self-similarity and cellular automata will also be reviewed as modern
computational techniques that can be used for generating music material without creative
human input.
1.1 Motivation
Some useful starting points for researching the past and present of computer music are the
Computer Music Journal, the International Computer Music Conference 2 annually organized by the International Computer Music Association 3 , and some books such as Machine
Models of Music (Schwanauer & Levitt, 1993), Understanding music with AI (Balaban
et al., 1992), Music and Connectionism (Todd & Loy, 1991), and the anthologies of selected
articles from the Computer Music Journal (Roads & Strawn, 1985; Roads, 1992). However,
these resources are not only about algorithmic composition, but computer music in general.
For more specific information on algorithmic composition, surveys are a better option.
There are many surveys reviewing work on algorithmic composition. Some review both
analysis and composition by computer with AI methods (Roads, 1985), while others discuss
algorithmic composition from a point of view related to music theory and artistic considerations (Collins, 2009), or from the personal perspective of a composer (Langston, 1989;
Dobrian, 1993; Pope, 1995; Maurer, 1999). Some of them provide an in depth and comprehensive view of a specific technique for algorithmic composition, as Anders and Miranda
(2011) do for constraint programming, as Ames (1989) does for Markov chains, or as Santos
et al. (2000) do for evolutionary techniques, while some others are specialized in the comparison between paradigms for computational research on music, as Toiviainen (2000). Others
offer a wide-angle (but relatively shallow) panoramic of the field (Papadopoulos & Wiggins,
1999), review the early history of the field (Loy & Abbott, 1985; Ames, 1987; Burns, 1994),
or analyze methodologies and motivations for algorithmic composition (Pearce et al., 2002).
There are also works that combine in depth and comprehensive reviews for a wide range of
methods for algorithmic composition, such as Nierhaus‚Äôs (2009) book.
In this context, a natural question arises: why yet another survey? The answer is
that no existing survey article fulfills the following criteria: (a) to cover all methods in
a comprehensive way, but from a point of view primarily focused on AI research, and
(b) to be centered on algorithmic composition.4 Nierhaus‚Äôs (2009) book on algorithmic
2. The archives are available at http://quod.lib.umich.edu/i/icmc/
3. http://www.computermusic.org/
4. Many surveys conflate the discussion on algorithmic composition (synthesis of music) with the computational analysis of music, as in the work of Roads (1985), Nettheim (1997) or Toiviainen (2000). This
can become somewhat distracting if the reader is interested just in algorithmic composition.

514

AI Methods in Algorithmic Composition

composition comes close to fulfilling these criteria with long, detailed expositions for each
method and comprehensive reviews of the state of the art. In contrast, this survey is
intended to be a reasonably short article, without lengthy descriptions: just a reference
guide for AI researchers. With these aims in mind, this survey is primarily structured
around the methods used to implement algorithmic composition systems, though early
systems will also be reviewed separately.
A second, more practical motivation is accessibility. Since Computational Creativity
balances on the edge between AI and the arts, the relevant literature is scattered across
many different journals and scholarly books, with a broad spectrum of topics from computer
science to music theory. As a very unfortunate consequence, there are many different
paywalls between researchers and relevant content, translating sometimes into a lot of hassle,
only partially mitigated by relatively recent trends like self-archiving. This survey brings
together a substantial body of research on algorithmic composition, with the intention of
conveying it more effectively to AI researchers.

2. Introducing Algorithmic Composition
Traditionally, composing music has involved a series of activities, such as the definition of
melody and rhythm, harmonization, writing counterpoint or voice-leading, arrangement or
orchestration, and engraving (notation). Obviously, this list is not intended to be exhaustive
or readily applicable to every form of music, but it is a reasonable starting point, especially
for classical music. All of these activities can be automated by computer to varying degrees,
and some techniques or languages are more suitable for some of these than others (Loy &
Abbott, 1985; Pope, 1993).
For relatively small degrees of automation, the focus is on languages, frameworks and
graphical tools to provide support for very specific and/or monotone tasks in the composition process, or to provide raw material for composers, in order to bootstrap the composition
process, as a source of inspiration. This is commonly known as computer-aided algorithmic composition (CAAC), and constitutes a very active area of research and commercial
software development: many software packages and programming environments can be
adapted to this purpose, such as SuperCollider (McCartney, 2002), Csound (Boulanger,
2000), MAX/MSP (Puckette, 2002), Kyma (Scaletti, 2002), Nyquist (Simoni & Dannenberg, 2013) or the AC Toolbox (Berg, 2011). The development of experimental CAAC
systems at the IRCAM5 (such as PatchWork, OpenMusic and their various extensions)
should also be emphasized (Assayag et al., 1999). Ariza‚Äôs comprehensive repository of software tools and research resources for algorithmic composition6 constitutes a good starting
point (Ariza, 2005a) to explore this ecosystem, as well as algorithmic composition in general.
Earlier surveys (such as Pennycook, 1985 and Pope, 1986) are also useful for understanding
the evolution of the field, especially the evolution of graphical tools to aid composers.
Our survey, on the other hand, is more concerned with algorithmic composition with
higher degrees of automation of compositional activities, rather than typical CAAC. In other
words, we focus more on techniques, languages or tools to computationally encode human
musical creativity or automatically carry out creative compositional tasks with minimal or
5. http://www.ircam.fr/
6. http://www.flexatone.net/algoNet/

515

Fern√°ndez & Vico

no human intervention, instead of languages or tools whose primary aim is to aid human
composers in their own creative processes.
Obviously, the divide between both ends of the spectrum of automation (CAAC representing a low degree of automation, algorithmic composition a high degree of automation) is
not clear, because any method that automates the generation of creative works can be used
as a tool to aid composers, and systems with higher degrees of automation can be custombuilt on top of many CAAC frameworks.7 Furthermore, a human composer can naturally
include computer languages and tools as an integral part of the composition process, such
as Brian Eno‚Äôs concept of generative music (Eno, 1996). To conclude these considerations,
this survey is about computer systems for automating compositional tasks where the user
is not expected to be the main source of creativity (at most, the user is expected to set
parameters for the creative process, encode knowledge about how to compose, or to provide examples of music composed by humans to be processed by the computer). This also
includes real-time automatic systems for music improvisation, such as in jazz performance,
or experimental musical instruments that automate to a certain extent the improvisation
of music.
Finally, a few more considerations, to describe what this survey is not about:
‚Ä¢ Although music can be defined as ‚Äúorganized sound‚Äù, a composition written in traditional staff notation does not fully specify how the music actually sounds: when a
piece of music is performed, musicians add patterns of small deviations and nuances in
pitch, timing and other musical parameters. These patterns account for the musical
concept of expressiveness or gesture, and they are necessary for the music to sound
natural. While the problem of automatically generating expressive music is important
in itself, and involves creativity, it is clearly not within the boundaries of algorithmic
composition as reviewed in this survey. The reader is referred to Kirke and Miranda‚Äôs
(2009) review of this area for further information.
‚Ä¢ The computational synthesis of musical sounds, or algorithmic sound synthesis, can be
understood as the logical extension of algorithmic composition to small timescales; it
involves the use of languages or tools for specifying and synthesizing sound waveforms,
rather than the more abstract specification of music associated with traditional staff
notation. The line between algorithmic composition and algorithmic sound synthesis
is blurred in most of the previously mentioned CAAC systems, but this survey is not
concerned with sound synthesis; interested readers may refer to Roads‚Äôs (2004) book
on the subject.
‚Ä¢ In computer games (and other interactive settings), music is frequently required to
gracefully adapt to the state of the game, according to some rules. This kind of
music is commonly referred to as non-linear music (Buttram, 2003) or procedural
audio (Farnell, 2007). Composing non-linear music presents challenges of its own, not
specifically related to the problem of algorithmic composition, so we will not review
the literature on this kind of music.
7. This is the case of many of the systems for algorithmic composition described here. For example,
PWConstraints (described in Section 3.2.3) is built on top of PatchWork, as described by Assayag et al.
(1999).

516

AI Methods in Algorithmic Composition

These three scenarios (automated expressiveness, algorithmic sound synthesis and nonlinear music) will be sparingly mentioned in this survey, only mentioned when innovative
(or otherwise notable) techniques are involved.
2.1 The Early Years
In this section, we will review early research published on algorithmic composition with
computers, or with a clear computational approach. While these references might have
been discussed by methodology in the following sections, it is useful to group them together
here, since it is difficult to find a survey discussing all of them.
The earliest use of computers to compose music dates back to the mid-1950s, roughly
at the same time as the concept of Artificial Intelligence was coined at the Darmouth
Conference, though the two fields did not converge until some time later. Computers were
expensive and slow, and also difficult to use, as they were operated in batch mode.
One of the most commonly cited examples is Hiller and Isaacson‚Äôs (1958) Illiac Suite,
a composition that was generated using rule systems and Markov chains, late in 1956. It
was designed as a series of experiments on formal music composition. During the following
decade, Hiller‚Äôs work inspired colleagues from the same university to further experiment
with algorithmic composition, using a library of computer subroutines for algorithmic composition written by Baker (also a collaborator of Hiller), MUSICOMP (Ames, 1987). This
library provided a standard implementation of the various methods used by Hiller and
others.
Iannis Xenakis, a renowned avant-garde composer, profusely used stochastic algorithms
to generate raw material for his compositions, using computers since the early 1960s to
automate these methods (Ames, 1987). Though his work can be better described as CAAC,
he still deserves being mentioned for being a pioneer. Koenig, while not as well known as
Xenakis, also was a composer that in 1964 implemented an algorithm (PROJECT1) using
serial composition (a musical theory) and other techniques (as Markov chains) to automate
the generation of music (Ames, 1987).
However, there were also several other early examples of algorithmic composition, though
not so profusely cited as Hiller and Xenakis‚Äôs. Push Button Bertha, composed in 1956
(Ames, 1987) around the same time as Hiller‚Äôs Illiac Suite, is perhaps the third most
cited example: a song whose music was algorithmically composed as a publicity stunt by
Burroughs (an early computer company), generating music similar to a previously analyzed
corpus. However, there is at least one earlier, unpublished work by Caplin and Prinz in 1955
(Ariza, 2011), which used two approaches: an implementation of Mozart‚Äôs dice dame and
a generator of melodic lines using stochastic transitional probabilities for various aspects
of the composition. Another commonly cited example by Brooks et al. (1957) explored the
potential of the Markoff 8 chain method.
Several other early examples are also notable. Olson‚Äôs (1961) dedicated computer was
able to compose new melodies related to previously fed ones, using Markov processes. While
the work was submitted for publication in 1960, they claimed to have built the machine in
the early 1950s. Also of interest is Gill‚Äôs (1963) algorithm, implemented at the request of the
8. ‚ÄúMarkov‚Äù and ‚ÄúMarkoff‚Äù are alternative transliterations of the Russian surname –ú–∞ÃÅ—Ä–∫–æ–≤. The spelling
‚ÄúMarkov‚Äù has been prevalent for decades, but many older papers used ‚ÄúMarkoff‚Äù.

517

Fern√°ndez & Vico

BBC, which represents a hallmark in the application of classical AI techniques to algorithmic
composition: it used a hierarchical search with backtracking to guide a compositional process inspired by Schoenberg‚Äôs twelve-tone technique. Finally, it is worth mentioning what
may represent the first dissertation on algorithmic composition: Padberg‚Äôs (1964) Ph.D.
thesis implemented a compositional framework (based in formal music theory) in computer
code. Her work is unusual in that, instead of using random number generators, she used
raw text input to drive procedural techniques in order to generate all the parameters of the
composition system.
Non-scholarly early examples also exist, though they are difficult to assess because of
the sparsity of the published material, and the fact that they are mostly not peer-reviewed.
For example, Pinkerton (1956) described in Scientific American a ‚ÄúBanal Tune-Maker‚Äù, a
simple Markov chain created from several tens of nursery tunes, while Sowa (1956) used
a GENIAC machine9 to implement the same idea (Cohen, 1962), and Raymond Kurzweil
implemented in 1965 (Rennie, 2010) a custom-made device that generated music in the style
of classical composers. Another example, unfortunately shrouded in mystery, is Raymond
Scott‚Äôs ‚ÄúElectronium‚Äù (Chusid, 1999), an electronic device whose development spanned
several decades, reportedly able to generate abstract compositions. Unfortunately, Scott
never published or otherwise explained his work.
As machines became less expensive, more powerful and in some cases interactive, algorithmic composition slowly took off. However, aside from the researchers at Urbana (Hiller‚Äôs
university), there was little continuity in research, and reinventing the wheel in algorithmic
composition techniques was common. This problem was compounded by the fact that initiatives in algorithmic composition often came from artists, who tended to develop ad hoc
solutions, and the communication with computer scientists was difficult in many cases.

3. The Methods
The range of methodological approaches used to implement algorithmic composition is
notably wide, encompassing many, very different methods from Artificial Intelligence, but
also borrowing mathematical models from Complex Systems and even Artificial Life. This
survey has been structured by methodology, devoting a subsection to each one:
3.1

Grammars

3.2

Symbolic, Knowledge-Based Systems

3.3

Markov Chains

3.4

Artificial Neural Networks

3.5

Evolutionary and Other Population-Based Methods

3.6

Self-Similarity and Cellular Automata

Figure 1 summarizes the taxonomy of the methods reviewed in this survey. Together,
Sections 3.1 and 3.2 describe work using symbolic techniques that can be characterized
as classical ‚Äúgood old-fashioned AI‚Äù. Although grammars (Section 3.1) are symbolic and
9. A GENIAC Electric Brain, an electric-mechanic machine promoted as an educational toy. Despite being
marketed as a computer device, all the ‚Äúcomputing‚Äù was performed by the human operator.

518

AI Methods in Algorithmic Composition

Artificial intelligence
Symbolic AI

Optimization

(Knowledge-based, Rule-based)
Sections 3.1, 3.2

Computational methods
for automatic generation
of music material
(not based on models
of human creativity)

Population-based methods
Grammars

Rule learning

Section 3.1

Section 3.2.1

Evolutionary algorithms

L-systems

Sections 3.1.2, 3.2.2, 3.4.1, 3.5

Section 3.1.1

Constraint
satisfaction

Related
methods

Automatic

Interactive

Section 3.5.1

Section 3.5.2

Section 3.2.3

Section 3.1.3

Complex systems
Case-based
reasoning

Concurrency
models

Section 3.2.4

Section 3.2.5

Other population-based methods
Section 3.5.3

Self-similarity
Section 3.6

Machine learning
Markov chains
Related statistical methods
Section 3.3

Cellular automata
Artificial neural networks

Section 3.6.1

Section 3.4

Figure 1: Taxonomy of the methods reviewed in this survey
knowledge-based, and thus should be included as part of Section 3.2, they have been segregated in a separate subsection because of their relative historical importance in algorithmic
composition. Sections 3.3 and 3.4 describe work using various methodologies for machine
learning, and Section 3.5 does the same for evolutionary algorithms and other populationbased optimization methods. Although the methodologies described in Section 3.6 are not
really a form of ‚ÄúArtificial Intelligence‚Äù, they have been included because of their importance in algorithmic composition as automatic sources of music material (i.e., they do not
depend on any model of human creativity for generating music material).
There have been other attempts to systematize algorithmic composition, such as the
taxonomies of Papadopoulos and Wiggins (1999) and Nierhaus (2009). Our taxonomy
is roughly similar to Nierhaus‚Äôs, with some differences, such as including L-systems as
grammars instead of self-similar systems. The reader may be surprised to find that many
methods for machine learning and optimization are missing from our taxonomy. There are
several reasons for this. In some cases, some methods are subsumed by others. For example,
in machine learning, many different methods have been formulated in the mathematical
framework of artificial neural networks. In other cases, a method has been used only rarely,
almost always together with other methods. For example, in optimization, this is the case
of tabu search, which has been used a few times in the context of constraint satisfaction
problems (Section 3.2.3), and simulated annealing, which has been occasionally combined
with constraint satisfaction, Markov processes and artificial neural networks.
It is difficult to neatly categorize the existing literature in algorithmic composition with
any hierarchical taxonomy, because the methods are frequently hybridized, giving rise to
many possible combinations. This is specially true for evolutionary methods, which have
519

Fern√°ndez & Vico

been combined with almost every other method. Additionally, some papers can be considered to belong to different methodologies, depending on the selected theoretical framework10 , while others are unique in their approaches11 , further complicating the issue. Finally, the lines between some methods (as rule systems, grammars and Markov chains) are
frequently blurred: in some cases, ascribing a work to one of them becomes, in the end, a
largely arbitrary exercise depending on the terminology, intentions and the domain of the
researchers. Each method will be presented separately (but also presenting existing hybridizations with other methods), describing the state of the art in a mostly chronological
order for each method.
Although this classification is not fully comprehensive, we have only found one (arguably
remote) example using a method that is not related to the ones listed above: Amiot et al.
(2006), who applied the Discrete Fourier Transform (DFT) to generate variations of musical
rhythms. Given a rhythm as a sequence of numerical symbols, they represented it in the
frequency domain by computing its DFT. Variations on that rhythm were generated by
slightly perturbing the coefficients of the transform and converting back to the time domain.
3.1 Grammars and Related Methods
In broad terms, a formal grammar may be defined as a set of rules to expand high-level
symbols into more detailed sequences of symbols (words) representing elements of formal
languages. Words are generated by repeatedly applying rewriting rules, in a sequence of
so-called derivation steps. In this way, grammars are suited to represent systems with hierarchical structure, which is reflected in the recursive application of the rules. As hierarchical
structures can be recognized in most styles of music, it is hardly surprising that formal
grammar theory has been applied to analyze and compose music for a long time12 , despite recurring concerns that grammars fail to capture the internal coherency and subtleties
required for music composition (Moorer, 1972).
To compose music using formal grammars, an important step is to define the set of
rules of the grammar, which will drive the generative process. The rules are traditionally
multi-layered, defining several subsets (maybe even separated in distinct grammars) of rules
for different phases of the composition process: from the general themes of the composition,
down to the arrangement of individual notes. While early authors derived the rules by hand
from principles grounded in music theory, other methods are possible, like examining a corpus of pre-existing musical compositions to distill a grammar able to generate compositions
in the general style of the corpus, or using evolutionary algorithms. Another important
aspect is the mapping between the formal grammar and the musical objects that it generates, which usually relates the symbols of the derived sequences with elements of the music
composition, as notes, chords or melodic lines. However, other mappings are possible, as
using the derivation tree to define the different aspects of the musical composition. Another
important aspect of the automatic composition process is the election of the grammatical
10. For example, Markov chains can be formulated as stochastic grammars; some self-similar systems can be
characterized as L-system grammars; rule learning and case-based reasoning are also machine learning
methods; etc.
11. For example, Kohonen‚Äôs method (Kohonen et al., 1991), which is neither grammatical nor neural nor
Markovian, but can be framed in either way, according to its creator.
12. See, e.g., the survey by Roads (1979).

520

AI Methods in Algorithmic Composition

Reference

Composition task

Comments

Lidov & Gabura, 1973

melody

early proposal

Rader, 1974

melody

early proposal,
very detailed grammar

Ulrich, 1977

jazz chord identification

integrated in an ad hoc system
(to produce jazz improvisations)

Baroni & Jacoboni, 1978

grammar for Bach chorales

early proposal

Leach & Fitch, 1995
(XComposer)

structure, rhythm and melody

uses chaotic non-linear systems
(self-similarity)

Hamanaka et al., 2008

generate variations on two melodies
(by altering the derivation tree)

inspired by Lerdahl et al.‚Äôs (1983)
GTTM

Roads, 1977

structure, rhythm and melody

grammar compiler

Holtzman, 1981

structure, rhythm and melody

grammar compiler

Jones, 1980

structure

space grammars
(uses the derivation tree)

Bel, 1992
(Bol Processor)

improvisation of tabla rhythms

tool for field research

Kippen & Bel, 1989

improvisation of tabla rhythms

grammatical inference

Cruz-Alc√°zar & Vidal-Ruiz,
1998

melody

grammatical inference

Gillick et al., 2009

jazz improvisation

grammatical inference.
Implemented as an extension to
Keller and Morrison‚Äôs (2007)
ImprovGenerator

Kitani & Koike, 2010
(ImprovGenerator)

real-time drum rhythm improvisation

online grammatical inference

Keller & Morrison, 2007
(Impro-Visor)

jazz improvisation

sophisticated GUI interface

Quick, 2010

classical three-voice counterpoint

integrated in a Schenkerian
framework

Chemillier, 2004

jazz chord sequences

implemented in OpenMusic and
MAX

Table 1: References for Section 3.1 (algorithmic composition with grammars), in order of
appearance.

rules to be applied. While many approaches are possible, the use of activation probabilities
for the rules (stochastic grammars) is common. In the process of compiling information
for this survey, it has been noted that almost all research has been done on regular and
context-free grammars, as context-sensitive and more general grammars seem to be very
difficult to implement effectively, except for very simple toy systems.
Lidov and Gabura (1973) implemented an early example of a formal grammar to compose simple rhythms. Another early example was implemented by Rader (1974): he defined
a grammar by hand from rather simple music concepts, enriching the rules of the grammar
with activation probabilities. Other early examples used grammars driven by rules from
music theories, either as a small part of a synthesis engine, as Ulrich‚Äôs (1977) grammar
521

Fern√°ndez & Vico

for enumerating jazz chords, or by inferring the rules from classical works, as Baroni and
Jacoboni‚Äôs (1978) grammar to generate melodies. A Generative Theory of Tonal Music
(Lerdahl et al., 1983), a book presenting a grammatical analysis of tonal music, is a relatively early theoretical work that can be said to have influenced the use of grammars for
algorithmic composition, though it is not directly concerned with algorithmic composition,
but with a grammatical approach to the analysis of music. This book has been widely popular, and has had a lasting impact on the field and high citation rates. Examples of later
work inspired by this book include Pope‚Äôs (1991) ‚ÄúT-R Trees‚Äù, Leach and Fitch‚Äôs (1995)
‚Äúevent trees‚Äù, and Hamanaka et al.‚Äôs (2008) ‚Äúmelody morphing‚Äù.
In the 1980s, some proposed approaches more in line with computer science, abstracting
the process to generate the grammars instead of codifying them by hand, though at the cost
of producing less interesting compositions. Roads (1977) proposed a framework to define,
process and use grammars to compose music, while Holtzman (1981) described a language
to define music grammars and automatically compose music from them. Meanwhile, Jones
(1980) proposed the concept of space grammars, in conjunction with a novel mapping
technique: instead of using the terminal symbols as the building blocks of the composition,
he used the derivation tree of the terminal sequence to define the characteristics of the
composition. This approach was unfortunately not developed far enough to yield significant
results. In spite of these early efforts, most research on grammatical representations of
music was focused on analysis rather than synthesis. Some instances, such as Steedman‚Äôs
(1984) influential grammar for the analysis of jazz chord progressions, were later adapted
for synthesis (see below).
The problem with a grammatical approach to algorithmic composition is the difficulty
to manually define a set of grammatical rules to produce good compositions. This problem
can be solved by generating the rules of the grammar (and the way they are applied) automatically. For example, although Bel (1992) implemented the BOL processor to facilitate
the creation by hand of more or less sophisticated music grammars13 , he also explored the
automated inference of regular grammars (Kippen & Bel, 1989). Later, Cruz-Alc√°zar and
Vidal-Ruiz (1998) implemented several methods of grammatical inference: analyze a corpus of pre-existing classical music compositions, represented with a suitable set of symbols,
then inducing stochastic regular grammars (Markov chains) able to parse the compositions
in the corpus, and finally applying these grammars to generate new compositions that are
in a similar style to the compositions in the corpus. Gillick et al. (2009) used a similar
approach (also Markovian) to synthesize jazz solos, but with a more elaborated synthesis
phase. Kitani and Koike (2010) provide another example of grammatical inference, in this
case used for real-time improvised accompaniment.
However, others still designed their grammars by hand, carefully choosing the mapping between terminal symbols and musical objects, as Keller and Morrison (2007) did
for jazz improvisations. Another approach is to take a pre-existing music theory with a
strong hierarchical methodology, as designing a grammar inspired in Schenkerian analysis
(Quick, 2010), or using Lerdhal‚Äôs grammatical analysis to derive new compositions from two
previously existing ones by altering the derivation tree (Hamanaka et al., 2008), or even de13. Initially to represent and analyze informal knowledge about Indian tabla drumming, but later also to
represent other music styles.

522

AI Methods in Algorithmic Composition

Reference

Composition task

Comments

Prusinkiewicz, 1986

melody

mapping turtle graphics to music scores

Nelson, 1996

melody

mapping turtle graphics to music scores

Mason & Saffle, 1994

melody (counterpoint is suggested)

mapping turtle graphics to music scores

Soddell & Soddell, 2000

aural representations
of biological data

L-system modulates pitch intervals

Morgan, 2007

composition for a large
instrumental ensemble

ad hoc symbolic mapping

Langston, 1989

melody

L-system is interpreted to arrange
pre-specified fragments

Worth & Stepney, 2005

melody

several mappings and L-system types

Manousakis, 2006

melody (sound synthesis)

complex, multi-dimensional mapping.
Implemented in MAX.

McCormack, 1996

melody, polyphonies

contex-sensitive L-systems

DuBois, 2003

real-time accompaniment

implemented in MAX

Wilson, 2009

melody

mapping turtle graphics to music scores

McGuire, 2006

arpeggiator

simple symbolic mapping

Watson, 2008

base chord progression

L-systems are used the context of a
larger, multi-stage system

Gogins, 2006

voice leading

Musical theory (pitch spaces).
Implemented in Csound

Bulley & Jones, 2011

arpeggiator

part of a real-time art installation.
Implemented in MAX

Pestana, 2012

real-time accompaniment

implemented in MAX

Table 2: References for Section 3.1.1, in order of appearance.

veloping a jazz on-the-fly improviser (Chemillier, 2004) by adapting Steedman‚Äôs grammar,
previously implemented for analysis purposes.
3.1.1 L-Systems
Lindenmayer Systems, commonly abbreviated to L-systems, are a specific variant of formal
grammar, whose most distinctive feature is parallel rewriting, i.e., at each derivation step,
not one but all possible rewriting rules are applied at once. They have been successfully
applied in different scenarios, specially to model microbial, fungi and plant growth and
shapes, because they are particularly well-suited to represent the hierarchical self-similarity
characteristic of these organisms. This ability to represent self-similar structures, together
with the fact that L-systems are easier to understand and apply than traditional formal
grammars, have made L-systems fairly popular in algorithmic composition.
Arguably, the most visually stunning way to use L-systems has been the synthesis of
2D and 3D renderings of plants, using a mapping from sequences of symbols to graphics
based on turtle graphics (Prusinkiewicz & Lindenmayer, 1990). It is only natural that
the first application of L-systems to algorithmic composition used turtle graphics to render
an image that was then interpreted into a musical score (Prusinkiewicz, 1986), mapping
523

Fern√°ndez & Vico

coordinates, angles and edge lengths into musical objects. This approach has been used
by music composers, as Nelson‚Äôs (1996) Summer Song and Mason and Saffle‚Äôs (1994) idea
of using different rotations and stretchings of the image to implement counterpoint. As a
funny side note, Soddell and Soddell (2000) generated aural renditions of their biological
L-system models, to explore new ways to understand them. Additionally, other composers
used new approaches not dependent upon the graphical interpretation of the L-systems,
such as Morgan‚Äôs (2007) symbolic mapping. One popular is to pre-generate a collection
of short fragments and/or other musical objects, and define an algorithm to interpret the
final sequence of symbols as instructions that transform and arrange the fragments into a
composition. This approach has been used by Langston (1989) and Kyburz (Supper, 2001),
while Edwards (2011) used a more convoluted but ultimately similar mapping.
However, these two approaches (the graphics-to-music and the pre-generated sequences)
only scratch the surface of the technical possibilities to generate music with L-systems; many
other mappings are possible (Worth & Stepney, 2005). In some cases, these mappings can
become exceedingly complex, such as the implementation of Manousakis (2006), whose
L-systems drove a multidimensional automata whose trajectory was then interpreted as
music. While most composers and researchers experimented with context-free L-systems,
McCormack (1996, 2003a) used context-sensitive, parametric L-systems to increase the
expressiveness of the compositions and enable the implementation of polyphony. He also
used a rich and comprehensive mapping from the symbol sequence to the musical score,
interpreting the symbols in the sequence as instructions to modulate the parameters of
an automata driving a MIDI synthesizer, though the grammars were ultimately specified
by hand. DuBois (2003) used a simpler but also rich approach, mapping the symbols
to elemental musical objects (as notes or instruments) or simple transformations applied
to them, using brackets to encode polyphony. He also used L-systems to drive real-time
synthetic accompaniment, by extracting features from the audio signal of a performer (as
the pitch and loudness of the notes), encoding them as symbols to be expanded by L-system
rules, and using the resulting symbol sequences to drive MIDI synthesizers. In spite of these
developments, new mappings based on the images rendered by the turtle method are still
investigated (Wilson, 2009).
L-systems can also be used to implement tools to assist the compositional process by
solving just a part of it, as generating more complex arpeggios than off-the-shelf arpeggiators
(McGuire, 2006), or providing just the base chord progression of a composition (Watson,
2008), sometimes applying elements of music theory to implement the rules (Gogins, 2006).
Another area of research is the implementation of real-time improvisers, either for limited
parts of the composition process (Bulley & Jones, 2011), or for accompaniment (Pestana,
2012).
3.1.2 Grammars and Evolutionary Algorithms
Evolutionary methods have also been used together with grammars. In this case, a common
approach is to evolve the grammatical rules, as in GeNotator (Thywissen, 1999), in which
the genomes are grammars specified through a GUI and the fitness function is interactive
(the user assigns the fitness of the grammars). A more exotic example by Khalifa et al.
524

AI Methods in Algorithmic Composition

Reference

Composition task

Comments

Thywissen, 1999
(GeNotator)

structure

the grammar is the genotype
in an interactive evolutionary algorithm

Khalifa et al., 2007

melody

the grammar is part of the fitness function

Ortega et al., 2002

melody

grammatical evolution

Reddin et al., 2009

melody

grammatical evolution

Shao et al., 2010
(Jive)

melody

interactive grammatical evolution

Bryden, 2006

melody

interactive evolutionary algorithm with L-systems

Fox, 2006

melody

interactive evolutionary algorithm with L-systems

Peck, 2011

melody

evolutionary algorithm with L-systems

Dalhoum et al., 2008

melody

grammatical evolution with L-systems

Table 3: References for Section 3.1.2, in order of appearance.
(2007) uses the grammar as part of the fitness function instead of the generation of the
compositions.
Some evolutionary methods are specifically adapted to handle grammars. This is the
case of grammatical evolution, a method in which the genomes are sequences of numbers
or symbols controlling the application of rules of a pre-defined (and possibly stochastic)
grammar. The most common approach is to represent the music as the output from the
grammar, which can range from very general to specific for a given music style. Several
instances of this method have been developed: from an early, bare-bones implementation
(Ortega et al., 2002) to a more elaborated one using a simple fitness function based on general concepts from music theory (Reddin et al., 2009). However, there are other approaches,
such as the system implemented by Shao et al. (2010), whose grammar is used to produce
intermediate code, which is then used to generate the music.
As in the more general case of formal grammars, evolutionary algorithms have been
used to create L-systems. However, most examples use an interactive fitness function (the
fitness is assigned by a human), like the basic implementation of Bryden (2006) and the
approach based on genetic programming used by Fox (2006). Others use very simplistic
fitness functions, with modest results (Peck, 2011). A more sophisticated approach was
used by Dalhoum et al. (2008), using grammatical evolution with a fitness function based on
a distance metric of the synthesized compositions to a pre-specified corpus of compositions.
3.1.3 Related Methods
Finally, this subsection presents a few examples that do not exactly use grammars, but
utilize similar or borderline approaches.
The first one is the application of Kohonen‚Äôs Dynamically Expanding Context (DEC)
method to algorithmic composition (Kohonen et al., 1991). In DEC, a set of music examples
is fed to the algorithm, which infers a model from the structure of the examples that may
be construed as a stochastic context-sensitive grammar. The model is as parsimonious as
possible, that is, the rules have as little contextual information as possible. Then, the
inferred grammar is used to generate new compositions. Drewes and H√∂gberg‚Äôs (2007)
525

Fern√°ndez & Vico

Reference

Composition task

Comments

Kohonen et al., 1991

melody

Uses Kohonen‚Äôs Dynamically Expanding Context

Drewes & H√∂gberg, 2007

generate variations on
a melody

applies tree-based algebraic transformations

Cope, 1992 (EMI),
2000 (SARA, ALICE),
2005 (Emily Howell)

melody

EMI uses Augmented Transition Networks

Table 4: References for Section 3.1.3, in order of appearance.
work is also borderline, using regular tree grammars to generate a basic scaffold that is
then modified by algebraic operations to generate a final music composition.
But the more famous example in this category is Cope‚Äôs (1992) ‚ÄúExperiments in Musical
Intelligence‚Äù (EMI), a software application able to analyze a set of musical compositions in a
specific style (for example, Bach‚Äôs) and to derive an Augmented Transition Network (ATN),
i.e., a finite state automaton able to parse relatively complex languages. EMI then applies
pattern-matching algorithms to extract signatures or short musical sequences characteristic
of the style of the set of examples being analyzed, determining how and when to use these
signatures in compositions with that style. After this analysis, the synthesis phase generates
new music compositions that comply with the specifications encoded in the inferred ATN,
with quite impressive results. He iterated EMI‚Äôs design in other applications, like SARA
and ALICE (Cope, 2000), but ultimately tried a new approach with yet another application,
‚ÄúEmily Howell‚Äù. Cope (2005) reported that ‚ÄúEmily Howell‚Äù developed a unique style by
a process of trial and error guided by human input; however, other researchers (Wiggins,
2008) have disputed the validity of his methodology.
3.2 Symbolic, Knowledge-Based Systems and Related Methods
Here, knowledge-based system is used as an umbrella term encompassing various rule-based
systems under several different paradigms, with the common denominator of representing
knowledge as more or less structured symbols. Since knowledge about musical composition
has traditionally been structured as sets of more or less formalized rules for manipulating
musical symbols (Anders & Miranda, 2011), knowledge-based and rule systems come as a
natural way to implement algorithmic composition. In fact, it is extremely common for
algorithmic composition systems to include some kind of composition rules at some point
of the workflow. The most known early work on algorithmic composition is an example:
classical rules for counterpoint were used in the generation of the first and second movements
of the Illiac Suite (Hiller & Isaacson, 1958). Because of this, this subsection is mostly
confined to the description of systems with strong foundations in AI (as expert systems),
sidestepping to a certain degree the works of composers that are difficult to categorize,
because of the ad hoc nature of their approaches and the very different language they use.
Starting with an exposition of early work, Gill‚Äôs (1963) paper, already cited in Section 2.1, presented the first application of classical AI heuristics to algorithmic composition: he used a hierarchical search with backtracking to guide a set of compositional rules
from Schoenberg‚Äôs twelve-tone technique. Another notable example is Rothgeb‚Äôs (1968)
Ph.D. thesis: he encoded in SNOBOL a set of rules extracted from eighteenth century
526

AI Methods in Algorithmic Composition

Reference

Composition task

Comments

Gill, 1963

Schoenberg‚Äôs twelve-tone
technique

hierarchical search with backtracking

Rothgeb, 1968

unfigured bass

implemented in SNOBOL

Thomas, 1985
(Vivace)

four-part harmonization

implemented in LISP

Thomas et al., 1989
(Cantabile)

Indian raga style

implemented in LISP

Steels, 1986

four-part harmonization

uses Minsky‚Äôs frames

Riecken, 1998
(Wolfgang)

melody

uses Minsky‚Äôs SOM

Horowitz, 1995

jazz improvisation

uses Minsky‚Äôs SOM

Fry, 1984
(Flavors Band)

jazz improvisation and other
styles

phrase processing networks (networks of
agents encoding musical knowledge)

Gjerdingen, 1988
(Praeneste)

species counterpoint

implements a theory of how composers work

Schottstaedt, 1989

species counterpoint

constraint-based search with backtracking

L√∂the, 1999

piano minuets

set of rules extracted from a classical textbook

Ulrich, 1977

jazz improvisation

also uses a grammar (for jazz chords)

Levitt, 1981

jazz improvisation

Criticized by Horowitz (1995)
for being overly primitive

Hirata & Aoyagi, 1988

jazz improvisation

uses logic programming

Rowe, 1992
(Cypher)

interactive jazz
improvisation

uses Minsky‚Äôs SOM

Walker, 1994
(ImprovisationBuilder)

interactive jazz
improvisation

implemented in SmallTalk

Ames & Domino, 1992
(Cybernetic Composer)

jazz, rock

also uses Markov chains for rhythm

Table 5: References for Section 3.2, in order of appearance.
music treatises to harmonize the unfigured bass, that is to say, determine adequate chords
from a sequence of bass notes.14 He discovered that the classical rules were incomplete and
incoherent to a certain extent.
These were recurring problems for many others implementing rules of composition
straight from musical theory. For example, Thomas (1985) designed a rule-based system
for four-part chorale harmonization implemented in Lisp15 , with the intent of clarifying the
musical rules she taught to her students. Later, she designed another rule system (Thomas
et al., 1989) for simple melody generation in the Indian raga style. Another example in
harmonization is the use of Minsky‚Äôs paradigm of frames by one of his students to encode a
set of constraints to solve a relatively simple problem from tonal harmony, finding a passing chord between two others (Steels, 1979), and later to tackle the problem of four-part
harmonization (Steels, 1986). Minsky developed other paradigms, such as K-lines and the
14. It should be noted that this stems from the practice of not completely specifying the harmonization, a
problem that performers were expected to solve by improvisation.
15. All the systems discussed in this paragraph were implemented in Lisp.

527

Fern√°ndez & Vico

Reference

Composition task

Comments

Schwanauer, 1993
(MUSE)

four-part
harmonization

presents the learning techniques in a similar way to
Roads (1985, sect. 8.2)

Widmer, 1992

harmonization

based on user evaluations of a training corpus

Spangler, 1999

real-time four-part
harmonization

prioritizes harmonic errors by severity,
in order to refine the results

Morales & Morales, 1995

species counterpoint

uses logic programming

Table 6: References for Section 3.2.1, in order of appearance.
Society of Mind (SOM), which also influenced the work on algorithmic composition of two
of his students, Riecken and Horowitz. Riecken (1998) used them in a system that composed monophonic melodies according to user-specified ‚Äúemotional‚Äù criteria, while Horowitz
(1995) used them in a system that improvised jazz solos. Fry‚Äôs (1984) phrase processing
networks, while not directly based on SOM, were specialized procedural representations of
networks of agents implementing musical transformations to encode knowledge about jazz
improvisation and other styles.
Other researchers have also explored different ways to generate species counterpoint
with rule-based systems: Gjerdingen (1988) implemented a system based on the use of
several pre-specified musical schemata, implementing a theory of how composers work,
while Schottstaedt (1989) used a more formal approach: a constraint-based search with
backtracking. He followed a classical rulebook on species counterpoint, to the point of
bending some rules and creating new ones in order to get as close as possible to the scores
serving as examples in that book. Also on the formal side, L√∂the (1999) extracted a set of
rules from a classical textbook for composing minuets.
Other music styles demanded different approaches: as jazz performances are improvisations over existing melodies, knowledge-based systems for jazz were structured as more or
less sophisticated analysis-synthesis engines. For example, the work of Ulrich (1977): his
system analyzed a melody and fitted it to a harmonic structure. Another student of Minsky
(Levitt, 1981) implemented a rule-based jazz improviser formulating some of the rules as
constraints, while Hirata and Aoyagi (1988) encoded the rules in logic programming, trying
to design a more flexible system. Rowe (1992) used a SOM architecture16 for Cypher, an
analysis-synthesis engine able to play jazz interactively with a human performer, notable for
its flexibility and the musical knowledge encoded into it. Also, Walker (1994) implemented
an object-oriented analysis-synthesis engine able to play jazz interactively with a human
performer, and Ames and Domino (1992) implemented a hybrid system (using rules and
Markov chains) for the generation of music in several popular genres.
3.2.1 Rule Learning
While the knowledge implemented in rule-based systems is usually static, part of the knowledge may be dynamically changed or learned. The natural term for this concept is machine
learning, but its meaning is unfortunately vague, because it is used as a catch-all for many
methods, including neural networks and Markov chains.
16. He was not a student of Minsky, though.

528

AI Methods in Algorithmic Composition

A few examples of rule-based learning systems have been developed. For example,
Schwanauer (1993) implemented MUSE, a rule-based system for solving several tasks in fourpart harmonization. While the core ruleset was static, a series of constraints and directives
for the composition process where also built in the system, and their application was also
used to dynamically change the rule priorities. Additionally, when the system successfully
solved a task, it was able to deduce new composite rules by extracting patterns of rule
application. Widmer (1992) implemented another example: a system for the harmonization
of simple melodies. It was based on user evaluations of a training corpus: from a hierarchical
analysis of the training melodies and theirs evaluations, it extracted rules of harmonization.
Spangler (1999) implemented a system for generating rule systems for harmonizing fourpart chorales in the style of Bach, with the constraint of doing the harmonization in real
time. The rulesets were generated by analyzing databases of examples with algorithms that
applied formal concepts of information theory for distilling the rules, and the violations of
harmonic rules were prioritized in order to refine the results. Using the framework of logic
programming, Morales and Morales (1995) designed a system that learned rules of classical
counterpoint from musical examples and rule templates.
3.2.2 Rule-Based Methods and Evolutionary Algorithms
The most intuitive way to hybridize rule-based knowledge systems and evolutionary algorithms is to craft a fitness function from the ruleset. This can be done efficiently for domains
whose rules have been adequately codified, and compliance with the rules can be expressed
as a graduated scale, instead of a binary (yes/no) compliance.
A good example is four-part baroque harmonization for a pre-specified melody, which
lends itself particularly well to this approach. McIntyre (1994) extracted a set of rules for
performing this harmonization from classical works, and codified them as a set of scoring
functions. The fitness was a weighted sum of these scores, with a tiered structure: some
scores were not added unless other specific scores had values above some thresholds (because they were more critical or prerequisites to produce good harmonizations). A slightly
different approach was used by Horner and Ayers (1995): they defined two classes of rules:
one for defining acceptable voicings for individual chords, used to enumerate all possible
voicings, and another for defining how the voices are allowed to change between successive chords. An evolutionary algorithm was used to find music compositions, whose search
space was constructed with the enumeration of voicings (first class of rules). The fitness
of each candidate solution was simply the amount of violated rules from the second class.
Phon-Amnuaisuk et al. (1999) also did four-part harmonization using a set of rules to build
the fitness function and musical knowledge to design the genotype and the mutation and
crossover operators, but the lack of global considerations in the fitness function led to modest results. In contrast, Maddox and Otten (2000) got good results implementing a system
very similar to McIntyre‚Äôs (1994), but using a more flexible representation, resulting in a
larger search space of possible individuals, and without the tiered structure in the fitness
function, enabling a less constrained search process.
Another good example is species counterpoint: Polito et al. (1997) extracted rules for
species counterpoint from a classic eighteenth century music treatise, using them to define
fitness functions in a multi-agent genetic programming system: each agent performed a
529

Fern√°ndez & Vico

Reference

Composition task

Comments

McIntyre, 1994

four-part harmonization

explores several schemes to combine
rules into the fitness function

Horner & Ayers, 1995

four-part harmonization

two stages: enumeration of possible
chord voicings, evolutionary algorithm
for voice-leading rules

Phon-Amnuaisuk et al., 1999

four-part harmonization

criticizes vanilla evolutionary algorithms
for generating unstructured
harmonizations

Maddox & Otten, 2000

four-part harmonization

similar to McIntyre‚Äôs (1994)

Polito et al., 1997

species counterpoint

multi-agent genetic programming system

Gwee, 2002

species counterpoint

fuzzy rules

Table 7: References for Section 3.2.2, in order of appearance.
set of composition or transformation operations on a given melody specified as a seed,
and they cooperated to produce the composition. Gwee (2002) exhaustively studied the
computational complexity of problems related to the generation of species counterpoint
with rulesets, and implemented an evolutionary algorithm whose fitness function was based
on a set of fuzzy rules (although he also experimented with trained artificial neural networks
as fitness functions).
3.2.3 Constraint Satisfaction
Gradually (in a process that spanned the 1980s and 1990s), some researchers on algorithmic
composition with rule-based systems adopted formal techniques based on logic programming. For example, Boenn et al. (2008) used answer set programming to encode rules for
melodic composition and harmonization. However, most of the work on logic programming
has been under a different paradigm: the formulation of algorithmic composition tasks as
constraint satisfaction problems (CSPs). Previously referenced work, as Steels‚Äôs (1979),
Levitt‚Äôs (1981), Schottstaedt‚Äôs (1989) and L√∂the‚Äôs (1999) can be seen as part of a gradual
trend towards the formulation of musical problems as CSPs17 , although constraint logic
programming (CLP) came to be the tool of choice to solve CSPs. Good surveys on CLP
for algorithmic composition have been written by Pachet and Roy (2001) and Anders and
Miranda (2011).
Ebcioƒülu worked for many years in this area, achieving notable results. In a first work
implemented in Lisp (Ebcioƒülu, 1980), he translated rules of fifth-species strict counterpoint
to composable Boolean functions (he had to add rules of his own to bring the system into
producing acceptable results, though), and used an algorithm that produced an exhaustive
enumeration of the compositions satisfying a previously arranged set of rules: basically, he
implemented a custom engine for logic programming in Lisp. Over the next decade, he
the tackled the problem of writing four-part chorales in the style of J. S. Bach. Finally, he
produced CHORAL, a monumental expert system (Ebcioƒülu, 1988), distilling into it 350
rules to guide the harmonization process and the melody generation. To keep the problem
17. While Gill‚Äôs (1963) implementation was formulated as a CSP, it was somewhat primitive by later standards.

530

AI Methods in Algorithmic Composition

tractable, he designed a custom logic language (BSL) with optimizations over standard logic
languages, as backjumping. His system received substantial publicity, and was supposed to
reach the level of a talented music student, in his own words.
Following Ebcioƒülu‚Äôs work, many constraint systems have been implemented for harmonization or counterpoint. Tsang and Aitken (1991) implemented a CLP system using Prolog
to harmonize four-part chorales. However, their system was grossly inefficient.18 Ovans and
Davison (1992) described an interactive CSP system for first-species counterpoint, where
a human user drove the search process, and the system constrained the possible outputs
(according to counterpoint rules) as the search progressed. They took care of efficiency
by using arc-consistency in the resolution of the constraints. Ram√≠rez and Peralta (1998)
solved a different problem: given a monophonic melody, their CLP system generated a
chord sequence to harmonize it. Phon-Amnuaisuk (2002) implemented a constraint system
for harmonizing chorales in the style of J. S. Bach, but with an innovation over previous
systems: to add knowledge to the system about how to apply the rules and control the
harmonization process explicitly, thus modulating the search process in an explicit and
flexible way. Anders and Miranda (2009) analyzed a Schoenberg‚Äôs textbook on the theory
of harmony, programming a system in Strasheela (see below) to produce self-contained harmonic progressions, instead of harmonizing pre-existing melodies, as most other constraint
systems do.
While many CLP systems have been implemented to solve classical problems in harmonization or counterpoint, some researchers have studied the application of CLP techniques to
different problems. In a very simple application, Wiggins (1998) used a CLP system to generate short fragments of serial music. Zimmermann (2001) described a two-stage method,
where both stages used CLP: the first stage (AARON) took as input a ‚Äústoryboard‚Äù to specify the mood of a composition as a function of time, and generated a harmonic progression
and a sequence of directives. The second (COMPOzE) generated a four-part harmonization
according to the previously arranged progression and directives; the result was intended as
background music. Laurson and Kuuskankare (2000) studied constraints for the instrumentation19 of guitars and trumpets (i.e., constraints for composing music easily playable
in these instruments). Chemillier and Truchet (2001) analyzed two CSPs: a style of Central African harp music, and Ligeti textures. They used heuristic search in their analyzes
instead of backtracking, heralding OMClouds‚Äô approach to constraint programming (see
below). Sandred (2004) proposed the application of constraint programming to rhythm.
Several general-purpose constraint programming systems for algorithmic composition
have been proposed (i.e., languages and environments to program the constraints). One
of the earliest examples was Courtot‚Äôs (1990) CARLA, a CLP system for generating polyphonies with a visual front-end and a rich, extendable type system designed to represent
relationships between different musical concepts. Pachet and Roy (1995) implemented another general-purpose musical CLP (Backtalk) in an object-oriented framework (MusES),
designing a generator of four-part harmonizations on top of it. Their key contribution
was a hierarchical arrangement of constraints on notes and chords, dramatically decreasing the (both cognitive and computational) complexity of the resulting constraint system.
18. In spite of using just 20 rules, it required up to 70 megabytes of memory to harmonize a phrase of 11
notes.
19. That is to say, take into account the way an instrument is played when composing its part.

531

Fern√°ndez & Vico

Reference

Composition task

Comments

Boenn et al., 2008

melody and harmonization

answer set programming

Ebcioƒülu, 1980

species counterpoint

implemented in LISP

Ebcioƒülu, 1988
(CHORAL)

four-part harmonization

implemented in a custom logic language (BSL)

Tsang & Aitken, 1991

four-part harmonization

very inefficient

Ovans & Davison, 1992

species counterpoint

interactive search

Ram√≠rez & Peralta, 1998

melody harmonization

simpler constraint solver

Phon-Amnuaisuk, 2002

four-part harmonization

explicit control over the search process

Anders & Miranda, 2009

Schoenberg‚Äôs Theory of
Harmony

implemented in Strasheela

Wiggins, 1998

Schoenberg‚Äôs twelve-tone
technique

very simple demonstration

Zimmermann, 2001
(Coppelia)

structure, melody,
harmonization, rhythm

two stages: harmonic plan (Aaron) and
execution (Compoze)

Laurson & Kuuskankare,
2000

guitar and trumpet
instrumentation

implemented with PWConstraints

Chemillier & Truchet, 2001

African harp and Ligeti
textures

implemented in OpenMusic

Sandred, 2004

rhythm

implemented in OpenMusic

Courtot, 1990
(CARLA)

polyphony, general purpose

early general-purpose system

Pachet & Roy, 1995
(BackTalk)

four-part harmonization

implemented in MusEs

Rueda et al., 1998

polyphony, general purpose

describes PWConstraints (implemented in
PatchWork) and Situation (implemented in
OpenMusic)

Rueda et al., 2001

general purpose

describes PiCO
describes ntcc

Olarte et al., 2009

general purpose

Allombert et al., 2006

interactive improvisation

uses ntcc

Rueda et al., 2006

interactive improvisation

uses ntcc and Markovian models

Pachet et al., 2011

melody

integrates Markovian models and constraints

Truchet et al., 2003

general purpose

describes OMClouds

Anders, 2007

general purpose

describes Strasheela

Sandred, 2010

general purpose

describes PWMC.
Implemented in PatchWork

Carpentier & Bresson, 2010

orchestration

uses multi-objective optimization
to discover candidate solutions.
Interfaces with OpenMusic and MAX

Yilmaz & Telatar, 2010

harmonization

fuzzy logic

Aguilera et al., 2010

species counterpoint

probabilistic logic

Geis & Middendorf, 2008

four-part harmonization

multi-objective Ant Colony Optimization

Herremans & Sorensena,
2012

species counterpoint

variable neighborhood with tabu search

Davismoon & Eccles, 2010

melody, rhythm

uses simulated annealing to combine
constraints with Markov processes

Martin et al., 2012

interactive improvisation

implemented in MAX

Table 8: References for Section 3.2.3, in order of appearance.

532

AI Methods in Algorithmic Composition

Rueda et al. (1998) reviewed two other early general-purpose systems, PWConstraints and
Situation. PWConstraints was able to (relatively easily) handle problems in polyphonic
composition through a subsystem (score-PMC), while Situation was more flexible and implemented more optimizations in its search procedures. PiCO (Rueda et al., 2001) was
an experimental language for music composition that seamlessly integrated constraints,
object-oriented programming and a calculus for concurrent processes. The idea was to use
constraint programming to specify the voices in a composition, and to use the concurrent
calculus to harmonize them. The authors also implemented a visual front-end to PiCO for
ease of use, Cordial. In a similar way to PiCO, ntcc was another language for constraint
programming that implemented primitives for defining concurrent systems, although it was
not specifically designed for algorithmic composition. ntcc has been proposed to generate
rhythm patterns and as a more expressive alternative to PiCO (Olarte et al., 2009), and
has mainly been used for machine improvisation: Allombert et al. (2006) used it as the
improvisation stage of their two-stage system (the first stage used a temporal logic system
to compose abstract temporal relationships between musical objects, while the ntcc stage
generated concrete music realizations), and Rueda et al. (2006) used ntcc to implement
a real-time system that learned a Markovian model (using a Factor Oracle) from musicians and concurrently applied it to generate improvisations. Not related to ntcc, Pachet
et al. (2011) has also proposed a framework to combine constraint satisfaction and Markov
processes.
OMClouds (Truchet et al., 2003) was another general-purpose (but purely visual) constraint system for composition, but its implementation set it apart from most other formal
systems: internally, the constraints are translated to cost functions. Instead of the optimized tree search with backtracking usual in CLP, an adaptive tabu search was performed,
seeking to minimize a solution with minimal cost. This avoids some problems inherent to
constraint programming, such as overconstraining, but it cannot be guaranteed to completely navigate the search space. Anders (2007) implemented Strasheela, a system that
was expressly designed to be highly flexible and programmable, aiming to overcome a perceived limitation of previous general-purpose systems: the difficulty to implement complex
with constraints related to multiple aspects of the compositions process. Finally, another
purely visual constraint system, PWMC, was proposed by Sandred (2010) to overcome perceived limitations of score-PMC. It was able to handle constraints concerning not only pitch
structure as score-PMC, but also rhythm and metric structure.
It should be stressed that, while CLP has become the tool of choice to solve CSPs,
other approaches are also used. Previously cited OMClouds is just one of these. Carpentier
and Bresson (2010) implemented a mixed system for orchestration that worked in a curious way: the user fed the system with a target sound and a set of symbolic constraints; a
multi-objective evolutionary algorithm found a set of orchestration solutions matching the
target sound, and a local search algorithm filtered out the solutions not complying with
the constraints. Yilmaz and Telatar (2010) implemented a system for simple constraint
harmonization with fuzzy logic, while Aguilera et al. (2010) used probabilistic logic to solve
first-species counterpoint. More exotic solutions have been proposed, as the use of Ant
Colony Optimization with a multi-objective approach to solve the constraints of Baroque
harmonization (Geis & Middendorf, 2008), variable neighborhood with tabu search to solve
soft constraints for first-species counterpoint (Herremans & Sorensena, 2012), or simulated
533

Fern√°ndez & Vico

Reference

Composition task

Comments

Pereira et al., 1997

Baroque music

hierarchical analysis and representation

Ribeiro et al., 2001
(MuzaCazUza)

Baroque music

generates a melody from a harmonic line

Ramalho & Ganascia, 1994

jazz improvisation

uses a rule-based system for analysis

Parikh, 2003

jazz improvisation

also uses a rule system to analize music

Eigenfeldt & Pasquier, 2010

jazz chord progressions

also uses Markovian models

Sabater et al., 1998

harmonization

also uses a rule system

Table 9: References for Section 3.2.4, in order of appearance.
annealing to combine constraints with Markov processes (Davismoon & Eccles, 2010). Finally, Martin et al. (2012) presented an even more exotic approach: a real-time music
performer that reacted to its environment. While some of the aspects of the music where
controlled by Markov chains, others where expressed as a CSP. To solve this CSP in real
time, a solution was calculated at random (but quickly) using binary decision diagrams.
3.2.4 Case-Based Reasoning
Case-based reasoning (CBR) is another formal framework for rule-based systems. In the
CBR paradigm, the system has a database of cases, that can be defined as instances of
a problem with their corresponding solutions. Usually, a case also contains structured
knowledge about how the problem is solved in that case. When faced with a new problem,
the system matches it against the case database. Unless the new problem is identical to
one recorded in the case database, the system will have to select a case similar to the new
problem, and adapt the corresponding solution to the new problem. If the new solution is
deemed appropriate, a new case (recording the new problem along with the new solution)
may be included in the database.
Several researchers have used CBR for algorithmic composition. Pereira et al. (1997)
implemented a system that generated its case database from just three Baroque music
pieces, which were analyzed into hierarchical structures; the cases were their nodes. The
system composed just the soprano melodic line of the piece, searching for similar cases in its
case database. The results were comparable to the output of a first-year student, according
to music experts consulted by the authors. An intersecting set of researchers implemented
a simpler CBR composing system (Ribeiro et al., 2001) that generated a melody from a
harmonic line, this time with a case database generated from just six Baroque pieces. Cases
were represented in a different way, tough: each case represented the rhythm, the melody
and other attributes associated to a chord in a given context. To generate a new music piece,
a harmonic line was specified, and the system fleshed out the music piece by matching the
cases to the harmonic line.
Hybrid systems have also been proposed. Ramalho and Ganascia (1994) proposed a jazz
improviser that used a rule system to analyze incoming events (for example, the ongoing
sequence of chords) and a CBR engine to improvise. The case database was assembled by
extracting patterns from transcriptions of jazz recordings, and consisted of descriptions of
contexts and how to play in these contexts. During the improvisation, the current context
534

AI Methods in Algorithmic Composition

Reference

Composition task

Comments

Haus & Sametti, 1991
(Scoresynth)

melody

Petri nets

Lyon, 1995

melody

Petri nets to encode Markov chains

Holm, 1990

melody, sound synthesis

inspired in CSP process algebra

Ross, 1995
(MWSCCS)

melody

custom process algebra

Rueda et al., 2001

general purpose

describes PiCO

Allombert et al. (2006)

interactive improvisation

uses ntcc

Rueda et al., 2006

interactive improvisation

uses ntcc and Markovian models

(Olarte et al., 2009)

general purpose, rhythms

describes ntcc

Table 10: References for Section 3.2.5, in order of appearance.

was analyzed by the rule system, and those cases applying in the current context were
extracted from the database and combined to determine the output of the improviser. Considering that Ramalho and Ganascia‚Äôs system was too inflexible, Parikh (2003) implemented
another jazz improviser, intending to use a large case database containing jazz fragments
from various sources, in order to get a system with a style of its own. Eigenfeldt and
Pasquier (2010) used a case-based system to generate variable-order Markov models for
jazz chord progressions.
Outside the jazz domain, a hybrid system for harmonizing melodies of popular songs
was implemented by Sabater et al. (1998): given a melody, the system sequentially decided
the chords to harmonize it. If the CBR module failed to match a case, the system fell back
to a simple heuristic rule system to select an appropriate chord. As the harmonized output
was added to the case database, the CBR module gradually learned over time from the rule
system.
3.2.5 Concurrency Models
Concurrency models can be described as formal languages to specify, model and/or reason
about distributed systems. They provide primitives to precisely define the semantics of
interaction and synchronization between several entities. Their main application has been
modeling and designing distributed or concurrent computer systems, but they have also
been used as languages to partially or fully model the composition process, because music
composition can be formulated as an endeavor to carefully synchronize streams of music
events produced by several interacting entities. Concerning algorithmic composition, the
most used concurrency models have been Petri nets and several kinds of process algebras,
also known as process calculi. Detailed descriptions of these models are beyond the scope of
this survey; see for example Reisig‚Äôs (1998) book on Petri nets and Baeten‚Äôs (2005) survey
on process algebras for more information.
Petri nets have been used as the basis for Scoresynth (Haus & Sametti, 1991), a visual
framework for algorithmic composition in which Petri nets were used to describe transformations of musical objects (sequences of notes and musical attributes), and the synchronization
535

Fern√°ndez & Vico

between musical objects was implicit in the structure of the net. Petri nets have also been
used as an efficient and compact way to implement Markov chains (Lyon, 1995).
Process algebras were first used for algorithmic composition by Holm (1990), although
his model (inspired by Hoare‚Äôs algebra, CSP) was more geared towards sound synthesis
than music composition. A more proper example is Ross‚Äôs (1995) MWSCCS, an extension (adding concepts for music composition) of a previously existing algebra (WSCCS).
Specifications for algorithmic composition written in MWSCCS were meant to resemble
grammatical specifications, but with a richer expressive power. Later examples have also
been cited in Section 3.2.3, as the PiCO language (Rueda et al., 2001), which integrated
logical constraints and a process algebra. Also cited in that Section, ntcc is a process algebra that has been used to implement machine improvisation (Allombert et al., 2006) and
to drive a Markovian model (using a Factor Oracle) for real-time machine learning and
improvisation (Rueda et al., 2006). It has also been proposed to generate rhythm patterns,
and as a more expressive alternative to PiCO (Olarte et al., 2009).
3.3 Markov Chains and Related Methods
Conceptually, a Markov chain is a simple idea: a stochastic process, transiting in discrete
time steps through a finite (or at most countable) set of states, without memory: the next
state depends just on the current state, not on the sequence of states that preceded it
or on the time step. In their simplest incarnations, Markov chains can be represented as
labeled directed graphs: nodes represent states, edges represent possible transitions, and
edge weights represent the probability of transition between states. However, Markov chains
are more commonly represented as probability matrices.
When Markov chains are applied to music composition, the probability matrices may
be either induced from a corpus of pre-existing compositions (training), or derived by hand
from music theory or by trial-and-error. The former is the most common way to use them in
research, while the latter is more used in software tools for composers. An important design
decision is how to map the states of the Markov chain to musical objects. The simplest
(but fairly common) mapping just assigns a sequential group of notes to each state, with
the choice of just one note (instead of a larger sequence) being fairly common.
It is also common to extend the consideration of the ‚Äúcurrent state‚Äù: in an n-th order
Markov chain, the next state depends on the last n states, not just the last one. As a
consequence, the probability matrix has n + 1 dimensions. In algorithmic composition,
Markov chains are mostly used as generative devices (generating a sequence of states), but
they can also be used as analysis tools (evaluating the probability of a sequence of states).
In the latter case, the term n-gram is also used, though strictly speaking it refers to a
sequence of N states.
Markov chains were a very popular method in the early years of algorithmic composition.
Early examples have already been reviewed in Section 2.1; additionally, Ames (1989) also
provides a good survey. However, Markov chains generated from a corpus of pre-existing
compositions captured just local statistical similarities, and their limitations soon became
apparent (Moorer, 1972): low-n Markov chains produced strange, unmusical compositions
that wandered aimlessly, while high-n ones essentially rehashed musical segments from the
corpus and were also very computationally expensive to train.
536

AI Methods in Algorithmic Composition

Reference

Composition task

Comments

Tipei, 1975

melody

Markov chains are part of a larger,
ad hoc system

Jones, 1981

melody

very simple introduction for composers

Langston, 1989

melody

dynamic weights

North, 1991

melody

Markov chains are part of a larger,
ad hoc system

Ames & Domino, 1992
(Cybernetic Composer)

jazz, rock

uses Markov chains for rhythms

Visell, 2004

real-time generative art
installation

Liberal use of the concept of HMM.
Implemented in MAX

Zicarelli, 1987
(M and Jam Factory)

interactive improvisation

commercial GUI applications
alternative representation for transition
matrices. Implemented in athenaCL

Ariza, 2006
Ponsford et al., 1999

composing sarabande pieces

adds symbols to expose the structure
of the pieces

Lyon, 1995

melody

implements Markov chains
with Petri nets

Verbeurgt et al., 2004

melody

two stages: a Markovian model
and an artificial neural network

Thom, 2000
(BoB)

interactive jazz improvisation

statistical machine learning

Lo & Lucas, 2006

melody

evolutionary algorithm, Markov chains
used in the fitness function

Werner & Todd, 1997

melody

co-evolutionary algorithm, Markov
chains used as evolvable fitness functions

Thornton, 2009

melody

grammar-like hierarchy
of Markov models

Cruz-Alc√°zar and Vidal-Ruiz
(1998)

melody

analysis with grammatical inference,
generation with Markovian models

Gillick et al. (2009)

jazz improvisation

analysis with grammatical inference,
generation with Markovian models

Eigenfeldt & Pasquier, 2010

jazz chord progressions

uses case-based reasoning

Davismoon & Eccles, 2010

melody, rhythm

uses simulated annealing to combine
constraints with Markov processes

Pachet et al., 2011

melody

integrates Markovian models and
constraints

Grachten, 2001

jazz improvisation

integrates Markovian models
and constraints

Manaris et al., 2011

interactive melody improvisation

Markov chains generate candidates
for an evolutionary algorithm

Wooller & Brown, 2005

transitioning between two melodies

alternates Markov chains
from the two melodies

Table 11: References for Section 3.3, in order of appearance.
Because of this, Markov chains came to be seen as a source of raw material, instead of a
method to truly compose music in an automated way, except for some specialized tasks such
537

Fern√°ndez & Vico

as rhythm selection (McAlpine et al., 1999). Therefore, while research interest in Markov
chains receded in subsequent years as these limitations became apparent and other methods
were developed, they remained popular among composers. However, citing even a relevant
subset of all the works were composers use Markov chains as part of their compositional
process would inflate the reference list beyond reasonable length. A few typical examples of
Markov chains used by composers (sometimes as part of a larger automatic compositional
framework or software system) are the papers of Tipei (1975), Jones (1981), Langston (1989,
although he used dynamically computed weights), North (1991) and Ames and Domino
(1992). It should be noted that composers sometimes deconstruct formal methods to adapt
them to their own purposes, as when Visell (2004) used the concept of a Hidden Markov
Model (described below) to implement a manually-tuned real-time generative art system.
In addition, many software suites use Markov chains to provide musical ideas to composers, even if the probabilities are specified by hand instead of generated from a corpus.
Ariza (2006) gives a compact list of software suites and experimental programs using Markov
chains, while his thesis (Ariza, 2005b) provides a comprehensive view of the field. Much
has been done for usability in this field, by using GUI interfaces (Zicarelli, 1987), but also
developing more effective ways to encode the probability matrices, for example as compact
string specifications (Ariza, 2006).
However, novel research on Markov chains for algorithmic compositions has still been
carried out in several ways. For example, Ponsford et al. (1999) used a corpus of sarabande
pieces (relatively simple dance music) to generate new compositions using Markov models20 ,
but with a pre-processing stage to automatically annotate the compositions of the corpus
with symbols to make explicit their structure, and a post-processing stage using a template
to constrain the structure of the synthesized composition, in order to generate minimally
acceptable results. Another way is the hybridization of Markov chains with other methods.
For example, Lyon (1995) used Petri nets as an efficient and compact way to implement
Markov chains, while Verbeurgt et al. (2004) used Markov chains21 to generate a basic
pattern for the melody, which was then refined with an artificial neural network. In the
BoB system (Thom, 2000), Markov chains were trained by statistical learning: from a set of
jazz solos, statistical signatures were extracted for pitches, melodic intervals and contours.
Then, these signatures were used to define the transition probabilities of a Markov chain
whose output was sampled to generate acceptable solos. Lo and Lucas (2006) trained
Markov chains with classic music pieces, but, instead of generating compositions with them,
used them as fitness evaluators in an evolutionary algorithm to evolve melodies encoded
as sequences of pitches. Werner and Todd (1997) also used Markov chains to evaluate
simple (32-note) melodies, but with the particularity that the chains themselves were also
subject to evolution, to investigate sexual evolutionary dynamics. Thornton (2009) defined
a set of grammar-like rules from an existing composition, inferring a hierarchy of Markov
models to use statistical patterns of the analyzed composition at multiple levels. As already
mentioned in Section 3.1, Cruz-Alc√°zar and Vidal-Ruiz (1998) and Gillick et al. (2009) used
grammatical inference with Markovian models. Regarding symbolic methods, Eigenfeldt
and Pasquier (2010) used a case-based system to generate Markov processes for jazz chord
20. Their work is commonly cited in the literature as grammatical, but their methodology is thoroughly
statistical.
21. Also reviewed in Section 3.4.

538

AI Methods in Algorithmic Composition

progressions, (Davismoon & Eccles, 2010) used simulated annealing to combine constraints
and Markov processes, and Pachet et al. (2011) proposed a framework to combine Markovian
generation of music with rules (constraints) to produce better results.
Additionally, Markov chains remained a feasible option for restricted problems (for example, real-time performances, as jazz improvisation), as their limitations were less apparent
in these cases than in the generation of whole compositions. For example, Grachten (2001)
developed a jazz improviser where Markov chains generated duration and pitches, and then a
system of constraints refined the output, and pre-defined licks (short musical patterns) were
inserted at appropriate times. Manaris et al. (2011) also implemented an improviser, using a
Markov model trained with user input to generate a population of candidate melodies, feeding them into an evolutionary algorithm, whose fitness function rewarded melodies whose
metrics were similar to the user input‚Äôs metrics. A different (but also restricted) problem
was studied by Wooller and Brown (2005): applying Markov chains to generate musical
transitions (morphings) between two different pieces in a simple application of non-linear
music, by stochastically alternating between two Markov chains, each one trained with one
of the pieces.
3.3.1 Related Methods
More sophisticated Markovian models (and related statistical methods; see the survey in
Conklin, 2003) have also been applied for algorithmic composition, as in Pachet‚Äôs (2002)
Continuator, a real-time interactive music system. The Continuator departs from common
Markov chain implementations in that it uses variable-order (also known as mixed-order)
Markov chains22 , which are not constrained to a fixed n value, and can be used to get the best
of low and high-n chains. Conklin and Witten (1995) implemented a sophisticated variableorder scheme23 , whose main feature was the consideration in parallel of multiple viewpoints
or sequences of events in the compositions (for example, pitches, durations, contours, etc.),
instead of integrating them all in a unique sequence of symbols, as it was common for most
implementations of Markov chains. Variable-order Markov chains have also been used as
part of a larger real-time music accompaniment system (Martin et al., 2012). Other variableorder schemes used in algorithmic composition, formulated in a machine learning framework,
are Prediction Suffix Trees (PSTs, Dubnov et al., 2003), more space-efficient structures like
Factor Oracles 24 (Assayag & Dubnov, 2004), and Multiattribute Prediction Suffix Graphs
(MPSGs, Trivi√±o Rodr√≠guez & Morales-Bueno, 2001), which can be considered an extension
of PSTs to consider multiple viewpoints as in Conklin and Witten‚Äôs work. Sastry (2011)
also used multiple viewpoints and PSTs to modelize Indian tabla compositions, though his
model could also be used to generate new compositions.
Hidden Markov Models (HMMs) also are generalizations of Markov chains that have
been used for algorithmic composition. A HMM is a Markov chain whose state is unobservable, but some state-dependent output is visible. Training a HMM involves not only
22. It should be noted that Kohonen‚Äôs method (Kohonen et al., 1991), reviewed in Section 3.1.3, is similar
(in some ways) to variable-order chains.
23. Conklin and Witten‚Äôs method has also been described as grammatical, but they are included here because
their emphasis in formal statistical analysis.
24. Also implemented with a concurrent constraint paradigm by Rueda et al. (2006). See Section 3.2.3 and
Section 3.2.5 for more details.

539

Fern√°ndez & Vico

Reference

Composition task

Comments

Pachet, 2002
(Continuator)

interactive improvisation

variable-order

Conklin & Witten, 1995

Bach chorales

multiple viewpoint systems

Martin et al., 2012

interactive improvisation

variable-order; implemented in MAX

Dubnov et al., 2003

melody

Prediction Suffix Trees.
Implemented in OpenMusic

Rueda et al., 2006

interactive improvisation

uses ntcc and Factor Oracles

Assayag & Dubnov, 2004

melody

Factor Oracles.
Implemented in OpenMusic

Trivi√±o Rodr√≠guez &
Morales-Bueno, 2001

melody

Multiattribute Prediction Suffix Graphs

Sastry, 2011

improvisation of tabla rhythms

multiple viewpoints and Prediction
Suffix Trees.
Implemented in MAX

Farbood & Schoner, 2001

species counterpoint

Hidden Markov Models

Biyikoglu, 2003

four-part harmonization

Hidden Markov Models

Allan, 2002

four-part harmonization

Hidden Markov Models

Morris et al., 2008
(SongSmith)

melody harmonization

Hidden Markov Models

Schulze, 2009
(SuperWillow)

melody, rhythm, two-voice
harmonization

Hidden Markov Models
and Prediction Suffix Trees

Yi & Goldsmith, 2007

four-part harmonization

Markov Decision Processes

Martin et al., 2010

interactive improvisation

Partially Observable
Markov Decision Processes

Table 12: References for Section 3.3.1, in order of appearance.
determining a matrix of transition probabilities, but also a matrix of output probabilities
(that is, for each state, the probability of each possible output). Then, given a sequence
of outputs, it is possible to compute the most likely sequence of states to produce that sequence of outputs, using the Viterbi dynamic programming algorithm. In this way, HMMs
find a globally optimized sequence of states, while simpler Markov methods perform just local optimization. When applied to algorithmic composition, HMMs are appropriate to add
elements to an existing composition (most commonly, counterpoint and harmonization),
given a set of pre-existing examples: the composition is modeled as a sequence of outputs
of the HMM, and the additions are computed as the most likely sequence of states of the
HMM.
Farbood and Schoner (2001) implemented the earliest example of a HMM for algorithmic
composition: they trained a second-order HMM to generate Palestrina-style first-species
counterpoint (the simplest way to write counterpoint), defining the training set from rules
used to teach counterpoint. A related problem is to train HMMs with a set of chorale
harmonizations in the style of J.S. Bach in order to get more Bach-like harmonizations.
This problem has been researched by Biyikoglu (2003) and Allan (2002); the latter divided
the problem of harmonization into the same three subtasks as in HARMONET (Hild et al.,
1992). For Microsoft‚Äôs SongSmith software, Morris et al. (2008) trained a HMM with
540

AI Methods in Algorithmic Composition

300 lead sheets (specifications for song melodies) to generate chords to accompany a userspecified vocal melody, parametrizing the resulting system with a very intuitive interface
for non-technical users. Schulze (2009) generated music in several styles using mixed-order
Markov chains to generate the melodies, and HMMs to harmonize them.
Markov Decision Processes (MDPs) are another generalization of Markov models, in
which an agent maximizes some utility function by taking actions to probabilistically influence the next state, and Partially Observable MDPs (POMDPs) represent the corresponding
generalization of HMMs. Experimental systems for algorithmic composition have been implemented with MDPs (Yi & Goldsmith, 2007) and POMDPs (Martin et al., 2010), though
it is not clear that these sophisticated models offer definitive advantages over simpler ones.
3.4 Artificial Neural Networks and Related Methods
Artificial Neural Networks (ANNs) are computational models inspired in biological neural
networks, consisting of interconnected sets of artificial neurons: very simple computational
devices that aggregate numeric inputs into a single numeric output using a (generally)
simple but nonlinear function. Some neurons have connections that are set externally
(input connections), while other have output signals intended to be read as the result
of the network‚Äôs computation (output connections). Typically, neurons are organized in
recurrent networks (some or all neurons have inputs that come from other neurons) with
several interconnected layers, and many variations can be found in the literature. ANNs
are typically used as a machine learning method, using a set of examples (input patterns)
to train the network (i.e., to set the weights of the connections between neurons), in order
to use it to recognize or generate similar patterns. Effectively, this means that neural
networks need a pre-existing corpus of music compositions (all of them in a very similar
style, generally); therefore they can at most imitate the style of the training examples. Most
papers use a supervised learning approach, meaning that the examples in the training set
are associated with a signal, and the ANN learns this association. An important aspect
of ANN design is the modelization of musical composition, that is, the mapping between
music or music notation and the inputs and outputs of the network. Another important
aspect is the way in which compositions are fed to the ANNs: they may be presented as
temporal patterns in the network inputs, which are usually windowed in segments, but in
some cases they are fed at once (as wholes) to the ANNs (these implementations do not
scale well, though, because of the big ANNs needed to model long compositions).
ANNs were first used during the 1970s and 1980s to analyze musical compositions, creating artificial models of cognitive theories of music (Todd & Loy, 1991), but they were later
adapted for music composition. The first example was implemented by Todd (1989), who
used a three-layered recurrent ANN designed to produce a temporal sequence of outputs
encoding a monophonic melody, each output signal of the network representing an absolute
pitch. Given a set of one or more composition examples, the ANN was trained to associate
a single input configuration to the output temporal sequence of the corresponding composition. Then, feeding input configurations different to the ones used during the training
created melodies interpolated between the ones used during the training. If just one melody
was used during the training, the result was an extrapolation from it. Later that year, Duff
(1989) published another early example, but using a different approach, encoding relative
541

Fern√°ndez & Vico

Reference

Composition task

Comments

Todd, 1989

melody

three layers, recurrent

Duff, 1989

melody

two layers, recurrent

Mozer, 1991
(CONCERT)

melody

psychologically-grounded representation
of pitch
feedforward model, used as the fitness
function in an optimization algorithm

Lewis, 1991
Shibata, 1991

harmonization

feedforward model

Bellgard & Tsang, 1992

harmonization

effective Boltzmann machine

Melo, 1998

harmonization

the ANN is trained
to model music tension

Toiviainen, 1995

jazz improvisation

recurrent model

Nishijimi & Watanabe, 1993

jazz improvisation

feedforward model

Franklin, 2001

jazz improvisation

recurrent model

Hild et al., 1992
(HARMONET)

four-part harmonization

three-layered architecture
(two ANNs and a constraint system)

Feulner & H√∂rnel, 1994
(MELONET)

four-part harmonization

uses HARMONET and another ANN
for melodic variations

Goldman et al., 1996
(NETNEG)

species counterpoint

ANN for basic melody, an ensemble of
agents refine the melody

Verbeurgt et al., 2004

melody

two stages: a Markovian model
and an ANN

Adiloglu & Alpaslan, 2007

species counterpoint

feedforward model

Browne & Fox, 2009

melody

simulated annealing with an ANN
to measure musical tension

Coca et al., 2011

melody

recurrent model, uses chaotic non-linear
systems to introduce variation

Table 13: References for Section 3.4, in order of appearance.

instead of absolute pitches (as Todd‚Äôs work) in the mapping, for composing music in Bach‚Äôs
style.
As a machine learning paradigm, ANNs can be used in many different ways, so Todd‚Äôs
approach is not the only possible; indeed, other early papers provide different examples. For
example, Mozer (1991) developed a recurrent ANN with a training program devised to capture both local and global patterns in the set of training examples. The model also featured
in the output mapping a sophisticated multidimensional space for pitch representation, to
capture a formal psychological notion of similarity between different pitches. In this way,
similar output signals are mapped to similar pitches, in order to facilitate the learning phase
and improve the composition phase. Lewis (1991) proposed another ANN framework: creation by refinement, in which a feedforward ANN was trained with a set of patterns ranging
from random to very good music, associating each pattern with a (possibly) multidimensional musicality score. In this way, the training phase generated a mapping function from
patterns to musicality scores. Then, to create new compositions, the mapping was inverted:
starting from a purely random pattern, a gradient-descent algorithm used the ANN as a
542

AI Methods in Algorithmic Composition

critique, reshaping the random pattern to maximize the musicality score in the hope of
finally producing a pleasant composition. Unfortunately, this paradigm had a prohibitive
computational cost, so it was tested only with fairly simple and short compositions.
Most of the early examples described above were experiments at composing more or less
full-fledged monophonic compositions. However, ANNs were also used to automate other
tasks in music composition, as harmonization of pre-existing melodies. Shibata (1991) implemented an early example: a feedforward ANN that represented chords using their component tones, trained for harmonizing simple MIDI music, whose performance was measured
by human listeners. A more sophisticated ANN used for harmonization, the effective Boltzmann machine (EBM), also provided a measure of the quality of the output relative to the
training set (Bellgard & Tsang, 1992). Melo (1998) also harmonized classical music, but
with a notable twist: in order to model the tension25 in the music to be harmonized, he
measured the tension curve reported by several human subjects while listening to the music,
and then used an averaged tension curve to train an ANN, such that the chord progressions
generated by the ANN matched the tension level suggested by the curve. As it can be seen,
harmonization was a popular test case, but other problems were also tried. For example,
Toiviainen (1995) used ANNs to generated jazz improvisations based on a set of training
examples. The ANNs were able to create new jazz melodic patterns based on the training
set. In a similar way, Nishijimi and Watanabe (1993) trained a set of feedforward ANNs
to produce jazz improvisations in a jam session, by modeling several music features of jazz
and using examples of modeled jazz improvisations to train the ANNs. Franklin (2001)
used a recurrent ANNs to improvise jazz (trade four solos with a jazz performer), trained
in two phases: a first phase training an ANN with a set of pre-specified examples, and a
second phase where the ANN is reconfigured and trained by reinforcement learning, where
the reinforcement values are obtained by applying a set of heuristic rules.
Some researchers came to use hybrid systems, combining ANNs with other methods.
One of the first examples was HARMONET (Hild et al., 1992): a model designed to solve
a more complex task: four-part choral harmonization in Bach‚Äôs style. HARMONET had
a three-layered architecture: the first component was a feedforward ANN with a sophisticated encoding of musical information (optimized for harmonization functions instead of
individual pitches), which was used to extract harmonization information. The output was
fed to the second component, a rule-based constraint satisfaction algorithm to generate the
chords, and the final component was another ANN designed to add quaver ornaments to
the previously generated chords. As an evolution of HARMONET, MELONET (Feulner &
H√∂rnel, 1994; improved by H√∂rnel & Degenhardt, 1997) not only harmonized chorales, but
also generated melodic variations for their voices, using HARMONET as a first processing
stage for the harmonization, then used another neural network to generate the melodic
variations.
NETNEG (Goldman et al., 1996) was another hybrid system that used an ANN trained
with sixteenth century classical music compositions. The ANN generated a basic melody by
segments. After each segment was created, an ensemble of agents generated a polyphonic
elaboration of the segment. The agents had rule-based systems crafted from music theoret25. An important property of music, rather difficult to define. At each point in time, the tension is related
to the interplay between structure and uncertainty perceived by the listener in the flow of the music.
Informally, it can be defined as the unfinishedness of the music if it were stopped at that point.

543

Fern√°ndez & Vico

ical considerations, and coordinated to maintain a coherent global output. ANNs can also
be combined with probabilistic methods: in the work of Verbeurgt et al. (2004), a set of
training sequences was decomposed into musical motifs, encoded in relative pitch. Then, a
Markov chain was constructed, whose states were the motifs. New compositions were generated by the Markov chain, but to assign the absolute pitches to the motifs in the resulting
composition, they trained an ANN. Adiloglu and Alpaslan (2007) used feedforward ANNs
to generate two-voice counterpoint, applying notions of music theory to the representation
of musical information in the networks. In Browne and Fox‚Äôs (2009) system, simulated
annealing was used to arrange small fragments (motifs) of classical music, trying to get
a profile of musical tension (the same metric as in Melo, 1998) similar to the profile of a
pre-specified composition, measured using an ANN specialized in music perception. Finally,
another hybrid system was implemented by Coca et al. (2011), which used ANNs trained
with pre-existing compositions together with pseudo-random musical input generated from
a chaotic system, in order to generate more complex compositions in the synthesis phase.
3.4.1 ANNs with Evolutionary Algorithms
Among hybrid systems, those combining ANNs with evolutionary algorithms quickly became the most popular. Usually, an ANN was trained to act as the fitness function of an
evolutionary algorithm. This is the case of the earliest example of these hybrid systems,
NEUROGEN (Gibson & Byrne, 1991). Its fitness function was the composed result of two
ANNs, one for judging the intervals between pitches and the other for the overall structure. A genetic algorithm with a rather rigid, classical binary representation was used,
severely limiting the applicability of the whole implementation. However, there are also
‚Äúinverted‚Äù frameworks where the evolving individuals are ANNs. For example, H√∂rnel and
Ragg (1996) evolved HARMONET networks, but the fitness was the network performance
in training and harmonization. In another example (Chen & Miikkulainen, 2001), recurrent
three-layered ANNs evolved to compose music, and the fitness was computed from a set of
rules from music theory.
Given the modular nature of evolutionary algorithms and the perceived complexity of
ANNs, it is not uncommon that the evolutionary framework is laid down in a first research
work, and only in subsequent developments ANNs are used to replace the original fitness
function.26 For example, Spector and Alpern (1994) developed a genetic programming (GP)
framework for jazz improvisations: the individuals were programs composed by collections
of transformations that produced improvisations upon being fed previously existing jazz
melodies, and the fitness function aggregated several simple principles from jazz music
theory. The following year (Spector & Alpern, 1995), they updated their model to train an
ANN to be used as their fitness function. However, this scheme does not always fare well,
specially if the initial framework uses interactive fitness. This is the case of GenJam (Biles,
1994), an evolutionary algorithm for generating jazz melodies with an interactive fitness
function. Later on (Biles et al., 1996), as the interactive fitness evaluation represented a
severe fitness bottleneck, ANNs were tried to partially offload evaluation from human users,
with no success, as the ANNs failed to satisfactorily generalize the evaluations from their
26. This approach is risky, though, because evolutionary algorithms tend to find and exploit unexpected and
undesired quirks in any fitness evaluation function; more so if the evaluator is an ANN.

544

AI Methods in Algorithmic Composition

Reference

Composition task

Comments

Gibson & Byrne, 1991

melody, rhythm

Two ANNs to define the fitness function

H√∂rnel & Ragg, 1996

melody harmonization

evolves HARMONET, the fitness is the ANN‚Äôs
performance in training and harmonization

Chen & Miikkulainen, 2001

melody

evolves recurrent networks,
the fitness is computed from a set of rules

Spector & Alpern, 1994

melody

genetic programming, ANNs as fitness functions

Biles et al., 1996

jazz improvisation

ANNs as fitness functions

Johanson & Poli, 1998
(GP-Music)

melody

genetic programming, ANNs as fitness functions

Klinger & Rudolph, 2006

melody

ANNs and decision trees as fitness functions

Manaris et al., 2007

melody

genetic programming, ANNs as fitness functions

Burton, 1998

drum rhythms

Adaptive Resonance Theory
(unsupervised learning) as fitness function

Phon-Amnuaisuk et al., 2007

melody

genetic programming, self-organinzing map
(unsupervised learning) as fitness function

Table 14: References for Section 3.4.1, in order of appearance.

training sets. In the case of the GP-Music System (Johanson & Poli, 1998), which used
GP with procedural representations of short melodies, the trained ANNs were not a failure,
but decidedly below par with respect to the performance of the algorithm with interactive
fitness. Klinger and Rudolph (2006) compared the performance of feedforward ANNs with
learned decision trees, finding that the latter performed better and their ratings were easier
to understand. In spite of these examples, more successful instances do exist: Manaris et al.
(2007) extracted several statistical metrics from music compositions and trained an ANN
to recognize compositions whose metrics‚Äô distributions featured Zipf‚Äôs law, then used it as
the fitness function in a GP framework whose individuals were procedural representations
of polyphonic compositions. The results were validated as aesthetically pleasing by human
testers.
All the research described up to this point uses ANNs with supervised learning. However,
methods using unsupervised learning also exist. Burton (1998) proposed a genetic algorithm
with a classical binary representation for generating multi-voice percussion rhythms, whose
fitness function presented an unconventional feature mix. It used Adaptive Resonance Theory (ART), an ANN with unsupervised learning, initially trained to perform automatic
clustering of a set of drum rhythms. Then, during the execution of the genetic algorithm,
the unsupervised learning continued. The fitness was a measure of how near was the individual to some cluster. If the individual represented a brand new rhythm so different as to add
a new cluster, the rhythm was presented to the user to decide if it was musically acceptable.
In this way, Burton tried to get the best of interactive and automatic fitness evaluation.
A different example with unsupervised learning was presented by Phon-Amnuaisuk et al.
(2007), able to generate variations over a pre-specified composition. It used GP whose individuals were procedural representations of melodies, while the fitness was the similarity
to the pre-specified composition, as measured by a self-organizing map (SOM) previously
trained with musical elements of the pre-specified composition.
545

Fern√°ndez & Vico

Reference

Composition task

Comments

Baggi, 1991

jazz improvisation

ad hoc connectionist expert system

Laine, 2000

simple rhytms

uses central pattern generators

Dorin, 2000

poly-rhythmic musical patterns

uses Boolean networks

Hoover et al., 2012

acompaniment

uses CPPNs

Table 15: References for Section 3.4.2, in order of appearance.

3.4.2 Related Methods
Finally, this subsection presents methods that may be considered roughly similar to ANNs,
or more generally, connectionist. For example, Neurswing (Baggi, 1991) may be described
as an ad hoc expert system for jazz improvisation crafted in a connectionist framework.
Surprisingly, many research papers cite Neurswing as an ANN framework, despite Baggi‚Äôs
disclaimer: ‚Äú[Neurswing], though only vaguely resembling a neural net or a connectionist
system, [. . . ]‚Äù (Baggi, 1991). Laine (2000) used very simple ANNs to implement Central
Pattern Generators, whose output patterns where then interpreted as more or less simple
rhythms (motion patterns in his terminology).
Boolean networks are another connectionist paradigm in which each node has a binary
state and the edges between nodes are directed; each node‚Äôs state changes in discrete steps
according to a (usually randomly chosen) Boolean function whose inputs are the states of
the nodes with connections to that node. They may be considered as generalizations of
cellular automata, and depending on the wiring and the distribution of Boolean functions,
their states can change in very complex patterns, with potentially complex responses to external forcing. Because of these properties, Dorin (2000) used Boolean networks to generate
complex poly-rhythmic musical patterns, modulable in real time by the user.
Hoover et al. (2012) proposed another connectionist approach: compositional pattern
producing networks (CPPNs). These are feedforward networks where each ‚Äúneuron‚Äù may
use a different, arbitrary function, instead of the classical sigmoid function. They are usually
designed by interactive evolutionary methods, and can be used to generate or modulate
highly complex patterns. In the cited paper, they were fed a pre-existing simple composition
as input, in order to generate an accompaniment for it.
3.5 Evolutionary and Other Population-Based Methods
Most evolutionary algorithms (EAs) approximately follow a common pattern: a changing
set of candidate solutions (a population of individuals) undergoes a repeated cycle of evaluation, selection and reproduction with variation. The first step is to generate the candidate
solutions of the initial set, either from user-specified examples or in a more or less random
way. Each candidate is then evaluated using a fitness function, a heuristic rule to measure
its quality. The next phase is selection: a new set of candidate solutions is generated by
copying candidate solutions from the old one; each candidate solution is copied a number
of times probabilistically proportional to its fitness. This step decreases the diversity of
the population, which is restored by applying (to a fraction of the candidate solutions)
some operators designed to increase the variation (for example, mutation or recombination
546

AI Methods in Algorithmic Composition

operators). These steps are applied iteratively; as a result, best and mean fitness gradually
tend to increase.
While this algorithmic pattern is common to all EAs, there exist many different algorithms using different sets of selection rules, variation operators and solution encoding. In
an EA, the encoded form of a candidate solution is the genotype, while the phenotype is
the translation of that coded form into a solution. Holland‚Äôs original formulation of genetic algorithms is strongly associated with a plain and direct encoding of genotypes as
binary strings, but this is not the case in most papers using EAs. Because of this, the
term evolutionary is preferred over genetic in this paper. Another popular variant, Koza‚Äôs
genetic programming, represents genotypes as tree structures, often encoding expressions of
a programming language, while the phenotype is the result of evaluating these expressions.
Since EAs are particularly prone to be hybridized with other methods, they are also
reviewed in the other sections: with grammars in Section 3.1.2, with ANNs in Section 3.4.1,
with Markov chains in Section 3.3‚Ä† , with rule-based systems in Section 3.2.2, and with
cellular automata in Section 3.6.1‚Ä° . In general, the papers cited in these sections will not
be discussed here. We also recommend some literature to learn more about evolutionary
computer music: Burton and Vladimirova (1999) wrote a survey with long, thorough descriptions of the referenced papers, while the survey of Santos et al. (2000) is more similar
to ours in style, packed with brief descriptions. Miranda and Biles‚Äôs (2007) book is more
recent, but also contains work on other optimization methods (as swarm optimization) and
algorithmic composition techniques (as cellular automata).
3.5.1 Evolution with Automatic Fitness Functions
The difficulty to define automatic fitness functions has been a constant issue, frequently
limiting the application of evolutionary methods to well-defined and restricted problems
in composition. Horner and Goldberg (1991) provided one of the first examples: they
implemented an EA for thematic bridging, a composition technique consisting of defining
a sequence (with a pre-specified preferred length) of small musical patterns such that the
first and the last ones are pre-specified, and each pattern is the result of applying a simple
transformation to the previous one. Naturally, the individuals in the EA were defined as
lists of operations applied to the initial pattern to generate the sequence of patterns. The
fitness measured how close the final pattern (generated from the operations) was to the
pre-specified final pattern, plus the difference between actual and preferred lengths of the
sequence. Essentially the same work (with differences in the underlying representation and
operation set) was reported by Ricanek et al. (1993).
A common way to implement a fitness function is as a weighted sum of features of the
composition (although tuning the weights to optimize the EA can prove difficult except for
toy problems). For example, Marques et al. (2000) composed short polyphonic melodies
using a very direct representation for the genotypes and also a simple fitness function,
with a rather simple, ad hoc evaluation of harmony and melodic value. The results were
reportedly acceptable. Johnson et al. (2004) also composed short melodies using an EA
‚Ä†. Only a few examples of evolutionary algorithms were described in this section, not warranting a dedicated
subsection for them.
‚Ä°. Same case as in the previous note.

547

Fern√°ndez & Vico

Reference

Composition task

Comments

Horner & Goldberg, 1991

thematic bridging

fitness: distance to original melodies

Ricanek et al., 1993

thematic bridging

fitness: distance to original melodies

Marques et al., 2000

polyphony

fitness: combination of features

Johnson et al., 2004

melody

fitness: combination of features

Papadopoulos & Wiggins,
1998

jazz improvisation

fitness: combination of features

Harris, 2008
(JazzGen)

jazz improvisator

fitness: combination of features

Towsey et al., 2001

melodic extension

fitness: combination of features
(only fitness, no evolutionary algorithm)

Birchfield, 2003

melody, rhythm

fitness: combination of features

Garay Acevedo, 2004

species counterpoint

fitness: combination of features

Lozano et al., 2009

melody
harmonization

fitness: combination of features

De Prisco et al., 2010

unfigured bass

multi-objective optimization

Freitas & Guimar√£es, 2011

melody
harmonization

multi-objective optimization

Gartland-Jones, 2002

generate variations
on two melodies

fitness: distance to a melody

Alfonseca et al., 2005

melody

fitness: distance to corpus of melodies

√ñzcan & Er√ßal, 2008
(AMUSE)

generate variations
on a melody

fitness: combination of features

Wolkowicz et al., 2009

melody

fitness: distance to corpus of melodies

Laine & Kuuskankare, 1994

melody

fitness: distance to a melody. Genetic programming

Spector & Alpern, 1994

jazz improvisation

fitness: combination of features. Genetic programming

Dahlstedt, 2007

contemporary
classical music

fitness: combination of features. Genetic programming

Esp√≠ et al., 2007

melody

fitness: combination of features extracted fropm a
corpus of melodies. Genetic programming

Jensen, 2011

melody

fitness: distance to a corpus of melodies.
Genetic programming

D√≠az-Jerez, 2011;
S√°nchez-Quintana et al.,
2013

contemporary
classical music, other
genres

sophisticated indirect encoding

Table 16: References for Section 3.5.1, in order of appearance.
with a fitness function that was a weighted sum of a series of very basic, local features
of the melody. Papadopoulos and Wiggins (1998) implemented a system that, given a
chord progression, evolved jazz melodies by relative pitch encoding, using as fitness function
a weighted sum of eight evaluations of characteristics of the melody, ranging from very
simple heuristics about the speed and the position of the notes to user-specified contour and
similarity to user-specified music fragments. A similar approach was implemented by Harris
(2008), with modest (if promising) results. While Towsey et al. (2001) did not actually
implement an EA, they discussed how to build a fitness function for melodic extension
548

AI Methods in Algorithmic Composition

(given a composition, extend it for a few bars): they proposed to extract 21 statistical
characteristics from a corpus of pre-specified compositions, defining the fitness function as
a weighted sum of the distance between the individual and the mean of the characteristic.
In a similar vein, Birchfield (2003) implemented a fitness function as a giant weighted sum
of many features in a hierarchical EA, with multiple population levels, each individual in
a population being composed of individuals from lower populations (similar to the model
described in Biles, 1994; see Section 3.5.2). He used the output of the EA as material
to arrange a long composition for ten instruments. Garay Acevedo (2004) implemented a
simple EA to compose first species counterpoint, but the features weighted in the fitness
function were too simplistic, leading to modest results. Lozano et al. (2009) generated chord
sequences to harmonize a pre-specified melody in two steps: first a simple EA generated a
set of possible solutions according to simple local considerations (appropriateness of each
chord for the corresponding part of the melody) between the chords and the notes of the
melody, and then a variable neighborhood search was used to establish a chord progression
according to global considerations.
The alternative to implementing the fitness function as a weighted sum of musical features is to use multi-objective evolutionary algorithms (MOEAs). However, these have very
rarely been used, most probably because they are harder to implement, both conceptually and in practice. MOEAs have been used by De Prisco et al. (2010) to harmonize the
unfigured bass27 and by Freitas and Guimar√£es (2011) for harmonization.
Another approach consists of measuring the fitness as the distance to a target composition or corpus of compositions. For example, Gartland-Jones (2002) implemented an EA
to compose hybrids between two pre-specified compositions (a goal similar to Hamanaka
et al.‚Äôs, 2008, cited in Section 3.1) by using one to seed the initial population, and the
distance to the other (sum of difference in pitch for each note) as the fitness function. Alfonseca et al. (2005) used a more sophisticated evaluation: the fitness of each composition
in the population was the sum of distances to a corpus of pre-specified target compositions. The metric was the normalized compression distance, a measure of how different two
symbol strings are, based on their compressed lengths (both concatenated and separated).
√ñzcan and Er√ßal (2008) used a simple genetic representation and a fitness function based
on a weighted sum of a long list of simple musical characteristics, reportedly being able
to generate improvisations over a pre-specified melody with a given harmonic context, but
they did not specify how the evolved melodies were related to the pre-specified music. In
the EA implemented by Wolkowicz et al. (2009), individuals were encoded using relative
pitches, and a sophisticated statistical analysis of n-gram sequences in a pre-specified corpus
of compositions was used to implement the fitness function.
Genetic programming has also been used with fitness functions based on comparisons
with pre-specified music. In the work of Laine and Kuuskankare (1994), the individuals
were discrete functions of time whose output (phenotype) was interpreted as a sequence of
pitches. The fitness was simply the sum of differences in pitches between a pre-specified
target composition and the phenotype of each individual, in a similar way to GartlandJones (2002). However, it is frequent to find fitness functions based on the analysis of
characteristics of the compositions evolving in the algorithm, often comparing them against
27. For a description of the unfigured bass, see the discussion of Rothgeb‚Äôs (1968) work in Section 3.2.

549

Fern√°ndez & Vico

characteristics of a pre-specified training set of compositions. Spector and Alpern (1994)
used genetic programming for jazz improvisation, ‚Äútrading fours‚Äù: the individuals were
functions that took as input a ‚Äúfour‚Äù and produced another one by applying a series of
transformations to it. The fitness was determined by applying a series of score functions
that measured the rhythm, tonality and other features of the produced ‚Äúfour‚Äù, comparing
them against a database of high-quality examples from renowned artists.
Also using genetic programming, Dahlstedt (2007) composed relatively short contemporary classical music pieces, with a simple fitness function: a set of target values were
assigned for several statistics of the compositions (as note density or pitch standard deviation, among others), and the fitness was a weighted sum of the differences between the
target values and the values for each individual. The individuals were trees whose nodes
represented notes and different operations over musical sequences (using a developmental
process from genotype to phenotype). Reportedly, the generated pieces were of acceptable
quality, because the genotype model was especially well suited for contemporary classical
music. Esp√≠ et al. (2007) used a simple tree representation for compositions (but without
indirect encoding), defining the fitness function as a weighted sum of sophisticated statistical models for melody description (measuring the distance to the values of a set of
pre-specified compositions) and several relatively simple characteristics of the composition.
Jensen (2011) also used a simple tree representation for compositions; the fitness was calculated measuring frequency distributions of simple events in the compositions, rating them
according to Zipf‚Äôs law and similarity to pre-specified compositions.
One of the latest and most successful results in evolutionary computer music follows
an evo-devo strategy. Iamus is a computer cluster which hybridizes bioinspired techniques:
compositions evolve in an environment ruled by formal constraints and aesthetic principles (D√≠az-Jerez, 2011). But compositions also develop from genomic encodings in a way
that resembles embryological development (hence the evo-devo), providing high structural
complexity at a relatively low computational cost. Each composition is the result of an
evolutionary process where only the instruments involved and a preferred duration have
been specified, and are included in the fitness function. Iamus can write professional scores
of contemporary classical music, and it has published its debut album in September 2012
(Ball, 2012; Coghlan, 2012), with ten works interpreted by first-class musicians (including the LSO for the orchestra piece). Melomics, the technology behind this avant-garde
computer-composer, is also mastering other genres and transferring the result to industry
(S√°nchez-Quintana et al., 2013). After compiling a myriad of musical fragments of most
essential styles in a browsable, web-based repository (Stieler, 2012). For the first time,
Melomics is offering music as a real commodity (priced by size of its MIDI representation),
where ownership over a piece is directly transferred to the buyer.
3.5.2 Musical IGAs
From the previous exposition, it is apparent that designing an objective and convenient
fitness function for evaluating music compositions is a very difficult problem.28 If the music
is to be evaluated in terms of subjective aesthetic quality, it may become impractical or
28. To the point that artists sometimes find ‚Äúunconventional‚Äù ways around this problem: Waschka (1999)
argued to have solved the problem by assigning a purely random fitness value to the individuals.

550

AI Methods in Algorithmic Composition

Reference

Composition task

Comments

Hartmann, 1990

melody

inspired by Dawkins‚Äô biomorphs

Nelson, 1993

melody

inspired by Dawkins‚Äô biomorphs

Horowitz, 1994

rhythms

inspired by Dawkins‚Äô biomorphs

Pazos et al., 1999

rhythms

binary genotype

Degazio, 1996

melody

binary genotype; graphical representation

Biles, 1994
(GenJam)

jazz improvisation

two hierarchically structured populations
(measures and jazz phrases)

Tokui & Iba, 2000

rhythms

two hierarchically structured populations
(short and long rhythmic patterns).
Genetic programming

Jacob, 1995

melody

the user trains ‚Äúcritics‚Äù that act as fitness functions

Schmidl, 2008

melody

the user trains ‚Äúcritics‚Äù that act as fitness functions

Putnam, 1994

melody

genetic programming

Ando & Iba, 2007

melody

genetic programming

MacCallum et al., 2012
(DarwinTunes)

melody

genetic programming

Kaliakatsos-Papakostas
et al., 2012

melody, 8-bit sound
synthesis

genetic programming

Hoover et al., 2012

acompaniment

uses CPPNs

McDermott & O‚ÄôReilly, 2011

interactive generative
music

similar to CPPNs

Ralley, 1995

melody

minimizes user input by clustering candidates

Unehara & Onisawa, 2001

melody

minimizes user input with elitism

D√≠az-Jerez, 2011

contemporary classical
music

minimizes user fatigue producing small, good
compositions

Beyls, 2003

melody

uses cellular automata; graphical representation

Moroni et al., 2000
(Vox Populi)

melody

complex graphical representation

Ventrella, 2008

melody

the whole population comprises the melody

Marques et al., 2010

melody

minimizes evolutionary iterations

Table 17: References for Section 3.5.2, in order of appearance.
directly impossible to define a formal fitness function. Because of these inconveniences,
many researchers have resorted to implement the fitness function with human evaluators.
A common term for describing this class of EAs is musical IGA (interactive genetic algorithm29 , MIGA for short). As MIGAs represent a substantial percentage of the total body
of work on EAs for algorithmic composition, this subsection is devoted to them.
The first MIGAs were implemented by composers intrigued by the concept of evolutionary computing, resulting in more or less peculiar architectures from the perspective
of common practice in evolutionary computing, but also by computer scientists exploring
29. Most research tagged as IGA does not use the binary genotypes commonly associated with the term
genetic algorithm, but the term is very common.

551

Fern√°ndez & Vico

the field. Hartmann (1990), inspired by Dawkins‚Äô biomorphs, presented one of the first
applications of evolutionary computing to composition, a MIGA that he unfortunately described in a notoriously laconic and obscure language, resulting in a very low citation rate
for his work. Also inspired by the biomorphs, Nelson (1993) described a toy MIGA for
evolving short rhythms over a fixed melodic structure, with simple binary genotypes (each
bit simply denoted the presence or absence of sound). More formal models similar in scope
to Nelson‚Äôs were designed by Horowitz (1994) and Pazos et al. (1999). They implemented
rhythm generators for multiple instruments, each one with its own independent rhythm
pattern encoded in the genotype (Horowitz‚Äôs genotypes were parametric, while Pazos et
al. used more direct binary encodings). Degazio (1996) implemented a system in which
the genotype was a set of parameters (in later iterations, a mini-language to describe the
parameters) to instruct his CAAC software to generate melodies.
The best known MIGA may be GenJam, a system for generating jazz solos, developed
over several years. In its first incarnation (Biles, 1994), it was formulated as a MIGA with
two hierarchically structured populations: one of measures, and other of jazz phrases, constructed as sequences of measures. Given a chord progression and several other parameters,
jazz solos emerged by concatenating selected phrases during the evolutionary process, and
the fitness was integrated over time by accumulating fixed increments and decrements from
simple good/bad indications from the evaluator. Further iterations of the system included
the already discussed use of ANNs as fitness functions (Biles et al., 1996) and the possibility
to trade fours with a human performer, by dynamically introducing into the population the
music performed by the human (Biles, 1998). Tokui and Iba (2000) used a similar solution
for creating rhythms with multiple instruments: a population of short sequences specified
as list of notes, and another population of tree structures representing functions in a simple
macro language that used the short sequences as building blocks. Another example of hierarchical structuring of the MIGA is Jacob‚Äôs (1995) system for general-purpose composition,
with three inter-dependent evolutionary processes: one involving the human user to train
ears to evaluate short musical sequences, another one to compose musical phrases using the
ears (filters) as fitness functions, and another also involving the human user to train an
arranger that reorders the resulting phrases into the final output of the system. Schmidl
(2008) implemented a similar system, but without a high-level arranger module, and with
ears automatically trained from a set of examples, in order to minimize user interaction and
enable real-time composition.
Genetic programming with interactive evaluation has been used several times. Putnam
(1994) implemented an early example: each individual coded for a set of functions that
generated a melody as the result of an iterated function system. Tokui and Iba‚Äôs (2000)
example has been already cited. Ando and Iba (2007) implemented a fully interactive
system (not only the selection, but also the reproduction and mutation were user-guided),
where the genotype model was similar to Dahlstedt‚Äôs (2007). MacCallum et al. (2012) used
trees to encode Perl expressions that generated polyphonic short loops, but concentrated on
analyzing the interactive evolution from the point of view of theoretical biology. KaliakatsosPapakostas et al. (2012) used a rather different approach to generate 8-bit melodies: each
individual was a function composed of bitwise operators that generated a waveform by
iterating the function. In fact, that work might be described as sound synthesis over large
time scales, rather than music composition.
552

AI Methods in Algorithmic Composition

Some MIGAs with graph-based genetic representations also exist, as the implementation
based in CPPNs (Hoover et al., 2012) that was already cited in Section 3.4.2. McDermott
and O‚ÄôReilly (2011) used a similar paradigm: genotypes were sequences of integers that
indirectly encoded graphs, whose nodes represented functions, and their connections were
compositions of functions. The output nodes generated musical output in one or more
voices, which were modulated by user inputs.
A problem common to all MIGAs is user fatigue: candidate solution evaluation is a
comparatively slow and monotone task that rapidly leads to user fatigue. Even with small
population sizes and small numbers of generations, it remains a significant problem that has
been solved by many researchers in different ways. For example, Ralley (1995) used a binary
representation with relative pitch encoding for the genotypes, and classified the population
with a clustering algorithm, deriving similarity metrics from rudimentary spectral analysis of
the scores. The user was simply required to evaluate the closest composition to the centroid
of each cluster. A more exotic solution was employed by previously cited Tokui and Iba
(2000): training a neural network to filter out candidates with low fitness, thus presenting
to the user individuals of acceptable quality. Unehara and Onisawa (2001) presented just
10% of candidate melodies to the human user, and then parts of the genomes of the best
rated ones were dispersed in the population by ‚Äúhorizontal gene transfer‚Äù. McDermott and
O‚ÄôReilly (2011) also limited the number of candidates exposed to user rating, filtering out
the worst ones with heuristic functions. Another option to minimize user fatigue is to
produce small compositions that already are reasonably good. The Melomics system (see
last paragraph in Section 3.5.1) can be used in this way (D√≠az-Jerez, 2011).
Other common ways to manage the problem include low population sizes and/or hierarchical structuring of the algorithm (Biles, 1994), or providing statistical information and/or
rendering graphical representations of the compositions in order to make possible their
evaluation without actually listening to them (Degazio, 1996). Graphical representations
are also particularly useful if using generative methods as L-systems or cellular automata
(Beyls, 2003). Putnam (1994) used a web interface to reach out to more volunteers. Moroni
et al. (2000) tried to solve the problem using sophisticated GUI abstractions, with complex
non-linear mappings between the graphic controls and the parameters of the fitness function
and other aspects of the evolutionary process, to produce a highly modulable system for
real-time interactive composition of melodies. To mitigate user fatigue, Ventrella (2008)
presented a population of short melodies as a continuous stream of sound; fitness was obtained through a binary signal set by the user. Marques et al. (2010) limited user fatigue in
the generation of short, simple melodies by severely limiting the number of generations of
the algorithm, and generating a reasonably good starting population by drawing the notes
using Zipf‚Äôs law.
3.5.3 Other Population-Based Methods
Finally, this subsection presents other methods that are also population-based. For example, the metaheuristic method Harmony Search is inspired in the improvisation process of
musicians, though in practice can be framed as an evolutionary method with a specific way
to structure candidate solutions and perform selection, crossover and mutation operations.
Geem and Choi (2007) used this method to harmonize Gregorian chants (i.e., to write or553

Fern√°ndez & Vico

Reference

Composition task

Comments

Geem & Choi, 2007

harmonize
Gregorian chants

harmony search

Geis & Middendorf, 2008

four-part
harmonization

multi-objective Ant Colony Optimization

Tominaga & Setomoto, 2008

polyphony,
counterpoint

artificial chemistry

Werner & Todd, 1997

melody

co-evolutionary algorithm, Markov chains used
as evolvable fitness functions

Bown & Wiggins, 2005

melody

individuals are Markov chains
that compose and evaluate music

Miranda, 2002

melody

individuals agree on a common set of
‚Äúintonation patterns‚Äù

Miranda et al., 2003,
sect. IV

melody

individuals are grammars that compose music

McCormack, 2003b

interactive soundscape

individuals indirectly compete for users‚Äô attention

Dahlstedt & Nordahl, 2001

soundscape

music emerges from collective interactions

Beyls, 2007

soundscape

music emerges from collective interactions

Blackwell & Bentley, 2002

soundscape

music emerges from collective interactions

Eldridge & Dorin, 2009

soundscape,
sound synthesis

music emerges from collective interactions,
individuals exist in the frequency domain

Bown & McCormack, 2010

interactive soundscape,
sound synthesis

music emerges from collective interactions,
individuals exist in the frequency domain

Table 18: References for Section 3.5.3, in order of appearance.

ganum lines for the chants). Other methods are also population-based but not properly
evolutionary. An example is the use of Ant Colony Optimization (ACO) to solve constraint
harmonization problems (Geis & Middendorf, 2008), already mentioned in Section 3.2.3.
In ACO, the candidate solutions are represented as paths in a graph, and a population of
agents (ants) traverse the graph, cooperating to find the optimal path.
As a more exotic example, an Artificial Chemistry is a generative system consisting of
a multiset of strings of symbols. These strings (analogues of molecules) can react according
to a pre-specified set of rules (analogues of chemical reactions), generating new strings from
the existing ones. Tominaga and Setomoto (2008) used this method, encoding polyphonic
compositions in the strings and musical rules for counterpoint in the reaction rules of the
artificial chemistry: starting from a set of simple strings, the system generated progressively
more complex ones, though the aesthetical value of the resulting compositions varied widely.
A more popular method based on populations of individuals is the Artificial Ecosystem.
In an artificial ecosystem, compositions emerge from the interaction between individuals in
a simulation with evolutionary and/or cultural interactions, taking inspiration in the evolutionary origins of music in humans (Wallin & Merker, 2001). Frequently, the complexity
of the simulations is severely limited by the available computational power, and in some
cases the goal is not music composition per se, but the study of evolutionary dynamics, the
emergence of shared cultural traits and avant-garde artistic experimentation.
554

AI Methods in Algorithmic Composition

An early example by Werner and Todd (1997) investigated sexual evolutionary dynamics
in a population of males (small compositions) and females (Markov chains initially generated
from a corpus of songs) that evaluated how much the males deviated from their expectations.
However, most studies use just one kind of agent, as in the work of Bown and Wiggins (2005),
whose agents used Markov chains for both compose and analyze music. Miranda (2002)
and Miranda, Kirby, and Todd (2003, sect. IV) implemented models with a similar goal: to
study the emergence of common structures (shared cultural knowledge). In the first case a
population of agents strove to imitate each other‚Äôs intonation patterns (short sequences of
pitches); in the second case agents learned to compose music by inferring musical grammars
from other agents‚Äô songs. Bosma (2005) extended Miranda‚Äôs (2002) model, using neural
networks in the agents to learn and compose music, although with tiny population sizes. As
part of an art installation, McCormack (2003b) proposed a virtual ecosystem with evolving
agents able to compose music using a rule-based system, competing for resources that were
indirectly determined by the interest of human observers.
An alternative is that the music is not composed by the agents, but emerges as an
epiphenomenon of the whole ecosystem. The models of Dahlstedt and Nordahl (2001) and
Beyls (2007) used simple organisms in a two-dimensional space whose collective behavior
was mapped into complex compositions, while Blackwell and Bentley‚Äôs (2002) model was
similar but three-dimensional, and the dynamics of the agents were inspired in swarm
and flocking simulations. While all these examples use either homogeneous or spatially
structured ecosystems, a recent trend is the use of sound as an environment in itself. In
Eldridge and Dorin‚Äôs (2009) model, the agents dwelt in the one-dimensional space of the
Fourier transform of a sample of ambient sound, feeding off and moving the energy across
frequencies. Bown and McCormack (2010) implemented a similar model, in which the
agents were neural networks that generated sound and competed for room in the space of
frequencies of ambient sound.
3.6 Self-Similarity and Cellular Automata
In the late 1970s, two notable results about music were reported by Voss and Clarke (1978).
The first was that, for music of many different styles, the spectral density of the audio
signal was (approximately) inversely proportional to its frequency; in other words, it approximately follows a 1/f distribution. This is not so surprising: many different data series
follow this property, from meteorological data to stock market prices; it is usually referred
to as 1/f noise or pink noise. The second result was that random compositions seemed
more musical and pleasing (for a wide range of evaluators, from unskilled people to professional musicians and composers) when the pitches were determined by a source of 1/f noise,
rather than other common random processes as white (uncorrelated) noise or Brownian motion (random walks). Although the first result has been since challenged30 , the second one
has been used by composers as a source of raw material. Bolognesi (1983) implemented an
early example influenced by Voss and Clarke‚Äôs results, but composers used data series with
1/f noise as raw material even before these results, early in the 1970s (Doornbusch, 2002).
30. The main criticism is that the data samples used by Voss and Clarke were hours long, merging in each
sample many different compositions (and even non-musical sounds from a radio station). In view of their

555

Fern√°ndez & Vico

Reference

Composition task

Comments

Voss & Clarke, 1978

melody

first reference to 1/f noise in music

Bolognesi, 1983

melody

early deliberate use of 1/f noise in music

Doornbusch, 2002

melody

reference to early non-deliberate use of 1/f noise in music

Gogins, 1991

melody

iterated function systems

Pressing, 1988

melody,
sound synthesis

chaotic non-linear maps

Herman, 1993

melody

chaotic non-linear dynamical systems

Langston, 1989

melody

fractional Brownian motion

D√≠az-Jerez, 2000

melody

fractals and other self-similar systems

Bidlack, 1992

melody

various fractal and chaotic systems

Leach & Fitch, 1995
(XComposer)

melody, rhythm

uses various fractal and chaotic systems

Hinojosa-Chapel, 2003

melody

uses various fractal and chaotic systems to fill the

Coca et al., 2011

melody

uses chaotic systems to add variation

Table 19: References for Section 3.6, in order of appearance.
There remains the question of why 1/f noise produces more musical results that other
random processes. The consensus in the research and artistic communities is self-similarity:
the structure of 1/f noise is statistically similar across several orders of magnitude (Farrell
et al., 2006). Self-similarity is a common feature in classical music compositions (Hs√º &
Hs√º, 1991), and is also one of the defining features of fractals (in fact, 1/f noise also has
fractal characteristics). Because of this, fractals have been extensively used as a source
of inspiration and raw material for compositions and CAAC software. In general, selfsimilar musical patterns have multiple levels of structure, with pleasing regularities but
also dotted with sudden changes. Because these characteristics can be also present in the
output of chaotic systems (whose attractors are also fractal structures), these are also used
to generate musical patterns. Commonly used techniques to generate self-similar musical
patterns include chaotic systems such as iterated function systems (Gogins, 1991), nonlinear maps (Pressing, 1988) and non-linear dynamical systems (Herman, 1993), but also
fractional Brownian motion (Langston, 1989), cellular automata (discussed below) and Lsystems (already discussed in Section 3.1.1). More exotic methods are also possible, as
musical renderings of fractal images or number sequences with fractal characteristics (D√≠azJerez, 2000). These methods are widely regarded as not suitable to produce melodies or
compositions in their own right, but as a source of inspiration or raw material (Bidlack,
1992). Because of this, no extensive review will be provided here.31 However, full-fledged
algorithmic composition methods can use them as part of the creative process, as in Leach
and Fitch‚Äôs (1995) XComposer, where chaotic systems are used to fill the structures laid
critics, such as Nettheim (1992), these samples could not possibly be representative of single musical
pieces (see also the discussion in D√≠az-Jerez, 2000, pp. 136‚Äì138).
31. Good (if somewhat outdated) reviews can be found in the work of Jones (1989), D√≠az-Jerez (2000) and
Nierhaus (2009). The list of composers using fractals and chaotic systems for CAAC is so long that it is
impractical to consistently describe all the existing relevant work.

556

AI Methods in Algorithmic Composition

down by a hierarchical model, or in Hinojosa-Chapel‚Äôs (2003) paradigm for interactive
systems, where they are also used as a source of musical material. They can also be used
to add complexity to compositions generated by other means.32
3.6.1 Cellular Automata
A cellular automaton (CA) is a discrete (in time, space and state) dynamic system composed
of very simple computational units (cells) usually arranged in an ordered n-dimensional (and
potentially unbounded) grid (or any other regular tiling). Each cell can be in one of a finite
number of states. In each discrete time step, each cell‚Äôs state is deterministically updated,
using a set of transition rules that take into account its own state and its neighbors‚Äô states.
Although this definition can be generalized in multiple ways, it represents a good first
approximation. Cellular automata are used in many disciplines across Science and the
Humanities as dynamical models of complex spatial and temporal patterns emerging from
the local interaction of many simple units; music composition is just one of these disciplines.
Cellular automata can be used to generate fractal patterns and discrete versions of chaotic
dynamical systems, but they also represent an alternative computational paradigm to realize
algorithmic composition.33 Unfortunately, just like fractals and chaotic systems, CA also
tend to produce interesting but somewhat unmusical patterns that are used as inspiration
or raw material rather than directly as music compositions. Although CA are argued to be
better suited to sound synthesis than to algorithmic composition (Miranda, 2007), only the
latter application will be reviewed here.
Xenakis was known to be deeply interested in the application of CA to music. In his
orchestral composition Horos, released in 1986, he is widely regarded to have used a CA to
configure the structure of the composition, though it was then heavily edited by hand (Hoffmann, 2002). Early, better documented explorations of CA for music composition include
the implementations of Beyls (1989), Millen (1990), and Hunt et al. (1991), which mapped
the patterns generated by user-defined CA to MIDI output. Beyls (1989) presented CA as
a generative system for real-time composition of avant-garde music, exploring several ways
to complexify the generated musical patterns (as changing the transition rules according to
meta-rules), while Millen (1990) presented a minimalist CAAC system. Hunt et al. (1991)
implemented another CAAC system designed to give the composer more control over the
composition process. Echoing Beyls‚Äôs (1989) early work, Ariza (2007) proposed to bend the
transition rules in order to increase the space of parameters available to the composer for experimentation, by either randomly changing the state of some isolated cells or dynamically
changing the transition rules from one generation to the next.
CAMUS (Miranda, 1993) is a more known CA system for algorithmic composition with
an innovative design using two bidimensional CA: Conway‚Äôs Game of Life (used to determine
musical sequences) and Griffeath‚Äôs Crystalline Growths (used to determine the instrumentation of the notes generated by the first CA). Each activated cell in the Game of Life was
mapped to a sequence of three notes, whose instrument was selected according to the corresponding cell in the second CA (the Crystalline Growths system). Unfortunately, according
to its own creator (Miranda, 2007), CAMUS did not produce very musical results: its out32. See, e.g., the description of the work by Coca et al. (2011) in Section 3.4.
33. For a more detailed survey, see e.g. the work of Burraston and Edmonds (2005).

557

Fern√°ndez & Vico

Reference

Composition task

Comments

Hoffmann, 2002

structure

reference to early use of CA in music (Xenakis‚Äôs Horos)

Beyls, 1989

melody

early use of CA in music

Millen, 1990

melody

early use of CA in music

Hunt et al., 1991

melody

early use of CA in music

Ariza, 2007

melody

dynamically changing CA rules

Miranda, 1993
(CAMUS)

melody,
instrumentation

two CA: one for the melody,
other for the instrumentation

McAlpine et al., 1999
(CAMUS 3D)

melody, rhythm,
instrumentation

same as above, plus Markov chains to select rhythm

Bilotta & Pantano, 2001

melody

explores several mappings from CA to music events

Dorin, 2002
(Liquiprism)

rhythmic patterns

several interacting CA

Ball, 2005, Miljkovic, 2007

melody, rhythm

references to WolframTones

Phon-Amnuaisuk, 2010

melody

uses ANNs to learn CA rules

Beyls, 2003

melody

interactive evolutionary algorithm

Bilotta & Pantano, 2002

melody

extends Bilotta and Pantano‚Äôs (2001) work
with an evolutionary algorithm

Lo, 2012

melody

evolutionary algorithm,
Markov chains used in the fitness function

Table 20: References for Section 3.6.1, in order of appearance.
put was more properly considered as raw material to be edited by hand. CAMUS was later
generalized, using a Markov chain to determine the note durations and three-dimensional
versions of the Game of Life and Crystalline Growths (McAlpine et al., 1999).
More recently, Bilotta and Pantano (2001) explored several different mappings to generate music from CA: local codes (mapping cells to pitches, the usual mapping in most
papers), global codes (mapping the entropy of the whole pattern in each generation to musical events) and mixed codes (mapping groups of cells to musical events). Dorin (2002) used
six bidimensional finite CA arranged in a cube (their edges connected), running at different speeds, to generate complex poly-rhythmic patterns.34 Finally, WolframTones35 (Ball,
2005) is a commercial application of CA to music composition, using a database of four
billions of transition rules for one-dimensional CA (all possible transition rules taking into
account five neighbors). WolframTones searches for rules that produce chaotic or complex
patterns. These patterns are mapped to musical events, and the system is able to search
for patterns whose musical mapping resembles one of a set of pre-defined musical styles
(Miljkovic, 2007).
Although CA are commonly used to generate musical material in a ‚Äúuncontrolled‚Äù way
(i.e., the composer tunes the parameters of the CA by hand), it is possible to use other
methods to design the CA (states, transition rules, etc.). For example, Phon-Amnuaisuk
34. In Section 3.4.2, similar work (Dorin, 2000) with Boolean networks (a connectionist paradigm usually
seen as a generalization of CA) was mentioned.
35. http://tones.wolfram.com/

558

AI Methods in Algorithmic Composition

(2010) used artificial neural networks trained to learn the transition rules of a CA: given
a melody, its piano-roll notation was interpreted as the temporal pattern of a CA, and the
network was trained to learn the transition rules for that temporal pattern. Then, given
other initial conditions, the network produced new compositions in piano-roll notation.
Evolutionary algorithms are also used to design the parameters (transition rules, states,
etc.) of CA. In some cases, previous work with hand-designed CA is adapted to use an
evolutionary algorithm. This is the case of Beyls (2003), who used an interactive evolutionary algorithm to evolve the parameters of a CA, and Bilotta and Pantano (2002), who
adapted their previously discussed work (Bilotta & Pantano, 2001) to use an evolutionary
algorithm, although the fitness function was poorly described. Lo (2012) applied evolutionary algorithms to generate CA for algorithmic composition in a more comprehensive way,
experimenting with various fitness functions based on extracting statistical models from a
corpus of pre-existing compositions, including metrics based on Markov models and Zipf‚Äôs
law.

4. Conclusions
In this survey, several hundreds of papers on algorithmic composition have been briefly reviewed. Obviously, none of them has been described in detail. Rather, this survey has been
intended as a short reference guide for the various methods commonly used for algorithmic
composition. As Pearce et al. (2002) noted, most papers on algorithmic composition do
not adequately (a) specify the precise practical or theoretical aims of research; (b) use a
methodology to achieve these aims; or (c) evaluate the results in a controlled, measurable
and repeatable way. Researchers of algorithmic composition have very diverse backgrounds,
and, in many cases, they do not present their work in a way that enables comparison with
others. Because of these considerations, we have presented the literature in a ‚Äúnarrative‚Äù
style, classifying the existing work in several broad categories, and providing brief descriptions of the papers in an approximately chronological order for each category.
4.1 About Creativity
Algorithmic composition automates (to varying degrees) the various tasks associated with
music composition, such as the generation of melodies or rhythms, harmonization, counterpoint and orchestration. These tasks can be applied in two ways: (a) to generate music
imitating a corpus of compositions or a specific style, and (b) to automate composition
tasks to varying degrees, from designing mere tools for human composers, to generating
compositions without human intervention:
Generating music imitating a corpus of compositions or a specific style. Most
instances of this kind of problem (including real-time improvisation systems that elaborate on input from human musicians) can be considered as solved: imitation problems
have been tackled with many different methods, in many cases with reasonable success
(such as Cope‚Äôs EMI, 1992, or Pachet‚Äôs Continuator, 2002). In fact, since the origins
of computational algorithmic composition, there has been a bias in the research community towards imitation problems (Nierhaus, 2009). This may be attributed to the
559

Fern√°ndez & Vico

difficulty to merge the mindset of computer science (clear-cut definitions, precise algorithms, straight methodologies) with the mindset of artistic work (intuition, vagueness,
cultural heritage and artistic influences). These two mindsets may be compared to
the once common cultural divide in Artificial Intelligence between neats and scruffies.
Unfortunately, while the neats reign supreme in Artificial Intelligence, they have yet
to gain the upper hand in Artificial Creativity.
Automating composition tasks to varying degrees. In the case of automated
systems for algorithmic composition intended to reproduce human creativity in some
way, there is the problem of evaluating their performance: the concept of artistic
creativity eludes a formal, unambiguous and effective definition. This makes it difficult
to evaluate these systems in a completely rigorous way. Certainly, many frameworks
have been proposed for assessing computational creativity36 , but not one can be easily
and uniformly applied to computers and humans alike, in a way that does not spark
controversy. It may seem simple to measure computational creativity against human
standards: we can simply ask people to listen to human and machine compositions,
and declare an algorithmic composition system as creative if these people cannot tell
apart its compositions from human ones. As Ariza (2009) noted, this kind of ‚Äúmusical
Turing Test‚Äù has been performed by many different researchers trying to validate their
systems, but they are valid if the algorithmic composition system just aspires to imitate,
not to be truly creative and create a truly innovative work of art.
There is also the view that systems for algorithmic composition cannot attain true creativity, even in principle. In fact, it has been suggested (Kugel, 1990) that no Turing-equivalent
formalism can truly simulate human creativity, i.e., musical creativity is not effectively computable, thus preventing computer systems from completely imitating human composers,
even in theory. This argument is not without merits, but it is open to debate, precisely
because it lacks a rigorous, unambiguous definition of creativity.
4.2 About the Methods
Regardless of these (more or less abstract) considerations about true creativity, this survey
has presented existing work on algorithmic composition, organized in several categories. As
described at the beginning of Section 3, these categories can be grouped in a few classes:
Symbolic AI (grammars and rule-based systems). Under this umbrella, we have
grouped very different techniques. These techniques can be used both for imitation (be
it the style of a specific composer, or more generally a musical style) and automation of
composition tasks. They have proved very effective, and they are very popular (at least,
by sheer volume of reviewed work), but in most cases, they are very labor-intensive,
because they require musical knowledge to be encoded and maintained in the symbolic
framework of choice. There has also been a clear trend towards more and more formal
systems, gradually moving from ad hoc rule systems to constraint satisfaction and other
various formalisms.
36. For example, Gero‚Äôs (2000), Pearce and Wiggins‚Äôs (2001), Ritchie‚Äôs (2007) and Boden‚Äôs (2009).

560

AI Methods in Algorithmic Composition

Machine learning (Markov chains and artificial neural networks). Because of
their nature, machine learning techniques are used primarily for imitation, although
both Markov chains (and related statistical methods) and artificial neural networks
can be also used to automate composition tasks (such as harmonization). It should be
noted that some techniques described here as symbolic AI are also machine learning
(like Cope‚Äôs ATNs, rule learning or case-based reasoning).
Optimization techniques (evolutionary algorithms). As in the case of machine
learning, optimization techniques (mostly evolutionary algorithms) have been profusely
used for imitation, since it is natural to express the objective of the optimization (the
fitness function) as the distance to the musical style to be imitated. However, the
automation of composition tasks has also been explored, more so than in the case of
machine learning techniques.
Self-similarity and cellular automata. Strictly speaking, these techniques are not a
form of AI. As explained at the beginning of Section 3, they just represent a convenient
way to generate novel musical material without resorting to human musical knowledge,
but the problem is that musical material generated in this way is very rough; it is most
commonly used by human composers as raw material to build upon.
After reviewing the literature, it becomes apparent that there is no silver bullet: except for
strict, limited imitation of specific musical styles or real-time improvisation systems that
elaborate on input from human musicians, almost all approaches to algorithmic composition
seem to be unable to produce content which can be deemed on a par with professional
human composers, even without taking into account the problem of creativity as discussed
in Section 4.1. Very few examples stand out, and then only in some niche applications, such
as the contemporary classical music composed by Iamus (Ball, 2012).
As there is no silver bullet, one obvious way forward is the hybridization of two or
more methods. In fact, from our review of the existing work, it seems apparent that many
researchers are already following this route, but there are some hybridizations that have
rarely been explored. For example, the music material produced by systems based on
self-similarity and CA is commonly regarded as a mere source of inspiration for human
composers, rather than as a proper way to automate the composition of music, because
this music material generally lacks structure. However, it can be used as the first stage
in a process of algorithmic composition, to be modified and refined by subsequent stages,
probably based on some form of machine learning if the goal is to produce music in a specific
musical style, or some knowledge-based system (such as Leach and Fitch‚Äôs XComposer,
1995). In the case of evolutionary algorithms, self-similarity systems may be used to seed
the initial population, or to introduce variety to avoid premature convergence, and CA may
be used as individuals to be evolved (such as in the work of Lo, 2012, which also features
machine learning techniques). More research is required to explore the potential of this
kind of approach, combining self-similarity and CA-based systems with other methods.
In the case of optimization techniques, the multi-objective paradigm has rarely been
used, at least in comparison with the traditional single-objective approach. Composing
music usually requires balancing a set of many different, sometimes conflicting objectives,
to configure the various aspects of the music, so multi-objective optimization seems a natural
561

Fern√°ndez & Vico

way to tackle this problem. All too often, researchers use a weighted sum of parameters
to conflate all these objectives into a single fitness function. Very few researchers use
multi-objective optimization, as do Geis and Middendorf (2008), Carpentier and Bresson
(2010), De Prisco et al. (2010), and Freitas and Guimar√£es (2011). While multi-objective
optimization is harder (both conceptually and in practice), it represents a natural way of
dealing with the complexity of having many different objectives, and it should be explored
more by the research community.
Finally, in the specific case of evolutionary algorithms, the issue of encoding the individuals should also be examined. Looking at algorithmic composition as an optimization
problem, search spaces for musical compositions tend to be huge and high-dimensional.
Direct encodings (such as directly representing music as a sequence of pitches) make it
very difficult to explore the search space in an effective way, with problems of scalability
(the performance degrades significantly as the size of the problem increases) and solution
structure (the solutions generated by the algorithm tend to be unstructured, hard to adapt
and fragile). This problem is mitigated by indirect encodings, in which the genotype does
not directly represent the phenotype, but rather a ‚Äúlist of instructions‚Äù to build it. Many
different types of indirect encoding have been used in algorithmic composition, such as
L-systems, other types of grammars, or the various encoding styles used in genetic programming. However, other advanced techniques for indirect encoding have rarely been
applied to algorithmic composition, in order to overcome the aforementioned problems of
scalability and solution structure, such as those related to artificial embryogenies (Stanley
& Miikkulainen, 2003), which have been inspired by biological developmental processes.
Adding these to the evolutionary toolkit may be a way to enable more and more complex
compositional tasks to be tackled.
4.3 Final Thoughts
Computers have come to stay: the use of CAAC software is prevalent among many composers, and some artistic scenes (as generative music) embrace computer-generated music as
part of their identity. However, creativity is still in the hands of composers for the most part.
As argued in Section 4.1, creativity is an inherently subjective concept, and it is arguably
debatable the point at which a computational system may become truly creative. However,
even if a precise definition cannot be agreed upon, it is easy to see that the development
of algorithmic composition systems capable of independent creativity will radically change
the process of music composition, and consequently the market for music. This should not
be seen as yet another case of computers replacing humans in an ever more sophisticated
activity, but a potentially radical disruption in the way composers perform their work: just
like a pedagogical expert system does not supersedes the role of human teachers, but enable
new ways to do their work.
Being music one of the arts with a stronger mathematical background, it is not surprising
that most of the debate on whether machines can make original and creative works has
centered in this subfield of computational creativity. Hybridization of different techniques,
bioinspiration, and the use of high performance computing might bring about new realms
of (computer-) creativity. As science writer Philip Ball put it in his analysis of Melomics‚Äô
562

AI Methods in Algorithmic Composition

music composition technology: ‚Äú. . . unfolding complex structure from a mutable core has
enabled the kind of dramatic invention found in biological evolution‚Äù (Ball, 2012).

Acknowledgments
The authors wish to thank Ilias Bergstrom for his comments on a preliminary version of the
manuscript. Also, the critical review of our anonymous referees has greatly improved the
final version. This study was partially supported by a grant for the MELOMICS project
(IPT-300000-2010-010) from the Spanish Ministerio de Ciencia e Innovaci√≥n, and a grant for
the CAUCE project (TSI-090302-2011-8) from the Spanish Ministerio de Industria, Turismo
y Comercio. The first author was supported by a grant for the GENEX project (P09-TIC5123) from the Consejer√≠a de Innovaci√≥n y Ciencia de Andaluc√≠a. The first author also
wishes to thank his wife Elisa and his daughter Isabel for being there day after day, in spite
of the long hours spent writing this manuscript, and his family for the invaluable support
they have provided.

References
Adiloglu, K., & Alpaslan, F. N. (2007). A machine learning approach to two-voice counterpoint composition. Knowledge-Based Systems, 20 (3), 300‚Äì309.
Aguilera, G., Gal√°n, J. L., Madrid, R., Mart√≠nez, A. M., Padilla, Y., & Rodr√≠guez, P. (2010).
Automated generation of contrapuntal musical compositions using probabilistic logic
in Derive. Mathematics and Computers in Simulation, 80 (6), 1200‚Äì1211.
Alfonseca, M., Cebri√°n, M., & Ortega, A. (2005). Evolving computer-generated music
by means of the normalized compression distance. In Proceedings of the WSEAS
International Conference on Simulation, Modelling and Optimization, pp. 343‚Äì348,
Stevens Point, Wisconsin, USA.
Allan, M. (2002). Harmonising chorales in the style of Johann Sebastian Bach. Master‚Äôs
thesis, University of Edinburgh.
Allombert, A., Assayag, G., Desainte-Catherine, M., & Rueda, C. (2006). Concurrent constraints models for interactive scores. In Proceedings of the Sound and Music Computing Conference.
Ames, C. (1987). Automated composition in retrospect: 1956-1986. Leonardo, 20 (2), 169‚Äì
185.
Ames, C. (1989). The Markov process as a compositional model: A survey and tutorial.
Leonardo, 22 (2), 175‚Äì187.
Ames, C., & Domino, M. (1992). Understanding music with AI, chap. Cybernetic composer:
an overview, pp. 186‚Äì205. The MIT Press, Cambridge.
Amiot, E., Noll, T., Agon, C., & Andreatta, M. (2006). Fourier oracles for computer-aided
improvisation. In Proceedings of the International Computer Music Conference.
Anders, T. (2007). Composing Music by Composing Rules: Design and Usage of a Generic
Music Constraint System. Ph.D. thesis, Queen‚Äôs University Belfast.
563

Fern√°ndez & Vico

Anders, T., & Miranda, E. R. (2009). A computational model that generalises Schoenberg‚Äôs
guidelines for favourable chord progressions. In Proceedings of the Sound and Music
Computing Conference.
Anders, T., & Miranda, E. R. (2011). Constraint programming systems for modeling music
theories and composition. ACM Computing Surveys, 43 (4), 30:1‚Äì30:38.
Ando, D., & Iba, H. (2007). Interactive composition aid system by means of tree representation of musical phrase. In Proceedings of the IEEE Conference on Evolutionary
Computation, pp. 4258‚Äì4265.
Ariza, C. (2005a). Navigating the landscape of computer aided algorithmic composition
systems: A definition, seven descriptors, and a lexicon of systems and research. In
Proceedings of the International Computer Music Conference.
Ariza, C. (2005b). An Open Design for Computer-Aided Algorithmic Music Composition:
athenaCL. Ph.D. thesis, New York University.
Ariza, C. (2006). Beyond the transition matrix: A language-independent, string-based input
notation for incomplete, multiple-order, static Markov transition values. Unpublished
manuscript.
Ariza, C. (2007). Automata bending: Applications of dynamic mutation and dynamic rules
in modular One-Dimensional cellular automata. Computer Music Journal, 31 (1),
29‚Äì49.
Ariza, C. (2009). The interrogator as critic: The Turing test and the evaluation of generative
music systems. Computer Music Journal, 33 (2), 48‚Äì70.
Ariza, C. (2011). Two pioneering projects from the early history of computer-aided algorithmic composition. Computer Music Journal, 35 (3), 40‚Äì56.
Aschauer, D. (2008). Algorithmic composition. Master‚Äôs thesis, Vienna University of Technology.
Assayag, G., & Dubnov, S. (2004). Using factor oracles for machine improvisation. Soft
Computing - A Fusion of Foundations, Methodologies and Applications, 8 (9), 604‚Äì610.
Assayag, G., Rueda, C., Laurson, M., Agon, C., & Delerue, O. (1999). Computer-Assisted
composition at IRCAM: From PatchWork to OpenMusic. Computer Music Journal,
23 (3), 59‚Äì72.
Baeten, J. C. M. (2005). A brief history of process algebra. Theoretical Computer Science,
335 (2‚Äì3), 131‚Äì146.
Baggi, D. L. (1991). Neurswing: an intelligent workbench for the investigation of swing in
jazz. Computer, 24 (7), 60‚Äì64.
Balaban, M., Ebcioƒülu, K., & Laske, O. E. (1992). Understanding music with AI : perspectives on music cognition. The MIT Press, Cambridge.
Ball, P. (2005). Making music by numbers online. Nature News Online
(http://dx.doi.org/10.1038/050919-14).
Ball, P. (2012). Computer science: Algorithmic rapture. Nature, 488 (7412), 458.
564

AI Methods in Algorithmic Composition

Baroni, M., & Jacoboni, C. (1978). Proposal for a grammar of melody : The Bach chorales.
Les Presses de l‚ÄôUniversit√© de Montr√©al.
Bel, B. (1992). Modelling improvisatory and compositional processes. Languages of Design,
Formalisms for Word, Image and Sound, 1, 11‚Äì26.
Bellgard, M. I., & Tsang, C. P. (1992). Harmonizing music using a network of Boltzmann
machines. In Proceedings of the Annual Conference of Artificial Neural Networks and
their Applications, pp. 321‚Äì332, France.
Berg, P. (2011). Using the AC Toolbox. Institute of Sonology, Royal Conservatory, The
Hague.
Beyls, P. (1989). The musical universe of cellular automata. In Proceedings of the International Computer Music Conference, pp. 34‚Äì41.
Beyls, P. (2003). Selectionist musical automata: Integrating explicit instruction and evolutionary algorithms. In Proceedings of the Brazilian Symposium on Computer Music.
Beyls, P. (2007). Interaction and self-organisation in a society of musical agents. In Proceedings of the European Conference on Artificial Life.
Bidlack, R. (1992). Chaotic systems as simple (but complex) compositional algorithms.
Computer Music Journal, 16 (3), 33‚Äì47.
Biles, J. A. (1994). GenJam: A genetic algorithm for generating jazz solos. In Proceedings
of the International Computer Music Conference.
Biles, J. A. (1998). Interactive GenJam: Integrating real-time performance with a genetic
algorithm. In Proceedings of the International Computer Music Conference.
Biles, J. A., Anderson, P., & Loggi, L. (1996). Neural network fitness functions for a
musical IGA. In Proceedings of the International Symposium on Intelligent Industrial
Automation and Soft Computing.
Bilotta, E., & Pantano, P. (2001). Artificial life music tells of complexity. In Proceedings of
the European Conference on Artificial Life.
Bilotta, E., & Pantano, P. (2002). Synthetic harmonies: An approach to musical semiosis
by means of cellular automata. Leonardo, 35 (2), 153‚Äì159.
Birchfield, D. A. (2003). Evolving intelligent musical materials. Ph.D. thesis, Columbia
University, New York.
Biyikoglu, K. M. (2003). A Markov model for chorale harmonization. In Proceedings of the
Triennial ESCOM Conference.
Blackwell, T. M., & Bentley, P. (2002). Improvised music with swarms. In Proceedings of
the IEEE Conference on Evolutionary Computation, pp. 1462‚Äì1467.
Boden, M. A. (2009). Computer models of creativity. AI Magazine, 30 (3), 23‚Äì34.
Boenn, G., Brain, M., De Vos, M., & Fitch, J. (2008). Automatic composition of melodic
and harmonic music by Answer Set Programming. In Proceedings of the International
Conference on Logic Programming, pp. 160‚Äì174.
Bolognesi, T. (1983). Automatic composition: Experiments with self-similar music. Computer Music Journal, 7 (1), 25‚Äì36.
565

Fern√°ndez & Vico

Bosma, M. (2005). Musicology in a virtual world: A bottom up approach to the study of
musical evolution. Master‚Äôs thesis, University of Groningen and University of Plymouth.
Boulanger, R. C. (Ed.). (2000). The Csound Book: Perspectives in Software Synthesis,
Sound Design, Signal Processing, and Programming. The MIT Press.
Bown, O., & McCormack, J. (2010). Taming nature: tapping the creative potential of
ecosystem models in the arts. Digital Creativity, 21 (4), 215‚Äì231.
Bown, O., & Wiggins, G. A. (2005). Modelling musical behaviour in a cultural-evolutionary
system. In Proceedings of the International Joint Conference on Artificial Inteligence.
Brooks, F. P., Hopkins, A. L., Neumann, P. G., & Wright, W. V. (1957). An experiment in
musical composition. IRE Transactions on Electronic Computers, EC-6 (3), 175‚Äì182.
Browne, T. M., & Fox, C. (2009). Global Expectation-Violation as fitness function in evolutionary composition. In Proceedings of the Conference on Applications of Evolutionary
Computation, pp. 538‚Äì546.
Bryden, K. (2006). Using a Human-in-the-Loop evolutionary algorithm to create DataDriven music. In Proceedings of the IEEE Conference on Evolutionary Computation,
pp. 2065‚Äì2071.
Bulley, J., & Jones, D. (2011). Variable 4: A dynamical composition for weather systems.
In Proceedings of the International Computer Music Conference.
Burns, K. (1994). The History and Development of Algorithms in Music Composition,
1957-1993. Ph.D. thesis, Ball State University.
Burraston, D., & Edmonds, E. (2005). Cellular automata in generative electronic music
and sonic art: a historical and technical review. Digital Creativity, 16 (3), 165‚Äì185.
Burton, A. R. (1998). A Hybrid Neuro-Genetic Pattern Evolution System Applied to Musical
Composition. Ph.D. thesis, University of Surrey.
Burton, A. R., & Vladimirova, T. (1999). Generation of musical sequences with genetic
techniques. Computer Music Journal, 23 (4), 59‚Äì73.
Buttram, T. (2003). DirectX 9 Audio Exposed: Interactive Audio Development, chap. Beyond Games: Bringing DirectMusic into the Living Room. Wordware Publishing Inc.
Carpentier, G., & Bresson, J. (2010). Interacting with symbol, sound, and feature spaces
in orchid√©e, a computer-aided orchestration environment. Computer Music Journal,
34 (1), 10‚Äì27.
Chemillier, M. (2004). Toward a formal study of jazz chord sequences generated by Steedman‚Äôs grammar. Soft Computing - A Fusion of Foundations, Methodologies and Applications, 8 (9), 617‚Äì622.
Chemillier, M., & Truchet, C. (2001). Two musical CSPs. In Proceedings of the International
Conference on Principles and Practice of Constraint Programming.
Chen, C. C. J., & Miikkulainen, R. (2001). Creating melodies with evolving recurrent neural
networks. In Proceedings of the International Joint Conference on Neural Networks,
pp. 2241‚Äì2246.
566

AI Methods in Algorithmic Composition

Chusid, I. (1999). Beethoven-in-a-box: Raymond scott‚Äôs electronium. Contemporary Music
Review, 18 (3), 9‚Äì14.
Coca, A. E., Romero, R. A. F., & Zhao, L. (2011). Generation of composed musical structures through recurrent neural networks based on chaotic inspiration. In Proceedings
of the International Joint Conference on Neural Networks, pp. 3220‚Äì3226.
Coghlan, A. (2012).
215 (2872), 7.

Computer composer honours Turing‚Äôs centenary.

New Scientist,

Cohen, J. E. (1962). Information theory and music. Behavioral Science, 7 (2), 137‚Äì163.
Collins, N. (2009). Musical form and algorithmic composition. Contemporary Music Review,
28 (1), 103‚Äì114.
Conklin, D. (2003). Music generation from statistical models. In Proceedings of the Symposium on Artificial Intelligence and Creativity in Arts and Science.
Conklin, D., & Witten, I. (1995). Multiple viewpoint systems for music prediction. Journal
of New Music Research, 24 (1), 51‚Äì73.
Cope, D. (1992). Computer modeling of musical intelligence in EMI. Computer Music
Journal, 16 (2), 69‚Äì83.
Cope, D. (2000). The Algorithmic Composer. A-R Editions.
Cope, D. (2005). Computer Models of Musical Creativity. The MIT Press, Cambridge.
Courtot, F. (1990). A constraint-based logic program for generating polyphonies. In Proceedings of the International Computer Music Conference, pp. 292‚Äì294.
Cruz-Alc√°zar, P. P., & Vidal-Ruiz, E. (1998). Learning regular grammars to model musical style: Comparing different coding schemes. In Proceedings of the International
Colloquium on Grammatical Inference, pp. 211‚Äì222.
Dahlstedt, P. (2007). Autonomous evolution of complete piano pieces and performances. In
Proceedings of the European Conference on Artificial Life.
Dahlstedt, P., & Nordahl, M. G. (2001). Living melodies: Coevolution of sonic communication. Leonardo, 34 (3), 243‚Äì248.
Dalhoum, A. A., Alfonseca, M., Cebri√°n, M., S√°nchez-Alfonso, R., & Ortega, A. (2008).
Computer-generated music using grammatical evolution. In Proceedings of the MiddleEast Simulation Multiconference, pp. 55‚Äì60.
Davismoon, S., & Eccles, J. (2010). Combining musical constraints with Markov transition
probabilities to improve the generation of creative musical structures. In Proceedings
of the European Conference on the Applications of Evolutionary Computation.
De Prisco, R., Zaccagnino, G., & Zaccagnino, R. (2010). EvoBassComposer: a multiobjective genetic algorithm for 4-voice compositions. In Proceedings of the Genetic
and Evolutionary Computation Conference.
Degazio, B. (1996). The evolution of musical organisms. Leonardo Music Journal, 7, 27‚Äì33.
D√≠az-Jerez, G. (2000). Algorithmic Music Using Mathematical Models. Ph.D. thesis, Manhattan School of Music.
567

Fern√°ndez & Vico

D√≠az-Jerez, G. (2011). Composing with Melomics: Delving into the computational world
for musical inspiration. Leonardo Music Journal, 21, 13‚Äì14.
Dobrian, C. (1993). Music and artificial intelligence. Unpublished manuscript. Available at
http://music.arts.uci.edu/dobrian/CD.music.ai.htm.
Doornbusch, P. (2002). A brief survey of mapping in algorithmic composition. In Proceedings
of the International Computer Music Conference.
Dorin, A. (2000). Boolean networks for the generation of rhythmic structure. In Proceedings
of the Australasian Computer Music Conference, pp. 38‚Äì45.
Dorin, A. (2002). Liquiprism : Generating polyrhythms with cellular automata. In Proceedings of the International Conference on Auditory Display.
Drewes, F., & H√∂gberg, J. (2007). An algebra for tree-based music generation. In Proceedings
of the International Conference on Algebraic Informatics, pp. 172‚Äì188.
Dubnov, S., Assayag, G., Lartillot, O., & Bejerano, G. (2003). Using machine-learning
methods for musical style modeling. Computer, 36 (10), 73‚Äì80.
DuBois, R. L. (2003). Applications of Generative String-Substitution Systems in Computer
Music. Ph.D. thesis, Columbia University.
Duff, M. O. (1989). Backpropagation and Bach‚Äôs 5th cello suite (Sarabande). In Proceedings
of the International Joint Conference on Neural Networks, p. 575.
Ebcioƒülu, K. (1980). Computer counterpoint. In Proceedings of the International Computer
Music Conference.
Ebcioƒülu, K. (1988). An expert system for harmonizing four-part chorales. Computer Music
Journal, 12 (3), 43‚Äì51.
Edwards, M. (2011). Algorithmic composition: computational thinking in music. Communications of the ACM, 54 (7), 58‚Äì67.
Eigenfeldt, A., & Pasquier, P. (2010). Realtime generation of harmonic progressions using controlled Markov selection. In Proceedings of the International Conference on
Computational Creativity.
Eldridge, A., & Dorin, A. (2009). Filterscape: Energy recycling in a creative ecosystem. In
Proceedings of the Conference on Applications of Evolutionary Computation.
Eno, B. (1996). Generative Music, speech at the Imagination Conference. Available at
http://www.inmotionmagazine.com/eno1.html.
Esp√≠, D., Ponce de Le√≥n, P. J., P√©rez-Sancho, C., Rizo, D., nesta, J. I., Moreno-Seco, F., &
Pertusa, A. (2007). A cooperative approach to style-oriented music composition. In
Proceedings of the International Joint Conference on Artificial Inteligence.
Farbood, M., & Schoner, B. (2001). Analysis and synthesis of Palestrina-style counterpoint
using Markov chains. In Proceedings of the International Computer Music Conference.
Farnell, A. (2007). An introduction to procedural audio and itsapplication in computer
games. In Proceedings of the Audio Mostly Conference.
Farrell, S., Jan Wagenmakers, E., & Ratcliff, R. (2006). 1/f noise in human cognition: Is it
ubiquitous, and what does it mean?. Psychonomic Bulletin & Review, 13 (4), 737‚Äì741.
568

AI Methods in Algorithmic Composition

Feulner, J., & H√∂rnel, D. (1994). MELONET: neural networks that learn harmony-based
melodic variations. In Proceedings of the International Computer Music Conference,
pp. 121‚Äì124, San Francisco.
Fox, C. W. (2006). Genetic hierarchical music structures. In Proceedings of the International
Florida Artificial Research Society Conference.
Franklin, J. (2001). Multi-phase learning for jazz improvisation and interaction. In Proceedings of the Biennial Symposium on Arts and Technology.
Freitas, A., & Guimar√£es, F. (2011). Melody harmonization in evolutionary music using
multiobjective genetic algorithms. In Proceedings of the Sound and Music Computing
Conference.
Fry, C. (1984). Flavors band: A language for specifying musical style. Computer Music
Journal, 8 (4), 20‚Äì34.
Garay Acevedo, A. (2004). Fugue composition with counterpoint melody generation using
genetic algorithms. In Proceedings of the International Conference on Computer Music
Modeling and Retrieval, pp. 96‚Äì106.
Gartland-Jones, A. (2002). Can a genetic algorithm think like a composer?. In Proceedings
of the Generative Art Conference.
Geem, Z. W., & Choi, J. Y. (2007). Music composition using harmony search algorithm.
In Proceedings of the Conference on Applications of Evolutionary Computation, pp.
593‚Äì600.
Geis, M., & Middendorf, M. (2008). Creating melodies and baroque harmonies with ant
colony optimization. International Journal of Intelligent Computing and Cybernetics,
1 (2), 213‚Äì218.
Gero, J. S. (2000). Computational models of innovative and creative design processes.
Technological Forecasting and Social Change, 64 (2‚Äì3), 183‚Äì196.
Gibson, P. M., & Byrne, J. A. (1991). NEUROGEN, musical composition using genetic
algorithms and cooperating neural networks. In Proceedings of the International Conference on Artificial Neural Networks, pp. 309‚Äì313.
Gill, S. (1963). A technique for the composition of music in a computer. The Computer
Journal, 6 (2), 129‚Äì133.
Gillick, J., Tang, K., & Keller, R. M. (2009). Learning jazz grammars. In Proceedings of
the Sound and Music Computing Conference, pp. 125‚Äì130.
Gjerdingen, R. (1988). Explorations in Music, the Arts, and Ideas: Essays in Honor of
Leonard B. Meyer, chap. Concrete musical knowledge and a computer program for
species counterpoint, pp. 199‚Äì228. Pendragon Press.
Gogins, M. (1991). Iterated functions systems music. Computer Music Journal, 15 (1),
40‚Äì48.
Gogins, M. (2006). Score generation in voice-leading and chord spaces. In Proceedings of
the International Computer Music Conference.
569

Fern√°ndez & Vico

Goldman, C., Gang, D., Rosenschein, J., & Lehmann, D. (1996). NETNEG: a hybrid
interactive architecture for composing polyphonic music in real time. In Proceedings
of the International Computer Music Conference, pp. 133‚Äì140.
Grachten, M. (2001). JIG : jazz improvisation generator. In Proceedings of the Workshop on
Current Research Directions in Computer Music, pp. 1‚Äì6. Audiovisual Institute-UPF.
Gwee, N. (2002). Complexity and Heuristics in Rule-Based Algorithmic Music Composition.
Ph.D. thesis, Louisiana State University.
Hamanaka, M., Hirata, K., & Tojo, S. (2008). Melody morphing method based on GTTM.
In Proceedings of the International Computer Music Conference, pp. 155‚Äì158.
Harris, R. (2008). Algorithmic composition of jazz. Master‚Äôs thesis, University of Bath.
Hartmann, P. (1990). Natural selection of musical identities. In Proceedings of the International Computer Music Conference.
Haus, G., & Sametti, A. (1991). Scoresynth: a system for the synthesis of music scores
based on Petri nets and a music algebra. IEEE Computer, 24 (7), 56‚Äì60.
Herman, M. (1993). Deterministic chaos, iterative models, dynamical systems and their
application in algorithmic composition. In Proceedings of the International Computer
Music Conference.
Herremans, D., & Sorensena, K. (2012). Composing first species counterpoint with a variable
neighbourhood search algorithm. Journal of Mathematics and the Arts, 6 (4), 169‚Äì189.
Hild, H., Feulner, J., & Menzel, D. (1992). HARMONET: a neural net for harmonising
chorales in the style of J.S. Bach. In Proceedings of the Conference on Neural Information Processing Systems.
Hiller, L. A., & Isaacson, L. M. (1958). Musical composition with a High-Speed digital
computer. Journal of the Audio Engineering Society, 6 (3), 154‚Äì160.
Hinojosa-Chapel, R. (2003). Realtime algorithmic music systems from fractals and chaotic
functions: Toward an active musical instrument. Master‚Äôs thesis, Universitat Pompeu
Fabra.
Hirata, K., & Aoyagi, T. (1988). How to realize jazz feelings: a logic programming approach. In Proceedings of the International Conference on Fifth Generation Computer
Systems.
Hoffmann, P. (2002). Towards an "automated art": Algorithmic processes in xenakis‚Äô compositions. Contemporary Music Review, 21 (2-3), 121‚Äì131.
Holm, F. (1990). CESAM: A concept engine for synthesis of audio and music. In Proceedings
of the International Computer Music Conference.
Holtzman, S. R. (1981). Using generative grammars for music composition. Computer
Music Journal, 5 (1), 51‚Äì64.
Hoover, A. K., Szerlip, P. A., Norton, M. E., Brindle, T. A., Merritt, Z., & Stanley, K. O.
(2012). Generating a complete multipart musical composition from a single monophonic melody with functional scaffolding. In Proceedings of the International Conference on Computational Creativity.
570

AI Methods in Algorithmic Composition

H√∂rnel, D., & Degenhardt, P. (1997). A neural organist improvising baroque-style melodic
variations. In Proceedings of the International Computer Music Conference, pp. 430‚Äì
433.
H√∂rnel, D., & Ragg, T. (1996). A connectionist model for the evolution of styles of harmonization. In Proceedings of the International Conference on Music Perception and
Cognition.
Horner, A., & Ayers, L. (1995). Harmonization of musical progressions with genetic algorithms. In Proceedings of the International Computer Music Conference.
Horner, A., & Goldberg, D. E. (1991). Genetic algorithms and computer-assisted music
composition. In Proceedings of the International Conference on Genetic Algorithms,
pp. 337‚Äì441.
Horowitz, M. D. (1994). Generating rhythms with genetic algorithms. In Proceedings of the
AAAI National Conference on Artificial intelligence, Menlo Park.
Horowitz, M. D. (1995). Representing musical knowledge. Ph.D. thesis, Columbia University.
Hs√º, K. J., & Hs√º, A. (1991). Self-similarity of the "1/f noise" called music. Proceedings of
the National Academy of Sciences of the United States of America, 88 (8), 3507‚Äì3509.
Hunt, A., Kirk, R., & Orton, R. (1991). Musical applications of a cellular automata workstation. In Proceedings of the International Computer Music Conference.
Jacob, B. L. (1995). Composing with genetic algorithms. In Proceedings of the International
Computer Music Conference.
Jensen, J. H. (2011). Evolutionary music composition: A quantitative approach. Master‚Äôs
thesis, Norwegian University of Science and Technology.
Johanson, B., & Poli, R. (1998). GP-music: An interactice genetic programming system
for music generation with automated fitness raters. In Proceedings of the Annual
Conference on Genetic Programming, pp. 181‚Äì186.
Johnson, M., Tauritz, D. R., & Wilkerson, R. (2004). Evolutionary computation applied to
melody generation. In Proceedings of the Artificial Neural Networks in Engineering
(ANNIE) Conference.
Jones, K. (1980). A space grammar for the stochastic generation of Multi-Dimensional
structures. In Proceedings of the International Computer Music Conference.
Jones, K. (1981). Compositional applications of stochastic processes. Computer Music
Journal, 5 (2), 45‚Äì61.
Jones, K. (1989). Generative models in computer-assisted musical composition. Contemporary Music Review, 3 (1), 177‚Äì196.
Kaliakatsos-Papakostas, M. A., Epitropakis, M. G., Floros, A., & Vrahatis, M. N. (2012).
Interactive evolution of 8-Bit melodies with genetic programming towards finding aesthetic measures for sound evolutionary and biologically inspired music, sound, art and
design. In Proceedings of the International Conference on Evolutionary and Biologically Inspired Music, Sound, Art and Design, pp. 141‚Äì152.
571

Fern√°ndez & Vico

Keller, R. M., & Morrison, D. R. (2007). A grammatical approach to automatic improvisation. In Proceedings of the Sound and Music Computing Conference, pp. 330‚Äì337.
Khalifa, Y. M. A., Khan, B. K., Begovic, J., Wisdom, A., & Wheeler, A. M. (2007). Evolutionary music composer integrating formal grammar. In Proceedings of the Genetic
and Evolutionary Computation Conference, pp. 2519‚Äì2526, New York.
Kippen, J., & Bel, B. (1989). The identification and modelling of a percussion language,
and the emergence of musical concepts in a machine-learning experimental set-up.
Computers and the Humanities, 23 (3), 199‚Äì214.
Kirke, A., & Miranda, E. (2009). A survey of computer systems for expressive music
performance. ACM Computing Surveys, 42 (1), 3:1‚Äì3:41.
Kitani, K. M., & Koike, H. (2010). ImprovGenerator: Online grammatical induction for onthe-fly improvisation accompaniment. In Proceedings of the International Conference
on New Interfaces for Musical Expression.
Klinger, R., & Rudolph, G. (2006). Evolutionary composition of music with learned melody
evaluation. In Proceedings of the WSEAS International Conference on Computational
Intelligence, Man-Machine Systems and Cybernetics, pp. 234‚Äì239, Stevens Point, Wisconsin, USA.
Kohonen, T., Laine, P., Tiits, K., & Torkkola, K. (1991). Music and Connectionism, chap.
A Nonheuristic Automatic Composing Method, pp. 229‚Äì242. The MIT Press, Cambridge.
Kugel, P. (1990). Myhill‚Äôs Thesis: There‚Äôs more than computing in musical thinking. Computer Music Journal, 14 (3), 12‚Äì25.
Laine, P. (2000). A Method for Generating Musical Motion Patterns. Ph.D. thesis, University of Helsinki.
Laine, P., & Kuuskankare, M. (1994). Genetic algorithms in musical style oriented generation. In Proceedings of the IEEE Conference on Evolutionary Computation, pp.
858‚Äì862.
Langston, P. (1989). Six techniques for algorithmic music composition. In Proceedings of
the International Computer Music Conference.
Laurson, M., & Kuuskankare, M. (2000). Towards idiomatic instrumental writing: A constraint based approach. In Proceedings of the Annual Symposium on Systems Research
in the Arts.
Leach, J., & Fitch, J. (1995). Nature, music, and algorithmic composition. Computer Music
Journal, 19 (2), 23‚Äì33.
Lerdahl, F., Jackendoff, R., & Jackendoff, R. S. (1983). A Generative Theory of Tonal
Music. The MIT Press, Cambridge.
Levitt, D. A. (1981). A melody description system for jazz improvisation. Master‚Äôs thesis,
Massachusetts Institute of Technology.
Lewis, J. P. (1991). Music and Connectionism, chap. Creation by refinement and the problem of algorithmic music composition. The MIT Press, Cambridge.
572

AI Methods in Algorithmic Composition

Lidov, D., & Gabura, J. (1973). A melody writing algorithm using a formal language model.
Computer Studies in the Humanities and Verbal Behavior, 4 (3‚Äì4), 138‚Äì148.
Lo, M. Y. (2012). Evolving Cellular Automata for Music Composition with Trainable Fitness
Functions. Ph.D. thesis, University of Essex.
Lo, M., & Lucas, S. M. (2006). Evolving musical sequences with N-Gram based trainable fitness functions. In Proceedings of the IEEE Conference on Evolutionary Computation,
pp. 601‚Äì608.
L√∂the, M. (1999). Knowledge based automatic composition and variation of melodies for
minuets in early classical style. In Proceedings of the Annual German Conference on
Artificial Intelligence, pp. 159‚Äì170.
Loy, G., & Abbott, C. (1985). Programming languages for computer music synthesis, performance, and composition. ACM Computing Surveys, 17 (2), 235‚Äì265.
Lozano, L., Medaglia, A. L., & Velasco, N. (2009). Generation of Pop-Rock chord sequences
using genetic algorithms and variable neighborhood search. In Proceedings of the
Conference on Applications of Evolutionary Computation, pp. 573‚Äì578.
Lyon, D. (1995). Using stochastic Petri nets for real-time Nth-order stochastic composition.
Computer Music Journal, 19 (4), 13‚Äì22.
MacCallum, R. M., Mauch, M., Burt, A., & Leroi, A. M. (2012). Evolution of music by
public choice. Proceedings of the National Academy of Sciences of the United States
of America, 109 (30), 12081‚Äì12086.
Maddox, T., & Otten, J. (2000). Using an evolutionary algorithm to generate Four-Part
18th century harmony. In Proceedings of the WSEAS International Conference on
Mathematics and Computers in Business and Economics.
Manaris, B., Hughes, D., & Vassilandonakis, Y. (2011). Monterey mirror: Combining
Markov models, genetic algorithms, and power laws. In Proceedings of the IEEE
Conference on Evolutionary Computation.
Manaris, B., Roos, P., Machado, P., Krehbiel, D., Pellicoro, L., & Romero, J. (2007). A
corpus-based hybrid approach to music analysis and composition. In Proceedings of
the AAAI National Conference on Artificial intelligence, pp. 839‚Äì845.
Manousakis, S. (2006). Musical L-Systems. Master‚Äôs thesis, The Royal Conservatory, The
Hague.
Marques, V. M., Oliveira, V., Vieira, S., & Rosa, A. C. (2000). Music composition using genetic evolutionary algorithms. In Proceedings of the IEEE Conference on Evolutionary
Computation, pp. 714‚Äì719.
Marques, V. M., Reis, C., & Machado, J. A. T. (2010). Interactive evolutionary computation
in music. In Proceedings of the IEEE International Conference on Systems, Man and
Cybernetics, pp. 3501‚Äì3507.
Martin, A., Jin, C. T., & Bown, O. (2012). Implementation of a real-time musical decisionmaker. In Proceedings of the Australasian Computer Music Conference.
573

Fern√°ndez & Vico

Martin, A., Jin, C. T., van Schaik, A., & Martens, W. L. (2010). Partially observable Markov
decision processes for interactive music systems. In Proceedings of the International
Computer Music Conference.
Mason, S., & Saffle, M. (1994). L-Systems, melodies and musical structure. Leonardo Music
Journal, 4, 31‚Äì38.
Maurer, J. (1999). A brief history of algorithmic composition. Unpublished manuscript.
Available at https://ccrma.stanford.edu/~blackrse/algorithm.html.
McAlpine, K., Miranda, E., & Hoggar, S. (1999). Making music with algorithms: A CaseStudy system. Computer Music Journal, 23 (2), 19‚Äì30.
McCartney, J. (2002). Rethinking the computer music language: SuperCollider. Computer
Music Journal, 26 (4), 61‚Äì68.
McCormack, J. (1996). Grammar-Based music composition. Complexity International, 3,
320‚Äì336.
McCormack, J. (2003a). The Application of L-systems and Developmental Models to Computer Art, Animation and Music Synthesis. Ph.D. thesis, Monash University.
McCormack, J. (2003b). Evolving sonic ecosystems. Kybernetes, 32 (1‚Äì2), 184‚Äì202.
McDermott, J., & O‚ÄôReilly, U. M. (2011). An executable graph representation for evolutionary generative music. In Proceedings of the Genetic and Evolutionary Computation
Conference, pp. 403‚Äì410, New York.
McGuire, K. (2006). ArpEgg: a rewriting grammar for complex arpeggios. In Proceedings
of the Generative Art Conference.
McIntyre, R. A. (1994). Bach in a box: the evolution of four part baroque harmony using the genetic algorithm. In Proceedings of the IEEE Conference on Evolutionary
Computation, pp. 852‚Äì857.
Melo, A. F. (1998). A connectionist model of tension in chord progressions. Master‚Äôs thesis,
University of Edinburgh.
Miljkovic, K. (2007). From Mathematica to live performance: Mapping simple programs to
music. In Proceedings of the International Conference on Mathematics and Computation in Music.
Millen, D. (1990). Cellular automata music. In Proceedings of the International Computer
Music Conference.
Miranda, E. R. (1993). Cellular automata music: An interdisciplinary project. Journal of
New Music Research, 22 (1), 3‚Äì21.
Miranda, E. R. (2002). Mimetic development of intonation. In Proceedings of the International Conference on Music and Artificial Intelligence.
Miranda, E. R. (2007). Evolutionary Computer Music, chap. Cellular Automata Music:
From Sound Synthesis to Musical Forms, pp. 170‚Äì193. Springer-Verlag London.
Miranda, E. R., & Biles, J. A. (Eds.). (2007). Evolutionary computer music. Springer-Verlag
London.
574

AI Methods in Algorithmic Composition

Miranda, E. R., Kirby, S., & Todd, P. M. (2003). On computational models of the evolution of music: From the origins of musical taste to the emergence of grammars.
Contemporary Music Review, 22 (3), 91‚Äì111.
Moorer, J. A. (1972). Music and computer composition. Communications of the ACM,
15 (2), 104‚Äì113.
Morales, E., & Morales, R. (1995). Learning musical rules. In Proceedings of the International Joint Conference on Artificial Inteligence.
Morgan, N. (2007). Transformation and mapping of L-Systems data in the composition of a
large-scale instrumental work. In Proceedings of the European Conference on Artificial
Life.
Moroni, A., Manzolli, J., Zuben, F. V., & Gudwin, R. (2000). Vox Populi: An interactive
evolutionary system for algorithmic music composition. Leonardo Music Journal, 10,
49‚Äì54.
Morris, D., Simon, I., & Basu, S. (2008). Exposing parameters of a trained dynamic model
for interactive music creation. In Proceedings of the AAAI National Conference on
Artificial intelligence, pp. 784‚Äì791.
Mozer, M. (1991). Music and Connectionism, chap. Connectionist music composition based
on melodic, stylistic, and psychophysical constraints, pp. 195‚Äì211. The MIT Press,
Cambridge.
Nelson, G. L. (1993). Sonomorphs: An application of genetic algorithms to the growth and
development of musical organisms. In Proceedings of the Biennial Symposium on Arts
and Technology, pp. 155‚Äì169.
Nelson, G. L. (1996). Real time transformation of musical material with fractal algorithms.
Computers & Mathematics with Applications, 1, 109‚Äì116.
Nettheim, N. (1992). On the spectral analysis of melody. Journal of New Music Research,
21 (2), 135‚Äì148.
Nettheim, N. (1997). A bibliography of statistical applications in musicology. Musicology
Australia, 20 (1), 94‚Äì106.
Nierhaus, G. (2009). Algorithmic Composition: Paradigms of Automated Music Generation.
Springer Berlin / Heidelberg.
Nishijimi, M., & Watanabe, K. (1993). Interactive music composer based on neural networks. Fujitsu Scientific Technical Journal, 29 (2), 189‚Äì192.
North, T. (1991). A technical explanation of theme and variations: A computer music work
utilizing network compositional algorithms. Ex Tempore, 5 (2).
Olarte, C., Rueda, C., & Valencia, F. D. (2009). New Computational Paradigms for Computer Music, chap. Concurrent Constraint Calculi: a Declarative Paradigm for Modeling Music Systems. Editions Delatour France.
Olson, H. F. (1961). Aid to music composition employing a random probability system.
Journal of the Acoustical Society of America, 33, 1163‚Äì1170.
575

Fern√°ndez & Vico

Ortega, A., S√°nchez, R., & Alfonseca, M. (2002). Automatic composition of music by means
of grammatical evolution. In Proceedings of the Conference on APL.
Ovans, R., & Davison, R. (1992). An interactive Constraint-Based expert assistant for music
composition. In Proceedings of the Canadian Conference on Artificial Intelligence, pp.
76‚Äì81.
√ñzcan, E., & Er√ßal, T. (2008). A genetic algorithm for generating improvised music. In
Proceedings of the International Conference on Artificial Evolution, pp. 266‚Äì277.
Pachet, F. (2002). Interacting with a musical learning system: The Continuator. In Proceedings of the International Conference on Music and Artificial Intelligence, pp. 103‚Äì108.
Pachet, F., & Roy, P. (1995). Mixing constraints and objects: a case study in automatic
harmonization. In Proceedings of the Conference on Technology of Object-Oriented
Languages and Systems.
Pachet, F., & Roy, P. (2001). Musical harmonization with constraints: A survey. Constraints,
6 (1), 7‚Äì19.
Pachet, F., Roy, P., & Barbieri, G. (2011). Finite-length Markov processes with constraints.
In Proceedings of the International Joint Conference on Artificial Inteligence.
Padberg, H. A. (1964). Computer-composed canon and free-fugue. Ph.D. thesis, Saint Louis
University, St. Louis.
Papadopoulos, G., & Wiggins, G. (1998). A genetic algorithm for the generation of jazz
melodies. In Proceedings of the Finnish Conference on Artificial Intelligence (STeP).
Papadopoulos, G., & Wiggins, G. (1999). AI methods for algorithmic composition: A survey,
a critical view and future prospects. In Proceedings of the Symposium on Musical
Creativity, pp. 110‚Äì117.
Parikh, T. (2003). Iris: artificially intelligent real-time improvisation system. Master‚Äôs
thesis, Emory University.
Pazos, A., Santos del Riego, A., Dorado, J., & Romero Caldalda, J. J. (1999). Genetic music
compositor. In Proceedings of the IEEE Conference on Evolutionary Computation, pp.
885‚Äì890.
Pearce, M., Meredith, D., & Wiggins, G. (2002). Motivations and methodologies for automation of the compositional process. Music√¶ Scienti√¶, 6 (2), 119‚Äì147.
Pearce, M., & Wiggins, G. (2001). Towards a framework for the evaluation of machine
compositions. In Proceedings of the Symposium on Artificial Intelligence and Creativity
in Arts and Science, pp. 22‚Äì32.
Peck, J. M. (2011). Explorations in algorithmic composition: Systems of composition and
examination of several original works. Master‚Äôs thesis, State University of New York,
College at Oswego.
Pennycook, B. (1985). Computer-music interfaces: A survey. ACM Computing Surveys,
17 (2), 267‚Äì289.
Pereira, F., Grilo, C., Macedo, L., & Cardoso, A. (1997). Composing music with case-based
reasoning. In Proceedings of the Conference on Computational Models of Creative
Cognition.
576

AI Methods in Algorithmic Composition

Pestana, P. (2012). Lindenmayer systems and the harmony of fractals. Chaotic Modeling
and Simulation, 1 (1), 91‚Äì99.
Phon-Amnuaisuk, S. (2002). Control language for harmonisation process. In Proceedings of
the International Conference on Music and Artificial Intelligence, pp. 155‚Äì167.
Phon-Amnuaisuk, S. (2010). Investigating music pattern formations from heterogeneous
cellular automata. Journal of New Music Research, 39 (3), 253‚Äì267.
Phon-Amnuaisuk, S., Law, E. H., & Kuan, H. C. (2007). Evolving music generation with
SOM-fitness genetic programming. In Proceedings of the Conference on Applications
of Evolutionary Computation, pp. 557‚Äì566.
Phon-Amnuaisuk, S., Tuson, A., & Wiggins, G. (1999). Evolving musical harmonisation.
In Proceedings of the International Conference on Artificial Neural Nets and Genetic
Algorithms.
Pinkerton, R. C. (1956). Information theory and melody. Scientific American, 194 (2),
77‚Äì87.
Polito, J., Daida, J. M., & Bersano Begey, T. F. (1997). Musica ex machina: Composing
16th-Century counterpoint with genetic programming and symbiosis. In Proceedings
of the International Conference on Evolutionary Programming, pp. 113‚Äì124.
Ponsford, D., Wiggins, G., & Mellish, C. (1999). Statistical learning of harmonic movement.
Journal of New Music Research, 28 (2), 150‚Äì177.
Pope, S. T. (1986). Music notations and the representation of musical structure and knowledge. Perspectives of New Music, 24 (2), 156‚Äì189.
Pope, S. T. (1991). A tool for manipulating expressive and structural hierarchies in music
(or: "T-R trees in the MODE: A tree editor based loosely on Fred‚Äôs theory"). In
Proceedings of the International Computer Music Conference.
Pope, S. T. (1993). Music Processing, chap. Music composition and editing by computer,
pp. 25‚Äì72. Oxford University Press.
Pope, S. T. (1995). Fifteen years of computer-assisted composition. In Proceedings of the
Brazilian Symposium on Computer Music.
Pressing, J. (1988). Nonlinear maps as generators of musical design. Computer Music
Journal, 12 (2), 35‚Äì46.
Prusinkiewicz, P. (1986). Score generation with L-systems. In Proceedings of the International Computer Music Conference, pp. 455‚Äì457.
Prusinkiewicz, P., & Lindenmayer, A. (1990). The algorithmic beauty of plants. SpringerVerlag New York.
Puckette, M. (2002). Max at Seventeen. Computer Music Journal, 26 (4), 31‚Äì43.
Putnam, J. (1994). Genetic programming of music. Tech. rep., New mexico institute of
mining and technology.
Quick, D. (2010). Generating music using concepts from Schenkerian analysis and chord
spaces. Tech. rep., Yale University.
577

Fern√°ndez & Vico

Rader, G. M. (1974). A method for composing simple traditional music by computer.
Communications of the ACM, 17 (11), 631‚Äì638.
Ralley, D. (1995). Genetic algorithms as a tool for melodic development. In Proceedings of
the International Computer Music Conference, pp. 501‚Äì502.
Ramalho, G., & Ganascia, J.-G. (1994). Simulating creativity in jazz performance. In
Proceedings of the AAAI National Conference on Artificial intelligence, pp. 108‚Äì113,
Menlo Park.
Ram√≠rez, R., & Peralta, J. (1998). A constraint-based melody harmonizer. In Proceedings
of the Workshop on Constraints for Artistic Applications.
Reddin, J., McDermott, J., & O‚ÄôNeill, M. (2009). Elevated pitch: Automated grammatical
evolution of short compositions applications of evolutionary computing. In Proceedings
of the Conference on Applications of Evolutionary Computation, pp. 579‚Äì584.
Reisig, W. (1998). Elements of Distributed Algorithms: Modeling and Analysis with Petri
Nets. Springer.
Rennie, J. (2010). Ray Kurzweil‚Äôs slippery futurism. IEEE Spectrum, 47 (12), 24‚Äì28.
Ribeiro, P., Pereira, F. C., Ferrand, M., & Cardoso, A. (2001). Case-based melody generation
with MuzaCazUza. In Proceedings of the Symposium on Artificial Intelligence and
Creativity in Arts and Science, pp. 67‚Äì74.
Ricanek, K., Homaifar, A., & Lebby, G. (1993). Genetic algorithm composes music. In
Proceedings of the Southeastern Symposium on System Theory, pp. 223‚Äì227.
Riecken, D. (1998). WOLFGANG: "emotions" and architecture which enable learning to
compose music. In Proceedings of the International Conference of the Society for
Adaptive Behavior.
Ritchie, G. (2007). Some empirical criteria for attributing creativity to a computer program.
Journal for Artificial Intelligence, Philosophy and Cognitive Science, 17 (1), 67‚Äì99.
Roads, C. (1977). Composing grammars. In Proceedings of the International Computer
Music Conference.
Roads, C. (1979). Grammars as representations for music. Computer Music Journal, 3 (1),
48‚Äì55.
Roads, C. (1985). Research in music and artificial intelligence. ACM Computing Surveys,
17 (2), 163‚Äì190.
Roads, C. (Ed.). (1992). The Music Machine: Selected Readings from Computer Music
Journal. The MIT Press.
Roads, C. (2004). Microsound. The MIT Press.
Roads, C., & Strawn, J. (Eds.). (1985). Foundations of computer music. The MIT Press.
Ross, B. J. (1995). A process algebra for stochastic music composition. In Proceedings of
the International Computer Music Conference.
Rothgeb, J. (1968). Harmonizing the unfigured bass: A computational Study. Ph.D. thesis,
Yale University.
578

AI Methods in Algorithmic Composition

Rowe, R. (1992). Interactive Music Systems: Machine Listening and Composing. The MIT
Press, Cambridge.
Rueda, C., √Ålvarez, G., Quesada, L. O., Tamura, G., Valencia, F., D√≠az, J. F., & Assayag,
G. (2001). Integrating constraints and concurrent objects in musical applications: A
calculus and its visual language. Constraints, 6 (1), 21‚Äì52.
Rueda, C., Assayag, G., & Dubnov, S. (2006). A concurrent constraints factor oracle model
for music improvisation. In Proceedings of the Latin American Informatics Conference.
Rueda, C., Lindberg, M., Laurson, M., Bloch, G., & Assayag, G. (1998). Integrating constraint programming in visual musical composition languages. In Proceedings of the
Workshop on Constraints for Artistic Applications.
Sabater, J., Arcos, J., & L√≥pez de M√°ntaras, R. (1998). Using rules to support case-based
reasoning for harmonizing melodies. In Proceedings of the AAAI Spring Symposium
on Multimodal Reasoning, pp. 147‚Äì151.
S√°nchez-Quintana, C., Moreno-Arcas, F., Albarrac√≠n-Molina, D., Fern√°ndez, J. D., & Vico,
F. (2013). Melomics: A case-study of AI in Spain. AI Magazine, 34 (3), 99‚Äì103.
Sandred, O. (2004). Interpretation of everyday gestures ‚Äî composing with rules. In Proceedings of the Music and Music Science Conference.
Sandred, O. (2010). PWMC, a constraint-solving system for generating music scores. Computer Music Journal, 34 (2), 8‚Äì24.
Santos, A., Arcay, B., Dorado, J., Romero, J. J., & Rodr√≠guez, J. A. (2000). Evolutionary
computation systems for musical composition. In Proceedings of the International
Conference Acoustic and Music: Theory and Applications.
Sastry, A. (2011). N-gram modeling of tabla sequences using variable-length hidden Markov
models for improvisation and composition. Master‚Äôs thesis, Georgia Institute of Technology.
Scaletti, C. (2002). Computer music languages, Kyma, and the future. Computer Music
Journal, 26 (4), 69‚Äì82.
Schmidl, H. (2008). Pseudo-Genetic algorithmic composition. In Proceedings of the International Conference on Genetic and Evolutionary Methods.
Schottstaedt, W. (1989). Current directions in computer music research, chap. Automatic
Counterpoint, pp. 199‚Äì214. The MIT Press, Cambridge.
Schulze, W. (2009). A Formal Language Theory Approach To Music Generation. Ph.D.
thesis, Stellenbosch University.
Schwanauer, S. (1993). Machine models of music, chap. A learning machine for tonal composition, pp. 511‚Äì532. The MIT Press, Cambridge.
Schwanauer, S. M., & Levitt, D. A. (1993). Machine Models of Music. The MIT Press,
Cambridge.
Shao, J., McDermott, J., O‚ÄôNeill, M., & Brabazon, A. (2010). Jive: A generative, interactive, virtual, evolutionary music system applications of evolutionary computation.
In Proceedings of the Conference on Applications of Evolutionary Computation, pp.
341‚Äì350.
579

Fern√°ndez & Vico

Shibata, N. (1991). A neural network-based method for chord/note scale association with
melodies. NEC Research and Development, 32 (3), 453‚Äì459.
Simoni, M., & Dannenberg, R. B. (2013). Algorithmic Composition: A Guide to Composing
Music with Nyquist. University of Michigan Press.
Soddell, F., & Soddell, J. (2000). Microbes and music. In Proceedings of the Pacific Rim
International Conference on Artificial Intelligence.
Sowa, J. F. (1956). A machine to compose music. Instruction manual for GENIAC, Oliver
Garfield Company, Inc.
Spangler, R. R. (1999). Rule-Based Analysis and Generation of Music. Ph.D. thesis, California Institute of Technology.
Spector, L., & Alpern, A. (1994). Criticism, culture, and the automatic generation of
artworks. In Proceedings of the AAAI National Conference on Artificial intelligence,
pp. 3‚Äì8, Menlo Park.
Spector, L., & Alpern, A. (1995). Induction and recapitulation of deep musical structure. In
Proceedings of the International Joint Conference on Artificial Inteligence, pp. 41‚Äì48.
Stanley, K., & Miikkulainen, R. (2003). A taxonomy for artificial embryogeny. Artificial
Life, 9 (2), 93‚Äì130.
Steedman, M. J. (1984). A generative grammar for jazz chord sequences. Music Perception:
An Interdisciplinary Journal, 2 (1), 52‚Äì77.
Steels, L. (1979). Reasoning modeled as a society of communicating experts. Master‚Äôs
thesis, Massachusetts Institute of Technology, Cambridge.
Steels, L. (1986). Learning the craft of musical composition. In Proceedings of the International Computer Music Conference.
Stieler, W. (2012). Die mozart-Maschine. Technology Review (German edition), 12/2012,
26‚Äì34.
Supper, M. (2001). A few remarks on algorithmic composition. Computer Music Journal,
25 (1), 48‚Äì53.
Thom, B. (2000). BoB: an interactive improvisational music companion. In Proceedings of
the International Conference on Autonomous Agents, pp. 309‚Äì316, New York.
Thomas, M. T. (1985). Vivace: A rule based AI system for composition. In Proceedings of
the International Computer Music Conference, pp. 267‚Äì274.
Thomas, M. T., Chatterjee, S., & Maimone, M. W. (1989). Cantabile: A rule-based system
for composing melody. In Proceedings of the International Computer Music Conference.
Thornton, C. (2009). Hierarchical Markov modelling for generative music. In Proceedings
of the International Computer Music Conference.
Thywissen, K. (1999). GeNotator: an environment for exploring the application of evolutionary techniques in computer-assisted composition. Organised Sound, 4 (2), 127‚Äì133.
Tipei, S. (1975). MP1: a computer program for music composition. In Proceedings of the
Annual Music Computation Conference.
580

AI Methods in Algorithmic Composition

Todd, P. M. (1989). A connectionist approach to algorithmic composition. Computer Music
Journal, 13 (4), 27‚Äì43.
Todd, P. M., & Loy, D. G. (1991). Music and Connectionism. The MIT Press, Cambridge.
Toiviainen, P. (1995). Modeling the target-note technique of bebop-style jazz improvisation:
an artificial neural network approach. Music Perception: An Interdisciplinary Journal,
12 (4), 399‚Äì413.
Toiviainen, P. (2000). Readings in Music and Artificial Intelligence, chap. Symbolic AI
versus Connectionism in Music Research, pp. 47‚Äì67. Harwood Academic Publishers.
Tokui, N., & Iba, H. (2000). Music composition with interactive evolutionary computation.
In Proceedings of the Generative Art Conference.
Tominaga, K., & Setomoto, M. (2008). An artificial-chemistry approach to generating
polyphonic musical phrases. In Proceedings of the Conference on Applications of
Evolutionary Computation, pp. 463‚Äì472.
Towsey, M. W., Brown, A. R., Wright, S. K., & Diederich, J. (2001). Towards melodic
extension using genetic algorithms. Educational Technology & Society, 4 (2), 54‚Äì65.
Trivi√±o Rodr√≠guez, J. L., & Morales-Bueno, R. (2001). Using multiattribute prediction
suffix graphs to predict and generate music. Computer Music Journal, 25 (3), 62‚Äì79.
Truchet, C., Assayag, G., & Codognet, P. (2003). OMClouds, a heuristic solver for musical
constraints. In Proceedings of the International Conference on Metaheuristics.
Tsang, C. P., & Aitken, M. (1991). Harmonizing music as a discipline of constraint logic
programming. In Proceedings of the International Computer Music Conference.
Ulrich, J. W. (1977). The analysis and synthesis of jazz by computer. In Proceedings of the
International Joint Conference on Artificial Inteligence, pp. 865‚Äì872.
Unehara, M., & Onisawa, T. (2001). Composition of music using human evaluation. In
Proceedings of the IEEE International Conference on Fuzzy Systems, pp. 1203‚Äì1206.
Ventrella, J. J. (2008). The Art of Artificial Evolution, chap. Evolving Structure in Liquid
Music, pp. 269‚Äì288. Springer Berlin / Heidelberg.
Verbeurgt, K., Fayer, M., & Dinolfo, M. (2004). A hybrid Neural-Markov approach for
learning to compose music by example. In Proceedings of the Canadian Conference
on Advances in Artificial Intelligence, pp. 480‚Äì484.
Visell, Y. (2004). Spontaneous organisation, pattern models, and music. Organised Sound,
9 (02), 151‚Äì165.
Voss, R. F., & Clarke, J. (1978). ‚Äù1/f noise‚Äù in music: Music from 1/f noise. Journal of the
Acoustical Society of America, 63, 258‚Äì263.
Walker, W. F. (1994). A conversation-based framework for musical improvisation. Ph.D.
thesis, University of Illinois.
Wallin, N. L., & Merker, B. (2001). The Origins of Music. The MIT Press.
Waschka, R. (1999). Avoiding the fitness bottleneck: Using genetic algorithms to compose
orchestral music. In Proceedings of the International Computer Music Conference, pp.
201‚Äì203.
581

Fern√°ndez & Vico

Watson, L. A. (2008). Algorithmic composition for flute and accompaniment. Master‚Äôs
thesis, University of Bath.
Werner, M., & Todd, P. M. (1997). Too many love songs: Sexual selection and the evolution
of communication. In Proceedings of the European Conference on Artificial Life.
Widmer, G. (1992). Qualitative perception modeling and intelligent musical learning. Computer Music Journal, 16 (2), 51‚Äì68.
Wiggins, G. A. (1998). The use of constraint systems for musical composition. In Proceedings
of the Workshop on Constraints for Artistic Applications.
Wiggins, G. A. (2008). Computer models of musical creativity: A review of computer models
of musical creativity by David Cope. Literary and Linguistic Computing, 23 (1), 109‚Äì
116.
Wilson, A. J. (2009). A symbolic sonification of L-systems. In Proceedings of the International Computer Music Conference, pp. 203‚Äì206.
Wolkowicz, J., Heywood, M., & Keselj, V. (2009). Evolving indirectly represented melodies
with corpus-based fitness evaluation. In Proceedings of the Conference on Applications
of Evolutionary Computation, pp. 603‚Äì608.
Wooller, R., & Brown, A. R. (2005). Investigating morphing algorithms for generative
music. In Proceedings of the International Conference on Generative Systems in the
Electronic Arts.
Worth, P., & Stepney, S. (2005). Growing music: Musical interpretations of L-Systems.
In Proceedings of the Conference on Applications of Evolutionary Computation, pp.
545‚Äì550.
Yi, L., & Goldsmith, J. (2007). Automatic generation of four-part harmony. In Proceedings
of the Conference on Uncertainty in Artificial Intelligence.
Yilmaz, A. E., & Telatar, Z. (2010). Note-against-note two-voice counterpoint by means of
fuzzy logic. Knowledge-Based Systems, 23 (3), 256‚Äì266.
Zicarelli, D. (1987). M and Jam factory. Computer Music Journal, 11 (4), 13‚Äì29.
Zimmermann, D. (2001). Modelling musical structures. Constraints, 6 (1), 53‚Äì83.

582

Journal of Artificial Intelligence Research 48 (2013) 305-346

Submitted 04/13; published 10/13

A Global Model for Concept-to-Text Generation
Ioannis Konstas
Mirella Lapata

IKONSTAS @ INF. ED . AC . UK
MLAP @ INF. ED . AC . UK

Institute for Language, Cognition and Computation,
School of Informatics, University of Edinburgh,
10 Crichton Street, EH8 9AB, Edinburgh UK

Abstract
Concept-to-text generation refers to the task of automatically producing textual output from
non-linguistic input. We present a joint model that captures content selection (‚Äúwhat to say‚Äù) and
surface realization (‚Äúhow to say‚Äù) in an unsupervised domain-independent fashion. Rather than
breaking up the generation process into a sequence of local decisions, we define a probabilistic context-free grammar that globally describes the inherent structure of the input (a corpus of
database records and text describing some of them). We recast generation as the task of finding
the best derivation tree for a set of database records and describe an algorithm for decoding in this
framework that allows to intersect the grammar with additional information capturing fluency and
syntactic well-formedness constraints. Experimental evaluation on several domains achieves results competitive with state-of-the-art systems that use domain specific constraints, explicit feature
engineering or labeled data.

1. Introduction
Concept-to-text generation broadly refers to the task of automatically producing textual output from
non-linguistic input (Reiter & Dale, 2000). Depending on the application and the domain at hand,
the input may assume various representations including databases of records, expert system knowledge bases, simulations of physical systems and so on. Figure 1 shows input examples and their
corresponding text for three domains: air travel, sportscasting and weather forecast generation.
A typical concept-to-text generation system implements a pipeline architecture consisting of
three core stages, namely content planning (selecting the appropriate content from the input and
determining the structure of the target text), sentence planning (determining the structure and lexical content of individual sentences), and surface realization (rendering the specification chosen by
the sentence planner into a surface string). Traditionally, these components are hand-engineered in
order to generate high quality text, at the expense of portability and scalability. It is thus no surprise that recent years have witnessed a growing interest in automatic methods for creating trainable
generation components. Examples include learning which database records should be present in a
text (Duboue & McKeown, 2002; Barzilay & Lapata, 2005) and how these should be verbalized
(Liang, Jordan, & Klein, 2009). Besides concentrating on isolated components, a few approaches
have emerged that tackle concept-to-text generation end-to-end. Due to the complexity of the task,
most models simplify the generation process, e.g., by creating output that consists of a few sentences, thus obviating the need for content planning, or by treating sentence planning and surface
realization as one component. A common modeling strategy is to break up the generation process
into a sequence of local decisions, each learned separately (Reiter, Sripada, Hunter, & Davy, 2005a;
Belz, 2008; Chen & Mooney, 2008; Angeli, Liang, & Klein, 2010; Kim & Mooney, 2010).
c
2013
AI Access Foundation. All rights reserved.

KONSTAS & L APATA

Pass

Bad Pass

Turn Over

Database:

from
to
pink3 pink7

from
to
pink7 purple3

from
to
pink7 purple3

Text:

pink3 passes the ball to pink7
(a) ROBO C UP

Database:

Temperature

Cloud Sky Cover

time
min mean max
06:00-21:00 9 15 21

time
percent (%)
06:00-09:00
25-50
09:00-12:00
50-75

Wind Speed

Wind Direction

time
min mean max
06:00-21:00 15 20 30
Text:

time
mode
06:00-21:00
S

Cloudy, with temperatures between 10 and 20 degrees. South wind around 20 mph.
(b) W EATHER G OV

Database:

Text:

Flight

Day Number

Month

from
to
denver boston

number dep/ar
9
departure

month
dep/ar
august departure

Condition

Search

arg1
arg2 type
arrival time 16:00 <

type what
query flight

Give me the flights leaving Denver August ninth coming back to Boston before 4pm.
(c) ATIS

Figure 1: Input-output examples for (a) sportscasting, (b) weather forecast generation, and (c) query
generation in the air travel domain.

In this paper we focus on the problem of generating text from a database and describe an
end-to-end generation model which performs content selection and surface realization jointly. More
specifically, the input to our model is a set of database records and collocated textual descriptions.
Consider the example in Figure 1b. Here, the records provide a structured representation of the
weather for a specific time interval (e.g., the temperature, the wind speed and direction) and the
text renders some of this information in natural language. We formulate the task of creating text
corresponding to a database through the following generative process: the database consists of a
306

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

set of typed tuples (record, field, value), and our aim is to choose a subset of these to talk about.
This naturally decomposes into selecting a sequence of records, and a sequence of fields within
the record. Finally, for each field we generate a sequence of words according to the value of that
field. Central to our approach is to jointly optimize this process, rather than breaking up the various
decisions into local problems and greedily trying to solve each one of them.
To do this, we define a probabilistic context-free grammar (PCFG) that captures the structure
of the database and how it can be verbalized. Generation then boils down to finding the best string
output as captured by the best derivation tree licensed by our grammar. In order to ensure that
our generation output is coherent, we intersect our grammar with additional information capturing
fluency and syntactic well-formedness constraints. Specifically, we experiment with a n-gram language model and a dependency model based on the work of Klein and Manning (2004). We follow
Chiang‚Äôs (2007) integration framework and show how it can be extended by intersecting a CFG
grammar with an arbitrary number of models (see Huang, 2008 for a similar proposal). Our work
is closest to that of Liang et al. (2009) who learn how to align database records and text segments
using a hierarchical hidden semi-Markov generative model (see Section 3.1 for details). We recast
their model as a PCFG and develop a decoding algorithm that allows us to go beyond alignments,
i.e., to generate multi-sentence text corresponding to database input.
Our model is conceptually simpler than previous approaches (e.g., Angeli et al., 2010; Kim &
Mooney, 2010); it encodes information about the domain and its structure globally, by considering
the input space simultaneously during generation. We thus need to train a single model (on a given
domain) once without having to separately optimize different content selection and surface realization components. More importantly, recasting generation into parsing allows us to optimize a joint
objective (hence finding the most likely grammar derivation that also yields a grammatical output
text) in a more principled manner, rather than approximating it with a greedy search over local decisions. Our only assumption is that the input must be a set of records essentially corresponding to
database-like tables whose columns describe fields of a certain type. Experimental evaluation on
three domains obtains results competitive to the state-of-the-art without using any domain specific
constraints, explicit feature engineering or labeled data.1
The remainder of this paper is structured as follows. Section 2 provides an overview of related
work. Section 3 presents our generation model; it defines the PCFG used in our experiments and
presents our decoding algorithm Section 4 discusses our experimental set-up and Section 5 presents
our results. Discussion of future work concludes the paper.

2. Related Work
The literature reveals many examples of generation systems that produce high quality text, almost
indistinguishable from human writing (Dale, Geldof, & Prost, 2003; Reiter, Sripada, Hunter, Yu,
& Davy, 2005b; Green, 2006; Turner, Sripada, & Reiter, 2009). Such systems often implement
a pipeline architecture and involve a great deal of manual effort. For instance, a typical content
selection module involves manually engineered rules based on the analysis of a large number of
texts from a domain-relevant corpus, and consultation with domain experts. Analogously, surface
1. A preliminary version of this work was published in the proceedings of NAACL 2012. The current article presents a
more general model, formulates explicitly our decoding algorithm and shows how to intersect a PCFG with an arbitrary number of external knowledge sources. In addition, we present several novel experiments, and a comprehensive
error analysis.

307

KONSTAS & L APATA

realization is often based on a grammar written by hand so as to cover the syntactic constructs and
vocabulary of the domain.
One of the earliest systems that exemplifies this approach is FOG (Goldberg, Driedger, & Kittredge, 1994), a weather forecast generator used by Environment Canada, the Canadian weather
service. FOG takes as input numerical simulations from meteorological maps and uses an expert
system to decide on the structure of the document with some optional human intervention via a
graphical interface. For sentence planning and surface realization, the generator uses a grammar
specific to the weather domain, as well as canned syntactic structures written by expert linguists
and encoded in Backus Naur Form (BNF). More recently, Reiter et al. (2005a) have developed
S UM T IME -M OUSAM, a text generator that produces marine weather forecasts for offshore oilrig applications. The content planner of the system is based on linear segmentation of the input
(i.e., time series data) and is informed by a pragmatic (Gricean) analysis of what should be communicated in weather forecasts (Sripada, Reiter, Hunter, & Yu, 2003). Sentence planning relies on rules
that select appropriate time phrases, based on an empirical study of human-written forecasts. Surface realization relies on special grammar rules that emulate the weather sub-language of interest,
again based on corpus analysis.
While existing generation systems can be engineered to obtain good performance on particular
domains, it is often difficult to adapt them across different domains. An alternative is to adopt a
data-driven approach and try to automatically learn the individual generation components or even
an end-to-end system. An example of this class of methods is described in the work of Barzilay
and Lapata (2005) who view content selection as an instance of collective classification. Given a
corpus of database records and texts describing some of them, they first use a simple anchor-based
alignment technique to obtain records-to-text alignments. Then, they use the alignments as training
data (records present in the text are positive labels, and all other records negative) and learn a content
selection model that simultaneously optimizes local label assignments and their pairwise relations.
Building on this work, Liang et al. (2009) present a hierarchical hidden semi-Markov generative
model that first determines which facts to discuss and then generates words from the predicates and
arguments of the chosen facts. Their model is decomposed into three tiers of HMMs that correspond
to chains of records, fields and words. They use Expectation Maximization (EM) for training and
dynamic programming for inference (see Section 3.1 for a more thorough description).
A few approaches have emerged more recently that combine content selection and surface realization. Kim and Mooney (2010) present a generator with a two-stage pipeline architecture: using
a generative model similar to the model in the work of Liang et al. (2009), they first decide what
to say and then verbalize the selected input with WASP‚àí1 , an existing generation system (Wong &
Mooney, 2007). In contrast, Angeli et al. (2010) propose a unified content selection and surface
realization model which also operates over the alignment output produced by the model of Liang
et al.. Their model decomposes into a sequence of discriminative local decisions. They first determine which records in the database to talk about, then which fields of those records to mention, and
finally which words to use to describe the chosen fields. Each of these decisions is implemented
as a log-linear model with features learned from training data. Their surface realization component
performs decisions based on automatically extracted templates that are filtered with domain-specific
constraints in order to guarantee fluent output.
Other related work has focused on mapping meaning representations (e.g., some logical form
or numeric weather data) to natural language, using explicitly aligned sentence/meaning pairs as
training data. For example, Wong and Mooney (2007) learn this mapping using a synchronous
308

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

context-free grammar (SCFG). They also integrate a language model with their SCFG and decode
the meaning representation input to text, using a left-to-right Early chart generator. Belz (2008)
creates a CFG by hand (using a set of template-based domain-specific rules) but estimates probabilities for rule application automatically from a development corpus. Ratnaparkhi (2002) uses a
dependency-style grammar of phrase fragments in the context of a dialogue system, incorporating
among others long-range dependencies. More recently, Lu and Ng (2011) propose in their work a
model that performs joint surface realization and lexical acquisition from input that is represented
in typed lambda calculus. They present a novel SCFG forest-to-string generation algorithm, that
captures the correspondence between natural language and logical form represented by Œª‚àíhybrid
trees.
Similar to the work of Angeli et al. (2010), we also present an end-to-end system that performs
content selection and surface realization. However, rather than breaking up the generation task into
a sequence of local decisions, we optimize what to say and how to say simultaneously. We do not
learn mappings from a logical form, but rather focus on input which is less structured and possibly
more noisy. Our key insight is to convert the set of database records serving as input to our generator
into a PCFG that is neither hand crafted nor domain specific but simply describes the structure of
the input. During training, we estimate the weights of the grammar rules using the EM algorithm
and a dynamic program similar to the inside-outside algorithm (Li & Eisner, 2009). During testing
we are given only a set of database and search for the best derivation tree licensed by the grammar.
While searching, we intersect our grammar with external linguistically motivated models and create
k-best lists of derivations, thus optimizing ‚Äúwhat to say‚Äù and ‚Äúhow to say‚Äù at the same time.

3. Problem Formulation
We assume our generator takes as input a set of database record tuples (r, f , v) ‚àà d and outputs a
text g that verbalizes some of these records. Each record token ri , with 1 ‚â§ i ‚â§ |d|, has a type ri .t,
which can be thought of as the name of the table in a relational database schema. Note that the
total number of records |d| can vary between examples. Figure 1b illustrates instances of record
types such as Temperature, Wind Speed, and Wind Direction. Each record token also has a set of
fields ri .f associated with it. For example, a record of type Wind Direction has two fields, namely
windDir1 .time and windDir1 .mode. We will henceforth abbreviate fields to their names (e.g., time
and mode) when the record type is apparent from the context. Fields have different values fk .v; in
Figure 1b the value of the field mode is S. Fields also have an associated type fk .t, which defines the
range of possible values they can take; our model supports integer and categorical value types. For
example, the top right table in Figure 1b named Cloud Sky Cover (sc for short), corresponds to four
database record tuples: (sc1 , time, 06:00-09:00), (sc1 , percent, 25-50), (sc2 , time, 09:00-12:00)
and (sc2 , percent, 50-75). Both time and percent are of categorical type.
The training corpus consists of several scenarios, i.e., database records d paired with texts w2
like those shown in Figure 1. In the weather forecast domain, a scenario corresponds to weatherrelated measurements of temperature, wind, speed, and so on collected for a specific day and time
(e.g., day or night). In sportscasting, scenarios describe individual events in the soccer game
(e.g., passing or kicking the ball). In the air travel domain, scenarios comprise of flight-related
details (e.g., origin, destination, day, time).
2. We use w to denote the gold-standard text and g to refer to the string of words our system generates.

309

KONSTAS & L APATA

d

...

r1

...

r1 . f 1

w1

...

w

...

ri . f 1

w

...

ri

...

w

...

ri . f|f|

w

...

r|r|

w

r|r| . f|f|

w

...

wN

Figure 2: Graphical model representation of the generative alignment model of Liang et al. (2009).
Shaded nodes represent observed variables (i.e., the database d and the collocated text w), unshaded
nodes indicate latent variables. Arrows indicate conditional dependencies between variables. Starting from the database d, the model emits a sequence of records; then for each record it emits a
sequence of fields, specific to the type of the particular record. Finally, for each record it uniformly
selects a number c and emits words w1 . . . wc .

Our goal is to first define a model that naturally captures the (hidden) relations between the
database records d and the observed text w. Once trained, we can use this model to generate text g
corresponding to new records d. Our model is an extension of the hierarchical hidden semi-Markov
model of Liang et al. (2009) which we describe in detail in the next section. Our key idea is to recast
this model as a probabilistic context-free grammar, therefore reducing the tasks of content selection
and surface realization into a common parsing problem.3 Arguably, we could have implemented this
model using a finite-state representation. However, the conceptualization of generation as parsing,
allows us to use the well-known CYK algorithm (Kasami, 1965; Younger, 1967) in order to find
the best g licensed by the grammar. It also affords a wider range of extensions that go beyond the
expressivity of the cascade of HMMs in the model of Liang et al. We furthermore ensure that the
resulting text is fluent by intersecting our grammar with externally trained surface level models,
namely a n-gram language model and a dependency model. Thus, our model will generate the parse
and more importantly text deemed most likely by both the grammar and the surface models. In the
following, we first describe the approach of Liang et al. and then move on to describe our grammar
and decoding algorithm, i.e., our procedure for finding the best g for a given input d.
310

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

3.1 A Model of Inducing Alignments
Liang et al. (2009) present a generative semi-hidden Markov model that learns the correspondence
between a world state and an unsegmented string of text without, however, generating an output
string of words g describing the world state. As in our case, the world state is represented by a set
of database records, with their associated fields and values. Their model is defined by a generative
process that can be summarized in three steps:
1. Record choice. Choose a sequence of records r to describe. Consecutive records are selected
on the basis of their types.
2. Field choice. For each record ri emit a sequence of fields ri .f.
3. Word choice. For each chosen field ri . fk generate a number of words c, where c > 0 is chosen
uniformly.
This process is implemented as a hierarchy of Markov chains which correspond to records, fields,
and values of the input database. As captured by a Markov chain of records conditioned on record
types; given a record type, then a record is chosen uniformly from the set of records with this type.
In this way, their model essentially captures rudimentary notions of local coherence and salience,
respectively. More formally:
|r|

p(r | d) = ‚àè p(ri .t | ri‚àí1 .t)
i

1
|s(ri .t)|

(1)

where s(t) is defined as a function that returns the set of records with type t: s = {r ‚àà d : r.t = t}, and
r0 .t is the START record type. Liang et al. (2009) also include a special null record type, which
accounts for words that do not particularly align with any record present in the database. Field
choice is modeled analogously as a Markov chain of fields for a given record choice ri of type t:
|ri .f|

p(f | ri .t) = ‚àè p(ri . fk | ri . fk‚àí1 )

(2)

k

They also implement special start and stop fields to model transitions at the boundaries of the
corresponding phrase. Finally, for a chosen record ri , a field fk and a uniformly chosen number c,
with 0 < c < N, they emit words independently given the field value and type. Note that since
their model always observes the words, this simplistic representation at the surface level is adequate
(however, relaxing the independence assumption, e.g., by additionally conditioning on the previous
word(s), could potentially yield a more powerful model):
|w|

p(w |ri , ri . fk , ri . fk .t) = ‚àè p(w j | ri .t, ri . fk .v)

(3)

j

Their model supports three different types of fields, namely string, categorical and integer. For each
of those they adopt a specific generation strategy at the word level. For string-typed fields, they
3. An alternative would be to learn a SFCG between the database input and the accompanying text. However, this would
involve considerable overhead in terms of alignment (as the database and the text do not together constitute a clean
parallel corpus, but rather a noisy comparable corpus), as well as grammar training and decoding using state-of-the
art statistical machine translation (SMT) methods, which we manage to avoid with our simpler approach.

311

KONSTAS & L APATA

Events:
Fields:
Text:

skyCover1
percent=0-25
cloudy ,

k
N
withg

temperature1
time=6am-9pm
temperatures between

min=9
10gand

max=21
20 degrees .

kwindDir1
mode=S
N
southg
windg

kwindSpeed1
N
mean=20
aroundg
20 mph .

Figure 3: Example of alignment output for the model of Liang et al. (2009) on the weather domain.
Subscripts refer to record tokens (e.g., skyCover1 is the first record with type Cloud Sky Cover).
emit a single word from the (possibly) multi-word value, chosen uniformly. For categorical fields,
they maintain a separate multinomial distribution of words for each field value. Finally, for integer
fields, they wish to capture the intuition that a numeric quantity in the database can be rendered in
the text as a word which is possibly some other numerical value due to stylistic factors. So they
allow several ways generating a word given a field value. These include generating the exact value,
rounding up or rounding down to a multiple of 5, rounding off to the closest multiple of 5, and
adding or subtracting some unexplained noise Œµ+ or Œµ‚àí , respectively. Each noise is modeled as a
geometric distribution, the parameters of which are trained given the value ri . fk .v.
An example of the model‚Äôs output for the weather domain is shown in Figure 3. The top
row contains the database records selected by the model (subscripts correspond to record tokens;
e.g., temperature1 refers to the first record of type temperature in Figure 1b). The second row contains the selected fields for each record with their associated values. The special field null aligns
with words that do not directly refer to the values of the database records, such as with, wind and
around. Finally, the last row shows the segmentation and alignment of the original text w produced
by the model.
As it stands, Liang et al.‚Äôs (2009) model generates an alignment between sequences of words and
facts in a database, falling short of creating a meaningful sentence or document. Kim and Mooney
(2010) address this problem by interfacing the alignments with WASP‚àí1 (Wong & Mooney, 2007).
The latter is a publicly available generation system which takes an alignment as input and finds the
most likely string using the widely popular noisy-channel model. Angeli et al. (2010) propose a
model different in spirit which nevertheless also operates over the alignments of Liang et al. Using
a template extraction method, they post-process the alignments in order to obtain a sequence of
records, fields, and words which are spanned by the chosen records and fields. The generation
process is then modeled as a series of local decisions, arranged hierarchically and each trained
discriminatively. For each record they choose to talk about, they then choose a subset of fields, and
finally a suitable template to render the chosen content. The same process repeats until it decides to
generate a special STOP record.
We do not treat the model of Liang et al. (2009) as a black box in order to obtain alignments.
Rather, we demonstrate how generation can be seamlessly integrated in their semi-hidden Markov
model by re-interpreting it as CFG rewrite rules and providing an appropriate decoding algorithm.
Our model simultaneously learns which records and fields to talk about, which textual units they
correspond to, and how to creatively rearrange them into a coherent document.
3.2 Grammar Definition
As mentioned earlier, we recast the model of Liang et al. (2009) as a series of CFG rewrite rules,
corresponding to the first two layers of the HMMs in Figure 2. We also include a set of grammar
rules that emit chains of words, rather than words in isolation. This can be viewed as an additional
312

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

1. S ‚Üí R(start)

GCS

GSURF

2. R(ri .t) ‚Üí FS(r j , start) R(r j .t)

[Pr = 1]
i
h
P(r j .t | ri .t) ¬∑ |s(r1i .t)|

3. R(ri .t) ‚Üí FS(r j , start)

h
i
P(r j .t | ri .t) ¬∑ |s(r1i .t)|

4. FS(r, r. fi ) ‚Üí F(r, r. f j ) FS(r, r. f j )

[P( f j | fi )]

5. FS(r, r. fi ) ‚Üí F(r, r. f j )

[P( f j | fi )]

6. F(r, r. f ) ‚Üí W(r, r. f ) F(r, r. f )

[P(w | w‚àí1 , r, r. f )]

7. F(r, r. f ) ‚Üí W(r, r. f )

[P(w | w‚àí1 , r, r. f )]

8. W(r, r. f ) ‚Üí Œ±

[P(Œ± | r, r. f , f .t, f .v, f .t = {cat, null})]

9. W(r, r. f ) ‚Üí gen( f .v)

[P(gen( f .v).mode | r, r. f , f .t = int)¬∑
P( f .v | gen( f .v).mode)]

Table 1: Grammar rules for GGEN and their weights shown in square brackets.

HMM over words for each field in the original model. The modification is important for generation; since we only observe the set of database records d, we need a better informed model during
decoding that captures word-to-word dependencies more directly. We should also point out that our
PCFG does not extend the underlying expressivity of the model presented in Liang et al., namely it
also describes a regular language.
Our grammar GGEN is defined in Table 1 (rules (1)‚Äì(9)) and contains two types of rules. GCS
rules perform content selection, whereas GSURF rules perform surface realization. Both types of
rules are purely syntactic (describing the intuitive relationship between records, records and fields,
fields and corresponding words), and could apply to any database with similar structure irrespectively of the semantics of the domain. Rule weights are governed by an underlying multinomial
distribution and are shown in square brackets. Non-terminal symbols are in capitals and denote intermediate states; the terminal symbol Œ± corresponds to all words seen in the training set, and gen( f .v)
is a function for generating integer numbers given the value of a field f . All non-terminals, save
the start symbol S, have one or more features (shown in parentheses) which act as constraints, similar to number and gender agreement constraints in augmented syntactic rules. Figure 4 shows two
derivation trees licensed by our grammar for the sentence ‚ÄúCloudy, with temperatures between 10
and 20 degrees.‚Äù (see the example in Figure 1b).
The first rule in the grammar denotes the expansion from the start symbol S to record R, which
has the special ‚Äòstart‚Äô record type (hence the notation R(start)). Rule (2) defines a chain between
two consecutive records, i.e., going from record ri to r j . Here, FS(r j , start) represents the set
of fields of record r j following record R(ri ). For example, in Figure 4a, the top branching rule
R(start) ‚Üí FS(sc2 , start)R(sc2 .t) (sc stands for Cloud Sky Cover) can be interpreted as follows.
Given we are at the beginning of the document, hence the record R(start), we will talk about the
313

KONSTAS & L APATA

S
R(start)
R(sc2 .t)

FS(sc2 ,start)
F(sc2 ,%)

FS(sc2 ,%)

W(sc2 ,%)

F(sc2 ,null)

R(t1 .t)

FS(t1 ,start)
FS(t1 ,min)

F(t1 ,min)

W(sc2 ,null) W(t1 ,min)

F(t1 ,min)

W(t1 ,min)

FS(t1 ,max)

F(t1 ,max)

F(t1 ,min)

W(t1 ,min)

W(t1 ,max)

F(t1 ,null)

F(t1 ,max)

W(t1 ,max) W(t1 ,null)

F(t1 ,min)

W(t1 ,null)

W(t1 ,min)

Cloudy

,

10

between

temperatures

with

F(t1 ,null)

and

.

degrees

20

...

(a)
S
R(start)
R(sc2 .t)

FS(sc2 ,start)
F(sc2 ,%)

FS(sc2 ,%)

W(sc2 ,%)

F(sc2 ,null)

R(t1 .t)

FS(t1 ,start)
FS(t1 ,null)

F(t1 ,null)

W(sc2 ,null) W(t1 ,null)

F(t1 ,null)
W(t1 ,null)

FS(t1 ,min)

F(t1 ,min)
W(t1 ,min)

F(t1 ,max)

F(t1 ,min)

F(t1 ,max)

W(t1 ,min) W(t1 ,max)

W(t1 ,max)

F(t1 ,max)
W(t1 ,max)

F(t1 ,max)
W(t1 ,max)

Cloudy

,

with

temperatures

10

between

and

20

degrees

.

...

(b)

Figure 4: Two derivation trees using the grammar in Table 1 for the sentence ‚ÄúCloudy, with temperatures between 10 and 20 degrees.‚Äù. We use sc as a shorthand for the record type Cloud Sky
Cover, and t for Temperature. Subscripts refer to record tokens (e.g., sc2 is the second Cloud Sky
Cover record, t1 is the first Temperature record, and so on).

314

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

part of the forecast that refers to Cloud Sky Cover, i.e., emit the set of fields spanned by the
non-terminal FS(sc2 , start). The field start in FS acts as a special boundary between consecutive
records. Note that in the input database of example 1b, there are two records of type Cloud Sky
Cover (see the second box in the example). Given that the value of the percent (%) field of the
second record is 50-75, it is more likely to lexicalize to the phrase ‚ÄúCloudy ,‚Äù. In a different
scenario, if the equivalent phrase was ‚ÄúMostly sunny ,‚Äù the first record with value 25-50 would
have been more appropriate. Rule R(sc2 .t) ‚Üí FS(t1 , start)R(t1 .t) (t stands for Temperature) is
interpreted similarly: once we talk about the sky coverage of the forecast we will move on to
describe the temperature outlook, via the field set spanned by the non-terminal FS(t1 , start) (see
the second sub-tree in Figure 4a). The weight of this rule is the bigram probability of two records
conditioned on their record type, multiplied with the normalization factor |s(r1i .t)| , where s(t) is a
function that returns the set of records with type t (Liang et al., 2009). We have also defined a null
record type i.e., a record that has no fields and acts as a smoother for words that may not correspond
to a particular record. Rule (3) is simply an escape rule, so that the parsing process (on the record
level) can finish.
Rule (4) is the equivalent of rule (2) at the field level, i.e., it describes the chaining of two
consecutive fields fi and f j . Non-terminal F(r, r. f ) refers to field f of record r. For example, in the
tree of Figure 4a, the rule FS(t1 , min) ‚Üí F(t1 , max) FS(t1 , max) specifies that we should talk about
the field max of record t1 (i.e., temperature record), after talking about the field min. Analogously
to the record level, we have also included a special null field type for the emission of words that do
not correspond to a specific record field (e.g., see the emission of the two last tokens ‚Äúdegrees .‚Äù in
the end of the phrase in the derivation tree. Rule (6) defines the expansion of field F to a sequence
of (binarized) words W, with a weight equal to the bigram probability of the current word given
the previous word, the current record, and field. See the consecutive application of this rule on the
derivation tree in the emission of the phrase ‚Äúwith temperatures between 10 ‚Äù.
Rules (8) and (9) are responsible for surface generation; they define the emission of words and
integers from W , given a field type and its value, and can thus be regarded as the lexical rules
of our grammar (see the pre-terminal expansions at the derivation tree of Figure 4a for examples).
Rule (8) emits a single word from the vocabulary of the training set. Its weight defines a multinomial
distribution over all seen words, for every value of field f , given that the field type is categorical
(denoted as cat in the grammar) or the special null field. Rule (9) is identical but for fields whose
type is integer. Function gen( f .v) generates an integer number given the field value, using either
of the following six ways (Liang et al., 2009): identical to the field value, rounding up or rounding
down to a multiple of 5, rounding off to the closest multiple of 5 and finally adding or subtracting
some unexplained noise Œµ+ or Œµ‚àí respectively. Each noise is modeled as a geometric distribution,
the parameters of which are trained given the value f .v. The weight is a multinomial over the six
integer generation function choices, given the record field f , times P( f .v | gen( f .v).mode), which is
set to the geometric distribution of noise Œµ+ and Œµ‚àí , or to 1 otherwise.
Naturally, our grammar can yield several derivation trees for a given input string. Notice the
difference between Figure 4a and Figure 4b in emitting the phrases ‚Äúwith temperatures between 10 ‚Äù
and ‚Äúand 20 degrees .‚Äù. In Figure 4a, the field min (whose record is Temperature) spans the entire
phrase, whereas in Figure 4b the phrase is split in two parts. The null field emits ‚Äúwith temperatures‚Äù
and the min field emits ‚Äúbetween 10 ‚Äù. Analogously, in the derivation tree in Figure 4a, the field max
emits the first three words, ‚Äúand 20 degrees‚Äù, then the null emits the full-stop on its own null field
315

KONSTAS & L APATA

of the same record (very common situation in case of punctuation marks). In the derivation tree of
Figure 4b, however, the whole phrase is spanned by the field max.
3.3 Generation
So far we have defined a probabilistic grammar which captures the structure of a database d with
records and fields as intermediate non-terminals, and words w (from the associated text) as terminals. The mapping between d and w is unknown and thus the intermediate multinomials (see the rule
weights of GGEN in Table 1) define a distribution over hidden correspondences h between records,
fields and their values. Given an input scenario from a database d we can generate its corresponding
text using the grammar in Table 1.
On a high-level our generation procedure can be described as follows. We first select the length
N of the output text (we defer discussion on how we achieve this to Section 4.3). Then, we apply
our grammar to the ‚Äúempty‚Äù document by building derivation trees in a bottom-up fashion, starting
from the lexical rules r ‚àà GSURF . For each word position in the document we emit a k-best list of
candidate words drawn from the corresponding distributions, given the values of the fields of the
records in d; then, we apply the rest of the rules r ‚àà GCS , keeping a list of k-best partial derivations
and partially generated text in each node4 , until we reach the root symbol S spanning the whole
document. Finally, we reconstruct the top-scoring generated string at the root of the tree, by following the pointers of the best derivation, down to the lexical rules that emit the words of the final
document. In order to guarantee the grammaticality of the final output text, we rescore the k-best
lists at each node by applying external linguistic knowledge, such as n-gram language models and
head dependency-style models, on the partially generated substrings.
In analogy to parsing, this procedure amounts to finding the most likely derivation, i.e., sequence
of rewrite rules for a given input. Note, that there is a subtle difference between syntactic parsing
and generation. In the former case, we observe a string of words and our goal is to find the most
probable syntactic structure, i.e., hidden correspondence hÃÇ. In generation, however, as described
above, the string is not observed; instead, we must thus find the best text gÃÇ, by maximizing both
over h and g (the latter is achieved with the use of external linguistic knowledge via rescoring),
where g = g1 . . . gN is a sequence of words licensed by GCS and GSURF . More formally:


gÃÇ = f arg max P (g, h)
(4)
g,h

where f is a function that takes as input a derivation tree (g, h) and returns gÃÇ. We use a modified
version of the CYK parser (Kasami, 1965; Younger, 1967) to find gÃÇ. Optimizing over both h and g
is intractable, so we approximate f by pruning the search space as we explain in Section 3.5.
In the following, we we will use the framework of deductive proof systems (Shieber, Schabes,
& Pereira, 1995) in order to describe our decoder. We first present a basic adaptation of the CYK
algorithm to our task and give a concrete decoding procedure that generates text, using a chart data
structure (Section 3.4). We then extend the basic decoder into a k-best decoder, by integrating external linguistic knowledge in an attempt to improve the quality of the output. The basic decoder
naively only optimizes function f over h, whereas the extended version maximizes both h and g,
approximately. Note that the framework of deductive proof systems is used here for convenience. It
4. We use an efficient method that compresses the stored substrings considerably, following the work of Chiang (2007);
see equation (12) in Section 3.6.

316

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

Items:

[A, i, j]
R(A ‚Üí B)
R(A ‚Üí BC)

Axioms:

[W, i, i + 1] : s

W ‚Üí gi+1 , gi+1 ‚àà {Œ±, gen()}

Inference rules:
(1)
(2)
Goal:

R(A ‚Üí B) : s [B, i, j] : s1
[A, i, j] : s ¬∑ s1
R(A ‚Üí B C) : s [B, i, k] : s1 [C, k, j] : s2
[A, i, j] : s ¬∑ s1 ¬∑ s2

[S, 0, N]

Figure 5: The basic decoder deductive system. Productions A ‚Üí B and A ‚Üí B C can be any of the
GCS rules in Figure 1; features on grammar non-terminals are omitted for the sake of clarity.
provides a level of abstract generalization for a number of algorithms. Examples include the recogntion of a sentence according to a grammar, learning inside and outside weights, Viterbi search, and
in our case generating text (see Goodman, 1999 for more details).
3.4 Basic Decoder
Analogously to a parser, our decoder can be generally defined as a set of weighted items (some of
which are designated axioms and others are goals, i.e., items to be proven) and a set of inference
rules of the form:
I1 : s1 . . . Ik : sk
Œ¶
I:s
which can be interpreted as follows: if all items Ii (i.e., the antecedents) have been first proven with
weight (or score) si , then item I (i.e., the consequent) is provable, with weight s provided the side
condition Œ¶ holds. The decoding process begins with the set of axioms, and progressively applies
the inference rules, in order to prove more items until it reaches one of the designated goals.
Our basic decoder is specified in Figure 5 and consists of four components, a class of items, a
set of axioms, a set of inference rules and a subclass of items, namely the goal items. Following the
work of Goodman (1999), items in our system take two forms: [A, i, j] indicates a generated span
from i to j, rooted at non-terminal A; R(A ‚Üí B) or R(A ‚Üí B C) corresponds to any of the content
selection production rules of GCS with one or two non-terminals on the right hand side. Axioms
correspond to each individual word generated by the surface realization grammar rules GSURF (see
(8) and (9) in Table 1). Our inference rules follow two forms, one for grammar production rules
with one non-terminal on the right hand side, and another one for rules with two non-terminals. For
example, inference rule (1) in Figure 5 combines two items, namely a rule of the form A ‚Üí B with
weight s and a generated span [B, i, j] with weight s1 rooted at B, and results to a new generated
span [A, i, j] with weight s ¬∑ s1 , rooted at A. Finally, our system has one goal, [S, 0, N], where S is the
root node of the grammar and N the (predicted) length of the generated text. The time complexity is
317

KONSTAS & L APATA

O(n3 ), as in the case of CYK algorithm. We could have converted our grammar rules in Chomsky
normal form (CNF) and implemented the original CYK algorithm. Note that our grammar is not
in CNF, since it contains unary productions of the type A ‚Üí B, i.e., with non-terminal symbols on
the right-hand side as well. We chose to directly implement inference rules (1) and (2) instead (see
Figure 5), since we know that the arity of our grammar is at most 2 and were thus able to avoid a
blow-up in the number of derived rules.
Now that we have defined the parsing strategy, we need a way to find the most likely derivation;
the pseudocode of Figure 6 gives the generation algorithm for the basic decoder. It uses an array
chart[A, i, j], the cells of which get filled with sets of weights of items. It also uses an identical array
bp[A, i, j] that stores back-pointers to the antecedents of each item rooted at A, as well as the actual
generated words when processing the lexical rules r ‚àà GSURF (abusing somewhat the traditional
interpretation of a back-pointer array, as a storage of pointers to antecedent chart items). The size
of the chart and the back-pointer array are set to the pre-defined number of N words we want to
generate (Section 4.3). The procedure begins by first filling in the ‚Äòdiagonal‚Äô cells of the chart
with unary spans rooted at W , with the weights of the lexical rules r ‚àà GSURF . Equivalently, the
back-pointers array takes the corresponding generated word. Note that in a conventionial parsing
procedure, we always assume that the ‚Äòdiagonal‚Äô cells of the chart are already filled in with the
actual words of the underlying sentence. In our case, we only assume a fixed-size chart with an
empty ‚Äòdiagonal‚Äô, which gets filled in with the top scoring words emitted by the lexical rules of
our grammar. Next, items are visited and combined in order, i.e., smaller spans come before larger
spans. Given the way our grammar is constructed, items rooted in F (corresponding to fields) will
come before items rooted in R (records) and ultimately before S. At any particular point in the chart,
the algorithm considers all the antecedent items that can be proven given the rules of GCS and stores
the highest scoring combination. Finally, we can construct the resulting string gÃÇ by recursively
visiting bp[S, 0, N]. We trace the back-pointers of each item to its antecedents down to the words gi
emitted by the axioms.
3.5 k-best Decoding
The basic decoder described so far will produce the best derivation tree of the input d given the
grammar GGEN which unfortunately may not correspond to the best generated text. In fact, the
output will often be poor as the model has no notion of what constitutes fluent language. The grammar encodes little knowledge with regard to syntactic well-formedness and grammatical coherence.
Essentially, surface realization boils down to the word bigram rules (6) and (7) and the lexical rules
in GSURF . The word bigram rules inject some knowledge about word combinations into the model,
but this kind of information is usually sparse and cannot capture longer range dependencies.
The generation process in Figure 6 picks the top scoring words emitted by the lexical production
rules (lines 3‚Äì5), in order to produce the best derivation at the root node S. Instead, it would be
preferable if we added to the chart a list of the top k words (as well as a list of the top k items [B, i, j],
[C, j, k] for each production rule r ‚àà GCS ), and thus produced a k-best list of derivations (with their
associated strings) at the root node. This can be done efficiently using the lazy algorithm found
in the work of Huang and Chiang (2005). Then, once the generation process is finished, we can
use a language model such as higher order n-grams, or head dependency-style rules to rescore the
k-best lists of generated strings directly (see also Charniak & Johnson, 2005 and Liang, BouchardCoÃÇteÃÅ, Klein, & Taskar, 2006 for application of a similar idea to parsing and machine translation,
318

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:

function D ECODE(GGEN ,d,N)
for i ‚Üê 0 . . . N do
for all r : W ‚Üí gi+1 ‚àà GSURF do
chart[W, i, i + 1] ‚Üê [W, i, i + 1] : s
bp[W, i, i + 1] ‚Üê gi+1
. store actual word gi+1
end for
end for
for l ‚Üê 2 . . . N do
for all i, k, j so that j ‚àí i = l and i < k < j do
for all items [B, i, j] or [B, i, k], [C, k, j] inferable from chart and rules r ‚àà GCS do
if r is of the form A ‚Üí B then
chart[A, i, j] ‚Üê max ([B, i, j] : s1 √ó P(r))
bp[A, i, j] ‚Üê argmax ([B, i, j] : s1 √ó P(r))
end if
if r is of the form A ‚Üí B C then
chart[A, i, j] ‚Üê max (chart[B, i, k] √ó chart[C, k, j] √ó P(r))
bp[A, i, j] ‚Üê argmax ([B, i, k] : s1 √ó [C, k, j] : s2 √ó P(r))
end if
end for
end for
end for
return chart[S, 0, N], bp[S, 0, N]
end function
Figure 6: Generation procedure for the basic decoder.

respectively). Although this method is fast, i.e., linear in k, we would practically have to set k very
high and search among exponentially many possible generations for a given input.
A better solution, which is common practice in machine translation, is to rescore the derivation
trees online. Chiang (2007) intersects a PCFG grammar with a weighted finite state automaton
(FSA), which represents a n-gram language model; the states of the FSA correspond to n ‚àí 1 terminal symbols. The resulting grammar is also a PCFG that incorporates the FSA. Similarly, we can
intersect our grammar with an ensemble of external probabilistic models, provided that they express
a regular language. The most probable generation gÃÇ is then calculated as:


gÃÇ = f arg max p(g) ¬∑ p( g, h | d)
(5)
g,h

where p(g, h | d) is the decoding likelihood for a sequence of words g = g1 . . . gN of length N and
the hidden correspondence h that emits it, i.e., the likelihood of our grammar for a given database
input scenario d. p(g) is a measure of the quality of each output and could for instance be provided
by a language model (see Section 4.2 for details on how we estimate p(g, h | d) and p(g)). In theory,
the function f above should optimize h and g jointly, thus admitting no search errors. In practice,
however, the resulting grammar after the intersection is prohibitively large, and calls for pruning of
the search space. In the following we show how to extend the basic generation decoder in Figure 5
by intersecting it (linearly) with an ensemble of external probabilistic models.
319

KONSTAS & L APATA

S
PP

ADVP
RB

NP

IN

PP

NP

NP

IN

NNS

NNS

QP
CD CC CD
Cloudy with temperatures between

10

and

20

CD
10

CC
and

degrees

(a)
ROOT

RB
Cloudy

IN
with

NNS
temperatures

IN
between

CD
20

NNS
degrees

(b)

Figure 7: Phrase structure tree and dependency graph for the same sentence.

In addition to n-gram language models which are routinely used as a means of ensuring lexical fluency and some rudimentary grammaticality, we also inject syntactic knowledge into our
generator. We represent syntactic information in the form of directed dependencies which could
potentially capture long range relationships beyond the horizon of a language model. Figure 7
shows a dependency-style representation for the sentence ‚ÄúCloudy with temperatures between 10
and 20 degrees‚Äù and its corresponding phrase structure. The dependency graph in Figure 7b captures
grammatical relations between words via directed edges from syntactic heads to their dependents
(e.g., from a verb to its subject or from a noun to a modifying adjective). Edges can be labeled to
indicate the type of head-dependent relationship (e.g., subject or object) or unlabeled as shown in
the figure. Formally, a dependency structure D is a set of dependency pairs hwh , wa i of a head wh
and an argument word wa , respectively. In general, the argument is the modifier, object or complement; the head most of the times determines the behavior of the pair. In Figure 7b, cloudy is the
head of with, with is the head of temperature, and so on. D(wh ) returns a set of dependency pairs
whose head is wh , e.g., D(10) = {and, 20}.
Previous work (Ratnaparkhi, 2002) has incorporated dependency information into surface realization more directly by generating a syntactic dependency tree rather than a word sequence. The
underlying probabilistic model predicts each word by conditioning on syntactically related words
320

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

(i.e., parent, grandparent, and siblings). Importantly, this approach requires a corpus that has been
annotated with dependency tree structures. We obviate the need for manual annotation by considering dependency structures that have been induced automatically in an unsupervised fashion. For
this, we use the Dependency Model with Valence (DMV; Klein & Manning, 2004), however, there
is nothing inherent in our formulation that restricts us to this model. Any other unsupervised model
that learns dependency structures in a broadly similar fashion (e.g., captures the attachment likelihood of an argument to its head) could have been used instead with the proviso that it operates on
structures that are isomorphic to the derivation trees generated by our grammar. This is necessary
if the intersecting dependency model expresses (up to) a context-free language, since we formulate
our model also as a CFG5 .
Finally, note that although we work with two external information sources (i.e., language models
and dependencies), the framework we propose applies to an arbitrary number of models expressing
a regular language. For instance, we could incorporate models that capture dependencies relating to
content selection such as field n-grams, however we leave this to future work.
3.6 Extended Decoder
We begin by introducing some notation. We define two functions p and q which operate over M
surface-level models and strings a = a1 . . . al , of length l, with ai ‚àà V ‚à™ {?}. V is the vocabulary
of the observed text w (obtained from the training corpus), and the ? symbol represents the elided
part of a string. Recall that our k-best decoder needs to keep a list of generated sub-strings a at
each node, for rescoring purposes. Note that these sub-strings are (potentially) different from the
observed text w; the top-scoring string on the root node essentially collapses to the final generated
text g. Storing lists of whole sub-strings generated so far at each node, would require considerable
amounts of memory. To avoid this we define a function q(a) that stores the essential minimum
string information needed for each of the surface-level models (the ? symbol stands for the omitted
parts of a string) at each step, in order to correctly compute the rescoring weight. Function p(a)
essentially calculates the rescoring weight for a given string, by linearly interpolating the scores of
each individual model mi with a weight Œ≤i . Therefore applying p(a) in a bottom-up fashion (see the
extended decoder of Figure 8) on the output of q(a) allows us to correctly compute the rescoring
weight of each model for the whole document incrementally. More formally:
M

M

p(a) = ‚àë Œ≤i pmi (a)
i

s.t.

‚àë Œ≤i = 1

(6)

i

In our setting, we make use of a language model (pm1 ) and a dependency model (pm2 ):
pm1 (a1 . . . al ) =

PLM (ai |ai‚àín+1 . . . ai‚àí1 )

‚àè

(7)

n‚â§i‚â§l
?‚àà{a
/ i‚àín+1 ,...,ai }


pm2 (a1 . . . al ) = PDEP D(ah ) , where ah ‚àà {a1 , . . . , al }

(8)

The function pm1 computes the LM probabilities for all complete n-grams in a string; PLM returns
the probability of observing a word given the previous n‚àí1 words. pm2 returns the probability of the
5. Intersecting two CFGs is undecidable, or PSPACE-complete if one CFG is finite (Nederhof & Satta, 2004).

321

KONSTAS & L APATA

a1 . . . al
mostly cloudy ,
with a
mostly cloudy ? cloudy , with a

pm1 (a1 . . . al )
PLM (,|mostly cloudy)
1
PLM (with|cloudy ,) √ó PLM (a|, with)

qm1 (a1 . . . al )
mostly cloudy ? cloudy ,
with a
mostly cloudy ? with a

Table 2: Example values for functions pm1 and qm1 for the phrase ‚Äúmostly cloudy, with a‚Äù. We
assume a 3-gram language model.
dependency model on the dependency structure D headed by word ah . For a dependency structure D,
each word ah has dependants depsD (ah , le f t) that attach on its left and dependents depsD (ah , right)
that attach on its right. Equation (9) recursively defines the probability of the dependency D(ah )
rooted at ah (Klein & Manning, 2004):


PDEP D(ah ) =
‚àè
‚àè PSTOP (¬¨STOP|ah , dir, ad j)
dir‚àà[le f t,right] depsD (ah ,dir)

(9)


PCHOOSE (aa |ah , dir)PDEP D(aa )
PSTOP (STOP|ah , dir, ad j)

PSTOP is a binary multinomial indicating whether to stop attaching arguments to a head word ah
given their direction, i.e., left or right, and their adjacency, i.e., whether they are directly adjacent
to ah or not. PCHOOSE is a multinomial over all possible argument words given ah and the direction
of attachment. We next define function q(a) which returns a set of M strings, one for each model mi
(we will use it shortly to expand the lexical items [A, i, j] of the basic decoder in Figure 5).

q(a) = hqm1 (a), . . . , qmM (a)i

(10)
(11)

(
a1 . . . an‚àí1 ? al‚àín+2 . . . al
qm1 (a1 . . . al ) =
a1 . . . al

if l ‚â• n
otherwise

(12)
(13)

Ô£±
Ô£¥
al
if l = 1
Ô£¥
Ô£¥
Ô£¥
Ô£≤q (a . . . a )
if pm2 (a1 . . . ak ) ‚â•
m2 1
k
qm2 (a1 . . . ak ak+1 . . . al ) =
Ô£¥
pm2 (ak+1 . . . al )
1‚â§k‚â§l
Ô£¥
Ô£¥
Ô£¥
Ô£≥q (a . . . a ) otherwise
m2 k+1
l

(14)

Function qm1 (a) compresses the string a, by eliding words when all their n-grams have been
recognized. We thus avoid storing the whole sub-generation string, produced by the decoder so far,
as mentioned earlier. Table 2 gives example values for pm1 (a) and qm1 (a) for the phrase ‚Äúmostly
cloudy, with a. Function qm2 (a) returns the head of the string a. As we progressively combine substrings (a1 . . . ak ) and (ak+1 . . . al ) together, for any 1 ‚â§ k ‚â§ l, and their head words ah1 ‚àà {a1 , . . . , ak }
and ah2 ‚àà {ak+1 , . . . , al }, function qm2 (a) returns either ah1 or ah2 . The probability PDEP decides
whether ah1 attaches to ah2 or vice versa, thus augmenting D(ah1 ) with the pair hah1 , ah2 i or D(ah2 )
with hah2 , ah1 i, respectively.
322

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

j

Items:

[A, i, j; q(gi )]
R(A ‚Üí B)
R(A ‚Üí BC)

Axioms:

i+1
[W, i, i + 1; q(gi+1
i )] : s ¬∑ p(gi )

W ‚Üí gi+1 , gi+1 ‚àà {Œ±, gen()}

Inference rules:
j

(1)

R(A ‚Üí B) : s [B, i, j; q(gi )] : s1
j
j
[A, i, j; q(gi )] : s ¬∑ s1 ¬∑ p(gi )

(2)

R(A ‚Üí B C) : s [B, i, k; q(gki )] : s1 [C, k, j; q(gk )] : s2
j
j
[A, i, j; q(gi )] : s ¬∑ s1 ¬∑ s2 ¬∑ p(gi )

j

Goal:

[S, 0, N; q(hsin‚àí1 gN0 h/si)]

Figure 8: Extended decoder using the rescoring function p(g). Productions A ‚Üí B and A ‚Üí B C
can be any of the GCS rules in Figure 1; features on grammar non-terminals are omitted for the sake
of clarity.
Note that equation (14) evaluates whether every word should attach to the left or right of every
other head word, and therefore essentially collapses to:

Pmdep = PDEP D(ah ) = PSTOP (¬¨STOP|ah , dir, ad j)PCHOOSE (aa |ah , dir)
(15)
PSTOP (STOP|ah , dir, ad j)
For example, in the case of pm2 (a1 . . . ak ), ah becomes one of a1 . . . ak , aa is one of ak+1 . . . al ,
dir = right and ad j is true if ah = ak and aa = ak+1 .
We are now ready to extend the basic decoder in Figure 5, so that it includes the rescoring funcj
tion p(gi ) over a generated sub-string gi . . . g j . The new deduction system is specified in Figure 8.
j
Items [A, i, j] become now [A, i, j; q(gi )]; they represent derivations from gi to g j rooted at the nonterminal A and augmented with model-specific strings as defined above; in other words, they include
the compressed sub-generations
 with elidedN parts and their head word. Analogously, our goal item
n‚àí1
N
now includes q hsi g0 h/si . Note that g0 is augmented with (n ‚àí 1) start symbols hsi and an end
symbol h/si. This is necessary for correctly computing n-gram probabilities at the beginning and
end of the sentence. Figure 9 shows example instantiations of the inference rules of our extended
decoder.
The generation procedure is identical to the procedure described for the basic decoder in Figure 6, save the exponential more items that need to be deducted. Recall that the chart in Figure 6
stores at each cell chart[A, i, j] the set of combined weights of cells that correspond to the proved antecedents of item [A, i, j]. The new chart 0 for the extended decoder equivalently stores a set of lists
j
of weights at each cell position chart 0 [A, i, j]. The list contains the items [A, i, j; q(gi )] that have the
j
same root non-terminal A and span between i and j, but a different set q(gi ), sorted best-first. The
running time of integrating the LM and DMV models is O (N 3 |V |4(n‚àí1) |P|), where V is the output
vocabulary and P the vocabulary used in the DMV. When using a lexicalized dependency model,
323

KONSTAS & L APATA

R (R(skyCover1 .t) ‚Üí FS(temp1 , start) R(temp1 .t)) : s
[FS(temp1 , start), 1, 2; hwith, INi] : s1 [R(temp1 .t), 2, 8; ha low ? 15 degrees, JJi] : s2
[R(skyCover1 .t), 1, 8; hwith a ? 15 degrees, JJi] : s ¬∑ s1 ¬∑ s2 ¬∑ p(hwith a ? 15 degrees, JJi)
R (FS(windSpeed1 , min) ‚Üí F(windSpeed1 , max) FS(windSpeed1 , max)) : s
[F(windSpeed1 , max), 3, 4; hhigh, JJi] : s1 [FS(windSpeed1 , max), 4, 5; h15, CDi] : s2
[FS(windSpeed1 , min), 3, 5; hhigh 15, JJi] : s ¬∑ s1 ¬∑ s2
R (F(windDir1 , mode) ‚Üí W(windDir1 , mode)) : s [W(windDir1 , mode), 3, 4; hsoutheast, JJi] : s1
[F(windDir1 , mode), 3, 4; hsoutheast, JJi] : s ¬∑ s1
Figure 9: Inference rules in the extended decoder for productions (2), (4), and (7) from Table 1
(W EATHER G OV domain). The strings in h. . .i, correspond to the output of the functions qmlm
and qmdep . We adopt an unlexicalized dependency model, trained on POS tags derived from the
Penn Treebank project (Marcus et al., 1993). In the first example IN corresponds to the word with
and JJ to the word low, in the second example JJ corresponds to the word high and CD to the
number 15, whereas in the third example JJ corresponds to the word southeast.
P collapses to V , otherwise it contains the part-of-speech (POS) tags for every gi ‚àà V . Notice that
rule (2) in Figure 8 combines two items that contain at most 2(n ‚àí 1) words, hence the exponent
4(n ‚àí 2). This running time is too slow to use in practice, so as we explain below we must adopt
some form of pruning in order to be able to explore the search space efficiently.
3.7 Approximate Search
j

j

Consider the task of deriving a k-best list of items L([A, i, j; q(gi )]) for the deducted item [A, i, j; q(gi )]
j
of rule (2) in the extended decoder of Figure 8. An item Lm ([A, i, j; q(gi )]) at position m of the list,
j
with 1 ‚â§ m ‚â§ k, takes the form [A, i, j; q(gm |i )]. An example of this procedure is shown in Figure 10.
j
The grid depicts all possible combinations of items [B, i, k; q(gki )] and [C, k, j; q(gk )] as inferred by
a rule of the form R(A ‚Üí B C) with their corresponding weights. Any of the k2 combinations can
be used to create the resulting k-best list shown at the bottom of the figure, and store it on the cell
of chart 0 [A, i, j]. However, we only want to keep k items, so most of them are going to be pruned
away. In fact, the grid of the example can be in the worst case a cube, i.e., can hold up to two three
dimensions, one for all the rules A ‚Üí B C with the same left hand-side non-terminal A, and two for
the corresponding items rooted on B and C6 ; this calls for the calculation of k3 combinations. A
better approach is to apply cube pruning (Chiang, 2007; Huang & Chiang, 2005), i.e., to compute
only a small corner of the grid and prune items out on the fly, thus obviating the costly computation
of all k3 combinations.
6. The deducted item [R(skyCover1 .t); q(g81 )] of Figure 10 can also be inferred by the rule R(R(skyCover1 .t) ‚Üí
R(windSpeed1 .t) FS(windSpeed1 , start)) (and its corresponding antecedent items) or the rule R(R(skyCover1 .t) ‚Üí
R(rainChance1 .t) FS(rainChance1 , start)), and so on. We illustrate only a slice of the cube, depicting the enumeration of k-best lists for a fixed grammar rule, for the sake of clarity.

324

[FS(temp1 , start), 1, 2; hwith, INi]

[FS(temp1 , start), 1, 2; ha, DTi]

[FS(temp1 , start), 1, 2; haround, RBi]

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

.95

.93

.91

[R(temp1 .t), 2, 8; ha low ? 15 degrees, JJi] .56

.40

.25

.20

[R(temp1 .t), 2, 8; hlow around ? 15 degrees, JJi] .54

.35

.30

.17

[R(temp1 .t), 2, 8; ha low ? around 17, RBi] .44

.15

.08

.10

‚áí

Ô£´
Ô£¨
Ô£¨
Ô£¨
Ô£¨
Ô£¨
Ô£¨
Ô£≠

[R(skyCover1 .t), 1, 8; hwith a ? 15 degrees, JJi
[R(skyCover1 .t), 1, 8; hwith low ? 15 degrees, JJi]
[R(skyCover1 .t), 1, 8; ha a ? 15 degrees, JJi]
[R(skyCover1 .t), 1, 8; haround low ? 15 degrees, RBi]
[R(skyCover1 .t), 1, 8; hwith a ? around 17, RBi]
¬∑¬∑¬∑

: .40
: .35
: .25
: .17
: .15

Ô£∂
Ô£∑
Ô£∑
Ô£∑
Ô£∑
Ô£∑
Ô£∑
Ô£∏

Figure 10: Computing an exhaustive list for the deducted item [R(skyCover1 .t); q(g81 )] via application of inference rule (2) of the extended decoder in Figure 9. The antecedent items are
the rule R (R(skyCover1 .t) ‚Üí R(temp1 .t) FS(temp1 , start)) and the items [R(temp1 .t), 2, 8; q(g82 )],
FS(temp1 , start), 1, 2; q(g21 )]. The figure shows a slice of the cube, for the particular rule; on each
side of the grid are the lists of the top three candidate items for each antecedent item, sorted bestfirst. Numbers in the grid represent the total score for each combination.

Consider Figure 11 as an example. Each side of the grid shows the lists of the top three items
for each antecedent item. Numbers on the grid represent the total score for each combination.
Figures 11b‚Äì11d illustrate the enumeration of the top three combinations in best-first order. Cells
in gray represent the frontiers at each iteration; cells in black are the resulting top three items. The
basic intuition behind cube pruning is that for a pair of antecedent items u1 = [B, i, k; q(gki )], u2 =
j
[C, k, j; q(gk )] and their sorted k-best lists L(u1 ), L(u2 ), the best combinations should lie close to the
upper-left corner of the grid. In the example, the 3-best list of the nodes u1 = [R(temp1 .t), 2, 8; q(g82 )]
325

[FS(temp1 , start), 1, 2; hwith, INi]

[FS(temp1 , start), 1, 2; ha, DTi]

[FS(temp1 , start), 1, 2; haround, RBi]

[FS(temp1 , start), 1, 2; hwith, INi]

[FS(temp1 , start), 1, 2; ha, DTi]

[FS(temp1 , start), 1, 2; haround, RBi]

[FS(temp1 , start), 1, 2; hwith, INi]

[FS(temp1 , start), 1, 2; ha, DTi]

[FS(temp1 , start), 1, 2; haround, RBi]

KONSTAS & L APATA

.95

.93

.91

.95

.93

.91

.95

.93

.91

[R(temp1 .t), 2, 8; ha low ? 15 degrees, JJi] .56

.40

.25

.20

.40

.25

.20

.40

.25

.20

[R(temp1 .t), 2, 8; hlow around ? 15 degrees, JJi] .54

.35

.30

.17

.35

.30

.17

.35

.30

.17

[R(temp1 .t), 2, 8; ha low ? around 17, RBi] .44

.15

.08

.10

.15

.08

.10

.15

.08

.10

(a)

(b)

(c)

Figure 11:
Computing item combinations for u1 = [R(temp1 .t), 2, 8; q(g82 )] and
u2 = [FS(temp1 , start), 1, 2; q(g21 )] using cube pruning. In (a)‚Äì(c) we enumerate the combinations of items in order to construct a resulting k-best list as described in the text.
and u2 = [FS(temp1 , start), 1, 2; q(g21 )] are:
h
i
L(u1 ) = ha low ? 15 degrees, JJi, hlow around ? 15 degrees, JJi, ha low ? around 17, RBi
h
i
L(u2 ) = hwith, INi, ha, DTi, haround, RBi
and intuitively the best combination should be the derivation on the top left corner7 :

 

L1 (u1 ), L1 (u2 ) = ha low ? 15 degrees, JJi, hwith, INi = hwith a ? 15 degrees, INi
In cases where the combination cost, i.e., the score of the grammar rule multiplied with the
rescoring weight p(g), is negligible, we could start enumerating item combinations in the order shown in Figures 11b‚Äì11c, starting from (L1 (u1 ), L1 (u2 )) and stopping at k. Since the two
lists are sorted it is guaranteed that L2 (u1 ), i.e., the second item in the k-best list of u1 is either
(L1 (u1 ), L2 (u2 )) or (L2 (u1 ), L1 (u2 )) (in the example of Figure 11b it is the latter). We thus select
it and move on to compute its neighboring combinations, and so on.8 For the computation of the
k-best lists of the axioms [W, i, i + 1; q(gii+1 )], we enumerate the top-k terminal symbols gi+1 .
If we take into account the combination cost, the grid is non-monotonic, and therefore the bestfirst guarantee no longer holds as we enumerate neighbors in the fashion just described. Huang
and Chiang (2007) argue that the loss incurred by the search error is insignificant compared to the
speedup gained. In any case, to overcome this, we compute the resulting k-best list, by first adding
7. Note that the head of the sub-generation fragment has shifted to the head of L2 .
8. Contrary to Huang and Chiang (2007) we use probabilities instead of log scores in the computation of the item
combinations, hence we select the biggest scoring combinations.

326

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

the computed item combinations in a temporary buffer, and then resort it after we have enumerated
a total of k combinations.
3.8 Learning
We represent our grammar and each input scenario as a weighted hypergraph (Gallo, Longo, Pallottino, & Nguyen, 1993). We follow the procedure proposed by Klein and Manning (2001) which
allows to transform any CFG to a hypergraph. In order to learn the weights of the grammar rules
we directly estimate them on the hypergraph representation using the EM algorithm. Formally, the
objective we are trying to optimize factorizes into:
P(r, ri .f, w|d) = ‚àè P(ri |d) ‚àè P(ri . f j |ri ) ‚àè P(w j |ri . f j , ri )
i

j

(16)

k

where r is the set of all record tokens ri . Given a training set of scenarios with database records d
and observed text w we maximize the marginal likelihood of the data, while summing out record
tokens ri and their fields ri .f, which can be regarded as latent variables:
arg max
Œ∏

‚àè ‚àë p(r, ri .f, w|d; Œ∏),

(17)

(w,d) r,ri .f

where Œ∏ are the multinomial distributions or weights of GGEN . The EM algorithm alternates between
the E-step and the M-step. In the E-step we compute the expected counts for the rules using a
dynamic program similar to the inside-outside algorithm (Li & Eisner, 2009). Then in the M-step,
we optimise Œ∏ by normalising the counts computed in the E-step. We initialise EM with a uniform
distribution for each multinomial distribution and applied add-0.001 smoothing to each multinomial
in the M-step. On average, EM converged for all datasets after 15 iterations. Note that the n-gram
language model and the dependency model are trained externally, hence their parameters are not
optimized alongside our model. The generation procedure for the extended decoder in Figure 8 is
implemented using dynamic programming. The choice of the hypergraph representation is merely
one of several alternatives. For example, we could have adopted a representation based on weighted
finite state transducers (de Gispert, Iglesias, Blackwood, Banga, & Byrne, 2010) since our model
describes a regular language both in terms of the PCFG and the surface level models we intersect
it with. It is also possible to represent our grammar as a pushdown automaton (Iglesias, Allauzen,
Byrne, de Gispert, & Riley, 2011) and intersect it with finite automata representing a language model
and dependency-related information, respectively. The choice of the hypergraph representation was
motivated by its compactness9 and the fact that it allows for future extensions of our PCFG with
rules which capture more global aspects of the generation problem (e.g., document planning) and
which unavoidably result in context-free languages.

4. Experimental Design
In this section we present our experimental setup for assessing the performance of our model. We
give details on the datasets we used, explain how our own model was trained, describe the models
used for comparison with our approach, and discuss how system output was evaluated.
9. Hypergraphs are commonly used in the machine translation literature to allow for compact encoding of SCFGs
even though in some cases they also describe regular languages. For example, this is true for the SCFGs employed
in hierarchical phrase-based SMT (Chiang, 2007) which assume a finite input language and do not permit infinite
recursions.

327

KONSTAS & L APATA

4.1 Data
We used our system to generate soccer commentaries, weather forecasts, and spontaneous utterances relevant to the air travel domain (examples are given in Figure 1). For the first domain we
used the dataset described in the work of Chen and Mooney (2008), which consists of 1,539 scenarios from the 2001‚Äì2004 Robocup game finals (henceforth ROBO C UP). Each scenario contains
on average |d| = 2.4 records, each paired with a short sentence (5.7 words). This domain has a
small vocabulary (214 words) and simple syntax (e.g., a transitive verb with its subject and object).
Records in this dataset were aligned manually to their corresponding sentences (Chen & Mooney,
2008). Given the relatively small size of this dataset, we performed cross-validation following previous work (Chen & Mooney, 2008; Angeli et al., 2010). We trained our system on three ROBO C UP
games and tested on the fourth, averaging over the four train/test splits.
For weather forecast generation, we used the dataset presented in the work of Liang et al. (2009),
which consists of 29,528 weather scenarios for 3,753 major US cities (collected over four days). The
vocabulary in this domain (henceforth W EATHER G OV) is comparable to ROBO C UP (345 words),
however, the texts are longer (N = 29.3) and more varied. On average, each forecast has 4 sentences
and the content selection problem is more challenging; only 5.8 out of the 36 records per scenario
are mentioned in the text which roughly corresponds to 1.4 records per sentence. We used 25,000
scenarios from W EATHER G OV for training, 1,000 scenarios for development and 3,528 scenarios
for testing. This is the same partition used in the work of Angeli et al. (2010).
For the air travel domain we used the ATIS dataset (Dahl, Bates, Brown, Fisher, Hunicke-Smith,
Pallett, Pao, Rudnicky, & Shriberg, 1994), consisting of 5,426 scenarios. These are transcriptions
of spontaneous utterances of users interacting with a hypothetical online flight booking system.
We used the dataset introduced in the work of Zettlemoyer and Collins (2007)10 and automatically converted their lambda-calculus expressions to attribute-value pairs following the conventions adopted in the study of Liang et al. (2009).11 Figure 1c shows the output of our conversion process from the original lambda expression Œªx. f light(x) ‚àß f rom(x, denver) ‚àß to(x, boston) ‚àß
day number departure(x, 9) ‚àß month departure(x, august)‚àß < (arrival time(x), 16:00). Given
such an expression, we first create a record for each variable (e.g., x). We then assign record types
according to the corresponding class types (e.g., variable x has class type flight). Next, fields and
values are added from predicates with two arguments with the class type of the first argument matching that of the record type. The name of the predicate denotes the field, and the second argument
denotes the value (e.g., f rom(x, denver) is used to fill the record of type Flight, since the type of
the first argument is also f light). The name of the function becomes the field name, (i.e., from) and
the second argument is set as its value, (i.e., denver). Note that some functions have names such as
month departure, month arrival, day number arrival, day number departure and so on. In order
to reduce the resulting number of record types, we created aggregate record types which embed
the common information (i.e., departure, or arrival) to a special field. In the example, the function
day number departure is split into the value departure of the field dep/ar for the record Day, and
into the field number with value 9. We also defined special record types, such as Condition and
Search. The latter is introduced for every lambda operator and assigned the categorical field what
with value flight which refers to the record type of variable x.
10. The original corpus contains user utterances of single dialogue turns which would result in trivial scenarios. Zettlemoyer and Collins (2007) concatenate all user utterances referring to the same dialogue act, (e.g., book a flight), thus
yielding more complex scenarios with longer sentences.
11. See Konstas (2013) for the resulting dataset.

328

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

In contrast to the two previous datasets, ATIS has a much richer vocabulary (927 words); each
scenario corresponds to a single sentence (average length is 11.2 words) with 2.65 out of 19 record
types mentioned on average. Note that the original lambda expressions were created based on
the utterance, and thus contain all the necessary information conveyed in the meaning of the text.
As a result, all of the converted records in each scenario are mentioned in the corresponding text.
Following the work of Zettlemoyer and Collins (2007), we trained on 4,962 scenarios and tested on
ATIS NOV93 which contains 448 examples.
4.2 Model Training
Generation in our model amounts to finding the best derivation (gÃÇ, h) that maximizes the product
of two likelihoods, namely p(g, h | d) and p(g) (see equation (5)). p(g, h | d) corresponds to the
rules of GGEN that generate the word sequence g, whereas p(g) is the likelihood of g independently
of d. We estimate p(g, h | d) as described in Section 3.8. Examples of the top scoring items of the
multinomial distributions for some of the grammar rules of GGEN are given in Table 3. We obtain
an estimate for p(g) by linearly interpolating the score of a language model and DMV (Klein &
Manning, 2004).
Specifically, our language models were trained with the SRI toolkit (Stolcke, 2002) using add-1
smoothing.12 For the ROBO C UP domain, we used a bigram language model given that the average
text length is relatively small. For W EATHER G OV and ATIS, we used a trigram language model.
We obtained an unlexicalized version of the DMV13 for each of our domains. All datasets were
tagged automatically using the Stanford POS tagger (Toutanova, Klein, Manning, & Singer, 2003)
and words were augmented with their part of speech, e.g., low becomes low/JJ, around becomes
around/RB and so on; words with several parts of speech were duplicated as many times as the
number of different POS tags assigned to them by the tagger. For example, the gust may act both
as a noun and a verb, given their context, hence we keep both augmented forms, i.e., gust/NNS and
gust/VBS. We initialized EM to uniform distributions where a small amount of noise14 was added
over all multinomials (i.e., PSTOP and PCHOOSE ) to break initial symmetry. Klein and Manning (2004)
use a harmonic distribution instead, where the probability of one word heading another is higher
if they appear closer to one another. Preliminary results on the development set showed that the
former initialization scheme was more robust across datasets.
Our model has two hyperparameters: the number of k-best derivations considered by the decoder and the vector Œ≤ of weights for model integration. Given that we only interpolate two models whose weights should sum to one, we only need to modulate a single interpolation parameter 0 ‚â§ Œ≤LM ‚â§ 1. When Œ≤LM is 0, the decoder is only influenced by the DMV and conversely when
Œ≤LM is 1 the decoder is only influenced by the language model. In the general case, we could learn
the interpolation parameters using minimum error rate training (Och, 2003), however this was not
necessary in our experiments. We performed a grid search over k and Œ≤LM on held-out data taken
12. Adopting a more complex smoothing technique such as Good-Turing (Good, 1953) is usually not applicable in so
small vocabularies. The statistics for computing the so called count-of-counts, i.e., the number words occurring once,
twice and so on, are not sufficient and lead to poor smoothing estimates.
13. When trained on the WSJ-10 corpus, our implementation of the DMV obtained the same accuracy as reported in
the work of Klein and Manning (2004). WSJ-10 consists of 7,422 sentences with at most 10 words after removing
punctuation.
14. Repeated runs with different random noise on the WSJ-10 corpus yielded the same results; accuracy stabilized around
the 60th iteration (out of 100).

329

KONSTAS & L APATA

Weight Distribution
P(Œ± | pass, from, purple2)
P(Œ± | steal, null, NULL)
P(Œ± | turnover, null, NULL)

Top-5 scoring items
purple2, a, makes, pink10, short
ball, the, steals, from, purple8
to, the, ball, kicks, loses

(a) ROBO C UP

Weight Distribution
P(ri .t | temperature)
P(ri .t | windSpeed)
P(ri .t | skyCover)
P( fi | temperature.time)
P( fi | windSpeed.min)
P( fi | gust.max)
P(Œ± | skyCover, percent, 0-25)
P(Œ± | skyCover, percent, 25-50)
P(Œ± | rainChance, mode, Definitely)

Top-5 scoring items
windDir, sleetChance, windSpeed,
freezingRainChance, windChill
gust, null, precipPotential,
windSpeed, snowChance
temperature, skyCover, thunderChance,
null, rainChance
min, max, mean, null, time
max, time, percent, mean, null
min, mean, null, time, max
‚Äú,‚Äù, clear, mostly, sunny, mid
‚Äú,‚Äù, cloudy, partly, clouds, increasing
rain, of, and, the, storms

(b) W EATHER G OV

Weight Distribution
P(ri .t | search)
P(ri .t | flight)
P(ri .t | day)
P(Œ± | flight, to, mke)
P(Œ± | search, what, flight)
P(Œ± | search, type, query)

Top-5 scoring items
flight, search, when, day, condition
search, day, flight, month, condition
when, search, flight, month, condition
mitchell, general, international, takeoffs, depart
I, a, like, to, flight
list, the, me, please, show
(c) ATIS

Table 3: Top-5 scoring items of the multinomial distributions for record rules, field rules and the
categorical word rewrite rule of GGEN (see rules (2), (4), and (8) in Table 1, respectively). The first
column of each table shows the underlying multinomial distribution for the corresponding rule. For
example P(Œ± | pass, from, purple2), corresponds to the distribution of emitting word Œ± given the
value purple2 of the field from of the record with type pass.

from W EATHER G OV, ROBO C UP, and ATIS, respectively. The optimal values for k and Œ≤LM for the
three domains (when evaluating system performance with BLEU-4) are shown in Table 4.
We conducted two different tuning runs, one for a version of our model that only takes the LM
into account (k- BEST- LM; Œ≤LM = 1) and another one where the LM and the DMV are integrated
(k- BEST- LM - DMV). As can be seen, optimal values for k are generally larger for k- BEST- LM - DMV.
This is probably due to noise introduced by the DMV; as a result, the decoder has to explore the
search space more thoroughly. In an effort to investigate the impact of the DMV further, we fixed
330

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

k- BEST- LM
ROBO C UP
W EATHER G OV
ATIS

k
25
15
40

(a) Interpolation with LM

k- BEST- LM - DMV
ROBO C UP
W EATHER G OV
ATIS

k
85
65
40

Œ≤LM
0.9
0.3
0.6

(b) Interpolation with LM and DMV

Table 4: Optimal values for parameters k and Œ≤LM calculated by performing grid search against
BLEU-4 on the development set. Œ≤LM in Table (a) is set to 1.

Œ≤LM = 0 on the development set and performed a grid search with the DMV on its own. Model
performance dropped significantly (by 5‚Äì8% BLEU points) which is not entirely surprising given
that the DMV alone cannot guarantee fluent output. Its contribution rather rests on capturing more
global dependencies outwith the local horizon of the language model.
4.3 Determining the Output Length
Unlike other generation systems that operate on the surface realization level with word templates,
we emit each word individually in a bottom-up fashion. Therefore, we need to decide on the number
of words N we wish to generate before beginning the decoding process. A common approach is to
fix N to the average text length of the training set (Banko, Mittal, & Witbrock, 2000). However, this
would not be a good choice in our case, since text length does not follow a normal distribution. As
shown in Figure 12 the distribution of N across domains is mostly skewed.
To avoid making unwarranted assumptions about our output, we trained a linear regression
model that determines the text length individually for each scenario. As input to the model, we
used a flattened version of the database, with features being record-field pairs. The underlying idea
is that if a scenario contains many records and fields, then we should use more words to express
them. In contrast, if the number of records and fields is small, then it is likely that the output is more
laconic. In an attempt to capture the number of words needed to communicate specific record-field
pairs, we experimented with different types of feature values, e.g., by setting a feature to its actual
value (categorical or numerical) or its frequency in the training data. The former scheme worked
better in denser datasets, such as W EATHER G OV and ROBO C UP whereas the latter was adopted
in ATIS which has a sparser database, as a means to smooth out infrequent values. When trained
on the training set and tested on the development set our regression model obtained a correlation
coefficient of 0.64 for ROBO C UP, 0.84 for W EATHER G OV, and 0.73 for ATIS (using Pearson‚Äôs r).
4.4 System Comparison
We evaluated three configurations of our system. A baseline that uses the top scoring derivation in
each subgeneration (1- BEST) and two versions of our model that make better use of our decoding
algorithm. One version integrates the k-best derivations with a LM (k- BEST- LM), the other version additionally takes the DMV into account (k- BEST- LM - DMV). Preliminary experiments with a
model that integrates the k-best derivations with the DMV did not exhibit satisfactory results (see
Section 4.2) and we omit them here for the sake of brevity. We compared the output of our models to
331

KONSTAS & L APATA

6000

700
600
500
400
300
200
100

Frequency

Frequency

7000
5000
4000
3000
200
1000
3 5 7 9 11 13 15 17

9

(a) Text length N in ROBO C UP

21 33 45 57 69 81

(b) Text length N in W EATHER G OV

Frequency

2400
2000
1600
1200
800
400
2

6 10 14 18 22 26 30 34 38 44 48
(c) Text length N in ATIS

Figure 12: Text length distribution in ROBO C UP, W EATHER G OV, and ATIS (training set).
Angeli et al. (2010) whose approach is closest to ours and state-of-the-art on the W EATHER G OV.15
For ROBO C UP, we also compared against the best-published results (Kim & Mooney, 2010).
4.5 Evaluation
We evaluated system output automatically, using the BLEU-4 modified precision score (Papineni,
Roukos, Ward, & Zhu, 2002) with the human-written text as reference. In addition, we evaluated
the generated text via a judgment elicitation study. Participants were presented with a scenario and
its corresponding verbalization and were asked to rate the latter along two dimensions: fluency
(is the text grammatical and overall understandable?) and semantic correctness (does the meaning
conveyed by the text correspond to the database input?). The subjects used a five point rating scale
where a high number indicates better performance. We randomly selected 12 documents from the
test set (for each domain) and generated output with our models (1- BEST and k- BEST- LM - DMV) and
Angeli et al.‚Äôs (2010) model. We also included the original text (H UMAN) as gold standard. We thus
15. We are grateful to Gabor Angeli for providing us with the code of his system.

332

F IXED

J OINT

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

System
1- BEST
k- BEST- LM
k- BEST- LM - DMV
1- BEST
k- BEST- LM
k- BEST- LM - DMV
A NGELI
K IM -M OONEY

BLEU
8.01.
24.88‚àó
23.14‚àó
10.79.‚ó¶‚Ä†
30.90‚àó‚Ä†
29.73‚àó‚Ä†
28.70‚àó‚Ä†
47.27‚àó.‚ó¶

System
1- BEST
k- BEST- LM
k- BEST- LM - DMV
A NGELI

BLEU
8.64.‚ó¶
33.70‚àó‚ó¶
34.18‚àó.‚ó¶
38.40‚àó.

(b) W EATHER G OV

System
1- BEST
k- BEST- LM
k- BEST- LM - DMV
A NGELI

BLEU
11.85.‚ó¶
29.30‚àó
30.37‚àó‚ó¶
28.70‚àó

(c) ATIS

(a) ROBO C UP

Table 5: BLEU-4 scores on ROBO C UP, W EATHER G OV, and ATIS (‚àó : significantly different from
1- BEST; ‚ó¶ : significantly different from A NGELI; . significantly different from k- BEST- LM;  : significantly different from k- BEST- LM - DMV; ‚Ä† : significantly different from K IM -M OONEY.
obtained ratings for 48 (12 √ó 4) scenario-text pairs for each domain. The study was conducted over
the Internet using Amazon Mechanical Turkand involved 305 volunteers (104 for ROBO C UP, 101
for W EATHER G OV, and 100 for ATIS), all self reported native English speakers. Our experimental
instructions are given in Appendix A.

5. Results
We conducted two experiments on the ROBO C UP domain. We first assessed the performance of
our generator on joint content selection and surface realization and obtained the results shown in
the upper half of Table 5a (see J OINT). In a second experiment we forced the generator to use the
gold-standard records from the database. This was necessary in order to compare with previous
work (Angeli et al., 2010; Kim & Mooney, 2010).16 Our results are summarized in lower half of
Table 5a (see F IXED).
Overall, our generator performs better than the 1- BEST baseline and comparably to Angeli et al.
(2010). k- BEST- LM - DMV is slightly worse than k- BEST- LM. This is due to the fact that sentences
in ROBO C UP are very short (their average length is 5.7 words) and as a result our model cannot
recover any meaningful dependencies. Using the Wilcoxon signed-rank test we find that differences
in BLEU scores among k- BEST- LM - DMV, k- BEST- LM and A NGELI are not statistically significant. Kim and Mooney (2010) significantly outperform these three models and the 1- BEST baseline
(p < 0.01). This is not entirely surprising, however, as their model requires considerable more
supervision (e.g., during parameter initialization) and includes a post-hoc re-ordering component.
Finally, we also observe a substantial increase in performance compared to the joint content selection and surface realization setting. This is expected as the generator is faced with an easier task
and there is less scope for error.
With regard to W EATHER G OV, our model (k- BEST- LM and k- BEST- LM - DMV) significantly improves over the 1- BEST baseline (p < 0.01) but lags behind Angeli et al. (2010) and the difference is
16. Angeli et al. (2010) and Kim and Mooney (2010) fix content selection both at the record and field level. We let our
generator select the appropriate fields, since these are at most two per record type and this level of complexity can be
easily tackled during decoding.

333

KONSTAS & L APATA

F1 (%)

BLEU-4 (%)

100
90
80
70
60
50
40
30
20
10
5 000 10 000 15 000 20 000 25 000
Number of training scenarios

50
45
40
35
30
25
20
15
10
5
5 000 10 000 15 000 20 000 25 000
Number of training scenarios

(a) Alignment

(b) Generation output

Figure 13: Learning curves displaying how the quality of the alignments and generated output vary
as a function of the size of the training data.

statistically significant (p < 0.01). Since our system emits words based on a language model rather
than a template, it displays more freedom in word order and lexical choice, and thus is likelier to
produce more creative output, sometimes even overly distinct compared to the reference. Dependencies seem to play a more important role here, yielding overall better performance.17 Interestingly,
k- BEST- LM - DMV is significantly better than k- BEST- LM in this domain (p < 0.01). Sentences in
W EATHER G OV are longer than in ROBO C UP and this allows the k- BEST- LM - DMV to learn dependencies that capture information complementary to the language model.
On ATIS, the k- BEST- LM - DMV model significantly outperforms the 1- BEST (p < 0.01) and
A NGELI (p < 0.05), whereas k- BEST- LM performs comparably. Furthermore, k- BEST- LM - DMV is
significantly better than k- BEST- LM (p < 0.01). The ATIS domain is the most challenging with
respect to surface realization. The vocabulary is larger than ROBO C UP by a factor of 4.3 and
W EATHER G OV by a factor of 2.7. Because of the increased vocabulary the model learns richer
dependencies which improve its fluency and overall performance.
We also examined the amount of training data required by our model. We performed learning
experiments on W EATHER G OV since it contains more training scenarios than ROBO C UP and ATIS
and is more challenging with regard to content selection. Figures 13(a) and (b) show how the number of training instances influnces the quality of the alignment and generation output, respectively.
We measure alignment F-score following the methodology outlined in the work of Liang et al.
(2009) using their gold alignments. The graphs show that 5,000 scenarios are enough for obtaining
reasonable alignments and generation output. A very small upward trend can be detected with increasing training instances, however it seems that considerably larger amounts would be required to
obtain noticeable improvements.
17. DMV is commonly trained on a sentence-by-sentence basis. In the ROBO C UP and ATIS datasets, each scenario-text
pair corresponds to a single sentence. In W EATHER G OV, however, the text may include multiple sentences. In
the latter case we trained the DMV on the multi-sentence text without presegmenting it into individual sentences.
This non-standard training regime did not seem to pose any difficulty in this domain, as we can safely assume that
all examples have the same elided root head, namely ‚Äúweather‚Äù (e.g., The weather is mostly cloudy, with a low
around 30).

334

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

System
1- BEST
k- BEST- LM - DMV
A NGELI
H UMAN

ROBO C UP
F
SC
‚Ä†‚ó¶
2.14
2.09‚Ä†‚ó¶
‚àó
4.05
3.55‚àó‚Ä†
‚àó
4.01
3.47‚àó‚Ä†
4.17‚àó
3.97‚àó‚ó¶

W EATHER G OV
F
SC
‚Ä†‚ó¶
2.25
2.53‚Ä†‚ó¶
‚àó
3.89
3.54‚àó
‚àó
3.82
3.72‚àó
4.01‚àó
3.58‚àó

ATIS
F
2.40‚Ä†‚ó¶
3.96‚àó
3.86‚àó
4.16‚àó

SC
2.49‚Ä†‚ó¶
3.82‚àó‚ó¶
3.31‚àó‚Ä†
3.96‚àó‚ó¶

Table 6: Mean ratings for fluency (F) and semantic correctness (SC) on system output elicited by
humans on ROBO C UP, W EATHER G OV, and ATIS (‚àó : significantly different from 1- BEST; ‚ó¶ : significantly different from A NGELI;  : significantly different from k- BEST- LM - DMV; ‚Ä† : significantly
different from H UMAN).
The results of our human evaluation study are shown in Table 6. We report mean ratings for each
system and the gold-standard human authored text. Our experimental participants rated the output
on two dimensions, namely fluency (F) and semantic correctness (SC). We elicited judgments only
for k- BEST- LM - DMV as it generally performed better than k- BEST- LM in our automatic evaluation
(see Table 5). We carried out an Analysis of Variance (A NOVA) to examine the effect of system
type (1- BEST, k- BEST- LM - DMV, A NGELI, and H UMAN) on the fluency and semantic correctness
ratings. We used Tukey‚Äôs Honestly Significant differences (HSD) test, as explained by Yandell
(1997) to assess whether means differences are statistically significant.
On all three domains our system (k- BEST- LM - DMV) is significantly better than the 1- BEST baseline (a < 0.01) in terms of fluency. Our output is indistinguishable from the gold-standard (H UMAN)
and A NGELI (pair-wise differences among k- BEST- LM - DMV, A NGELI and H UMAN are not statistically significant). With respect to semantic correctness, on ROBO C UP, k- BEST- LM - DMV is significantly better than 1- BEST (a < 0.01) but significantly worse than H UMAN (a < 0.01). Although
the ratings for k- BEST- LM - DMV are numerically higher than A NGELI, the difference is not statistically significant. A NGELI is also significantly worse than H UMAN (a < 0.01). On W EATHER G OV,
the semantic correctness of k- BEST- LM - DMV and A NGELI is not significantly different. These two
systems are also indistinguishable from H UMAN. On ATIS, k- BEST- LM - DMV is the best performing model with respect to semantic correctness. It is significantly better than 1- BEST and A NGELI
(a < 0.01) but not significantly different from H UMAN.
In sum, we observe that performance improves when k-best derivations are taken into account
(the 1- BEST system is consistently worse). Our results also show that taking dependency-based
information into account boosts model performance over and above what can be achieved with a
language model. Our model is on par with A NGELI on ROBO C UP and W EATHER G OV but performs
better on ATIS when evaluated both automatically and by humans. Error analysis suggests that a
reason for A NGELI‚Äôs poorer performance on ATIS might be its inability to create good quality
surface templates. This is due to the lack of sufficient data and the fact that templates cannot
fully express the same database configurations in many different ways. This is especially true for
ATIS which consists of transcriptions of spontaneous spoken utterances and the same meaning can
be rendered in many different ways. For example, the phrases ‚Äúshow me the flights‚Äù, ‚Äúwhat are
the flights‚Äù, ‚Äúwhich flights‚Äù, and ‚Äúplease can you give me the flights‚Äù, all convey the exact same
meaning stemming from a Search record.
Our model learns domain specific conventions about ‚Äúhow to say‚Äù and ‚Äúwhat to say‚Äù from data,
without any hand-engineering or manual annotation. Porting the system to a different domain is
335

KONSTAS & L APATA

Bad Pass
Input:
1- BEST:
k- BEST- LM - DMV:

from
to
pink11 purple5
pink11 pass purple5 purple5 pink11 pass purple5 purple5 purple5
pink11 made a pass that was intercepted by purple5

A NGELI:

pink11 made a bad pass that missed its target and was picked up by
purple5

H UMAN:

pink11 tries to pass but was intercepted by purple5
(a) ROBO C UP

Input:

1- BEST:
k- BEST- LM - DMV:

Temperature

Cloud Sky Cover

time
min mean max
06:00-21:00 32 39 46

time
percent (%)
06:00-21:00
75-100

Wind Speed

Wind Direction

time
min mean max
06:00-21:00 6
7
10

time
mode
06:00-21:00 SE

Near 46. Near 46. Near 46. Near 46. Near 46. With near 46. Southeast wind.
Mostly cloudy, with a high near 46. South southeast wind between 6 and 10 mph.

A NGELI :

A chance of rain or drizzle, with a high near 46. Southeast wind between 6
and 10 mph. mph. Chance of precipitation is 60%.

H UMAN:

Mostly cloudy, with a high near 46. South southeast wind between 6 and 10 mph.
(b) W EATHER G OV

Input:
1- BEST:
k- BEST- LM - DMV:

Flight

Day

Search

from
to
milwaukee phoenix

day
dep/ar/ret
saturday departure

type what
query flight

Milwaukee Phoenix on Saturday on Saturday on Saturday on Saturday
Show me the flights from Milwuakee to Phoenix on Saturday

A NGELI :

Show me the flights between Milwuakee and Phoenix on Saturday

H UMAN:

Milwuakee to Phoenix on Saturday
(c) ATIS

Figure 14: Example output on (a) sportscasting, (b) weather forecasting, and (c) air travel domains
with correct content selection.

straightforward, assuming a database and corresponding (unaligned) text. As long as the database
obeys the structure of the grammar GGEN , we need only retrain the model to obtain the weights of
the grammar rules; in addition, the system requires a domain specific language model and optionally
336

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

Gold:

Output:

Temperature

Cloud Sky Cover

Chance of Rain

time
min mean max
06:00-21:00 30 38 44

time
percent (%)
06:00-21:00
75-100

Time
Mode
06:00-21:00 Slight Chance

Wind Speed

Wind Direction

Precipitation Potential (%)

time
min mean max
06:00-21:00 6
6
7

time
mode
06:00-21:00 ENE

time
min mean max
06:00-21:00 9 20 35

A 40 percent chance of showers before 10am. Mostly cloudy, with a high
near 44. East northeast wind around 7 mph.
(a) Gold standard content selection and its verbalization

Content
Selection:

Output:

Temperature

Cloud Sky Cover

Chance of Rain

time
min mean max
06:00-21:00 30 38 44

time
percent (%)
06:00-21:00
75-100

time
mode
06:00-09:00 Chance

Wind Speed

Wind Direction

Chance of Thunderstorm

time
min mean max
06:00-21:00 6
6
7

time
mode
06:00-21:00 ENE

time
mode
06:00-13:00 -13:00-21:00 --

A chance of showers. Patchy fog before noon. Mostly cloudy, with a
high near 44. East wind between 6 and 7 mph.
(b) k- BEST- LM - DMV content selection

Content
Selection:

Output:

Temperature

Precipitation Potential (%)

Chance of Rain

time
min mean max
06:00-21:00 30 38 44

time
min mean max
06:00-21:00 9 20 35

time
mode
06:00-09:00 Chance

Wind Speed

Wind Direction

Chance of Thunderstorm

time
min mean max
06:00-21:00 6
6
7

time
mode
06:00-21:00 ENE

time
mode
06:00-21:00 --

A chance of showers. Patchy fog before noon. Mostly cloudy, with a high
near 44. East wind between 6 and 7 mph. Chance of precipitation is 35%
(c) A NGELI content selection

Figure 15: Example output on W EATHER G OV domain with incorrect content selection (in gray).

337

KONSTAS & L APATA

ROOT
on
on

show

on

me

on

from
Phoenix
Phoenix

show me the flights from Milwaukee to Phoenix on Saturday
Figure 16: Dependency structure for the sentence Show me the flights from Milwaukee to Phoenix
on Sunday as generated by k- BEST- LM - DMV (see Figure 14c). Intermediate nodes in the tree denote
the head words of each subtree.

information about heads and their dependents which the DMV learns in an unsupervised fashion.
In the latter case, we also need to tune the hyperparameter Œ≤LM , and in both cases k. Note, that
fine-tuning k becomes less important when integrating with a language model only. As we explain
in Section 4.2, the DMV possibly introduces noise, therefore we have to modulate k more carefully
so as to allow the decoder to search in a bigger space.
Examples of system output with correct content selection at the record level are given in Figure 14. Note that in the case of ROBO C UP, content selection is fixed to the gold standard. As can
be seen, the generated text is close to the human authored text. Also note that the output of our
system improves considerably when taking k-best derivations into account (compare 1- BEST and
k- BEST- LM - DMV in the figure). Figure 15a shows examples with incorrect content selection at the
record level for the W EATHER G OV domain. Figure 15a shows the gold standard content selection
and its corresponding verbalization. Figures 15b and 15c show the output of the k- BEST- LM - DMV
system and A NGELI. Tables in black denote record selection identical to the gold standard, whereas
tables in grey denote false positive recall. k- BEST- LM - DMV identifies an incorrect value for the
Mode field in the Chance of Rain record; in addition, it fails to select the Precipitation Potential (%) record altogether. The former mistake does not affect the correctness of the generator‚Äôs
output, whereas the latter does (i.e., it fails to mention the exact likelihood of rain, 40% in the gold
standard and 35% in A NGELI‚Äôs output). Finally, Figure 16 shows the dependency structure our
model produced for the sentence Show me the flights from Milwaukee to Phoenix on Saturday from
Figure 14c; notice the long range dependency between flights and on, which would otherwise be
inaccessible to a language model.
338

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

6. Conclusions
We have presented an end-to-end generation system that performs content selection and surface
realization simultaneously. Central to our approach is the encoding of generation as a parsing problem. We reformulate the input (a set of database records and text describing some of them) as a
PCFG and show how to approximately find the best generated string licensed by the grammar. We
evaluated our model on three domains (ROBO C UP, W EATHER G OV, ATIS) and showed that it is
able to obtain performance comparable or superior to the state-of-the-art. Our experiments were
also designed to assess several aspects of the proposed framework such as the use of k-best decoding and the intersection of our grammar with multiple information sources. We observed that k-best
decoding is essential to producing good quality output. Across domains, performance increases by
a factor of at least two when multiple derivations are taken into account. In addition, intersecting
the grammar with dependency-based information seems to capture syntactic information complementary to the language model. We argue that our approach is computationally efficient and viable
in practical applications. Outwith generation, we hope that some of the work described here might
be of relevance to other fields such as summarization or machine translation.
Future extensions are many and varied. An obvious extension concerns porting the framework
to more challenging domains with richer vocabulary and longer texts (e.g., product descriptions,
user manuals, sports summaries). A related question is how to extend the PCFG-based approach
advocated here so as to capture discourse-level document structure. Other future directions involve
exploiting the information available in the database more directly. Our model takes into account
the k-best derivations at decoding time, however inspection of these indicates that it often fails to
select the best one. Initial work (Konstas & Lapata, 2012) shows that the model presented here
can be adapted to use forest reranking, a technique that approximately reranks a packed forest of
exponentially many derivations (Huang, 2008). The reranker is essentially a structured perceptron
(Collins, 2002) enriched with local and non-local features. It therefore allows to explicitly model
dependencies across fields, records, and their interactions.
Finally, although not the focus of this paper, it is worth pointing out that the model described
here can also perform semantic parsing, i.e., convert text into a formal meaning representation. This
can be done trivially by modifying the grammar in Table 1. Instead of observing words as terminals
(rules (8) and (9)), we observe values of fields, given a particular word w, field, and record:
W(r, r. f ) ‚Üí f .v

[P( f .v | r, r. f , f .t, w)]

W(r, r. f ) ‚Üí gen(w)

[P(gen(w).mode | r, r. f , f .t=int)]

During decoding, the prior p(g) in equation (4) becomes p( f .v) and can be naively obtained by
creating an n-gram language model over the alignments between the meaning representations and
the text. Such alignments are in principle hidden but could be estimated using the model of Liang
et al. (2009).

Acknowledgments
We are grateful to the anonymous referees whose feedback helped to substantially improve the
present paper. Thanks to Luke Zettlemoyer and Tom Kwiatkowski for their help with the ATIS
dataset as well as Giorgio Satta and Frank Keller for helpful comments and suggestions. We also
339

KONSTAS & L APATA

thank the members of the Probabilistic Models reading group at the University of Edinburgh for their
feedback. A preliminary version of this work was published in the proceedings of NAACL 2012.

Appendix A. Experimental Instructions
A.1 Instructions
In this experiment you will be given tables that contain some facts about the weather (e.g., Temperature, Chance of Rain, Wind Direction, Cloud Coverage and so on) and their translation in
natural language. Example 1 below tabulates such weather related information and its translation as
Rainy with a high near 47. Windy, with an east wind between 5 and 15 mph.
Example 1
Category

Temperature

Fields

time: 17.00‚Äì06.00(+1 day) min: 30

mean: 40 max: 47

Wind Direction time: 17.00‚Äì06.00(+1 day) mode: SE
Cloud Sky Cover time: 17.00‚Äì06.00(+1 day) percent: 25‚Äì50
Chance of Rain time: 17.00‚Äì21.00

mode: Likely

Rainy with a high near 47. Windy , with an east wind between 5 and 15 mph.
Each row in the table contains a different weather-related event. The first row talks about temperature, the second one about wind direction, etc. Different event types instantiate different fields.
For example, Temperature has four fields, time, min, mean, and max. Fields in turn have values,
which can be either numbers (e.g., 47 degrees Fahrenheit for the event Temperature), or words (e.g.,
Likely or Slight Chance for the event Chance of Rain).
More specifically, you should read the above table as follows. For Temperature, the field time
and its value 17.00-06.00(+1 day) refers to temperatures measured between 5pm and 6am of the
following day. The minimum temperature recorded for that time period is 30 degrees Fahrenheit
(field min), the maximum is 47 degrees (field max) and on average the temperature is 40 degrees
(field mean). For the same time period, the wind will blow from a south east direction (the mode of
Wind Direction is SE). 25‚Äì50% of the sky will be covered with clouds (see field percent with value
25-50 in Cloud Sky Cover), which may be interpreted as a slightly cloudy outlook. Finally, from
5pm to 9pm it is likely to rain, as indicated by the mode field and its value Likely for the Chance
of Rain event.
Note that all temperature values are in the Fahrenheit scale. The Fahrenheit scale is an alternative
temperature scale to Celsius, proposed in 1724 by the physicist Daniel Gabriel Fahrenheit. The
formula that converts Fahrenheit degrees to Celsius is [F] = [C] √ó 59 + 32. So, for instance, ‚àí1 C =
30 F. Also note, the measure of speed used throughout the experiment is miles per hour, mph for
short.
All natural language translations have been generated by a computer program. Your task is to
rate the translations on two dimensions, namely Fluency and Semantic Correctness on a scale from
340

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

1 to 5. As far as Fluency is concerned, you should judge whether the translation is grammatical and
in well-formed English or just gibberish. If the translation is grammatical, then you should rate it
high in terms of fluency. If there is a lot of repetition in the translation or if it seems like word salad,
then you should give it a low number.
Semantic Correctness refers to the meaning conveyed by the translation and whether it corresponds to what is reported in the tabular data. In other words, does the translation convey the same
content as the table or not? If the translation has nothing to do with the categories, fields or values
described in the table, you should probably give it a low number for Semantic Correctness. If the
translation captures most of the information listed in the table, then you should give it a high number. Bear in mind that slight numerical deviations are normal and should not be penalized (e.g., it is
common for weather forecasters to round wind speed values to the closest 5, i.e., ‚Äò50 mph‚Äô instead
of ‚Äò47 mph‚Äô).
A.2 Rating Examples
In Example 1, you would probably give the translation a high score for Fluency (e.g., 4 or 5), since
it is coherent and does not contain any grammatical errors. However, you should give it a low
score for Semantic Correctness (e.g., 1‚Äì3), because it conveys information that is not in the table.
For example, ‚Äòwindy‚Äô and ‚Äòwind between 5 and 15 mph ‚Äô both relate to wind speed but are not
mentioned in the table. Let us now consider the following example:
Example 2
Category

Fields

Temperature

time: 17.00‚Äì06.00(+1 day) min: 40

mean: 45 max: 50

Wind Direction time: 17.00‚Äì06.00(+1 day) mode: S
Wind Speed

time: 17.00‚Äì 06.00(+1 day) min: 5

mean: 7 max: 15

Cloud Sky Cover time: 17.00‚Äì06.00(+1 day) percent: 0‚Äì25
Sunny, with a low around 40. South wind between 5 and 15 mph.
Here, you should give the translation high scores on both dimensions, namely Fluency and Semantic Correctness. The text is grammatical and succinctly describes the content of the table. For
example, 4 or 5 would be appropriate numbers.
Example 3
Category

Fields

Temperature

time: 17.00‚Äì06.00(+1 day) min: 30

mean: 40 max:47

Wind Direction time: 17.00‚Äì06.00(+1 day) mode: ESE
Around 40. Around 40. Around 40. East wind.
341

KONSTAS & L APATA

In example 3, the translation scores poorly on Fluency and Semantic Correctness. The text has
many repetitions and there is no clear correspondence between the translation and the table. ‚Äòaround
40 ‚Äô probably refers to the temperature, but it is not at all clear from the context of the text. ‚Äòeast
wind ‚Äô again refers to wind direction, but it is missing a verb or a preposition that would relate it to
the weather outlook. Appropriate scores for both dimensions would be 1 or 2.
Finally, while judging the translation pay attention to the values of the fields in the table in
addition to the event categories. For example, you may have an event Chance of Rain with a value
None in the mode field. This means that it is not likely to rain, and you should penalize any mention
of rain in the text, unless there is another event Chance of Rain for a different time period with a
different value in the mode field.
A.3 Rating Procedure
Before you start the experiment below you will be asked to enter your personal details. Next, you
will be presented with 15 table-translation pairs to evaluate in the manner described above. You will
be shown one pair at a time. Once you finish with your rating, click the button at the bottom right
to advance to the next response.
Things to remember:
‚Ä¢ If you are unsure how to rate a translation, click on the top right of your window the Help
link. You may also leave it open during the course of the experiment as a reference.
‚Ä¢ Higher numbers represent a positive opinion of the translation and lower numbers a negative
one.
‚Ä¢ Do not spend too long analyzing the translations; you should be able to rate them once you
have read them for the first time.
‚Ä¢ There is no right or wrong answer, so use your own judgment when rating each translation.
A.4 Personal Details
As part of the experiment we will ask you for a couple of personal details. This information will
be treated confidentially and will not be made available to a third party. In addition, none of your
responses will be associated with your name in any way. We will ask you to supply the following
information.
‚Ä¢ Your name and email address.
‚Ä¢ Your age and sex.
‚Ä¢ To specify, under ‚ÄôLanguage Region‚Äô, the place (city, region/state/province, country) where
you have learnt your first language.
‚Ä¢ To enter the code provided at the end of the experiment into the Mechanical Turk HIT.
342

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

References
Amazon Mechanical Turk (2012). Retrieved from https://www.mturk.com..
Angeli, G., Liang, P., & Klein, D. (2010). A simple domain-independent probabilistic approach
to generation. In Proceedings of the 2010 Conference on Empirical Methods in Natural
Language Processing, pp. 502‚Äì512, Cambridge, MA.
Banko, M., Mittal, V. O., & Witbrock, M. J. (2000). Headline generation based on statistical translation. In Proceedings of Association for Computational Linguistics, pp. 318‚Äì325, Hong Kong.
Barzilay, R., & Lapata, M. (2005). Collective content selection for concept-to-text generation. In
Proceedings of Human Language Technology and Empirical Methods in Natural Language
Processing, pp. 331‚Äì338, Vancouver, British Columbia.
Belz, A. (2008). Automatic generation of weather forecast texts using comprehensive probabilistic
generation-space models. Natural Language Engineering, 14(4), 431‚Äì455.
Charniak, E., & Johnson, M. (2005). Coarse-to-fine n-best parsing and maxent discriminative
reranking. In Proceedings of the 43rd Annual Meeting of the Association for Computational
Linguistics, pp. 173‚Äì180, Ann Arbor, Michigan.
Chen, D. L., & Mooney, R. J. (2008). Learning to sportscast: A test of grounded language acquisition. In Proceedings of International Conference on Machine Learning, pp. 128‚Äì135,
Helsinki, Finland.
Chiang, D. (2007). Hierarchical phrase-based translation. Computational Linguistics, 33(2), 201‚Äì
228.
Collins, M. (2002). Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms. In Proceedings of the 2002 Conference on Empirical
Methods in Natural Language Processing, pp. 1‚Äì8, Philadelphia, Pennsylvania.
Dahl, D. A., Bates, M., Brown, M., Fisher, W., Hunicke-Smith, K., Pallett, D., Pao, C., Rudnicky,
A., & Shriberg, E. (1994). Expanding the scope of the ATIS task: the ATIS-3 corpus. In
Proceedings of the Workshop on Human Language Technology, pp. 43‚Äì48, Plainsboro, New
Jersey.
Dale, R., Geldof, S., & Prost, J.-P. (2003). Coral: Using natural language generation for navigational
assistance. In Proceedings of the 26th Australasian Computer Science Conference, pp. 35‚Äì44,
Adelaide, Australia.
de Gispert, A., Iglesias, G., Blackwood, G., Banga, E. R., & Byrne, W. (2010). Hierarchical phrasebased translation with weighted finite-state transducers and shallow-n grammars. Computational Linguistics, 36(3), 505‚Äì533.
Duboue, P. A., & McKeown, K. R. (2002). Content planner construction via evolutionary algorithms
and a corpus-based fitness function. In Proceedings of International Natural Language Generation, pp. 89‚Äì96, Ramapo Mountains, NY.
Gallo, G., Longo, G., Pallottino, S., & Nguyen, S. (1993). Directed hypergraphs and applications.
Discrete Applied Mathematics, 42, 177‚Äì201.
Goldberg, E., Driedger, N., & Kittredge, R. (1994). Using natural-language processing to produce
weather forecasts. IEEE Expert, 9(2), 45‚Äì53.
343

KONSTAS & L APATA

Good, I. J. (1953). The population frequencies of species and the estimation of population parameters. Biometrika, 40(3/4), pp. 237‚Äì264.
Goodman, J. (1999). Semiring parsing. Computational Linguistics, 25(4), 573‚Äì605.
Green, N. (2006). Generation of biomedical arguments for lay readers. In Proceedings of the 5th
International Natural Language Generation Conference, pp. 114‚Äì121, Sydney, Australia.
Huang, L. (2008). Forest reranking: Discriminative parsing with non-local features. In Proceedings
of ACL-08: HLT, pp. 586‚Äì594, Columbus, Ohio.
Huang, L., & Chiang, D. (2005). Better k-best parsing. In Proceedings of the 9th International
Workshop on Parsing Technology, pp. 53‚Äì64, Vancouver, British Columbia.
Huang, L., & Chiang, D. (2007). Forest rescoring: Faster decoding with integrated language models.
In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics,
pp. 144‚Äì151, Prague, Czech Republic.
Iglesias, G., Allauzen, C., Byrne, W., de Gispert, A., & Riley, M. (2011). Hierarchical phrase-based
translation representations. In Proceedings of the 2011 Conference on Empirical Methods
in Natural Language Processing, pp. 1373‚Äì1383, Edinburgh, Scotland, UK. Association for
Computational Linguistics.
Kasami, T. (1965). An efficient recognition and syntax analysis algorithm for context-free languages. Tech. rep. AFCRL-65-758, Air Force Cambridge Research Lab, Bedford, Massachusetts.
Kim, J., & Mooney, R. (2010). Generative alignment and semantic parsing for learning from ambiguous supervision. In Proceedings of the 23rd Conference on Computational Linguistics,
pp. 543‚Äì551, Beijing, China.
Klein, D., & Manning, C. (2004). Corpus-based induction of syntactic structure: Models of dependency and constituency. In Proceedings of the 42nd Meeting of the Association for Computational Linguistics, pp. 478‚Äì485, Barcelona, Spain.
Klein, D., & Manning, C. D. (2001). Parsing and hypergraphs. In Proceedings of the 7th International Workshop on Parsing Technologies, pp. 123‚Äì134, Beijing, China.
Konstas, I. (2013). ATIS dataset retrieved from http://homepages.inf.ed.ac.uk/ikonstas/
index.php?page=resources..
Konstas, I., & Lapata, M. (2012). Concept-to-text generation via discriminative reranking. In
Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics:
Human Language Technologies, pp. 369‚Äì378, Jeju, South Korea.
Li, Z., & Eisner, J. (2009). First- and second-order expectation semirings with applications to
minimum-risk training on translation forests. In Proceedings of the 2009 Conference on
Empirical Methods in Natural Language Processing, pp. 40‚Äì51, Suntec, Singapore.
Liang, P., Bouchard-CoÃÇteÃÅ, A., Klein, D., & Taskar, B. (2006). An end-to-end discriminative approach to machine translation. In Proceedings of the 21st International Conference on Computational Linguistics and the 44th Annual Meeting of the Association for Computational
Linguistics, pp. 761‚Äì768, Sydney, Australia.
344

A G LOBAL M ODEL FOR C ONCEPT- TO -T EXT G ENERATION

Liang, P., Jordan, M., & Klein, D. (2009). Learning semantic correspondences with less supervision.
In roceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th
International Joint Conference on Natural Language Processing of the AFNLP, pp. 91‚Äì99,
Suntec, Singapore.
Lu, W., & Ng, H. T. (2011). A probabilistic forest-to-string model for language generation from
typed lambda calculus expressions. In Proceedings of the 2011 Conference on Empirical
Methods in Natural Language Processing, pp. 1611‚Äì1622, Edinburgh, Scotland, UK.
Marcus, M. P., Marcinkiewicz, M. A., & Santorini, B. (1993). Building a large annotated corpus of
English: the Penn treebank. Comput. Linguist., 19(2), 313‚Äì330.
Nederhof, M.-J., & Satta, G. (2004). The language intersection problem for non-recursive contextfree grammars. Information and Computation, 192(2), 172 ‚Äì 184.
Och, F. J. (2003). Minimum error rate training in statistical machine translation. In Proceedings
of the Annual Meeting on Association for Computational Linguistics, pp. 160‚Äì167, Sapporo,
Japan.
Papineni, K., Roukos, S., Ward, T., & Zhu, W.-J. (2002). Bleu: a method for automatic evaluation of machine translation. In Proceedings of 40th Annual Meeting of the Association for
Computational Linguistics, pp. 311‚Äì318, Philadelphia, Pennsylvania.
Ratnaparkhi, A. (2002). Trainable approaches to surface natural language generation and their
application to conversational dialog systems. Computer Speech & Language, 16(3-4), 435‚Äì
455.
Reiter, E., & Dale, R. (2000). Building natural language generation systems. Cambridge University
Press, New York, NY.
Reiter, E., Sripada, S., Hunter, J., & Davy, I. (2005a). Choosing words in computer-generated
weather forecasts. Artificial Intelligence, 167, 137‚Äì169.
Reiter, E., Sripada, S., Hunter, J., Yu, J., & Davy, I. (2005b). Choosing words in computer-generated
weather forecasts. Artificial Intelligence, 167, 137‚Äì169.
Shieber, S. M., Schabes, Y., & Pereira, F. C. N. (1995). Principles and implementation of deductive
parsing. Logic Programming, 24, 3‚Äì36.
Sripada, S. G., Reiter, E., Hunter, J., & Yu, J. (2003). Generating English summaries of time series
data using the gricean maxims. In Proceedings of the Ninth ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining, pp. 187‚Äì196. ACM Press.
Stolcke, A. (2002). SRILM ‚Äì an extensible language modeling toolkit. In Hansen, J. H. L., &
Pellom, B. L. (Eds.), Proceedings of the 7th International Conference on Spoken Language
Processing, pp. 901‚Äì904, Denver, Colorado. ISCA.
Toutanova, K., Klein, D., Manning, C. D., & Singer, Y. (2003). Feature-rich part-of-speech tagging
with a cyclic dependency network. In Proceedings of the 2003 Conference of the North
American Chapter of the Association for Computational Linguistics on Human Language
Technology - Volume 1, pp. 173‚Äì180, Edmonton, Canada.
Turner, R., Sripada, Y., & Reiter, E. (2009). Generating approximate geographic descriptions. In
Proceedings of the 12th European Workshop on Natural Language Generation, pp. 42‚Äì49,
Athens, Greece.
345

KONSTAS & L APATA

Wong, Y. W., & Mooney, R. (2007). Generation by inverting a semantic parser that uses statistical
machine translation. In Proceedings of the Human Language Technology and the Conference
of the North American Chapter of the Association for Computational Linguistics, pp. 172‚Äì
179, Rochester, NY.
Yandell, B. S. (1997). Practical Data Analysis for Designed Experiments. Chapman & Hall/CRC.
Younger, D. H. (1967). Recognition and parsing for context-free languages in time n3 . Information
and Control, 10(2), 189‚Äì208.
Zettlemoyer, L., & Collins, M. (2007). Online learning of relaxed CCG grammars for parsing to
logical form. In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural
Language Processing and Computational Natural Language Learning, pp. 678‚Äì687, Prague,
Czech Republic.

346

Journal of Artificial Intelligence Research 48 (2013) 115‚Äì174

Submitted 11/12; published 10/13

Taming the Infinite Chase: Query Answering
under Expressive Relational Constraints
Andrea Calƒ±ÃÄ

andrea@dcs.bbk.ac.uk

Department of Computer Science and Information Systems
University of London, Birkbeck College, UK

Georg Gottlob

georg.gottlob@cs.ox.ac.uk

Department of Computer Science
University of Oxford, UK

Michael Kifer

kifer@cs.stonybrook.edu

Department of Computer Science
Stony Brook University, USA

Abstract
The chase algorithm is a fundamental tool for query evaluation and for testing query
containment under tuple-generating dependencies (TGDs) and equality-generating dependencies (EGDs). So far, most of the research on this topic has focused on cases where the
chase procedure terminates. This paper introduces expressive classes of TGDs defined via
syntactic restrictions: guarded TGDs (GTGDs) and weakly guarded sets of TGDs (WGTGDs). For these classes, the chase procedure is not guaranteed to terminate and thus may
have an infinite outcome. Nevertheless, we prove that the problems of conjunctive-query
answering and query containment under such TGDs are decidable. We provide decision
procedures and tight complexity bounds for these problems. Then we show how EGDs
can be incorporated into our results by providing conditions under which EGDs do not
harmfully interact with TGDs and do not affect the decidability and complexity of query
answering. We show applications of the aforesaid classes of constraints to the problem of
answering conjunctive queries in F-Logic Lite, an object-oriented ontology language, and
in some tractable Description Logics.

1. Introduction
This paper studies a simple yet fundamental rule-based language for ontological reasoning
and query answering: the language of tuple-generating dependencies (TGDs). This formalism captures a wide variety of logics that so far were considered unrelated to each other:
the OWL-based languages EL (Baader, Brandt, & Lutz, 2005) and DL-Lite (Calvanese,
De Giacomo, Lembo, Lenzerini, & Rosati, 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009) on the one hand and object-based languages like F-Logic Lite (Calƒ±ÃÄ &
Kifer, 2006) on the other. The present paper is a significant extension of our earlier work
(Calƒ±ÃÄ, Gottlob, & Kifer, 2008), which has since been applied in other contexts and gave rise
to the Datalog¬± family (Calƒ±ÃÄ, Gottlob, & Pieris, 2011) of ontology languages. The present
paper focuses on the fundamental complexity results underlying one of the key fragments
of this family. Subsequent work has focused on the study of various special cases of this
formalism (Calƒ±ÃÄ, Gottlob, & Lukasiewicz, 2012a), their complexity, and extensions based on
other paradigms (Calƒ±ÃÄ, Gottlob, & Pieris, 2012b).
c
2013
AI Access Foundation. All rights reserved.

Calƒ±ÃÄ, Gottlob & Kifer

Our work is also closely related to the work on query answering and query containment (Chandra & Merlin, 1977), which are central problems in database theory and knowledge representation and, in most cases, are reducible to each other. They are especially
interesting in the presence of integrity constraints‚Äîor dependencies, in database parlance.
In databases, query containment has been used for query optimization and schema integration (Aho, Sagiv, & Ullman, 1979; Johnson & Klug, 1984; Millstein, Levy, & Friedman,
2000), while in knowledge representation it is often used for object classification, schema
integration, service discovery, and more (Calvanese, De Giacomo, & Lenzerini, 2002; Li &
Horrocks, 2003).
A practically relevant instance of the containment problem was first studied by Johnson and Klug (1984) for functional and inclusion dependencies and later by Calvanese,
De Giacomo, and Lenzerini (1998). Several additional decidability results were obtained by
focusing on concrete applications. For instance, the work by Calƒ±ÃÄ and Martinenghi (2010)
considers constraints arising from Entity-Relationship diagrams, while that by Calƒ±ÃÄ and
Kifer (2006) considers constraints derived from a relevant subset of F-logic (Kifer, Lausen,
& Wu, 1995), called F-Logic Lite.
Some literature studies variants or subclasses of tuple-generating dependencies (TGDs)
for the purpose of reasoning and query answering. A TGD is a Horn-like rule with existentially-quantified variables in the head. Some early works on this subject dubbed the resulting
language Datalog with value invention (Mailharrow, 1998; Cabibbo, 1998). More formally,
a TGD ‚àÄX‚àÄYŒ¶(X, Y) ‚Üí ‚àÉZŒ®(X, Z) is a first-order formula, where Œ¶(X, Y) and Œ®(X, Z)
are conjunctions of atoms, called body and head of the TGD, respectively. A TGD is satisfied by a relational instance B if whenever the body of the TGD is satisfied by B then
B also satisfies the head of the TGD. It is possible to enforce a TGD that is not satisfied
by adding new facts to B so that the head, and thus the TGD itself, will become satisfied.
These new facts will contain labeled null values (short: nulls) in the positions corresponding
to variables Z. Such nulls are similar to Skolem constants. The chase of a database D in
the presence of a set Œ£ of TGDs is the process of iterative enforcement of all dependencies
in Œ£, until a fixpoint is reached. The result of such a process, which we also call chase,
can be infinite and, in this case, this procedure cannot be used without modifications in
decision algorithms. Nevertheless, the result of a chase serves as a fundamental theoretical
tool for answering queries in the presence of TGDs (Calƒ±ÃÄ, Lembo, & Rosati, 2003a; Fagin,
Kolaitis, Miller, & Popa, 2005) because it is representative of all models of D ‚à™ Œ£.
In the present paper, we do not focus on a specific logical theory. Instead, we tackle
the common issue of the possibly non-terminating chase underlying several of the earlier
studies, including the works by Johnson and Klug (1984), by Calƒ±ÃÄ and Martinenghi (2010),
and by Calƒ±ÃÄ and Kifer (2006). All these works study constraints in the language of TGDs
and equality-generating dependencies (EGDs) using the chase technique, and all face the
problem that the chase procedure might generate an infinite result. We deal with this
problem in a much more general way by carving out a very large class of constraints for
which the infinite chase can be ‚Äútamed‚Äù, i.e., modified so that it would become a decision
procedure for query answering.
In Section 3, we define the notions of sets of guarded TGDs (GTGDs) and of weakly
guarded sets of TGDs (WGTGDs). A TGD is guarded if its body contains an atom called
116

Taming the Infinite Chase

guard that covers all variables occurring in the body. WGTGDs generalize guarded TGDs
by requiring guards to cover only the variables occurring at so-called affected positions
(predicate positions that may contain some labeled nulls generated during the chase). Note
that inclusion dependencies (or IDs) can be viewed as trivially guarded TGDs. The importance of guards lies in Theorem 3.5, which shows that there is a fixed set Œ£u of GTGDs plus
a single non-guarded TGD, such that query evaluation under Œ£u is undecidable. However,
we show that for WGTGDs the (possibly infinite) result of the chase has finite treewidth
(Theorem 3.14). We then use this result together with well-known results about the generalized tree-model property (Goncalves & GraÃàdel, 2000; GraÃàdel, 1999) to show that evaluating
Boolean conjunctive queries is decidable for WGTGDs (and thus also for GTGDs). Unfortunately, this result does not directly provide useful complexity bounds.
In Section 4, we show lower complexity bounds for conjunctive query answering under
weakly guarded sets of TGDs. We prove, by Turing machine simulations, that query evaluation under weakly guarded sets of TGDs is exptime-hard in case of a fixed set of TGDs,
and 2exptime-hard in case the TGDs are part of the input.
In Section 5, we address upper complexity bounds for query answering under weakly
guarded sets of TGDs. Let us first remark that showing D ‚à™ Œ£ |= Q is equivalent to
showing that the theory T = D ‚à™ Œ£ ‚à™ {¬¨Q} is unsatisfiable. Unfortunately, T is in general
not guarded because Q is not and because WGTGDs are generally non-guarded first-order
sentences (while GTGDs are). Therefore, we cannot (as one might think at first glance)
directly use known results on guarded logics (Goncalves & GraÃàdel, 2000; GraÃàdel, 1999) to
derive complexity results for query evaluation. We thus develop completely new algorithms
by which we prove that the problem in question is exptime-complete in case of bounded
predicate arities and, even in case the TGDs are fixed, 2exptime-complete in general.
In Section 6, we derive complexity results for reasoning with GTGDs. In the general
case, the complexity is as for WGTGDs but, interestingly, when reasoning with a fixed set
of dependencies (which is the usual setting in data exchange and in description logics), we
get much better results: evaluating Boolean queries is np-complete and is in ptime in case
the query is atomic. Recall that Boolean query evaluation is np-hard even in case of a
simple database without integrity constraints (Chandra & Merlin, 1977). Therefore, the
above np upper bound for general Boolean queries is optimal, i.e., there is no class of TGDs
for which query evaluation (or query containment) is more efficient.
In Section 7, we describe a semantic condition on weakly guarded sets of TGDs. We
prove that whenever a set of WGTGDs fulfills this condition, answering Boolean queries is
in np, and answering atomic queries, as well as queries of bounded treewidth, is in ptime.
Section 8 extends our results to the case of TGDs with multiple-atom heads. The
extension is trivial for all cases except for the case of bounded predicate arity.
Section 9 deals with equality generating dependencies (EGDs), a generalization of functional dependencies. Unfortunately, as shown in works by Chandra and Vardi (1985),
Mitchell (1983), Johnson and Klug (1984), Koch (2002), and Calƒ±ÃÄ et al. (2003a), query answering and many other problems become undecidable in case we admit both TGDs and
EGDs. It remains undecidable even if we mix the simplest class of guarded TGDs, namely,
inclusion dependencies, with the simplest type of EGDs, namely functional dependencies,
and even key dependencies (Chandra & Vardi, 1985; Mitchell, 1983; Johnson & Klug, 1984;
Calƒ±ÃÄ et al., 2003a). In Section 9, we present a sufficient semantic condition for decidabil117

Calƒ±ÃÄ, Gottlob & Kifer

BCQ type
GTGDs WGTGDs
general
2exptime 2exptime
atomic or fixed 2exptime 2exptime
Query answering for variable TGDs.
BCQ type
GTGDs
general
np
atomic or fixed
ptime
Query answering for fixed

WGTGDs
exptime
exptime
TGDs.

BCQ type
GTGDs WGTGDs
general
exptime
exptime
atomic or fixed exptime
exptime
Query answering for fixed predicate arity.
Figure 1: Summary of results. All complexity bounds are tight.
ity of query-answering under sets of TGDs and general EGDs. We call EGDs innocuous
when, roughly speaking, their application (i.e., enforcement) does not introduce new atoms,
but only eliminates atoms. We show that innocuous EGDs can be essentially ignored for
conjunctive query evaluation and query containment testing.
The TGD-based ontology languages in this paper are part of the larger family of ontology
languages called Datalog¬± (Calƒ±ÃÄ et al., 2011). Our results subsume the main decidability
and np-complexity result by Johnson and Klug (1984), the decidability and complexity
results on F-Logic Lite by Calƒ±ÃÄ and Kifer (2006), and those on DL-Lite as special cases. In
fact, Section 10 shows that our results are even more general than that.
The complexity results of this paper, together with some of their immediate consequences, are summarized in Figure 1, where all complexity bounds are tight. Notice that
the complexity in the case of fixed queries and fixed TGDs is the so-called data complexity,
i.e., the complexity with respect to the data only, which is of particular interest in database
applications. The complexity for variable Boolean conjunctive queries (BCQs) and variable
TGDs is called combined complexity. It is easy to see (but we will not prove it formally
for all classes) that all complexity results for atomic or fixed queries extend to queries
of bounded width, where by width we mean treewidth or even hypertree width (Gottlob,
Leone, & Scarcello, 2002)‚Äîsee also the works by Adler, Gottlob, and Grohe (2007), and
by Gottlob, Leone, and Scarcello (2001).

2. Preliminaries
In this section we define the basic notions that we use throughout the paper.
2.1 Relations, Instances and Queries
A relational schema R is a set of relational predicates, each having an arity‚Äîa non-negative
integer that represents the number of arguments the predicate takes. We write r/n to say
118

Taming the Infinite Chase

that a relational predicate r has arity n. Given an n-ary predicate r ‚àà R, a position r[k],
where 1 6 k 6 n, refers to the k-th argument of r. We will assume an underlying relational
schema R and postulate that all queries and constraints use only the predicates in R. The
schema R will sometimes be omitted when it is clear from the context or is immaterial.
We introduce the following pairwise disjoint sets of symbols: (i) A (possibly infinite) set
‚àÜ of data constants, which constitute the ‚Äúnormal‚Äù domain of the databases over the schema
R; (ii) a set ‚àÜN of labeled nulls, i.e., ‚Äúfresh‚Äù Skolem constants; and (iii) an infinite set ‚àÜV of
variables, which are used in queries and constraints. Different constants represent different
values (unique name assumption), while different nulls may represent the same value. We
also assume a lexicographic order on ‚àÜ ‚à™ ‚àÜN , with every labeled null in ‚àÜN following all
constant symbols in ‚àÜ. Sets of variables (or sequences, when the order is relevant) will
be denoted by X, i.e., X = X1 , . . . , Xk , for some k. The notation ‚àÉX is a shorthand for
‚àÉX1 . . . ‚àÉXk , and similarly for ‚àÄX.
An instance of a relational predicate r/n is a (possibly infinite) set of atomic formulas (atoms) of the form r(c1 , . . . , cn ), where {c1 , . . . , cn } ‚äÜ ‚àÜ ‚à™ ‚àÜN . Such atoms are also
called facts. When the fact r(c1 , . . . , cn ) is true, we say that the tuple hc1 , . . . , cn i belongs
to the instance of r (or just that it is in r, if confusion does not arise). An instance of
the relational schema R = {r1 , . . . , rm } is the set comprised of the instances of r1 , . . . , rm .
When instances are treated as first-order formulas, each labeled null is viewed as an existential variable with the same name, and relational instances with nulls correspond to
a conjunction of atoms preceded by the existential quantification of all the nulls. For instance, {r(a, z1 , z2 , z1 ), s(b, z2 , z3 )}, where {z1 , z2 , z3 } ‚äÜ ‚àÜN and {a, b} ‚äÜ ‚àÜ, is expressed as
‚àÉz1 ‚àÉz2 ‚àÉz3 r(a, z1 , z2 , z1 ) ‚àß s(b, z2 , z3 ). In the following, we will omit these quantifiers.
A fact r(c1 , . . . , cn ) is said to be ground if ci ‚àà ‚àÜ for all i ‚àà {1, . . . , n}. In such a case,
also the tuple hc1 , . . . , cn i is said to be ground. A relation or schema instance all of whose
facts are ground is said to be ground, and a ground instance of R is also called a database.
If A is a sequence of atoms ha1 , . . . , ak i or a conjunction of atoms a1 ‚àß . . . ‚àß ak , we use
atoms(A) to denote the set of the atoms in A: atoms(A) = {a1 , . . . , ak }. Given a (ground or
non-ground) atom a, the domain of a, denoted by dom(a), is the set of all values (variables,
constants orSlabeled nulls) that appear as arguments in a. If A is a set of atoms, we define
dom(A) = a‚ààA dom(a). If A is a sequence or a conjunction of atoms then we define
dom(A) = dom(atoms(A)). If A is an atom, a set, a sequence, or a conjunction of atoms,
we write vars(A) to denote the set of variables in A.
Given an instance B of a relational schema R, the Herbrand Base of B, denoted HB (B),
is the set of all atoms that can be formed using the predicate symbols of R and arguments
in dom(B). Notice that this is an extension of the classical notion of Herbrand Base, which
includes ground atoms only.
An n-ary conjunctive query (CQ) over R is a formula of the form q(X1 , . . . , Xn ) ‚Üê Œ¶(X),
where q is a predicate not appearing in R, all the variables X1 , . . . , Xn appear in X, and
Œ¶(X), called the body of the query, is a conjunction of atoms constructed with predicates
from R. The arity of a query is the arity of its head predicate q. If q has arity 0, then the
conjunctive query is called Boolean (BCQ). For BCQs, it is convenient to drop the head
predicate and simply view the query as the set of atoms in Œ¶(X). If not stated otherwise,
we assume that queries contain no constants, since constants can be eliminated from queries
by a simple polynomial time transformation. We will also sometimes refer to conjunctive
119

Calƒ±ÃÄ, Gottlob & Kifer

queries by just ‚Äúqueries‚Äù. The size of a conjunctive query Q is denoted by |Q|; it represents
the number of atoms in Q.
2.2 Homomorphisms
A mapping from a set of symbols S1 to another set of symbols S2 can be seen as a function
¬µ : S1 ‚Üí S2 defined as follows: (i) ‚àÖ (the empty mapping) is a mapping; (ii) if ¬µ is a
mapping, then ¬µ ‚à™ {X ‚Üí Y }, where X ‚àà S1 and Y ‚àà S2 is a mapping if ¬µ does not already
contain some X ‚Üí Y ‚Ä≤ with Y 6= Y ‚Ä≤ . If X ‚Üí Y is in a mapping ¬µ, we write ¬µ(X) = Y .
The notion of a mapping is naturally extended to atoms as follows. If a = r(c1 , . . . , cn )
is an atom and ¬µ a mapping, we define ¬µ(a) = r(¬µ(c1 ), . . . , ¬µ(cn )). For a set of atoms,
A = {a1 , . . . , am }, ¬µ(A) = {¬µ(a1 ), . . . , ¬µ(am )}. The set of atoms ¬µ(A) is also called image
of A with respect to ¬µ. For a conjunction of atoms C = a1 ‚àß . . . ‚àß am , ¬µ(C) is a shorthand
for ¬µ(atoms(C)), that is, ¬µ(C) = {¬µ(a1 ), . . . , ¬µ(am )}.
A homomorphism from a set of atoms A1 to another set of atoms A2 , with dom(A1 ‚à™
A2 ) ‚äÜ ‚àÜ ‚à™ ‚àÜN ‚à™ ‚àÜV is a mapping ¬µ from dom(A1 ) to dom(A2 ) such that the following
conditions hold: (1) if c ‚àà ‚àÜ then ¬µ(c) = c; (2) ¬µ(A1 ) ‚äÜ A2 , i.e., if an atom, a, is in A1 ,
then the atom ¬µ(a) is in A2 . In this case, we will say that A1 maps to A2 via ¬µ.
The answer to a conjunctive query Q of the form q(X1 , . . . , Xn ) ‚Üê Œ¶(X) over an instance
B of R, denoted by Q(B), is defined as follows: a tuple t ‚àà (‚àÜ ‚à™ ‚àÜN )n , is in Q(B) iff there
is a homomorphism ¬µ that maps Œ¶(X) to atoms of B, and hX1 , . . . , Xn i to t. In this case,
by abuse of notation, we also write q(t) ‚àà Q(B). A Boolean conjunctive query Q has a
positive answer on B iff hi (the tuple with no elements) is in Q(B); otherwise, it is said to
have a negative answer.
2.3 Relational Dependencies
We now define the main type of dependencies used in this paper, the tuple-generating
dependencies, or TGDs.
Definition 2.1. Given a relational schema R, a TGD œÉ over R is a first-order formula of
the form ‚àÄX‚àÄYŒ¶(X, Y) ‚Üí ‚àÉZŒ®(X, Z), where Œ¶(X, Y) and Œ®(X, Z) are conjunctions of
atoms over R, called body and head of the TGD, respectively; they are denoted by body(œÉ)
and head (œÉ). Such a dependency is satisfied in an instance B of R if, whenever there is a
homomorphism h that maps the atoms of Œ¶(X, Y) to atoms of B, there exists an extension
h2 of h (i.e., h2 ‚äá h) that maps the atoms of Œ®(X, Z) to atoms of B.
To simplify the notation, we will usually omit the universal quantifiers in TGDs. We
will also sometimes call TGDs rules because of the implication symbol in them. Notice
that, in general, constants of ‚àÜ can appear not only in the body, but also in the heads
of TGDs. For simplicity and without loss of generality, we assume that all constants that
appear in the the head of a TGDs also appear in the body of the same TGD.
The symbol |= will be used henceforth for the usual logical entailment, where sets of
atoms and TGDs are viewed as first-order theories. For such theories, we do not restrict
ourselves to finite models: we consider arbitrary models that could be finite or infinite. This
aspect is further discussed in Section 11.
120

Taming the Infinite Chase

2.4 Query Answering and Containment under TGDs
We now define the notion of query answering under TGDs. A similar notion is used in data
exchange (Fagin et al., 2005; Gottlob & Nash, 2006) and in query answering over incomplete
data (Calƒ±ÃÄ et al., 2003a). Given a database that does not satisfy all the constraints in Œ£,
we first define the set of completions (or repairs‚Äîsee Arenas, Bertossi, & Chomicki, 1999)
of that database, which we call solutions.
Definition 2.2. Consider a relational schema R, a set of TGDs Œ£, and a database D for
R. The set of instances {B | B |= D ‚à™ Œ£} is called the set of solutions of D given Œ£, and
is denoted by sol(D, Œ£).
The following is the definition of the problem, which we denote by CQAns, of answering
conjunctive queries under TGDs. The answers defined here are also referred to as certain
answers (see Fagin et al., 2005).
Definition 2.3. Consider a relational schema R, a set of TGDs Œ£, a database D for R,
and a conjunctive query Q on R. The answer to a conjunctive query Q on D given Œ£,
denoted by ans(Q, D, Œ£), is the set of tuples t such that for every B ‚àà sol(D, Œ£), t ‚àà Q(B)
holds.
Notice that the components of t in the above definition are necessarily constants from
‚àÜ. When t ‚àà ans(Q, D, Œ£), we also write D ‚à™ Œ£ ‚à™ {Q} |= q(t), where Q is represented as a
rule body(Q) ‚Üí q(X).
Containment of queries over relational databases has long been considered a fundamental
problem in query optimization, especially query containment under constraints such as
TGDs. Below we formally define this problem, which we call CQCont.
Definition 2.4. Consider a relational schema R, a set Œ£ of TGDs on R, and two conjunctive
queries Q1 , Q2 expressed over R. We say that Q1 is contained in Q2 under Œ£, denoted by
Q1 ‚äÜŒ£ Q2 , if for every instance B for R such that B |= Œ£ we have Q1 (B) is a subset of
Q2 (B).
2.5 The Chase
The chase was introduced as a procedure for testing implication of dependencies (Maier,
Mendelzon, & Sagiv, 1979), but later also employed for checking query containment (Johnson & Klug, 1984) and query answering on incomplete data under relational dependencies (Calƒ±ÃÄ et al., 2003a). Informally, the chase procedure is a process of repairing a database
with respect to a set of dependencies, so that the result of the chase satisfies the dependencies. By ‚Äúchase‚Äù we may refer either to the chase procedure or to its output. The chase
works on a database through the so-called TGD chase rule, which defines the result of the
applications of a TGD and comes in two flavors: oblivious and restricted.
Definition 2.5. [Oblivious Applicability] Consider an instance B of a schema R, and a
TGD œÉ = Œ¶(X, Y) ‚Üí ‚àÉZ Œ®(X, Z) over R. We say that œÉ is obliviously applicable to B if
there exists a homomorphism h such that h(Œ¶(X, Y)) ‚äÜ B.
121

Calƒ±ÃÄ, Gottlob & Kifer

Definition 2.6. [Restricted Applicability] Consider an instance B of a schema R, and a
TGD œÉ = Œ¶(X, Y) ‚Üí ‚àÉZ Œ®(X, Z) over R. We say that œÉ is restrictively applicable to B if
there exists a homomorphism h such that h(œï(X, Y)) ‚äÜ B, but there is no extension h‚Ä≤ of
h|X such that h‚Ä≤ (œà(X, Z)) ‚äÜ B.1
The oblivious form of applicability is called this way because it ‚Äúforgets‚Äù to check
whether the TGD is already satisfied. In contrast, a TGD is restrictively applicable only if
it is not already satisfied.
Definition 2.7. [TGD Chase Rule] Let œÉ be a TGD of the form Œ¶(X, Y) ‚Üí ‚àÉZ Œ®(X, Z)
and suppose that it is obliviously (resp., restrictively) applicable to an instance B via a
homomorphism h. Let h‚Ä≤ be an extension of h|X such that, for each Z ‚àà Z, h‚Ä≤ (Z) is a ‚Äúfresh‚Äù
labeled null of ‚àÜN not occurring in B, and following lexicographically all those in B. The
result of the oblivious (resp., restricted ) application of œÉ on B with h is B ‚Ä≤ = B‚à™h‚Ä≤ (Œ®(X, Z)).
œÉ,h

œÉ,h

We write B ‚àí‚ÜíO B ‚Ä≤ (resp., B ‚àí‚ÜíR B ‚Ä≤ ) to denote that B ‚Ä≤ is obtained from B through a
single oblivious (resp., restricted) chase step.
The TGD chase rule, defined above, is the basic building block to construct the chase of
a database under a set of TGDs. Depending on the notion of applicability in use‚Äîoblivious
or restricted‚Äîwe get the oblivious or the restricted chase. The formal definition of the
chase is given below.
Definition 2.8. [Oblivious and Restricted Chase] Let D be a database and Œ£ a set of
TGDs. An oblivious (resp., restricted) chase sequence of D with respect to Œ£ is a sequence
œÉi ,hi

of instances B0 , B1 , B2 , . . . such that B0 = D and, for all i > 0, Bi ‚àí‚Üí O Bi+1 (resp.,
œÉi ,hi

Bi ‚àí‚Üí R Bi+1 ) and œÉi ‚àà Œ£. We also assume that in any chase sequence the same pair
hœÉi , hi i is never applied more than once. The oblivious (resp., restricted) chase of D with
respect to Œ£, denoted Ochase(D, Œ£) (resp., Rchase(D, Œ£)), is defined as follows:
‚Ä¢ A finite oblivious (resp., restricted) chase of D with respect to Œ£ is a finite oblivious
œÉi ,hi

œÉi ,hi

(resp., restricted) chase sequence B0 , . . . , Bm such that Bi ‚àí‚Üí O Bi+1 (resp., Bi ‚àí‚Üí R
Bi+1 ) for all 0 6 i < m, and there is no œÉ ‚àà Œ£ such that its application yields an
instance B ‚Ä≤ 6= Bm . We define Ochase(D, Œ£) = Bm (resp., Rchase(D, Œ£) = Bm ).
œÉi ,hi

‚Ä¢ An infinite oblivious (resp., restricted) chase sequence B0 , B1 , . . ., where Bi ‚àí‚Üí O Bi+1
œÉi ,hi

(resp., Bi ‚àí‚Üí R Bi+1 ) for all i > 0, is fair if whenever a TGD œÉ = Œ¶(X, Y) ‚Üí
‚àÉZ Œ®(X, Z) of Œ£ is obliviously (resp., restrictedly) applicable to Bi with homomorphism h, then there exists an extension h‚Ä≤ of h|X and k > 0 such that h‚Ä≤ (head (œÉ)) ‚äÜ
Bk . An infinite oblivious chase of D with respect to Œ£ is a fair infinite chase sequence
œÉi ,hi

œÉi ,hi

B0 , B1 , . . . such that Bi ‚àí‚Üí O Bi+1 (resp., Bi ‚àí‚Üí R Bi+1 ) for all i > 0. In this case,
we define Ochase(D, Œ£) = limi‚Üí‚àû Bi (resp., Rchase(D, Œ£) = limi‚Üí‚àû Bi ).
It is easy to see that the chase can be infinite, if the sequence of applications of the chase
rule is infinite. We remark that the chase was defined for databases of ground tuples. However, the definition straightforwardly applies also to arbitrary instances, possibly containing
1. h|X denotes the restriction of h to the set of variables of X.

122

Taming the Infinite Chase

labeled nulls. We assume a fair deterministic strategy for constructing chase sequences. We
use Ochase [i] (D, Œ£) (resp., Rchase [i] (D, Œ£)) to denote the result of the i-th step of the oblivious (resp., restricted) chase of D with respect to Œ£. Notice that Ochase [i] (D, Œ£) (resp.,
Rchase [i] (D, Œ£)) is called the oblivious (resp., restricted) chase of D with respect to Œ£ up
to the derivation level i, as in the work by Calƒ±ÃÄ et al. (2012a).
Example 2.9. In this example, we show an oblivious chase procedure. Consider the following set Œ£ = {œÉ1 , œÉ2 , œÉ3 , œÉ4 } of TGDs.
œÉ1 :
œÉ2 :
œÉ3 :
œÉ4 :

r3 (X, Y )
r1 (X, Y )
r1 (X, Y ), r2 (Y )
r1 (X, Y )

‚Üí
‚Üí
‚Üí
‚Üí

r2 (X)
‚àÉZ r3 (Y, Z)
‚àÉZ r1 (Y, Z)
r2 (Y )

and let D = {r1 (a, b)}. The chase procedure adds to D the following sequence of atoms:
r3 (b, z1 ) via œÉ2 , r2 (b) via œÉ4 , r1 (b, z2 ) via œÉ3 , r3 (z2 , z3 ) via œÉ2 , r2 (z2 ) via œÉ4 , and so on.
2.6 Query Answering and the Chase
The problems of query containment and answering under TGDs are closely related to each
other and to the notion of chase, as explained below.
Theorem 2.10 (see Nash, Deutsch, & Remmel, 2006). Consider a relational schema R, a
database D for R, a set Œ£ of TGDs on R, an n-ary conjunctive query Q with head-predicate
q, and an n-ary ground tuple t (with values in ‚àÜ). Then t ‚àà ans(Q, D, Œ£) iff there exists a
homomorphism h such that h(body(Q)) ‚äÜ Rchase(D, Œ£) and h(head (Q)) = q(t).
Notice that the fact that h(body(Q)) ‚äÜ Rchase(D, Œ£) and h(head (Q)) = q(t) is equivalent to saying that q(t) ‚àà Q(Rchase(D, Œ£)), or that Rchase(D, Œ£) ‚à™ {Q} |= q(t). The
result of Theorem 2.10 is important, and it holds because the (possibly infinite) restricted
chase is a universal solution (Fagin et al., 2005), i.e., a representative of all instances in
sol(D, Œ£). More formally, a universal solution for D under Œ£ is a (possibly infinite) instance
U such that, for every instance B ‚àà sol(D, Œ£), there exists a homomorphism that maps U
to B. In the work by Nash et al. (2006) it is shown that the chase constructed with respect
to TGDs is a universal solution.
A freezing homomorphism for a query is a homomorphism that maps every distinct
variable in the query into a distinct labeled null in ‚àÜN . The following well known result is
a slight extension of a result by Chandra and Merlin (1977).
Theorem 2.11. Consider a relational schema R, a set Œ£ of TGDs on R, and two conjunctive queries Q1 , Q2 on R. Then Q1 ‚äÜŒ£ Q2 iff Œª(head (Q1 )) ‚àà Q2 (Rchase(Œª(body(Q1 )), Œ£)
for some freezing homomorphism Œª for Q1 .
From this and the results by Johnson and Klug (1984) and by Nash et al. (2006), we
easily obtain the following result, which is considered folklore.
Corollary 2.12. The problems CQAns and CQCont are mutually logspace-reducible.
123

Calƒ±ÃÄ, Gottlob & Kifer

2.7 Oblivious vs. Restricted Chase
As observed by Johnson and Klug (1984) in the case of functional and inclusion dependencies, things are more complicated if the restricted chase is used instead of the oblivious
one, since applicability of a TGD depends on the presence of other atoms previously added
to the database by the chase. It is technically easier to use the oblivious chase and it can
be used in lieu of the restricted chase because, as we shall prove now, a result similar to
Theorem 2.10 holds for the oblivious chase, i.e., it is also universal. This result, to the best
of our knowledge, has never been explicitly stated before. For the sake of completeness, we
present a full proof here.
Theorem 2.13. Consider a set Œ£ of TGDs on a relational schema R, and let D be
a database on R. Then there exists a homomorphism ¬µ such that ¬µ(Ochase(D, Œ£)) ‚äÜ
Rchase(D, Œ£).
Proof. The proof is by induction on the number m of applications of the TGD chase rule
in the construction of the oblivious chase Ochase(D, Œ£). We want to prove that, for all m
with m > 0, there is a homomorphism from Ochase [m] (D, Œ£) to Rchase(D, Œ£).
Base case. In the base case, where m = 0, no TGD rule has yet been applied, so
Ochase [0] (D, Œ£) = D ‚äÜ Rchase(D, Œ£) and the required homomorphism is simply the identity homomorphism ¬µ0 .
Inductive case. Assume we have applied the TGD chase rule m times and obtained
Ochase [m] (D, Œ£). By the induction hypothesis, there exists a homomorphism ¬µm that maps
Ochase [m] (D, Œ£) into Rchase(D, Œ£). Consider the (m + 1)-th application of the TGD chase
rule, for a TGD of the form Œ¶(X, Y) ‚Üí ‚àÉZŒ®(X, Z). By definition of applicability of TGDs,
there is a homomorphism ŒªO that maps Œ¶(X, Y) to atoms of Ochase(D, Œ£) and that it can
be suitably extended to another homomorphism, Œª‚Ä≤O , such that Œª‚Ä≤O maps each of the variables
in Z to a fresh null in ‚àÜN not already present in Ochase [m] (D, Œ£). As a result of the application of this TGD, all atoms in Œª‚Ä≤O (Œ®(X, Z)) are added to Ochase [m] (D, Œ£), thus obtaining
Ochase [m+1] (D, Œ£). Consider the homomorphism ŒªR = ¬µm ‚ó¶ ŒªO , which maps Œ¶(X, Y) to
atoms of Rchase(D, Œ£). Since Rchase(D, Œ£) satisfies all the dependencies in Œ£ (and so does
Ochase(D, Œ£)), there is an extension Œª‚Ä≤R of ŒªR that maps Œ®(X, Z) to tuples of Rchase(D, Œ£).
Denoting Z = Z1 , . . . , Zk , we now define ¬µm+1 = ¬µm ‚à™ {Œª‚Ä≤O (Zi ) ‚Üí Œª‚Ä≤R (Zi )}16i6k . To complete the proof, we now need to show that ¬µm+1 is indeed a homomorphism. The addition of Œª‚Ä≤O (Zi ) ‚Üí Œª‚Ä≤R (Zi ), with 1 6 i 6 k, is compatible with ¬µm because none of the
Œª‚Ä≤O (Zi ) appears in ¬µm . Therefore ¬µm+1 is a well-defined mapping. Now, consider an atom
r(X, Z) in Œ®(X, Z). Then the atom Œª‚Ä≤O (r(X, Z)) is added to Ochase(D, Œ£) in the (m+1)-th
step and ¬µm+1 (r(X, Y)) = ¬µm+1 (r(Œª‚Ä≤O (X), Œª‚Ä≤O (Z))) = r(¬µm+1 (Œª‚Ä≤O (X), ¬µm+1 (Œª‚Ä≤O (Z)). Notice that ¬µm+1 (Œª‚Ä≤O (X)) = ¬µm+1 (ŒªO (X)) = ŒªR (X) = Œª‚Ä≤R (X), and ¬µm+1 (Œª‚Ä≤O (Z)) = Œª‚Ä≤R (Z).
Therefore, ¬µm+1 (r(X, Z)) = r(Œª‚Ä≤R (X), Œª‚Ä≤R (Z)) = Œª‚Ä≤R (r(X, Z)), which is in Rchase(D, Œ£), by
construction.
The desired homomorphism from Ochase(D, Œ£) to Rchase(D, Œ£) is therefore
S
¬µ= ‚àû
¬µ
.
i=0 i
Corollary 2.14. Given a set Œ£ of TGDs over a relational schema R and a database D for
R, Ochase(D, Œ£) is a universal solution for D under Œ£.
124

Taming the Infinite Chase

Corollary 2.15. Given a Boolean query Q over a schema R, a database D for R, and a
set of TGDs Œ£, Ochase(D, Œ£) |= Q if and only if Rchase(D, Œ£) |= Q.
In the following, unless explicitly stated otherwise, ‚Äúchase‚Äù will mean the oblivious chase,
and chase(D, Œ£) will stand for Ochase(D, Œ£).
2.8 Decision Problems
Recall that, by Theorem 2.10, D ‚à™ Œ£ |= Q iff chase(D, Œ£) |= Q. Based on this, we define
two relevant decision problems and prove their logspace-equivalence.
Definition 2.16. The conjunctive query evaluation decision problem CQeval is defined as
follows. Given a conjunctive query Q with n-ary head predicate q, a set of TGDs Œ£, a
database D and a ground n-tuple t, decide whether t ‚àà ans(Q, D, Œ£) or, equivalently,
whether chase(D, Œ£) ‚à™ {Q} |= q(t).
Definition 2.17. The Boolean conjunctive query evaluation problem BCQeval is defined as
follows. Given a Boolean conjunctive query Q, a set of TGDs Œ£, and a database D, decide
whether chase(D, Œ£) |= Q.
The following result is implicit in the work of Chandra and Merlin (1977).
Lemma 2.18. The problems CQeval and BCQeval are logspace-equivalent.
Proof. Notice that BCQeval can be trivially made into a special instance of CQeval, e.g., by
adding a propositional atom as head atom. It thus suffices to show that CQeval polynomially
reduces to BCQeval. Let hQ, D, Œ£, q(t)i be an instance of CQeval, where q/n is the head
predicate of Q and t is a ground n-tuple. Assume the head atom of Q is q(X1 , . . . , Xn )
and t = hc1 , . . . , cn i. Then define Q‚Ä≤ to be the Boolean conjunctive query whose body is
body(Q) ‚àß q ‚Ä≤ (X1 , . . . , Xn ), where q ‚Ä≤ is a fresh predicate symbol not occurring in D, Q, or Œ£
It is easy to see that q(t) ‚àà Q(chase(D, Œ£)) iff chase(D ‚à™ {q ‚Ä≤ (c1 , . . . , cn )}, Œ£) |= Q‚Ä≤ .
By the above lemma and by the well-known equivalence of the problem of query containment under TGDs with the CQeval problem (Corollary 2.12), the three following problems
are logspace-equivalent: (1) CQ-eval under TGDs, (2) BCQeval under TGDs, (3) query
containment under TGDs. Henceforth, we will consider only one of these problems, the
BCQ-eval problem. By the above, all complexity results carry over to the other problems.
Dealing with multiple head-atoms. It turns out that dealing with multiple atoms in
TGD heads complicates the proof techniques, so we assume that all TGDs have a single
atom in their head. After proving our results for single-headed TGDs, we will extend these
results to the case of multiple-atom heads in Section 8.
2.9 Tree Decomposition and Related Notions
We now introduce the required notions about tree decompositions. A hypergraph is a pair
H = hV, Hi, where V is the set of nodes and H ‚äÜ 2V . The elements of H are thus subsets
of V ; they are called hyperedges. The Gaifman graph of a hypergraph H = hV, Hi, denoted
125

Calƒ±ÃÄ, Gottlob & Kifer

by GH , is an undirected graph where V is the set of nodes and an edge (v1 , v2 ) is in the
graph if v1 and v2 jointly occur in some hyperedge in H.
Given a graph G = hV, Ei, a tree decomposition of G is a pair hT, Œªi, where T = hN, Ai
is a tree, and Œª a labeling function Œª : N ‚Üí 2V such that:
S
(i) for all v ‚àà V there is n ‚àà N such that v ‚àà Œª(n); that is, Œª(N ) = n‚ààN Œª(n) = V ;
(ii) for every edge e = (v1 , v2 ) ‚àà E there is n ‚àà N such that Œª(n) ‚äá {v1 , v2 };
(iii) for every v ‚àà V , the set {n ‚àà N | v ‚àà Œª(n)} induces a connected subtree in T .
The width of a tree decomposition hT, Œªi is the integer value max{|Œª(n)| ‚àí 1 | n ‚àà N }.
The treewidth of a graph G = hV, Ei, denoted by tw(G), is the minimum width of all tree
decompositions of G. Given a hypergraph H, its treewidth tw(H) is defined as the treewidth
of its Gaifman graph: tw(H) = tw(GH ). Notice that the notion of treewidth immediately
extends to relational structures.

3. Guarded and Weakly-Guarded TGDs: Decidability Issues
This section introduces guarded TGDs (GTGDs) and weakly guarded sets of TGDs (WGTGDs), which enjoy several useful properties. In particular, we show that query answering
under these TGDs is decidable.
Definition 3.1. Given a TGD œÉ of the form Œ¶(X, Y) ‚Üí Œ®(X, Z), we say that œÉ is a (fully)
guarded TGD (GTGD) if there exists an atom in the body, called a guard, that contains all
the universally quantified variables of œÉ, i.e., all the variables X, Y that occur in Œ¶(X, Y).
To define weakly guarded sets of TGDs, we first give the notion of an affected position
in a predicate of a relational schema, given a set of TGDs Œ£. Intuitively, a position œÄ is
affected in a set of TGDs Œ£ if there exists a database D such that a labeled null appears
in some atom of chase(D, Œ£) at position œÄ. The importance of affected positions for our
definitions is that no labeled null can appear in non-affected positions. We define this notion
below.
Definition 3.2. Given a relational schema R and a set of TGDs Œ£ over R, a position œÄ of
a predicate p of R is affected with respect to Œ£ if either:
‚Ä¢ (base case) for some œÉ ‚àà Œ£, an existentially quantified variable appears in œÄ in head (œÉ),
or
‚Ä¢ (inductive case) for some œÉ ‚àà Œ£, the variable appearing at position œÄ in head (œÉ) also
appears in body(œÉ), and only at affected positions.
Example 3.3. Consider the following set of TGDs:
œÉ1 : p1 (X, Y ), p2 (X, Y ) ‚Üí ‚àÉZ p2 (Y, Z)
œÉ2 : p2 (X, Y ), p2 (W, X) ‚Üí p1 (Y, X)
Notice that p2 [2] is affected since Z is existentially quantified in œÉ1 . The variable Y in œÉ1
appears in p2 [2] (which is an affected position) and also in p1 [2] (which is not an affected
position). Therefore Y in œÉ1 does not make the position p2 [1] an affected one. Similarly,
126

Taming the Infinite Chase

in œÉ2 , X appears in the affected position p2 [2] and also in the non-affected position p2 [1].
Therefore, p1 [2] is not affected. On the other hand, Y in œÉ2 appears in p2 [2] and nowhere
else. Since we have already established that p2 [2] is an affected position, this makes p1 [1]
also an affected position.
Definition 3.4. Consider a set of TGDs Œ£ on a schema R. A TGD œÉ ‚àà Œ£ of the form
Œ¶(X, Y) ‚Üí ‚àÉ Œ®(X, Z) is said to be weakly guarded with respect to Œ£ (W GT GD) if there
is an atom in body(œÉ), called a weak guard, that contains all the universally quantified
variables of œÉ that appear in affected positions with respect to Œ£ and do not also appear
in non-affected positions with respect to Œ£. The set Œ£ is said to be a weakly guarded set of
TGDs if each TGD œÉ ‚àà Œ£ is weakly guarded with respect to Œ£.
A GTGD or WGTGD may have more than one guard. In such a case, we will pick a
lexicographically first guard or use some other criterion for fixing the guard of a rule. The
actual choice will not affect our proofs and results.
The following theorem shows the undecidability of conjunctive query answering under
TGDs. This result, in its general form, follows from undecidability results for TGD implication (see Beeri & Vardi, 1981; Chandra, Lewis, & Makowsky, 1981b). We show here
that the CQ answering problem remains undecidable even in case of a fixed set Œ£ of singleheaded TGDs with a single non-guarded rule, and a ground atom as query. Our proof is
‚Äúfrom first principles‚Äù as it reduces the well-known halting problem for Turing machines to
query-answering under TGDs. More recently, Baget, LecleÃÄre, Mugnier, and Salvat (2011a)
showed that CQ answering is undecidable also in case Œ£ contains a single TGD, which,
however, contains multiple atoms in its head.
Theorem 3.5. There exists a fixed atomic BCQ Q and a fixed set of TGDs Œ£u , where all
TGDs in Œ£u are guarded except one, such that it is undecidable to determine whether for a
database D, D ‚à™ Œ£u |= Q or, equivalently, whether chase(D, Œ£u ) |= Q.
Proof. The proof hinges on the observation that, with appropriate input facts D, using a
fixed set of TGDs that consists of guarded TGDs and a single unguarded TGD, it is possible
to force an infinite grid to appear in chase(D, Œ£u ). By a further set of guarded rules, one
can then easily simulate a deterministic universal Turing machine (TM) M, which executes
every deterministic TM with an empty input tape, whose transition table is specified in
the database D. This is done by using the infinite grid, where the i-th horizontal line of
the grid represents the tape content at instant i. We assume that transitions of the Turing
machine M are encoded into a relation trans of D, where for example, the ground atom
trans(s1 , a1 , s2 , a2 , right) means ‚Äúif the current state is s1 and symbol a1 is read, then switch
to state s2 , write a2 , and move to the right‚Äù.
We show how the infinite grid is defined. Let D contain (among other initialization
atoms that specify the initial configuration of M) the atom index (0), which defines the
initial point of the grid. Also, we make use of three constants right, left, stay for encoding
the three types of moves. Consider the following TGDs:
index (X) ‚Üí ‚àÉY next(X, Y )
next(X, Y ) ‚Üí index (Y )
trans(T), next(X1 , X2 ), next(Y1 , Y2 ) ‚Üí grid (T, X1 , Y1 , X2 , Y2 )
127

Calƒ±ÃÄ, Gottlob & Kifer

where T stands for the sequence of argument variables S1 , A1 , S2 , A2 , M , as appropriate
for the predicate trans. Note that only the last of these three TGDs is non-guarded. The
above TGDs define an infinite grid whose points have co-ordinates X and Y (horizontal
and vertical, respectively) and where for each point its horizontal and vertical successors
are also encoded. In addition, each point appears together with each possible transition
rule. It is not hard to see that we can simulate the progress of our Turing machine M using
suitable initialization atoms in D and guarded TGDs. To this end, we need additional
predicates cursor (Y, X), meaning that the cursor is in position X at time Y , state(Y, S),
expressing that M is in state S at time Y , and content(X, Y, A), expressing that at time
Y , the content of position X in the tape is A. The following rule encodes the behavior of
M on all transition rules that move the cursor to the right:
grid (S1 , A1 , S2 , A2 , right, X1 , Y1 , X2 , Y2 ),
cursor (Y1 , X1 ), state(Y1 , S1 ), content(X1 , Y1 , A1 ) ‚Üí
cursor (Y2 , X2 ), content(X1 , Y2 , A2 ), state(Y2 , S2 ), mark (Y1 , X1 )
Such a rule has also obvious sibling rules for ‚Äúleft‚Äù and ‚Äústay‚Äù moves. For the sake of
brevity only, the above rule contains multiple atoms in the head. This is not a problem, as
such rules have no existentially quantified variables in the head. Therefore, each TGD with
multiple head-atoms can be replaced by an equivalent set of TGDs with single-atom heads
and identical bodies.
Notice that the mark predicate in the head marks the tape cell that is modified at
instant Y1 . We now need additional ‚Äúinertia‚Äù rules, which ensure that all other positions
in the tape are not modified between Y1 and the following time instant Y2 . To this end,
we use two different markings: keep f for the tape positions that follow the one marked
with mark , and keep p for the preceding tape positions. In this way, we are able, by making
use of guarded rules only, to ensure that, at every instant Y1 , every tape cell X, such that
keep p (Y1 , X) or keep f (Y1 , X) is true, keeps the same symbol at the instant Y2 following
Y1 . The rules below then propagate the aforementioned markings forward and backwards,
respectively, starting from the marked tape positions.
mark (Y1 , X1 ), grid (T, X1 , Y1 , X2 , Y2 ) ‚Üí keep f (Y1 , X2 )
keep f (Y1 , X1 ), grid (T, X1 , Y1 , X2 , Y2 ) ‚Üí keep f (Y1 , X2 )
mark (Y1 , X2 ), grid (T, X1 , Y1 , X2 , Y2 ) ‚Üí keep p (Y1 , X1 )
keep p (Y1 , X2 ), grid (T, X1 , Y1 , X2 , Y2 ) ‚Üí keep p (Y1 , X1 )
We also have inertia rules for all a ‚àà {a1 , . . . , a‚Ñì , ‚ô≠}, where {a1 , . . . , a‚Ñì , ‚ô≠} is the tape alphabet:
keep f (Y1 , X1 ), grid (T, X1 , Y1 , X2 , Y2 ), content(X1 , Y1 , a) ‚Üí content(X1 , Y2 , a)
keep p (Y1 , X1 ), grid (T, X1 , Y1 , X2 , Y2 ), content(X1 , Y1 , a) ‚Üí content(X1 , Y2 , a)
Notice that we use the constant a instead of a variable in the above rules in order to have
the guardedness property. We therefore need two rules as above for every tape symbol, that
is, 2‚Ñì + 2 inertia rules altogether.
Finally, we assume, without loss of generality, that our Turing machine M has a single
halting state s0 which is encoded by the atom halt(s0 ) in D. We then add a guarded
128

Taming the Infinite Chase

rule state(Y, S), halt(S) ‚Üí stop. It is now clear that the machine halts iff chase(D, Œ£u ) |=
stop, i.e., iff D ‚à™ Œ£u |= stop. We have thus reduced the halting problem to the problem
of answering atomic queries over a database under Œ£u . The latter problem is therefore
undecidable.
Definition 3.6. [Guarded chase forest, restricted GCF] Given a set of WGTGDs Œ£ and a
database D, the guarded chase forest (GCF) for D and Œ£, denoted gcf(D, Œ£), is constructed
as follows.
(a) For each atom (fact) d in D, add a node labeled with d.
(b) For every node v labeled with a ‚àà chase(D, Œ£) and for every atom b obtained from
a (and possibly other atoms) by a one-step application of a TGD œÉ ‚àà Œ£, if a is the
image of the guard of œÉ then add one node v ‚Ä≤ labeled with b and an arc going from v
to v ‚Ä≤ .
Assuming the chase forest gcf(D, Œ£) is built inductively, following precisely the strategy of
a fixed deterministic chase procedure, the set of all non-root nodes of the chase forest is
totally ordered by a relation ‚â∫ that reflects their order of generation. The restricted GCF
for D and Œ£, denoted rgcf(D, Œ£), is obtained from gcf(D, Œ£) by eliminating each subtree
rooted in a node w whose label is a duplicate of an earlier generated node. Thus, if v and
w are nodes labeled by the same atom, and v ‚â∫ w, w and all nodes of the subtree rooted in
w are eliminated from gcf(D, Œ£) so as to obtain rgcf(D, Œ£). Note that in rgcf(D, Œ£) each
label occurs only once, therefore we can identify the nodes with their labels and say, for
instance, ‚Äúthe node a‚Äù instead of ‚Äúthe node v labeled by a‚Äù.
Example 3.7. Consider again Example 2.9 on page 123. The corresponding (infinite)
guarded chase forest is shown in Figure 2. Every edge from an a-node to a b-node is labeled
with the TGD whose application causes the introduction of b. Notice that some atoms (e.g.,
r2 (b) or r2 (z2 )) label more than one node in the forest. The nodes belonging also to the
restricted GCF are shaded in the figure.
r1 (a, b)
œÉ2
r3 (b, z1 )

œÉ4

œÉ3

r2 (b)

r1 (b, z2 )
œÉ2

œÉ1
r2 (b)

œÉ3

œÉ4

r3 (z2 , z3 )

r2 (z2 )

r1 (z2 , z4 )
œÉ2

œÉ1
¬∑¬∑¬∑

r2 (z2 )

œÉ4
¬∑¬∑¬∑

œÉ3
¬∑¬∑¬∑

Figure 2: Chase forest for Example 3.7.
The goal of the following material is to show that, for weakly guarded sets Œ£ of TGDs, the
possibly infinite set of atoms chase(D, Œ£) has finite treewidth (Lemma 3.13). This will then
be used to show the decidability of query-answering under WGTGDs (Theorem 3.14). As
a first step towards proving that chase(D, Œ£) has finite treewidth, we generalize the notion
129

Calƒ±ÃÄ, Gottlob & Kifer

of acyclicity of an instance, and then point out the relationship between this notion and
treewidth. We will then show that chase(D, Œ£) enjoys (a specific version of) our generalized
form of acyclicity (Lemma 3.11), from which the finite treewidth result immediately follows.
Definition 3.8. Let B be a (possibly infinite) instance for a schema R and let S ‚äÜ dom(B).
‚Ä¢ An [S]-join forest hF, ¬µi of B is an undirected labeled forest F = hV, Ei (finite or
infinite), whose labeling function ¬µ : V ‚Üí B is such that:
(1) ¬µ is an epimorphism, i.e., ¬µ(V ) = B;
(2) F is [S]-connected, i.e., for each c ‚àà dom(B) ‚àí S, the set {v ‚àà V
dom(¬µ(v))} induces a connected subtree in F .

|

c ‚àà

‚Ä¢ We say that B is [S]-acyclic if B has an [S]-join forest.
Notice that we are dealing with a relational instance, but the above definition works for
any relational structure, including queries. Definition 3.8 generalizes the classical notion of
hypergraph acyclicity (Beeri, Fagin, Maier, Mendelzon, Ullman, & Yannakakis, 1981) of an
instance or of a query: an instance or a query, seen as a hypergraph, is hypergraph-acyclic
(which is the same as Œ±-acyclic according to Fagin, 1983) if and only if it is [‚àÖ]-acyclic .
The following Lemma follows from the definitions of [S]-acyclicity.
Lemma 3.9. Given an instance B for a schema R, and a set S ‚äÜ dom(B), if B is [S]acyclic, then tw(B) 6 |S| + w, where w is the maximum predicate arity in R and tw(B) is
the treewidth of B.
Proof. By hypothesis, B is [S]-acyclic and therefore has an [S]-join forest hF, ¬µi, where
F = hV, Ei. A tree decomposition hT, Œªi with T = hN, Ai, is constructed as follows. First,
we take N = V ‚à™ {n0 }, where n0 is an auxiliary node. Let Vr ‚äÜ V be the set of nodes that
are roots in the [S]-join forest F and let Ar be the set of edges from n0 to each node in Vr .
We define A = E ‚à™ Ar . The labeling function is defined as follows: Œª(n0 ) = S, and for all
nodes v 6= n0 , Œª(v) = dom(¬µ(v)) ‚à™ S. We now show that hT, Œªi is a tree decomposition.
Recalling the definition of tree decompositions in Section 2.9, (i) holds trivially because F
is a join forest and ¬µ(V ) = B. As for (ii), we notice that edges in the Gaifman graph of B
are such that for each atom d = r(c1 , . . . , cm ) in B there is a clique among nodes c1 , . . . , cm .
Since for the same atom there exists v ‚àà V such that ¬µ(v) = d and Œª(v) ‚äá dom(¬µ(v)), (ii)
holds immediately. Finally we consider connectedness. Let us take a value c appearing in
B as argument. If c ‚àà S, the set {v ‚àà N | c ‚àà Œª(v)} is the entire N , by construction, so
connectedness holds. If c 6‚àà S, the set {v ‚àà N | c ‚àà Œª(v)} induces a connected subtree in F
and therefore in T , since Œª(v) = ¬µ(v) ‚à™ S. Therefore, (iii) holds. Notice also that the width
of such a tree decomposition is at most |S| + w by construction.
Definition 3.10. Let D be a database for a schema R, and HB (D) be the Herbrand Base
of D as defined in Section 2. We define:
‚Ä¢ chase ‚ä• (D, Œ£) = chase(D, Œ£) ‚à© HB (D), and
‚Ä¢ chase + (D, Œ£) = chase(D, Œ£) ‚àí chase ‚ä• (D, Œ£)
130

Taming the Infinite Chase

In plain words, chase ‚ä• (D, Œ£) is the finite set of all null-free atoms in chase(D, Œ£). In
contrast, chase + (D, Œ£) may be infinite; it is the set of all atoms in chase(D, Œ£) that have
at least one null as an argument. Note that chase ‚ä• (D, Œ£) ‚à™ chase + (D, Œ£) = chase(D, Œ£)
and chase ‚ä• (D, Œ£) ‚à© chase + (D, Œ£) = ‚àÖ.
Lemma 3.11. If Œ£ is a weakly guarded set of TGDs and D a database, then chase + (D, Œ£)
is [dom(D)]-acyclic, and so is therefore chase(D, Œ£).
In order to prove this result, we resort to an auxiliary lemma.
Lemma 3.12. Let D be a database and Œ£ a weakly guarded set of TGDs. Let as be a node
of rgcf(D, Œ£) where the null value Œ∂ ‚àà ‚àÜN is first introduced, and let af be a descendant
node of as in rgcf(D, Œ£) that has Œ∂ as an argument. Then, Œ∂ appears in every node (=atom)
on the (unique) path from as to af .
Proof. Let a1 = as , a2 , . . . , an = af be the path from as to af . By the definition of affected
positions, Œ∂ appears only in affected positions in the atoms in the chase. Suppose, to the
contrary, that Œ∂ does not appear in some intermediate atom in the above path. Then,
there is i, 2 6 i 6 n ‚àí 1, such that Œ∂ does not appear in ai , but appears in ai+1 . Since Œ∂
appears only in affected positions, in order to be in ai+1 it must either appear in ai or to
be invented when ai+1 was added. The first case is ruled out by the assumption, and the
second is impossible because Œ∂ was first introduced in a1 , not in ai+1 ‚Äîa contradiction.
We now come back to the proof of Lemma 3.11.
Proof. The proof is constructive, by exhibiting a [dom(D)]-join forest F = hV, Ei for
chase(D, Œ£). We take F as rgcf(D, Œ£) and define, for each atom d ‚àà rgcf(D, Œ£), the
labeling function ¬µ for F as ¬µ(d) = d. Since every atom of chase(D, Œ£) is ‚Äúcovered‚Äù by its
corresponding node of F , it only remains to show that chase(D, Œ£) is [dom(D)]-connected.
Take a pair of distinct atoms a1 , a2 in rgcf(D, Œ£) that both have the same value c ‚àà ‚àÜN in an
argument. The atoms a1 and a2 must have a common ancestor a in rgcf(D, Œ£) where c was
first invented: if they do not, the value c would have to be introduced twice in chase(D, Œ£).
By Lemma 3.12, c appears in all atoms on the paths from a to a1 and from a to a2 . It thus
follows that the set {v ‚àà V | c ‚àà ¬µ(v)} induces a connected subtree in F .
Lemma 3.13. If Œ£ is a weakly guarded set of TGDs and D a database for a schema R,
then tw(chase(D, Œ£)) 6 |dom(D)| + w, where w is the maximum predicate arity in R.
Proof. The claim follows from Lemmas 3.9 and 3.11.
Theorem 3.14. Given a relational schema R, a weakly guarded set of TGDs Œ£, a Boolean
conjunctive query Q, and a database D for R, the problem of checking whether D ‚à™ Œ£ |= Q,
or equivalently chase(D, Œ£) |= Q, is decidable.
Proof (sketch). We first remind a key result of Courcelle (1990), that generalizes an earlier
result of Rabin (1969). Courcelle‚Äôs result states that the satisfiability problem is decidable
for classes of first-order theories (more generally, theories of monadic second-order logic)
131

Calƒ±ÃÄ, Gottlob & Kifer

that enjoy the finite treewidth model property. A class C of theories has the finite-treewidth
model property if for each satisfiable theory T ‚àà C it is possible to compute an integer f (T )
such that T has a model of treewidth at most f (T )‚Äîsee also the works by Goncalves and
GraÃàdel (2000) and by GraÃàdel (1999), where a more general property, called the generalized
tree-model property, is discussed. We apply this to prove our theorem.
Let ¬¨Q be the universal sentence obtained by negating the existentially quantified conjunctive query Q. For all classes of TGDs, D ‚à™ Œ£ |= Q iff chase(D, Œ£) |= Q iff D ‚à™ Œ£ ‚à™ ¬¨Q
is unsatisfiable. Trivially, deciding whether D ‚à™ Œ£ |= Q is equivalent under Turing reductions to deciding whether D ‚à™ Œ£ 6|= Q. The latter holds iff D ‚à™ Œ£ ‚à™ {¬¨Q} is satisfiable
or, equivalently, iff chase(D, Œ£) is a model of ¬¨Q which, in turn, holds iff chase(D, Œ£) is a
model of D ‚à™ Œ£ ‚à™ {¬¨Q}. By Lemma 3.13, for WGTGDs, chase(D, Œ£) has finite treewidth.
Our decision problem thus amounts to checking whether a theory belonging to a class C ‚àó
of first-order theories (of the form D ‚à™ Œ£ ‚à™ {¬¨Q}) is satisfiable, where it is guaranteed
that whenever a theory in this class is satisfiable, then it has a model of finite treewidth
(namely, chase(D, Œ£)), and where C ‚àó therefore enjoys the finite treewidth model property.
Decidability thus follows from Courcelle‚Äôs result.
Determining the precise complexity of query answering under sets of guarded and weakly
guarded sets of TGDs will require new techniques, which are the subject of the next sections.

4. Complexity: Lower Bounds
In this section we prove several lower bounds for the complexity of the decision problem of
answering Boolean conjunctive queries under guarded and weakly guarded sets of TGDs.
Theorem 4.1. The problem BCQeval under WGTGDs is exptime-hard in case the TGDs
are fixed. The same problem is 2exptime-hard when the predicate arity is not bounded.
Both hardness results also hold for fixed atomic ground queries.
Proof. We start with the exptime-hardness result for fixed WGTGD sets Œ£. It is wellknown that apspace (alternating pspace, see Chandra, Kozen, & Stockmeyer, 1981a)
equals exptime. Notice that there are apspace-hard languages that are accepted by alternating polynomial-space machines that use at most n worktape cells, where n is the input
size, and where the input is initially placed on the worktape. (This is well-known and can
be shown by trivial padding arguments). To prove our claim, it thus suffices to simulate the
behavior of such a restricted linear space (linspace) Alternating Turing Machine (ATM)
M on an input bit string I by means of a weakly guarded set of TGDs Œ£ and a database
D. Actually, we will show a stronger result: that a fixed set Œ£ of WGTGDs can simulate
a universal ATM that in turn simulates every linspace ATM that uses at most n tape
cells on every input. Here both the ATM transition table and the ATM input string will be
stored in the database D. Then D ‚à™ Œ£ |= Q for some atomic ground query Q iff the ATM
accepts the given input.2
Without loss of generality, we can assume that the ATM M has exactly one accepting
state sa . We also assume that M never tries to read beyond its tape boundaries. Let M
2. This technique was proposed by Calƒ±ÃÄ et al. (2008). It is similar to a technique later described by Hernich,
Libkin, and Schweikardt (2011) in the proof of undecidability of the existence of so-called CWA (closedworld assumption) universal solutions in data exchange.

132

Taming the Infinite Chase

be defined as
M = (S, Œõ, ‚ô≠, Œ¥, s0 , {sa })
where S is the set of states, Œõ = {0, 1, ‚ô≠} is the tape alphabet, ‚ô≠ is the blank tape symbol, Œ¥
is the transition function, defined as Œ¥ : S √ó Œõ ‚Üí (S √ó Œõ √ó {‚Ñì, r, ‚ä•})2 (‚ä• denotes the ‚Äústay‚Äù
head move, while ‚Ñì and r denote ‚Äúleft‚Äù and ‚Äúright‚Äù, respectively), s0 ‚àà S is the initial state,
and {sa } is the singleton-set of accepting states. Since M is an alternating Turing machine
(ATM), its set of states S is partitioned into two sets: S‚àÄ and S‚àÉ (universal and existential
states, respectively). The general idea of the encoding is that configurations of M (except
for the initial configuration Œ∫) will be represented by fresh nulls vi , i > 1, that are generated
by the chase.
The relational schema. We now describe the predicates of the schema which we
use in the reduction. Notice that the schema is fixed and does not depend on the particular
ATM that we encode. The schema predicates are as follows.
(1) Tape. The ternary predicate symbol (a, c, v) denotes that in configuration v the cell
c contains the symbol a, with a ‚àà Œõ. Also, a binary predicate succ(c1 , c2 ) denotes the
fact that cell c1 follows cell c2 on the tape. Finally, neq(c1 , c2 ) says that two cells are
distinct.
(2) States. A binary predicate state(s, v) says that in configuration v the ATM M is in
state s. We use three additional unary predicates: existential , universal , and accept.
The atom existential (s) (resp., universal (s)) denotes that the state s is existential
(resp., universal), while accept(c) says that c is an accepting configuration, that is,
one whose state is the accepting state.
(3) Configurations. A unary predicate config(v) expresses the fact that the value v
identifies a configuration. A ternary predicate next(v, v1 , v2 ) is used to say that both
configurations v1 and v2 are derived from v. Similarly, we use follows(v, v ‚Ä≤ ) to say
that configuration v ‚Ä≤ is derived from v. Finally, a unary predicate init(v) states that
the configuration v is initial.
(4) Head (cursor). We use the fact cursor (c, v) to say that the head (cursor) of the
ATM is on cell c in configuration v.
(5) Marking. Similarly to what is done in the proof of Theorem 3.5, we use mark (c, v)
to say that a cell c is marked in a configuration v. Our TGDs will ensure that all
non-marked cells keep their symbols in a transition from one configuration to another.
(6) Transition function. To represent the transition function Œ¥ of M, we use a single
8-ary predicate transition: for every transition rule Œ¥(s, a) = ((s1 , a1 , m1 ), (s2 , a2 , m2 ))
we will have transition(s, a, s1 , a1 , m1 , s2 , a2 , m2 ).
The database D. The data constants of the database D are used to identify cells,
configurations, states and so on. In particular, we will use an accepting state sa and an
initial state s0 plus a special initial configuration Œ∫. The database describes the initial
configuration of the ATM with some technicalities.
(a) We assume, without loss of generality, the n symbols of the input I to occupy the
cells numbered from 1 to n, i.e., c1 , . . . , cn . For technical reasons, in order to obtain
a simpler TGD set below, we also use the dummy cell constants c0 and cn+1 , that
intuitively represent border cells without symbols. For the i-th symbol ai of I, the
database has the fact symbol (a, ci , Œ∫), for all i ‚àà {1, . . . , n}.
133

Calƒ±ÃÄ, Gottlob & Kifer

(b) An atom state(s0 , Œ∫) specifies that M is in state s0 in its initial configuration Œ∫.
(c) For every existential state sE and universal state sU , we have the facts existential (sE )
and universal (sU ). For the accepting state, the database has the fact accept(sa ).
(d) An atom cursor (c1 , Œ∫) indicates that, in the initial configuration, the cursor points
at the first cell.
(e) The atoms succ(c1 , c2 ), . . . , succ(cn‚àí1 , cn ) encode the fact that the cells c1 , . . . , cn
of the tape (beyond which the ATM does not operate) are adjacent. For technical
reasons, we also use the analogous facts succ(c0 , c1 ) and succ(cn , cn+1 ). Also, atoms
of the form neq(ci , cj ), for all i, j such that 1 6 i 6 n, 1 6 j 6 n and i 6= j, denote
the fact that the cells c1 , . . . , cn are pairwise distinct.
(f ) The atom config(Œ∫) says that Œ∫ is a valid configuration.
(g) The database has atoms of the form transition(s, a, s1 , a1 , m1 , s2 , a2 , m2 ), which
encode the transition function Œ¥, as described above.
The TGDs. We now describe the TGDs that define the transitions and the accepting
configurations of the ATM.
(a) Configuration generation. The following TGDs say that, for every configuration
(halting or non halting‚Äîwe do not mind having configurations that are derived from
a halting one), there are two configurations that follow it, and that a configuration
that follows another configurations is also a valid configuration:
config(V ), ‚Üí ‚àÉV1 ‚àÉV2 next(V, V1 , V2 )
next(V, V1 , V2 ) ‚Üí config(V1 ), config(V2 )
next(V, V1 , V2 ) ‚Üí follows(V, V1 )
next(V, V1 , V2 ) ‚Üí follows(V, V2 )
(b) Configuration transition. The following TGD encodes the transition where the
ATM starts at an existential state, moves right in its first configuration and left in
the second. Here C denotes the current cell, C1 and C2 are the new cells in the first
and the second configuration (on the right and on the left of C, respectively), and
the constants r, ‚Ñì, and ‚ä• represent the ‚Äúright,‚Äù the ‚Äúleft,‚Äù and the ‚Äústay‚Äù moves,
respectively.
transition(S, A, S1 , A1 , r, S2 , A2 , ‚Ñì), next(V, V1 , V2 ),
state(S, V ), cursor (C, V ), symbol (A, C, V ), succ(C1 , C), succ(C, C2 ) ‚Üí
state(S1 , V1 ), state(S2 , V2 ), symbol (A1 , C1 , V1 ), symbol (A2 , C2 , V2 ),
cursor (C1 , V1 ), cursor (C2 , V2 ), mark (C, V ),
There are nine rules like the above one, corresponding to all the possible moves of
the head in the child configurations C1 and C2 . These other moves are encoded via
similar TGDs. These rules suitably mark the cells that are written by the transition
by means of the predicate mark . The cells that are not involved in the transition
must retain their symbols, which is specified by the following TGD:
config(V ), follows(V, V1 ), mark (C, V ), symbol (C1 , A, V ), neq(C1 , C) ‚Üí symbol (C1 , A, V1 )
134

Taming the Infinite Chase

(c) Termination. The rule state(sa , V ) ‚Üí accept(V ) defines a configuration V to be
accepting if its state is the accepting state. The following TGDs state that, for an
existential state, at least one configuration derived from it must be accepting. For
universal states, both configurations must be accepting.
next(V, V1 , V2 ), state(S, V ), existential (S), accept(V1 ) ‚Üí accept(V )
next(V, V1 , V2 ), state(S, V ), existential (S), accept(V2 ) ‚Üí accept(V )
next(V, V1 , V2 ), state(S, V ), universal (S), accept(V1 ), accept(V2 ) ‚Üí accept(V )
Note that, for brevity, some of the TGDs we used have multiple atoms in the head.
However, these heads have no existentially quantified variables, so such multi-headed TGDs
can be replaced with sets of TGDs that have only one head-atom. Note also that the
database constants (r, ‚Ñì, and ‚ä•, and sa ) appearing in some rules can be eliminated by
introducing additional predicate symbols and database atoms. For example, if we add
the predicate acceptstate to the signature and the fact acceptstate(sa ) to the database D,
the rule state(sa , V ) ‚Üí accept(V ) can be replaced by the equivalent constant-free rule
acceptstate(X), state(X, V ) ‚Üí accept(V ).
It is not hard to show that the encoding described above is sound and complete. That is,
M accepts the input I if and only if chase(D, Œ£) |= accept(Œ∫). It is also easy to verify that
the set of TGDs we have used is weakly guarded‚Äîthis can be done by checking that each
variable appearing only in affected positions also appears in a guard atom. For instance,
take the above rule next(V, V1 , V2 ), state(S, V ), existential (S), accept(V1 ) ‚Üí accept(V ). It is
immediate to see that state[1] and existential [1] are non-affected (the TGDs never invent
new states), and that all variables appearing in affected positions only, namely V, V1 , V2 ,
appear in the guard atom next(V, V1 , V2 ). This proves the claim.
We now turn to the case where Œ£ is not fixed and has unbounded predicate arities.
For obtaining the 2exptime lower bound, it is sufficient to adapt the above proof so as
to simulate an ATM having 2n worktape cells, i.e., an aexpspace machine whose space is
restricted to 2n tape cells. Actually, to accommodate two dummy cells to the left and right
of the 2n effective tape cells, that are used for technical reasons, we will feature 2n+1 tape
cells instead of just 2n .
We will make sure that the input string is put on cells 1, . . . , n of the worktape. Given
that there are now many more than n worktape cells, we will fill all cells to the right of the
input string with the blank symbol ‚ô≠.
This time, the WGTGD set Œ£ will not be fixed, but will depend on n. Since a much
stronger result will be shown in Section 6 (Theorem 6.2), we do not belabor all the details
in what follows, but just explain how the above proof for fixed sets of TGDs needs to be
changed.
Rather than representing each tape cell by a data constant, each tape cell is now represented by a vector (b0 , b1 , b2 , . . . , bn ) of Boolean values from {0, 1}. The database D is the
same as before, except for the following changes:
‚Ä¢ D contains the additional facts bool (0), bool (1), zero(0), one(1).
‚Ä¢ Each fact symbol (a, ci , Œ∫) is replaced by the fact symbol (a, b0 , b1 , b2 , . . . , bn , Œ∫), where
(b0 , b1 , b2 , . . . , bn ) is the Boolean vector of length n representing the integer i, with
0 6 i 6 n 6 2n+1 .
135

Calƒ±ÃÄ, Gottlob & Kifer

‚Ä¢ The fact cursor (c1 , Œ∫) is replaced by the (n + 2)-ary fact cursor (0, 0, ¬∑ ¬∑ ¬∑ , 0, 1, Œ∫).
‚Ä¢ All succ and neq facts described under item (e) are eliminated. (Vectorized versions
of these predicates will be defined via Datalog rules‚Äîsee below).
The TGD set from before is changed as follows. In all rules, each cell-variable C is
replaced by a vector C of n variables. For example, the atom succ(C1 , C) now becomes
succ(C1 , C) = succ(C10 , C11 , . . . C1n , C 0 , C 1 , . . . , C n ).
We add Datalog rules for n-ary succ and neq predicates. For example, the n-ary predicate succ can be implemented by the following rules:
bool (X0 ), . . . , bool (Xn‚àí1 ) ‚Üí succ(X0 , . . . , Xn‚àí1 , 0 , X0 , . . . , Xn‚àí1 , 1),
bool (X0 ), . . . , bool (Xn‚àí2 ) ‚Üí succ(X0 , . . . , Xn‚àí2 , 0, 1 , X0 , . . . , Xn‚àí2 , 1, 0),
..
.
bool (X0 ), . . . , bool (Xn‚àíi ) ‚Üí succ(X0 , . . . , Xn‚àíi , 0, 1 . . . 1 , X0 , . . . , Xn‚àíi , 1, 0, . . . , 0),
..
.
‚Üí succ(0, 1, . . . , 1 , 1, 0, . . . , 0)
These rules contain constants which can be easily eliminated by use of the zero and
one predicates, which are extensional database (EDB) predicates. We further add simple Datalog rules that use the vectorized succ predicate to define vectorized versions for
the less than and the neq predicates. Using less than, we add a single rule that, for the
initial configuration Œ∫, puts blanks into all tape cells beyond the last cell n of the input:
less than(n, C) ‚Üí symbol (‚ô≠, C, Œ∫), where n is an n-ary binary vector representing the number n (i.e., the input size).
The resulting set of rules is weakly guarded and correctly simulates the aexpspace (alternating exponential space) Turing machine whose transition table is stored in the database
D. Our reduction is polynomial in time. Since aexpspace=2exptime, it immediately follows that when the arity is not bounded the problem is 2exptime-hard.

5. Complexity: Upper Bounds
In this section we present upper bounds for query answering under weakly guarded TGDs.
5.1 Squid Decompositions
We now define the notion of a squid decomposition, and prove a lemma called ‚ÄúSquid
Lemma‚Äù which will be a useful tool for proving our complexity results in the following
sub-sections.
Definition 5.1. Let Q be a Boolean conjunctive query with n body atoms over a schema
R. An R-cover of Q is a Boolean conjunctive query Q+ over R that contains in its body
all the body atoms of Q. In addition, Q+ may contain at most n other R-atoms.
Example 5.2. Let R = {r/2, s/3, t/3} and Q be the Boolean conjunctive query with
body atoms {r(X, Y ), r(Y, Z), t(Z, X, X)}. The following query Q+ is an R-cover of Q:
Q+ = {r(X, Y ), r(Y, Z), t(Z, X, X), t(Y, Z, Z), s(Z, U, U )}.
136

Taming the Infinite Chase

Lemma 5.3. Let B be an instance over a schema R and Q a Boolean conjunctive query
over B. Then B |= Q iff there exists an R-cover Q+ of Q such that B |= Q+ .
Proof. The only-if direction follows trivially from the fact that Q is an R-cover of itself. The
if direction follows straightforwardly from the fact that whenever there is a homomorphism
h : vars(Q+ ) ‚Üí dom(B), such that h(Q+ ) ‚äÜ B, then, given that Q is a subset of Q+ , the
restriction h‚Ä≤ of h to vars(Q) is a homomorphism vars(Q) ‚Üí dom(B) such that h‚Ä≤ (Q) =
h(Q) ‚äÜ B. Therefore B |= Q+ implies B |= Q.
Definition 5.4. Let Q be a Boolean conjunctive query over a schema R. A squid decomposition Œ¥ = (Q+ , h, H, T ) of Q consists of an R-cover Q+ of Q, a mapping h : vars(Q+ ) ‚Üí
vars(Q+ ), and a partition of h(Q+ ) into two sets H and T , with T = h(Q+ ) ‚àí H, for
which there exists a set of variables VŒ¥ ‚äÜ h(vars(Q+ )) such that: (i) H = {a ‚àà h(Q+ ) |
vars(a) ‚äÜ VŒ¥ }, and (ii) T is [VŒ¥ ]-acyclic. If an appropriate set VŒ¥ is given together with a
squid decomposition Œ¥ = (Q+ , h, H, T ), then, by a slight terminology overloading, we may
just speak about the squid decomposition (Q+ , h, H, T, VŒ¥ ).
Note that a squid decomposition Œ¥ = (Q+ , h, H, T ) of Q does not necessarily define a
query folding (Chandra & Merlin, 1977; Qian, 1996) of Q+ , because h does not need to be
an endomorphism of Q+ ; in other terms, we do not require that h(Q+ ) ‚äÜ Q+ . However, h
is trivially a homomorphism from Q+ to h(Q+ ).
Intuitively, a squid decomposition Œ¥ = (Q+ , h, H, T, VŒ¥ ) describes a way how a query
Q may be mapped homomorphically to chase(D, Œ£). First, instead of mapping Q to
chase(D, Œ£), we equivalently map h(Q+ ) = H ‚à™ T to chase(D, Œ£). The set VŒ¥ specifies those variables of h(Q+ ) that ought to be mapped to constants, i.e., to elements of
dom(D). The atoms set H is thus mapped to ground atoms, that is, elements of the finite set chase ‚ä• (D, Œ£), which may be highly cyclic. The [VŒ¥ ]-acyclic atom set T shall be
mapped to the possibly infinite set chase + (D, Œ£) which, however, is [dom(D)]-acyclic. The
‚Äúacyclicities‚Äù of chase + (D, Œ£) and of T will be exploited for designing appropriate decision
procedures for determining whether chase(D, Œ£) |= Q. All this will be made formal in the
sequel.
One can think of the set H in a squid decomposition Œ¥ = (Q+ , h, H, T, VŒ¥ ) as the head of
a squid, and the set T as a join-forest of tentacles attached to that head. This will become
clear in the following example and the associated Figure 3.
Example 5.5. Consider the following Boolean conjunctive query:
Q = {r(X, Y ), r(X, Z), r(Y, Z),
r(Z, V1 ), r(V1 , V2 ), r(V2 , V3 ), r(V3 , V4 ), r(V4 , V5 ),
r(V1 , V6 ), r(V6 , V5 ), r(V5 , V7 ), r(Z, U1 ), s(U1 , U2 , U3 ),
r(U3 , U4 ), r(U3 , U5 ), r(U4 , U5 )}.
Let Q+ be the following Boolean query: Q+ = Q ‚à™ {s(U3 , U4 , U5 )}. A possible squid
decomposition (Q+ , h, H, T, VŒ¥ ) can be based on the homomorphism h, defined as follows:
h(V6 ) = V2 , h(V4 ) = h(V5 ) = h(V7 ) = V3 , and h(X) = X for any other variable X in Q+ .
The result of the squid decomposition with VŒ¥ = {X, Y, Z} is the query shown in Figure 3.
137

Calƒ±ÃÄ, Gottlob & Kifer

Here the cyclic head H (encircled in the oval) is represented by its join graph,3 and the [VŒ¥ ]acyclic ‚Äútentacle‚Äù set T is depicted as a [VŒ¥ ]-join forest. Moreover, the forest representing
T is rooted in the ‚Äúbag‚Äù of H-atoms, so that the entire decomposition takes on the shape
of a squid. Note that if we eliminated the additional atom s(U3 , U4 , U5 ), the original set
of atoms {r(U3 , U4 ), r(U3 , U5 ), r(U4 , U5 )} would form a non-[VŒ¥ ]-acyclic cycle, and therefore
they would not all be part of the tentacles.

r(X, Y )

r(X, Z)
head
r(Y, Z)

r(Z, V1 )

r(Z, U1 )

r(V1 , V2 )

s(U1 , U2 , U3 )

r(V2 , V3 )

s(U3 , U4 , U5 )

tentacles

r(V3 , V3 )

r(U3 , U4 )

r(U3 , U5 )

r(U4 , U5 )

Figure 3: Squid decomposition from Example 5.5. Atoms in h(Q+ ) are shown.
The following two lemmas are auxiliary technical results.
Lemma 5.6. Let Q be a Boolean conjunctive query and let U be a (possibly infinite) [A]acyclic instance, where A ‚äÜ dom(U ). Assume U |= Q, i.e., there is a homomorphism
f : dom(Q) ‚Üí dom(U ) with f (Q) ‚äÜ U . Then:
(1) There is an [A]-acyclic subset W ‚äÜ U such that: (i) f (Q) ‚äÜ W and (ii) |W | < 2|Q|.
(2) There is a cover Q+ of Q such that |Q+ | < 2|Q|, and there is a homomorphism g
that extends f and g(Q+ ) = W .
Proof.
Part (1). By the assumption,4 U is [A]-acyclic and f : dom(Q) ‚Üí dom(U ) is a homomorphism such that f (Q) ‚äÜ U . Since U is [A]-acyclic, it has a (possibly infinite) [A]-join
forest T = hhV, Ei, Œªi. We assume, without loss of generality, that distinct vertices u, v of
T have different labels, i.e., Œª(u) 6= Œª(v). This assumption can be made by removing all
subforests rooted at nodes labeled by duplicate atoms. Let TQ be the finite subforest of T
3. The join graph of H has the atoms as nodes. An edge between two atoms exists iff the atoms share at
least one variable.
4. One may be tempted to conjecture that W = f (Q), but this does not work because acyclicity (and thus
also [A]-acyclicity) is not a hereditary property: it may well be the case that U is acyclic, while the
subset f (Q) ‚äÜ U is not. However, taking W = f (Q) works in case of arities at most 2.

138

Taming the Infinite Chase

that contains all ancestors in T of nodes s such that Œª(s) ‚àà f (Q). Let F = hhV ‚Ä≤ , E ‚Ä≤ i, Œª‚Ä≤ i be
the forest obtained from T as follows.
‚Ä¢ V ‚Ä≤ = {v ‚àà V | Œª(v) ‚àà f (Q)} ‚à™ K, where K is the set of all vertices of TQ that have at
least two children.
‚Ä¢ If v, w ‚àà V ‚Ä≤ then there is an edge from v to w in E ‚Ä≤ iff w is a descendant of v in T ,
and if the unique shortest path from v to w in T does not contain any other node
from V ‚Ä≤ .
‚Ä¢ Finally, for each v ‚àà V ‚Ä≤ , Œª‚Ä≤ (v) = Œª(v).
Let us define W = Œª(V ‚Ä≤ ). We claim that the forest F is an [A]-join forest of W . Since
Condition (1) of Definition 3.8 ([S]-join forest) is immediately satisfied, it suffices to show
Condition (2), that is, that F satisfies the [A]-connectedness condition. Assume, for any
pair of distinct vertices v1 and v2 in F , that for some value b ‚àà dom(U ) ‚àí A it holds
b ‚àà dom(Œª‚Ä≤ (v1 )) ‚à© dom(Œª‚Ä≤ (v2 )). In order to prove the aforementioned [A]-connectedness
condition, we need to show that there is at least one path in F between v1 and v2 (here
we view F as a undirected graph), and that for every node v ‚àà V ‚Ä≤ lying on each such
path we have b ‚àà dom(Œª‚Ä≤ (v)). By construction of F , v1 and v2 are connected in T and v
lies on the (unique) path between v1 and v2 in T . Since T is an [A]-join forest, we have
b ‚àà dom(Œª(v)) = dom(Œª‚Ä≤ (v)). Thus F is an [A]-join forest of W .
Moreover, by construction of F , the number of children of each inner vertex of F is
at least 2, and F has at most |Q| leaves. It follows that F has at most 2|Q| ‚àí 1 vertices.
Therefore W is an [A]-acyclic set of atoms such that |W | 6 2|Q| and W ‚äá f (Q).
Part (2). Q can be extended to Q+ as follows. For each atom r(t1 , . . . , tk ) in W ‚àí f (Q),
add to Q a new query atom r(Œæ1 , . . . , Œæk ) such that for each 1 6 i 6 k, Œæi is a newly invented
variable. Obviously, W |= Q+ and thus there is a homomorphism g extending f such that
g(Q+ ) = W . Moreover, by construction |Q+ | < 2|Q|.
Lemma 5.7. Let G be an [A]-acyclic instance and let G‚Ä≤ be an instance obtained from G
by eliminating a set S of atoms where dom(S) ‚äÜ A. Then G‚Ä≤ is [A]-acyclic.
Proof. If T = hhV, Ei, Œªi is an [A]-join forest for G then an [A]-join forest T ‚Ä≤ for G‚Ä≤ can
be obtained from G by repeatedly eliminating each vertex v from T where Œª(v) ‚àà S. By
construction, each atom e eliminated from G in this way has the property that dom(e) ‚äÜ A.
Hence, for every value b ‚àà dom(G) ‚àí A, the node u ‚àà V such that Œª(u) = e cannot belong
to the induced (connected) subtree {v ‚àà V | b ‚àà dom(Œª(v))}. We thus get that G‚Ä≤ enjoys
the [A]-connectedness property.
The following Lemma will be used as a main tool in the subsequent complexity analysis.
Lemma 5.8 (Squid Lemma). Let Œ£ be a weakly guarded set of TGDs on a schema R,
D a database for R, and Q a Boolean conjunctive query. Then chase(D, Œ£) |= Q iff
there is a squid decomposition Œ¥ = (Q+ , h, H, T ) and a homomorphism Œ∏ : dom(h(Q+ )) ‚Üí
dom(chase(D, Œ£)) such that: (i) Œ∏(H) ‚äÜ chase ‚ä• (D, Œ£), and (ii) Œ∏(T ) ‚äÜ chase + (D, Œ£).
Proof. ‚ÄúIf‚Äù. If there is a squid decomposition Œ¥ = (Q+ , h, H, T ) of Q and a homomorphism
Œ∏ as described, then the composition Œ∏ ‚ó¶ h is a homomorphism such that (Œ∏ ‚ó¶ h)(Q+ ) =
139

Calƒ±ÃÄ, Gottlob & Kifer

Œ∏(h(Q+ )) ‚äÜ chase(D, Œ£). Hence, chase(D, Œ£) |= Q+ and, by Lemma 5.3, chase(D, Œ£) |=
Q.
‚ÄúOnly if‚Äù. Assume U = chase(D, Œ£) |= Q. Then, there exists a homomorphism f :
vars(Q) ‚Üí dom(U ) with f (Q) ‚äÜ chase(D, Œ£). By Lemma 3.11, chase + (D, Œ£) is [dom(D)]acyclic. By Lemma 5.6, it then follows that there is a Boolean query Q+ with < 2|Q| atoms,
such that all atoms of Q are contained in Q+ , and there is a homomorphism g : dom(Q+ ) ‚Üí
dom(U ) with g(Q+ ) ‚äÜ U , such that g(Q+ ) is [dom(D)]-acyclic.
Partition vars(Q+ ) into two sets vars ‚ä• (Q+ ) and vars + (Q+ ) as follows:
‚Ä¢ vars ‚ä• (Q+ ) = {X ‚àà vars(Q+ ) | g(X) ‚àà dom(D)}
‚Ä¢ vars + (Q+ ) = vars(Q+ ) ‚àí vars ‚ä• (Q+ ).
Define a mapping h : vars(Q+ ) ‚Üí vars(Q+ ) as follows. For each X ‚àà vars(Q+ ), let h(X)
be the lexicographically first variable in the set {Y ‚àà vars(Q+ ) | g(Y ) = g(X)}. Let
us define VŒ¥ as VŒ¥ = h(vars ‚ä• (Q+ )). Moreover, let H be the set of all those atoms a of
h(Q+ ), such that vars(a) ‚äÜ VŒ¥ = h(vars ‚ä• (Q+ )), and let T = h(Q+ ) ‚àí H. Note that, by
definition of H, g(H) ‚äÜ chase ‚ä• (D, Œ£) and, by definition of T , g(T ) ‚äÜ chase + (D, Œ£). Let
Œ∏ be the restriction of g to dom(h(Q+ )). Clearly, Œ∏, h, H, and T fulfill the conditions (i)
and (ii) of the statement of this lemma. It thus remains to prove that Œ¥ = (Q+ , h, H, T ) is
actually a squid decomposition of Q. For this, we only need to show that T is [VŒ¥ ]-acyclic.
To prove this, first observe that for each pair of variables X, Y in vars(Q+ ) such that
g(X) = g(Y ) we have h(X) = h(Y ). Therefore Œ∏ is, by construction, a bijection between
h(dom(Q+ )) and dom(Œ∏(Q+ )). In particular, T ‚äÜ h(Q+ ) is isomorphic to Œ∏(T ) via the
restriction Œ∏T of Œ∏ to dom(T ). Since Œ∏T (T ) = Œ∏(T ) is obtained from the [dom(D)]-acyclic
instance Œ∏(Q+ ) by eliminating only atoms all of whose arguments are in dom(D) (namely
the atoms in Œ∏(H)), by Lemma 5.7, Œ∏T (T ) is itself [dom(D)]-acyclic and, therefore, trivially
also [dom(D) ‚à© dom(Œ∏(T ))]-acyclic. Now, since for every X ‚àà dom(T ) it holds that X ‚àà VŒ¥
iff Œ∏T (X) ‚àà dom(D), it immediately follows that, since Œ∏T (T ) is [dom(D)]-acyclic, T is
[VŒ¥ ]-acyclic.
5.2 Clouds and the Complexity of Query Answering under WGTGDs
The goal of this subsection is to prove the following theorem:
Theorem 5.9. Let Œ£ be a weakly guarded set of TGDs, D a database for a schema R,
and Q a Boolean conjunctive query. The problem of determining whether D ‚à™ Œ£ |= Q or,
equivalently, whether chase(D, Œ£) |= Q is in exptime in case of bounded arity, and in
2exptime in general.
For the general case (of unbounded arities), we first outline a short high-level proof
aimed at specialists in Computational Logic. This proof makes sophisticated use of previous
results. We will then give a much longer, self-contained proof, that works for both the
general case and the case of bounded arities. The self-contained proof also introduces some
concepts that will be used in the following sections.
High Level Proof Sketch of Theorem 5.9 (General Case). We transform the original problem
instance (D, Œ£, Q) into a guarded first-order theory Œì = œÑ (D, Œ£, Q) such that chase(D, Œ£) |=
140

Taming the Infinite Chase

Q iff Œì is unsatisfiable. The signature œÉ of Œì uses Œ£ as the set of constants plus a constant
for each element of dom(D). Moreover, œÉ includes all predicate symbols occurring in D, Œ£,
or Q, plus a special nullary (i.e., propositional) predicate symbol q.
Œì contains all ground facts of D, plus all instances of each rule r ‚àà Œ£ obtained from
r by replacing all variables of r that occur in non-affected positions with constants. Note
that the resulting rules are universally quantified guarded sentences. Moreover, for each
squid decomposition Œ¥ = (Q+ , h, H, T, VŒ¥ ), and each possible replacement Œ∏ of the set of
variables VŒ¥ by constants of the signature œÉ, Œì contains a guarded sentence œÜŒ∏Œ¥ obtained as
follows. Notice that QŒ∏Œ¥ := Œ∏(H) ‚à™ T is a Boolean acyclic conjunctive query. By the results
of Gottlob, Leone, and Scarcello (2003),5 QŒ∏Œ¥ can thus be rewritten (in polynomial time)
into an equivalent guarded sentence œàŒ¥Œ∏ . We define œÜŒ∏Œ¥ to be (œàŒ¥Œ∏ ‚Üí q), which is obviously
guarded, too. Let Œì‚àí denote the sentences of Œì mentioned so far. From this construction
and the Squid Lemma (Lemma 5.8), it follows that chase(D, Œ£) |= Q iff Œì‚àí |= q. Now let
Œì = Œì‚àí ‚à™ {¬¨q}. Obviously, Œì is unsatisfiable iff chase(D, Œ£) |= Q.
Note that the reduction œÑ is an arity-preserving exptime-reduction. Let t be an exponential upper bound on the runtime required by reduction œÑ (and thus also on the size
of œÑ (D, Œ£, Q)). A deterministic version of the algorithm in the work by GraÃàdel (1999) for
deciding whether a guarded theory of unbounded arity is satisfiable or unsatisfiable runs in
w
double-exponential time O(2O(s¬∑w ) ), where s is the size of the theory and w is its maximum
predicate arity. Therefore, the overall runtime of first computing Œì = œÑ (D, Œ£, Q) for an input (D, Œ£, Q) of size n and maximum arity w, and then checking whether Œì is unsatisfiable
w
is O(2O(t(n)¬∑w ) ), which is still only double-exponential. Deciding D ‚à™ Œ£ |= Q is thus in
2exptime.
‚ú∑
Note that in case of bounded w, a similar proof does not provide an exptime bound,
w
as 2t(n)¬∑w would still be doubly exponential due to the exponential term t(n), even if w is
constant. Actually, as noted by BaÃÅraÃÅny, Gottlob, and Otto (2010), evaluating non-atomic
conjunctive queries against guarded first-order theories of bounded predicate arity is in fact
2exptime-complete. Surprisingly, this remains true even for guarded theories D ‚à™ Œ£ where
D is a (variable) database and Œ£ a fixed guarded theory of a very simple form involving
disjunctions (Bourhis, Morak, & Pieris, 2013). We therefore needed to develop different
proof ideas.
In the rest of this section we present an independent and self-contained proof of Theorem 5.9 by developing tools for analyzing the complexity of query answering under WGTGDs. To this end we introduce the notion of a cloud of an atom a in the chase of a database
D under a set Œ£ of WGTGDs. Intuitively, the cloud of a is the set of atoms of chase(D, Œ£)
whose arguments belong to dom(a) ‚à™ dom(D). In other words, the atoms in the cloud
cannot have nulls that do not appear in a. The cloud is important because we will show
that the subtree of gcf(D, Œ£) rooted in a depends only on a and its cloud.
Definition 5.10. Let Œ£ be a weakly guarded set of TGDs on a schema R and D be a
database for R. For every atom a ‚àà chase(D, Œ£) the cloud of a with respect to Œ£ and D is
the following set: cloud (D, Œ£, a) = {b ‚àà chase(D, Œ£) | dom(b) ‚äÜ dom(a) ‚à™ dom(D)}. Notice
5. See Theorem 3 in that paper, its proof, the remark after that proof, and Corollary 3.

141

Calƒ±ÃÄ, Gottlob & Kifer

that for every atom a ‚àà chase(D, Œ£) we have D ‚äÜ cloud (D, Œ£, a). Moreover, we define
clouds(D, Œ£) = {cloud (D, Œ£, a) | a ‚àà chase(D, Œ£)}
clouds + (D, Œ£) = {(a, cloud (D, Œ£, a)) | a ‚àà chase(D, Œ£)}
Any subset S ‚äÜ cloud (D, Œ£, a) is called a subcloud of a (with respect to Œ£ and D). The
set of all subclouds of an atom a is denoted by subclouds(D, Œ£, a). Finally, we define
subclouds + (D, Œ£) = {(a, C) | a ‚àà chase(D, Œ£) and C ‚äÜ cloud (D, Œ£, a)}.
Definition 5.11. Let B be an instance (possibly with nulls) over a schema, R, and D be
a database over R. Let Œ± and Œ≤ be atoms from the Herbrand Base HB (B). We say that
Œ± and Œ≤ are D-isomorphic, denoted Œ± ‚âÉD Œ≤, or simply Œ± ‚âÉ Œ≤ in case D is understood, if
there is a bijective homomorphism6 f : dom(Œ±) ‚Üí dom(Œ≤) such that f (Œ±) = Œ≤ (and thus
also f ‚àí1 (Œ≤) = Œ±). This definition extends directly to the cases when Œ± and Œ≤ are sets of
atoms or atom-set pairs (in a similar fashion as in clouds + (D, Œ£)).
Example 5.12. If {a, b} ‚äÜ dom(D) and {Œ∂1 , Œ∂2 , Œ∂3 , Œ∂4 } ‚äÜ ‚àÜN , we have: p(a, Œ∂1 , Œ∂2 ) ‚âÉ
p(a, Œ∂3 , Œ∂4 ) and (p(a, Œ∂3 ), {q(a, Œ∂3 ), q(Œ∂3 , Œ∂3 ), r(Œ∂3 )}) ‚âÉ (p(a, Œ∂1 ), {q(a, Œ∂1 ), q(Œ∂1 , Œ∂1 ), r(Œ∂1 )}). On
the other hand, p(a, Œ∂1 , Œ∂2 ) 6‚âÉ p(a, Œ∂1 , Œ∂1 ) and p(a, Œ∂1 , Œ∂2 ) 6‚âÉ p(Œ∂3 , Œ∂1 , Œ∂2 ).
Lemma 5.13. Given a database D for a schema R and an instance B for R, the Disomorphism relation ‚âÉD on HB (B) (resp., 2HB (B) or HB (B) √ó 2HB (B) , as in Definition 5.11) is an equivalence relation.
The above lemma follows directly from the definitions; it lets us define, for every set A
of atoms of HB (B), the quotiont set A/‚âÉD with respect to the above defined equivalence
relation ‚âÉD . Such notion of quotient set naturally extends to sets of sets of atoms such as
clouds(D, Œ£), or sequences (pairs, in particular) thereof.
Lemma 5.14. Let Œ£ be a weakly guarded set of TGDs and let D be a database for a schema
R. Let |R| denote the number of predicate symbols in R, and w be the maximum arity of
the symbols in R. Then:
(1) For every atom a ‚àà chase(D, Œ£), we have |cloud (D, Œ£, a)| 6 |R| ¬∑ (|dom(D)| + w)w .
Thus, cloud (D, Œ£, a) is polynomial in the size of the database D if the arity w is
bounded and exponential otherwise.
w
(2) For each atom a ‚àà chase(D, Œ£), |subclouds(D, Œ£, a)| 6 2|R|¬∑(|dom(D)|+w) .
w
(3) |clouds(D, Œ£)/‚âÉ | 6 2|R|¬∑(|dom(D)|+w) , i.e., there are‚Äîup to isomorphism‚Äîat most
exponentially many possible clouds or subclouds in a chase, if the arity w is bounded,
otherwise doubly exponentially many.
w
(4) |clouds + (D, Œ£)/‚âÉ | 6 |subclouds + (D, Œ£)/‚âÉ | 6 |R|¬∑(|dom(D)|+w)w ¬∑2|R|¬∑(|dom(D)|+w) .
Proof. The claims are proved by combinatorial arguments as follows.
(1) All distinct atoms in a cloud are obtained by placing the symbols of a, plus possibly
symbols from dom(D), in at most w arguments of some predicate symbol in R. For
each predicate in R, the number of symbols to be thus placed is |dom(D)| + w.
6. Recall that, by definition, the restriction of a homomorphism to dom(D) is the identity mapping.

142

Taming the Infinite Chase

(2) The different ways we can choose subclouds(D, Œ£, a) clearly determines the set of
all subsets of cloud (D, Œ£, a).
(3) It is easy to see that the size of the set of all non-pairwise-isomorphic clouds in the
chase is bounded by the number of possible subclouds of a fixed atom.
(4) Here, we are counting the number of all possible subclouds, each associated with
its ‚Äúgenerating‚Äù atom. The inequality holds because, once we choose all non-pairwiseisomorphic clouds, each of their possible generating atoms can have as arguments only
|dom(D)| + w symbols with which to construct the subclouds.
Definition 5.15. Given a database D and a set of WGTGDs, let a be an atom in
chase(D, Œ£). We define the following notions:
‚Ä¢ a‚Üì is the set of all atoms that label nodes of the subtrees of gcf(D, Œ£) rooted in a;
‚Ä¢ ‚àáa = a‚Üì ‚à™ cloud (D, Œ£, a);
‚Ä¢ if S is a subset of atoms in gcf(D, Œ£), then gcf[a, S]7 is inductively defined as follows:
(i) S ‚à™ {a} ‚äÜ gcf[a, S];
(ii) b ‚àà gcf[a, S] if b ‚àà a‚Üì , and b is obtained via the chase rule applied using a TGD
with body Œ¶ and head-atom œà, and a homomorphism Œ∏, such that Œ∏(œà) = b and
Œ∏(Œ¶) ‚äÜ gcf[a, S].
Theorem 5.16. If D is a database for a schema R, Œ£ is a weakly guarded set of TGDs,
and a ‚àà chase(D, Œ£), then ‚àáa = gcf[a, cloud (D, Œ£, a)].
Proof. By the definitions of ‚àáa and gcf[a, cloud (D, Œ£, a)], we have gcf[a, cloud (D, Œ£, a)] ‚äÜ
‚àáa. It remains to show the converse inclusion: ‚àáa ‚äÜ gcf[a, cloud (D, Œ£, a)]. Define
levela (a) = 0 and for each fact b ‚àà cloud (D, Œ£, a) ‚àí ‚àáa we also define levela (b) = 0.
For every other atom c ‚àà a‚Üì , levela (c) is defined as the distance (i.e., the length of the path)
from a to c in gcf(D, Œ£).
We first show the following facts in parallel by induction on levela (b):
(1) If b ‚àà ‚àáa then cloud (D, Œ£, b) ‚äÜ gcf[a, cloud (D, Œ£, a)].
(2) If b ‚àà ‚àáa then b ‚àà gcf[a, cloud (D, Œ£, a)].
Statement (2) above is the converse inclusion we are after.
Induction basis. If levela (b) = 0, we have either (a) b ‚àà cloud (D, Œ£, a) ‚àí {a},
or (b) b = a. In case (a), cloud (D, Œ£, a) ‚äÜ gcf[a, cloud (D, Œ£, a)] and therefore b ‚àà
gcf[a, cloud (D, Œ£, a)], which proves (1). Moreover, since b ‚àà cloud (D, Œ£, a), b cannot contain more labeled nulls than a, so dom(b) ‚àí dom(D) ‚äÜ dom(a) ‚àí dom(D). Therefore
cloud (D, Œ£, b) ‚äÜ cloud (D, Œ£, a) ‚äÜ gcf[a, cloud (D, Œ£, a)], which proves (2). In case (b),
b = a and thus cloud (D, Œ£, a) = cloud (D, Œ£, b) ‚äÜ gcf[a, cloud (D, Œ£, a)], which proves (1).
Since b = a ‚àà gcf[a, cloud (D, Œ£, a)], (2) follows as well.
Induction step. Assume that (1) and (2) are satisfied for all c ‚àà ‚àáa such that
levela (c) 6 i and assume levela (b) = i + 1, where i > 0. The atom b is produced by a TGD
whose guard g matches some atom b‚àí at level i, which is, by the induction hypothesis, in
gcf[a, cloud (D, Œ£, a)]. The body atoms of such a TGD then match atoms whose arguments
7. D and Œ£ are implicit here, to avoid clutter.

143

Calƒ±ÃÄ, Gottlob & Kifer

must be in cloud (D, Œ£, b) and thus also in gcf[a, cloud (D, Œ£, a)], again by the induction hypothesis. Therefore, (2) holds for b. To show (1), consider an atom b‚Ä≤ ‚àà cloud (D, Œ£, b). In
case dom(b‚Ä≤ ) ‚äÜ dom(b‚àí ), we have cloud (D, Œ£, b‚Ä≤ ) ‚äÜ cloud (D, Œ£, b‚àí ) ‚äÜ gcf[a, cloud (D, Œ£, a)].
Otherwise, b‚Ä≤ contains at least one new labeled null that was introduced during the generation of b. Given that Œ£ is a weakly guarded set and each labeled null in ‚àÜN is introduced
only once in the chase, there must be a path from b to b‚Ä≤ in gcf(D, Œ£) (and therefore also
in ‚àáb). A simple additional induction on levelb (b‚Ä≤ ) shows that all the applications of TGDs
on that path must have been fired on elements of gcf[a, cloud (D, Œ£, a)] only. Therefore,
b‚Ä≤ ‚àà gcf[a, cloud (D, Œ£, a)], which proves (1).
The corollary below follows directly from the above theorem.
Corollary 5.17. If D is a database for a schema R, Œ£ is a weakly guarded set of TGDs,
a, b ‚àà chase(D, Œ£), and (a, cloud (D, Œ£, a)) ‚âÉ (b, cloud (D, Œ£, b)), then ‚àáa ‚âÉ ‚àáb.
Definition 5.18. Let D be a database and a an atom. The canonical renaming can a :
dom(a) ‚à™ dom(D) ‚Üí ‚àÜa ‚à™ dom(D), where ‚àÜa = {Œæ1 , . . . , Œæh } ‚äÇ ‚àÜN is a set of labeled nulls
not appearing in a, is a 1-1 substitution that maps each element of dom(D) into itself and
each null-argument of a to the first unused element Œæi ‚àà ‚àÜa . If S ‚äÜ cloud (D, Œ£, a) then
can a (S) is well-defined and the pair (can a (a), can a (S)) will be denoted by can(a, S).
Example 5.19. Let a = g(d, Œ∂1 , Œ∂2 , Œ∂1 ) and S = {p(Œ∂1 ), r(Œ∂2 , Œ∂2 ), s(Œ∂1 , Œ∂2 , b)}, where {d, b} ‚äÜ
dom(D) and {Œ∂1 , Œ∂2 } ‚äÜ ‚àÜN . Then can a (a) = g(d, Œæ1 , Œæ2 , Œæ1 ), and can a (S) = {p(Œæ1 ), r(Œæ2 , Œæ2 ),
s(Œæ1 , Œæ2 , b)}.
Definition 5.20. If D is a database for a schema R, Œ£ is a weakly guarded set of TGDs
on R, S is a set of atoms and a ‚àà S, then we write (D, Œ£, a, S) |= Q iff there exists a
homomorphism Œ∏ such that Œ∏(Q) ‚äÜ S ‚à™ a‚Üì .
The following result straightforwardly follows from Theorem 5.16 and the previous definitions.
Corollary 5.21. If D is a database for a schema R, Œ£ is a weakly guarded set of TGDs,
a ‚àà chase(D, Œ£), and Q is a Boolean conjunctive query, then the following statements are
equivalent:
(1)
(2)
(3)
(4)

‚àáa |= Q
(D, Œ£, a, cloud (D, Œ£, a)) |= Q
(D, Œ£, can a (a), cana (cloud (D, Œ£, a))) |= Q
there is a subset S ‚Ä≤ ‚äÜ cloud (D, Œ£, a) such that (D, Œ£, can a (a), can a (S ‚Ä≤ )) |= Q.

We will use the pair can(a, cloud (D, Œ£, a)) as a unique canonical representative of the
equivalence class {(b, cloud (D, Œ£, b)) | (b, cloud (D, Œ£, b)) ‚âÉ (a, cloud (D, Œ£, a))} in
clouds + (D, Œ£). Therefore, the set {can(a, cloud (D, Œ£, a)) | a ‚àà chase(D, Œ£)} and the
quotient set clouds + (D, Œ£)/‚âÉ are isomorphic. Note that, by Lemma 5.14, these sets are
finite and have size exponential in |D| + |Œ£| if the schema is fixed (and double exponential
otherwise).
Now, given a database D for a schema R, a weakly guarded set of TGDs Œ£ on R, and an
atomic Boolean conjunctive query Q, we describe an alternating algorithm Acheck(D, Œ£, Q)
144

Taming the Infinite Chase

that decides whether D‚à™Œ£ |= Q. We assume that Q has the form ‚àÉY1 , . . . , Y‚Ñì , q(t1 , t2 , . . . , tr ),
where the t1 , . . . , tr , with r > ‚Ñì, are terms (constants or variables) in dom(D)‚à™{Y1 , Y2 , . . . , Y‚Ñì }.
The algorithm Acheck returns ‚Äútrue‚Äù if it accepts some configuration, according to the
criteria explained below; otherwise, it returns ‚Äúfalse‚Äù. Acheck uses tuples of the form
(a, S, S ‚Ä≤ , ‚â∫, b) as its basic data structures (configurations). Intuitively, each such configuration corresponds to an atom a derived at some step of the chase computation together with
a set S ‚Ä≤ of already derived atoms belonging the cloud of a. The informal meaning of the
parameters of a configuration is as follows.
(1) a is the root atom of the chase subtree under consideration.
(2) S ‚äÜ cloud (D, Œ£, a); S is intuitively a subcloud containing a set of atoms of cloud (D, Œ£, a)
that, while computing chase(D, Œ£), are originally derived outside the subtree of the
guarded chase forest rooted in a (and are thus outside the subtree rooted in a of
rgcf(D, Œ£)). We expect these atoms to serve as ‚Äúside atoms‚Äù (i.e., atoms matching
non-guard atoms of a TGD) when deriving the desired atom b starting at a.
(3) S ‚Ä≤ contains, at every step in the computation, the subset of cloud (D, Œ£, a) that has
been computed so far, or can be assumed to be valid, as it will be verified in another
branch of the computation.
(4) ‚â∫ is a total ordering of the atoms in S consistent with the order in which the atoms
of S are proved by the algorithm (by simulating the chase procedure).
(5) b is an atom that needs to be derived. In some cases (namely, on the ‚Äúmain‚Äù path
in the proof tree developed by Acheck), the algorithm will not try to derive a specific
atom, but will just match the query atom q(t1 , . . . , tr ) against the atoms of that path.
In that case, we use the symbol ‚ãÜ in place of b.
We are now ready to describe the algorithm Acheck at a sufficiently detailed level. However,
we omit many low-level details.
Acheck first checks if D |= Q. If so, Acheck returns ‚Äútrue‚Äù and halts. Otherwise, the
algorithm attempts to guess a path, the so called main branch, that contains an atom q
that is an instance of Q. This is done as follows.
Initialization. The algorithm Acheck starts at D and guesses some atom a ‚àà D,
which it will expand into a main branch that will eventually lead to an atom q matching
the query Q. To this end, the algorithm guesses a set S ‚äÜ cloud (D, Œ£, a) and a total order
‚â∫ on S, and then generates the configuration c0 = (a, S, S ‚Ä≤ , ‚â∫, ‚ãÜ). The set S ‚Ä≤ is initialized
as S ‚Ä≤ = S.
Form of a configuration‚Äîadditional specifications. In each configuration,
the set set S is implicitly partitioned into two sets S ‚ä• and S + , where S ‚ä• ‚äÜ D and S + =
{a1 , a2 , . . . , ak } is disjoint from D. The total order ‚â∫ is such that all elements of S ‚ä• precede
those of S + . On S + , ‚â∫ is defined as a1 ‚â∫ a2 ‚â∫ ¬∑ ¬∑ ¬∑ ‚â∫ a ‚â∫ ¬∑ ¬∑ ¬∑ ‚â∫ ak .
Summary of tasks Acheck performs for each configuration. Assume the
Acheck algorithm generates a configuration c = (a, S, S ‚Ä≤ , ‚â∫, b), where b might be ‚ãÜ. Acheck
then performs the following tasks on c:
‚Ä¢ Acheck verifies that the guessed set S of c is actually a subset of cloud (D, Œ£, a). This
is achieved by a massive universal branching that will be described below under the
145

Calƒ±ÃÄ, Gottlob & Kifer

heading ‚ÄúUniversal Branching‚Äù. Let us, however, anticipate here how it works, as
this may contribute to the understanding of the other steps. Acheck will verify that
each of the atoms a1 , . . . , ak is in chase(D, Œ£), where, for each i ‚àà {1, . . . , k}, the
proof of ai ‚àà chase(D, Œ£) can use as premises only the atoms of S that precede ai ,
according to ‚â∫. The algorithm thus finds suitable atoms d1 , . . . , dk ‚àà D and builds
proof trees for a1 , . . . , ak . For each 1 6 i 6 k, it generates configurations of the
form (di , S, S ‚ä• ‚à™ {a1 , a2 , . . . , ai‚àí1 }, ‚â∫, ai ). Each such configuration will be used as a
starting point in a proof of ai ‚àà chase(D, Œ£) assuming that a1 , . . . , ai‚àí1 ‚àà chase(D, Œ£)
has already been established. Acheck thus simulates a sequential proof of all atoms of
cloud (D, Œ£, a) that are in S via a parallel universal branching from c.
‚Ä¢ Acheck tests whether c is a final configuration (i.e., an accepting or rejecting one).
This is described under the heading ‚ÄúTest for final Configuration‚Äù below.
‚Ä¢ If c is not a final configuration of Acheck, this means that its first component a is
not yet the one that will be matched to b (or the query, if b = ‚ãÜ). Acheck then
‚Äúmoves down‚Äù the chase tree by one step by replacing a with a child of a. This step
is described under the heading ‚ÄúExistential Branching‚Äù.
In the following, let c = (a, S, S ‚Ä≤ , ‚â∫, b) be a configuration, where b may be ‚ãÜ.
Test for final configuration. If b ‚àà D, then Acheck accepts this configuration,
and does not expand it further. If b = ‚ãÜ, then Acheck checks (via a simple subroutine)
whether Q matches a, i.e., if a is a homomorphic image of the query atom q(t1 , . . . , tr ). If
so, Acheck accepts c (and thus returns ‚Äútrue‚Äù) and does not expand it further. If b 6= ‚ãÜ,
Acheck checks whether a = b. If this is true, then Acheck accepts the configuration c and
does not expand it further. Otherwise, the configuration tree is expanded as described next.
Existential Branching. Acheck guesses a TGD œÅ ‚àà Œ£ having body Œ¶ and headatom œà, and whose guard g matches a via some substitution Œ∏ (that is, Œ∏(g) = a) such
that Œ∏(Œ¶) ‚äÜ S ‚Ä≤ . Œ∏(œà) then corresponds to a newly generated atom (possibly containing
some fresh labeled nulls in ‚àÜN ). Note that, if no such guess can be made, this existential
branching automatically fails and Acheck returns false. To define the configuration c1
that Acheck creates out of c, we first introduce an intermediate auxiliary configuration
ÀÜ bÃÇ), where:
cÃÇ = (aÃÇ, SÃÇ, SÃÇ ‚Ä≤ , ‚â∫,
(a) aÃÇ = Œ∏(œà) is the new atom generated by the application of œÅ with the substitution Œ∏.
(b) SÃÇ contains aÃÇ and each atom d of S such that dom(d) ‚äÜ dom(aÃÇ) ‚à™ dom(D). Thus, in
addition to the new atom aÃÇ, SÃÇ inherits all atoms that were in the subcloud S of the
parent configuration c that are ‚Äúcompatible‚Äù with aÃÇ. In addition, SÃÇ includes a set
newatoms(cÃÇ) of new atoms that are guessed by the Acheck algorithm. All arguments
of each atom of newatoms(cÃÇ) must be elements of the set dom(aÃÇ) ‚à™ dom(D).
(c) SÃÇ ‚Ä≤ = SÃÇ.
ÀÜ is a total order on SÃÇ ‚Ä≤ obtained from ‚â∫ by eliminating all atoms in S ‚àí SÃÇ and by
(d) ‚â∫
ordering the atoms from newatoms(cÃÇ) after all the atoms from the set oldproven(cÃÇ) =
SÃÇ ‚Ä≤ ‚à© S ‚Ä≤ (these are assumed to have already been proven at the parent configuration c).
(e) bÃÇ is defined as bÃÇ = b.
Next, Acheck constructs the configuration c1 out of cÃÇ by canonicalization: c1 = can aÃÇ (cÃÇ),
ÀÜ can aÃÇ (bÃÇ)), where can aÃÇ (‚â∫)
ÀÜ is the total
that is c1 = (can aÃÇ (aÃÇ), can aÃÇ (SÃÇ), can aÃÇ (SÃÇ ‚Ä≤ ), can aÃÇ (‚â∫),
‚Ä≤
ÀÜ
order on the atoms in can aÃÇ (SÃÇ ) derived from ‚â∫.
146

Taming the Infinite Chase

Intuitively, c1 is the ‚Äúmain‚Äù child of c on the way to deriving the query atom q(t1 , . . . , tr )
assuming that all atoms of the guessed subcloud S are derivable.
Universal Branching. In the above generated configuration cÃÇ, the set SÃÇ ‚Ä≤ is equal
to SÃÇ. As already said, this means that it is assumed for that configuration that the set of
atoms SÃÇ is derivable. To verify that this is indeed the case, Acheck generates in parallel,
using universal computation branching, a set of auxiliary configurations for proving that all
the guessed atoms in can aÃÇ (newatoms(cÃÇ)) are indeed derivable through the chase of D with
respect to Œ£.
ÀÜ on SÃÇ be a concateLet can aÃÇ (newatoms(cÃÇ)) = {n1 , . . . , nm } and let the linear order ‚â∫
ÀÜ
ÀÜ ¬∑ ¬∑ ¬∑ ‚â∫n
ÀÜ m . For each
nation of the order ‚â∫, restricted to oldproven(cÃÇ), and the order n1 ‚â∫n2 ‚â∫
(i)
1 6 i 6 m, Acheck generates a configuration c2 defined as
(i)
ÀÜ ni ).
c2 = (can aÃÇ (aÃÇ), can aÃÇ (SÃÇ), can aÃÇ (oldproven(cÃÇ)) ‚à™ {n1 , . . . , ni‚àí1 }, can aÃÇ (‚â∫),

This completes the description of the Acheck algorithm.
Theorem 5.22. The Acheck algorithm is correct and runs in exponential time in case of
bounded arities, and in double exponential time otherwise.
Proof.
Soundness. It is easy to see that the algorithm is sound with respect to the standard
chase, i.e., if Acheck(D, Œ£, Q) returns ‚Äútrue‚Äù, then chase(D, Œ£) |= Q. In fact, modulo
variable renaming, which preserves soundness according to Corollary 5.21, the algorithm
does nothing but chasing D with respect to Œ£, even if the chase steps are not necessarily
in the same order as in the standard chase. Thus, each atom derived by Acheck occurs in
some chase. Since every chase computes a universal solution that is complete with respect
to conjunctive query answering, whenever Acheck returns ‚Äútrue‚Äù, Q is entailed by some
chase, and thus also by the standard chase, chase(D, Œ£).
Completeness. The completeness of Acheck with respect to chase(D, Œ£) can be shown
as follows. Whenever chase(D, Œ£) |= Q, there is a finite proof of Q, i.e., a finite sequence
proof Q of generated atoms that ends with some atom q, which is an instance of Q. This
proof can be simulated by the alternating computation Acheck as follows: (i) steer the main
branch of Acheck towards (a variant of) q by choosing successively the same TGDs and
substitutions Œ∏ (modulo the appropriate variable renamings) as those used in the standard
chase for the branch of q; (ii) whenever a subcloud S has to be chosen for some atom a by
Acheck, choose the set of atoms cloud (D, Œ£, a) ‚à© (D ‚à™ atoms(proof Q )), modulo appropriate
variable renaming; (iii) for the ordering ‚â∫, always choose the one given by proof Q . The
fact that no Q-instance is lost when replacing configurations by their canonical versions is
guaranteed by Corollary 5.21.
Computational cost. In case of bounded arity, the size of each configuration c
is polynomial in D ‚à™ Œ£. Thus, Acheck describes an alternating pspace (i.e., apspace)
computation. It is well-known that apspace = exptime. In case the arity is not bounded,
each configuration requires at most exponential space. The algorithm then describes a
computation in Alternating expspace, which is equal to 2exptime.

147

Calƒ±ÃÄ, Gottlob & Kifer

Corollary 5.23. Let Œ£ be a weakly guarded set of TGDs, and let D be a database over
a schema R. Then, computing chase ‚ä• (D, Œ£) can be done in exponential time in case of
bounded arity, and in double exponential time otherwise.
Proof. It is sufficient to start with an empty set A and then cycle over ground atoms b in
the Herbrand base HB (D) while checking whether chase(D, Œ£) |= b. If this holds, we add
b to A. The result is chase ‚ä• (D, Œ£). The claimed time bounds follow straightforwardly.
We can now finally state our independent proof of Theorem 5.9.
Proof of Theorem 5.9. We construct an algorithm Qcheck such that Qcheck(D, Œ£, Q) outputs
‚Äútrue‚Äù iff D ‚à™ Œ£ |= Q (i.e., iff chase(D, Œ£) |= Q). The algorithm relies on the notion of squid
decompositions, and on Lemma 5.8; it works as follows.
(1) Qcheck starts by computing chase ‚ä• (D, Œ£).
(2) Qcheck nondeterministically guesses a squid decomposition Œ¥ = (Q+ , h, H, T ) of Q
based on a set VŒ¥ ‚äÜ vars(h(Q+ )), where H = {a ‚àà h(Q+ ) | vars(a) ‚äÜ VŒ¥ } and T is
[VŒ¥ ]-acyclic. Additionally, Qcheck guesses a substitution Œ∏0 : VŒ¥ ‚Üí dom(D) such that
Œ∏0 (H) ‚äÜ chase ‚ä• (D, Œ£). Note that this is an np guess, because the number of atoms
in Q+ is at most twice the the number of atoms in Q.
(3) Qcheck checks whether Œ∏0 can be extended to a homomorphism Œ∏ such that Œ∏(T ) ‚äÜ
chase + (D, Œ£). By Lemma 5.8, this is equivalent to check if chase(D, Œ£) |= Q. Such
a Œ∏ exists iff for each connected subgraph t of Œ∏0 (T ), there is a homomorphism Œ∏t
such that Œ∏t (t) ‚äÜ chase + (D, Œ£). The Qcheck algorithm thus identifies the connected
components of Œ∏0 (T ). Each such component is a [dom(D)]-acyclic conjunctive query,
some of whose arguments may contain constants from dom(D). Each such component
can thus be represented as a [dom(D)]-join tree t. For each such join tree t, Qcheck
now tests whether there exists a homomorphism Œ∏t such that Œ∏t (t) ‚äÜ chase + (D, Œ£).
This is done by the subroutine Tcheck, that takes the TGD set Œ£, the database D,
and a connected subgraph (i.e., a subtree) t of Œ∏0 (T ) as input. The inner workings of
Tcheck(D, Œ£, t) are described below.
(4) Qcheck outputs ‚Äútrue‚Äù iff the above check (3) gives a positive result.
The correctness of Qcheck follows from Lemma 5.8. Given that step (2) is nondeterministic, the complexity of Qcheck is in npX , i.e., np with an oracle in X, where X is
a complexity class that is sufficiently powerful for: (i) computing chase ‚ä• (D, Œ£), and (ii)
performing the tests Tcheck(D, Œ£, t).
We now describe the Tcheck subroutine.
General notions. Tcheck(D, Œ£, t) is obtained from Acheck via the following modifications. Each configuration of Tcheck maintains a pointer Tpoint to a vertex of t (an atom
aq ). Intuitively, this provides a link to the root of the subtree of t that still needs to be
matched by descendant configurations of c. In addition to the data structures carried by
each configuration of Acheck, each configuration of Tcheck also maintains an array subst
of length w, where w is the maximum predicate arity in R. Informally, subst encodes a
substitution that maps the current atom of t to (the canonicalized version of) the current
atom of chase(D, Œ£).
148

Taming the Infinite Chase

Tcheck works like Acheck, but instead of nondeterministically constructing a main configuration path of the configuration tree such that eventually some atom matches the query,
it nondeterministically constructs a main configuration (sub)tree œÑ of the configuration tree,
such that eventually all atoms of the join tree t get consistently translated into some vertices
of œÑ . An important component of each main configuration c of Tcheck is its current atom a.
Initially, a is some nondeterministically chosen atom of D. For subsequent configurations
of the alternating computation tree, a will take on nodes of gcf(D, Œ£).
Initialization. Similarly to Acheck, the computation starts by generating an initial
configuration (a, S, S, ‚â∫, ‚ãÜ, Tpoint, subst), where a is nondeterministically chosen from the
database D, Tpoint points to the root r of t, and subst is a homomorphic substitution
that subst(r) = a, if r is homomorphically mappable on a; otherwise subst is empty. This
configuration will now be the root of the main configuration tree.
In general, the pointer Tpoint of each main configuration c = (a, S, S ‚Ä≤ , ‚â∫, ‚ãÜ, Tpoint, subst)
points to some atom aq of t, which has not yet been matched. The algorithm attempts to
expand this configuration by successively guessing a subtree of configurations, mimicking a
suitable subtree of gcf(D, Œ£) that satisfies the subquery of t rooted at aq .
Whenever Tcheck generates a further configuration, just as for Acheck, Tcheck generates
via universal branching a number of configurations whose joint task is to verify that all
elements of S are indeed provable. (We do not provide further details on how this branching
is done.)
Expansion. The expansion of a main configuration c = (a, S, S ‚Ä≤ , ‚â∫, ‚ãÜ, Tpoint, subst)
works as follows. For a configuration c, Tcheck first checks whether there exists a homomorphism ¬µ such that ¬µ(subst(aq )) = a.
1. (¬µ exists.) If ¬µ exists, we have two cases:
1.1. If aq is a leaf of t, then the current configuration turns into an accepting one.
1.2. If aq is not a leaf of t, then Tcheck nondeterministically guesses whether ¬µ is
a good match, i.e., one that contributes to a global query answer and can be
expanded to map the entire tree t into gcf(D, Œ£).
1.2.1. (Good match). In case of a good match, Tcheck branches universally and
does the following for each child aqs of aq in t. It nondeterministically (i.e.,
via existential branching) creates a new configuration
cs = can as (as , Ss , Ss‚Ä≤ , ‚â∫s , ‚ãÜ, Tpoints , substs )
where Tpoints points to aqs , and where substs encodes the composition ¬µ ‚ó¶
substs . The atom as is guessed, analogously to what is done in Acheck, by
guessing some TGD œÅ ‚àà Œ£ having body Œ¶ and head atom œà, such that
the guard atom g matches a via some homomorphism Œ∏ (that is, Œ∏(g) = a)
and where Œ∏(Œ¶) ‚äÜ S ‚Ä≤ . The cloud subsets Ss and Ss‚Ä≤ are chosen again as in
Acheck. Intuitively, here Tcheck, having found a good match of aq on a, tries
to match the children of aq in t to children (and, eventually, descendants)
of a in gcf(D, Œ£). Finally, the function can as indicates that appropriate
canonizations are made to obtain cs from c (we omit the tedious details).
149

Calƒ±ÃÄ, Gottlob & Kifer

1.2.2. (No good match). In case no good match exists, a child configuration
cnew = cananew (anew , S, S ‚Ä≤ , ‚â∫, ‚ãÜ, Tpoint, subst)
of c is nondeterministically created, whose first component represents a child
anew of a, and where cnew inherits all of its remaining components from c.
Intuitively, after having failed at matching aq (to which, we remind, Tpoint
points) to a, Tcheck attempts at matching the same aq to some child of a in
gcf(D, Œ£). By analogy with the previous case, anew is obtained by guessing
some TGD œÅ ‚àà Œ£ having body Œ¶ and head atom œà, such that the guard
atom g matches a via some homomorphism Œ∏ (that is, Œ∏(g) = a), Œ∏(Œ¶) ‚äÜ S ‚Ä≤ ,
and where anew := Œ∏(œà). Again, the function term cananew indicates that
appropriate canonizations are applied (which we do not describe in detail).
2. (¬µ does not exist.) In this case, Tcheck proceeds exactly as in case 1.2.2, namely, it
attempts at matching the same aq to some child (or eventually some descendant) of
a in gcf(D, Œ£).
Correctness. The correctness of Tcheck can be shown along similar lines as for
Acheck. An important additional point to consider for Tcheck is that, given that the query
t is acyclic, it is actually sufficient to remember at each configuration c only the latest
‚Äúatom‚Äù substitution subst. The correctness of Qcheck then follows from the correctness of
Tcheck and from Lemma 5.8.
Computational cost. As for the complexity of Qcheck, note that in case the arity
is bounded, Tcheck runs in apspace = exptime, and computing chase ‚ä• (D, Œ£) is in exptime by Corollary 5.23. Thus, Qcheck runs in time npexptime = exptime. In case of
unbounded arities, both computing chase ‚ä• (D, Œ£) and running Tcheck are in 2exptime,
therefore Qcheck runs in time np2exptime = 2exptime.
‚ú∑
By combining Theorems 4.1 and 5.9 we immediately get the following characterization
for the complexity of reasoning under weakly guarded sets of TGDs.
Theorem 5.24. Let Œ£ be a weakly guarded set of TGDs on a schema R, D a database for
R, and Q a Boolean conjunctive query. Determining whether D ‚à™ Œ£ |= Q or, equivalently,
whether chase(D, Œ£) |= Q is exptime-complete in case of bounded predicate arities, even
if Œ£ is fixed and Q is atomic. In the general case of unbounded predicate arities, the same
problem is 2exptime-complete. The same completeness results hold for the problem of
query containment under weakly guarded sets of TGDs.
Generalization. The definition of WGTGDs can be generalized to classes of TGDs whose
unguarded positions are guaranteed to contain a controlled finite number of null-values
only. Let f be a computable integer function in two variables. Call a predicate position œÄ
of a TGD set Œ£ f -bounded if no more than f (|D|, |Œ£|) null values appear in chase(D, Œ£) as
arguments in position œÄ; otherwise call Œ£ f -unbounded. A set Œ£ of TGDs is f -weakly guarded
if each each rule of Œ£ contains an atom in its body that covers all variables which occur
within this rule in f -unbounded positions only. By a very minor adaptation of the proof of
Theorem 3.14, it can be seen that CQ-answering for the class of f -weakly guarded TGDs
is decidable. Moreover, by a simple modification of the Qcheck and Tcheck procedures,
150

Taming the Infinite Chase

allowing a polynomial number of nulls to enter ‚Äúunguarded‚Äù positions, it can be shown that
CQ-answering for fixed sets Œ£ of W‚àóGTGDs is exptime-complete in the worst case, where
the class of W‚àóGTGD sets is defined as follows. A set Œ£ of TGDs belongs to this class if
Œ£ is f -weakly guarded for some function f for which there exists a function g, such that
f (|D|, |Œ£|)| 6 |D|g(|Œ£|) .

6. Guarded TGDs
We now turn our attention to GTGDs. We first consider the case of a variable database D
as input. Later, we prove part of the complexity bounds under the stronger condition of
fixed database.
6.1 Complexity‚ÄîVariable Database
Theorem 6.1. Let Œ£ be a set of GTGDs over a schema R and D be a database for R. Let,
as before, w denote the maximum predicate arity in R and |R| the total number of predicate
symbols in R. Then:
(1) Computing chase ‚ä• (D, Œ£) can be done in polynomial time if both w and |R| are
bounded and, thus, also in case of a fixed set Œ£. The same problem is in exptime
(and thus exptime-complete) if w is bounded, and in 2exptime otherwise.
(2) If Q is an atomic or fixed Boolean query then checking whether chase(D, Œ£) |= Q is
ptime-complete when both w and |R| are bounded. The same problem remains ptimecomplete even in case Œ£ is fixed. This problem is exptime-complete if w is bounded
and 2exptime-complete in general. It remains 2exptime-complete even when |R| is
bounded.
(3) If Q is a general conjunctive query, checking chase(D, Œ£) |= Q is np-complete in
case both w and |R| are bounded and, thus, also in case of a fixed set Œ£. Checking
chase(D, Œ£) |= Q is exptime-complete if w is bounded and 2exptime-complete in
general. It remains 2exptime-complete even when |R| is bounded.
(4) BCQ answering under GTGDs is np-complete if both w and |R| are bounded, even
in case the set Œ£ of GTGDs is fixed.
(5) BCQ answering under GTGDs is exptime-complete if w is bounded and 2exptimecomplete in general. It remains 2exptime-complete even when |R| is bounded.
Proof. First, note that items (4) and (5) immediately follow from the first three items,
given that chase(D, Œ£) is a universal model. We therefore just need to prove items (1)-(3).
We first explain how the hardness results are obtained, and then deal with the matching
membership results.
Hardness Results. The ptime-hardness of checking chase(D, Œ£) |= Q for atomic (and
thus also fixed) queries Q and for fixed Œ£ follows from the fact that ground atom inference
from a fixed fully guarded Datalog program over variable databases is ptime-hard. In fact,
in the proof of Theorem 4.4 in the work by Dantsin, Eiter, Gottlob, and Voronkov (2001)
it is shown that fact inference from a single-rule Datalog program whose body has a guard
atom that contains all variables is ptime-hard. The np-hardness in item (3) is immediately
derived from the hardness of CQ containment (which in turn is polynomially equivalent to
151

Calƒ±ÃÄ, Gottlob & Kifer

query answering) without constraints (Chandra & Merlin, 1977). The hardness results for
exptime and 2exptime are all derived via minor variations of the proof of Theorem 4.1.
For example, when |R| is unbounded and w is bounded, the tape cells of the polynomial
worktape are simulated by using polynomially many predicate symbols. For example, the
fact that in configuration v cell 5 contains symbol 1 can be encoded as S51 (v). We omit
further details, given that a much stronger hardness result will be established via a full
proof in Theorem 6.2.
Membership results. The membership results are proved exactly as those for weakly
guarded sets of TGDs, except that instead of using the concept of cloud, we now use a
similar concept of restricted cloud, which coincides with that of a type of an atom in the
work by Calƒ±ÃÄ et al. (2012a). The restricted cloud rcloud (D, Œ£, a) of an atom a ‚àà chase(D, Œ£)
is the set of all atoms b ‚àà chase(D, Œ£) such that dom(b) ‚äÜ dom(a). By a proof that
is almost identical to the one of Theorem 5.16, we can show that if D is a database, Œ£
a set of GTGDs, and if a ‚àà chase(D, Œ£), then ‚àár a = gcf[a, rcloud (D, Œ£, a)], where ‚àár a
is defined as ‚àár a = {a‚Üì } ‚à™ rcloud (D, Œ£, a). It follows that, for the main computational
tasks, we can use algorithms rAcheck, rQcheck, and rTcheck, which differ from the already
familiar Acheck, Qcheck, and Tcheck only in that restricted clouds instead of the ordinary
clouds are used. However, unlike the case when both |R| and w are bounded and a cloud
(or subcloud) can have polynomial size in |D ‚à™ Œ£|, a restricted cloud rcloud (D, Œ£, a) has
a constant number of atoms, and storing its canonical version can a (rcloud (D, Œ£, a)) thus
requires logarithmic space only. In total, in case both |R| and w are bounded, due to the
use of restricted clouds (and subsets thereof) each configuration c of rAcheck and of rTcheck
only requires logarithmic space. Since alogspace = ptime, the ptime-results for atomic
queries in items (1) and (2) follow. Moreover, if both |R| and w are bounded, for general
(non-atomic and non-fixed) queries, the rQcheck algorithm decides if chase(D, Œ£) |= Q in
np by guessing a squid decomposition (in nondeterministic polynomial time) and checking
(in alogspace=ptime) if there is a homomorphism from this squid decomposition into
chase(D, Œ£). Thus, in this case, rQcheck runs in npptime = np, which proves the np upper
bound of Item (3). If, in addition, Q is fixed, then Q has only a constant number of squid
decompositions, and therefore rQcheck runs in ptimeptime = ptime, which proves the ptime
upper bound for fixed queries mentioned in item (2). The exptime and 2exptime upper
bounds are inherited from the same upper bounds for WGTGDs.
Note that one of the main results by Johnson and Klug (1984), namely, that query
containment under inclusion dependencies of bounded arities is np-complete, is a special
case of Item (3) of Theorem 6.1.
6.2 Complexity‚ÄîFixed Database
The next result tightens parts of Theorem 6.1 by showing that the above exptime and
2exptime-completeness results hold even in case of a fixed input database.
Theorem 6.2. Let Œ£ be set of GTGDs on a schema R. As before, let w denote the
maximum arity of predicate in R and |R| be the total number of predicate symbols. Then,
for fixed databases D, checking whether chase(D, Œ£) |= Q is exptime-complete if w is
152

Taming the Infinite Chase

bounded and 2exptime-complete for unbounded w. For unbounded w, this problem remains
2exptime-complete even when |R| is bounded.
Proof. First, observe that the upper bounds (i.e., the membership results for exptime and
2exptime) are inherited from Theorem 6.1, so it suffices to prove the hardness results for
the cases where Q is a fixed atomic query.
We start by proving that checking chase(D, Œ£) |= Q is exptime-hard if w is bounded.
It is well-known that apspace (alternating pspace) equals exptime.
As already noted in the proof of Theorem 4.1, it is sufficient to simulate an linspace
alternating Turing machine (ATM) M that uses at most n worktape cells on every input
(bit string) I of size n, where the input string is initially present on the worktape. In
particular, we will show that M accepts the input I iff chase(D, Œ£) |= Q.
Without loss of generality, we assume that (i) ATM M has exactly one accepting state,
a, which is also a halting state; (ii) the initial state of M is an existential state; (iii) M
alternates at each transition between existential and universal states; and (iv) M never
tries to read beyond its tape boundaries.
Let M be defined as M = (S, Œõ, Œ¥, q0 , {sa }), where S is the set of states, Œõ = {0, 1, ‚ô≠}
is the tape alphabet, ‚ô≠ ‚àà Œõ is the blank tape symbol, Œ¥ : S √ó Œõ ‚Üí (S √ó Œõ √ó {‚Ñì, r, ‚ä•})2
is the transition function (‚ä• denotes the ‚Äústay‚Äù head move, while ‚Ñì and r denote ‚Äúleft‚Äù
and ‚Äúright‚Äù respectively), q0 ‚àà S is the initial state, and {sa } is the singleton set of final
(accepting) states. Since M is an alternating TM, its set of states S is partitioned into
two sets, S‚àÄ and S‚àÉ ‚Äîuniversal and existential states, respectively. The general idea of the
encoding is that the different configurations of M on input I of length n will be represented
by fresh nulls that are generated in the construction of the chase.
Let us now describe the schema R. First, for each integer 1 6 i 6 n, R contains the
predicate head i /1, such that head i (c) be true iff at configuration c the head of M is over
the tape cell i. R also has the predicates zero i /1, one i /1, and blank i /1, where zero i (c),
one i (c), and blank i (c) are true if in configuration c the tape cell i contains the symbol 0, 1,
or ‚ô≠, respectively. Furthermore, for each state s ‚àà S, R has a predicate state s /1, such that
state s (c) is true iff the state of configuration c is s. R also contains: the predicate start/1,
where start(c) is true iff c is the starting configuration; the predicate config/1, which is true
iff its argument identifies a configuration; and the predicate next/3, where next(c, c1 , c2 )
is true if c1 and c2 are the two successor configurations of c. There are also predicates
universal /1 and existential /1, such that universal (c) and existential (c) are true if c is a
universal (respectively, existential) configuration. Finally, there is a predicate accepting/1,
where accepting(c) is true only for accepting configurations c, and a propositional symbol
accept, which is true iff the Turing Machine M accepts the input I.
We now describe a set Œ£(M, I) of GTGDs that simulates the behavior of M on input
I. The rules of Œ£(M, I) are as follows.
1. Initial configuration generation rules. The following rule creates an initial state: ‚Üí
‚àÉX init(X). We also add a rule init(X) ‚Üí config(X), which says that the initial
configuration is, in fact, a configuration.
2. Initial configuration rules. The following set of rules encodes the tape content of the
initial configuration, that is, the input string I. For each 1 6 i 6 n, if the i-th cell
of the tape contains a 0, we add the rule init(X) ‚Üí zero i (X); if it contains a 1, we
153

Calƒ±ÃÄ, Gottlob & Kifer

add init(X) ‚Üí one i (X). We also add the rule init(X) ‚Üí existential (X) in order
to say, without loss of generality, that the initial configuration is an existential one.
Moreover, we add the rules init(X) ‚Üí head 1 (X) and init(X) ‚Üí state s0 (X) to define
the initial values of the state and the head position of M on input I.
3. Configuration generation rules. We add a rule that creates two successor configuration
identifiers for each configuration identifier. Moreover, we add rules stating that these
new configuration identifiers indeed identify configurations:
config(X) ‚Üí ‚àÉX1 ,X2 next(X, X1 , X2 ),
next(X, Y, Z) ‚Üí config(Y ),
next(X, Y, Z) ‚Üí config(Z).
4. Transition rules. We show by example how transition rules are generated for each
transition in the finite control. Assume, for instance, that the transition table contains
a specific transition of the form: (s, 0) ‚Üí ( (s1, 1, r) , (s2, 0, ‚Ñì) ). Then we assert the
following rules, for 1 6 i 6 n:
head i (X), zero i (X), state s (X), next(X, X1 , X2 ) ‚Üí state s1 (X1 )
head i (X), zero i (X), state s (X), next(X, X1 , X2 ) ‚Üí state s2 (X2 ).
Moreover, for each 1 6 i < n we have these rules:
head i (X), zero i (X), state s (X), next(X, X1 , X2 ) ‚Üí one i (X1 )
head i (X), zero i (X), state s (X), next(X, X1 , X2 ) ‚Üí head i+1 (X1 ),
and for each 1 < i 6 n we add these rules:
head i (X), zero i (X), state s (X), next(X, X1 , X2 ) ‚Üí zero i (X2 )
head i (X), zero i (X), state s (X), next(X, X1 , X2 ) ‚Üí head i‚àí1 (X2 )
The other types of transition rules are constructed analogously. Note that the total
number of rules added is 6n times the number of transition rules. Hence it is linearly
bounded by the size n of the input string I to M.
5. Inertia rules. These rules state that tape cells in positions not under the head keep
their values. Thus, for each 1 6 i, j 6 n such that i 6= j we add the rules:
head i (X), zero j (X), next(X, X1 , X2 ) ‚Üí zero j (X1 )
head i (X), one j (X), next(X, X1 , X2 ) ‚Üí one j (X1 )
head i (X), blank j (X), next(X, X1 , X2 ) ‚Üí blank j (X1 ),
6. Configuration-type rules. These rules say that the immediate successor configurations
of an existential configuration are universal, and vice-versa:
existential (X), next(X, X1 , X2 ) ‚Üí universal (X1 )
existential (X), next(X, X1 , X2 ) ‚Üí universal(X2 )
universal (X), next(X, X1 , X2 ) ‚Üí existential (X1 )
universal (X), next(X, X1 , X2 ) ‚Üí existential (X2 ).
154

Taming the Infinite Chase

7. Acceptance rules. These recursive rules state when a configuration is accepting:
state sa (X) ‚Üí accepting(X)
existential (X), next(X, X1 , X2 ), accepting(X1 ) ‚Üí accepting(X)
existential (X), next(X, X1 , X2 ), accepting(X2 ) ‚Üí accepting(X)
universal (X), next(X, X1 , X2 ), accepting(X1 ), accepting(X2 ) ‚Üí accepting(X)
init(X), accepting(X) ‚Üí accept.
This completes the description of the set of TGDs Œ£(M, I). Note that this set is guarded,
has maximum predicate arity 3, can be obtained in logarithmic space from I and the
constant machine description of M. It faithfully simulates the behavior of the alternating
linear space machine M in input I. It follows that Œ£(M, I) |= accept iff M accepts input I.
Let D0 denote the empty database, and let Q0 be the ground-atom query accept. We then
have that Œ£(M, I) ‚à™ D0 |= Q0 iff M accepts input I. This shows that answering ground
atom queries on fixed databases constrained by bounded arity GTGDs is exptime-hard.
Let us now illustrate how we obtain the 2exptime hardness result for guarded TGDs
when arities are unbounded, but when the number |R| of predicate symbols of the schema R
is bounded by a constant. Given that aexpspace=2exptime (aexpspace ‚â° alternating
aexpspace), our aim is now to simulate an aexpspace Turing machine. It is sufficient
to simulate one that uses no more than 2n worktape cells, since the acceptance problem
for such machines is already 2exptime-hard. In fact, by trivial padding arguments, the
acceptance problem for every aexpspace machine can be transformed in polynomial time
into the acceptance problem for one using at most 2n worktape cells.
The problem is, however, that now we can no longer construct a polynomial number of
rules that explicitly address each worktape cell i, or each pair of cells i, j, since now there
is an exponential number of worktape cells. The idea now is to encode tape cell indexes
as vectors of symbols (v1 , . . . , vk ) where vi ‚àà {0, 1}. As in the proof of Theorem 4.1, we
could define, with a polynomial number of rules, a successor relation succ that stores pairs
of indexes as succ(v1 , . . . , vk , w1 , . . . , wk ). However, there is a further difficulty: we now
have two different types of variables: the variables Vi , Wj that range over the bits vi , wi in
the above-described bit vectors, and the variables X, Y, Z that range over configurations.
A major difficulty is that, given that our rules are all guarded, we must make sure that
these two types of variables, whenever they occur elsewhere in a rule body, also occur in
some guard. To this end, we will use a fixed database D01 that contains the single fact
zeroone(0, 1), and we will construct a ‚Äúguard‚Äù relation g such that for each vector v of
n bits and its binary successor w, and for each configuration x with its two successor
configurations y and z, the relation g contains a tuple g(v, w, x, y, z). We will use several
auxiliary relations to construct g.
For technical reasons, the first two arguments of some atoms below will be dummy
variables T0 and T1 that will always be forced to take the values 0 and 1, respectively.
This way, where convenient, we will have the values 0 and 1 available implicitly in form of
variables, and we will not need to use these constants explicitly in our rules.
Given that our database is now non-empty, we do not need to create the initial configuration identifier via an existential rule as before. We can simply take 0 as the identifier
155

Calƒ±ÃÄ, Gottlob & Kifer

of this initial configuration: zeroone(T0 , T1 ) ‚Üí init(T0 , T1 , T0 ). (Here, the first two arguments of init(T0 , T1 , T0 ) just serve, as explained, to carry the values 0 and 1 along.) We
also add: init(T0 , T1 , T0 ) ‚Üí config(T0 , T1 , T0 ) to assert that 0 is the identifier of the initial
configuration. Next we present the new configuration generation rules.
config(T0 , T1 , X) ‚Üí ‚àÉY, ‚àÉZ next(T0 , T1 , X, Y, Z),
next(T0 , T1 , X, Y, Z) ‚Üí config(T0 , T1 , Y ),
next(T0 , T1 , X, Y, Z) ‚Üí config(T0 , T1 , Z).
We use further rules to create a relation b such that each atom b(0, 1, v, x, y, z) contains
a tuple for each vector v of n bits, and for each configuration x. For better readability,
whenever useful, we will use superscripts for indicating the arity of vector variables: for
instance, V(n) denotes V1 , . . . , Vn . Moreover, 0(j) denotes the vector of j zeros and 1(j) the
vector of j ones. We start with the rule next(T0 , T1 , X, Y, Z) ‚Üí b(T0 , T1 , T0 (n) , X, Y, Z),
which defines an atom b(0, 1, 0(n) , x, y, z), for each configuration x and its next-successors
y and z.
The following n rules, for 1 6 i 6 n, generate an exponential number of new atoms, for
each triple X, Y, Z, by swapping 0s to 1s in all possible ways. Eventually, the chase will
generate all possible prefixes of n bits.
b(T0 , T1 , U1 , . . . , Ui‚àí1 , T0 , Ui+1 , . . . , Un , X, Y, Z) ‚Üí
b(T0 , T1 , U1 , . . . , Ui‚àí1 , T1 , Ui+1 , . . . , Un , X, Y, Z).
We are now ready to define the guard-relation g through another group of guarded rules.
For each 0 6 r < n, we add:
b(T0 , T1 , U(r) , T0 , T1 (n‚àír‚àí1) , X, Y, Z) ‚Üí g(U(r) , T0 , T1 (n‚àír‚àí1) , U(r) , T1 , T0 (n‚àír‚àí1) , X, Y, Z).
The above n rules define an exponential number of cell-successor pairs for each triple of
configuration identifiers X, Y, Z, where Y and Z are the ‚Äúnext‚Äù configurations following
X. In particular, the relation g contains precisely all tuples g(v, w, x, y, z), such that v is
an n-ary bit vector, w is its binary successor, x is a configuration identifier, y is its first
successor via the next relation, and z is its second successor via the next relation.
We are now ready to simulate an aexpspace Turing machine M‚Ä≤ over an input string
I by a set of GTGDs Œ£(M‚Ä≤ , I). Since this simulation is similar to the one presented in the
first part of this proof, we just sketch it and point out the main differences.
For the simulation, we use (in addition to the aforementioned auxiliary predicates)
predicates similar to the ones used earlier for the simulation of the exptime Turing machine
M. However, we only use a constant number of predicates. So, rather than using, atoms
head i (x), zero i (x) and so on, we use their vectorized versions head (v, x), zero(v, x) and so
on, where v is a bit vector of length n that takes the role of an exponential index. Thus,
for example, the equivalent of the earlier rule
head i (X), zero i (X), state s (X), next(X, X1 , X2 ) ‚Üí one i (X1 )
is g(V, W, X, X1 , X2 ), head (V, X), zero(V, X), state(X, s) ‚Üí one(V, X1 ). The earlier rule
head i (X), zero i (X), state s (X), next(X, X1 , X2 ) ‚Üí head i‚àí1 (X2 )
156

Taming the Infinite Chase

becomes g(V, W, X, X1 , X2 ), head (W, X), zero(W, X), state(X, s) ‚Üí head (V, X2 ). It is
now straightforward to see how the initialization rules can be written. Informally, for
copying the input string I to the worktape, we place the n input bits of I on the tape by
writing a rule for each such bit. We then add rules that fill all positions from n + 1 to 2n
with blanks. As this can be done in a similar way as in the second part of the proof of
Theorem 4.1, we omit the details.
The only remaining issue is the specification of the inertia rules. These rules deal with
pairs i, j of different, not necessary adjacent, tape cell positions in our earlier simulation.
Here we have only adjacent cell positions available so far. The problem can be solved in
different ways. One possibility is described below.
We can simply modify the definition of the predicate b by adding a second vector of
n bits to the b-atoms so that b-atoms actually have the form b(T0 , T1 , v, u, x, y, z), where
v and u range over all possible distinct pairs of bit vectors of length n. This u vector is
then carried over to the g-atoms. We can thus assume that the g-atoms now have the form
g(v, w, u, x, y, z). The former inertia rule head i (X), zero j (X), next(X, X1 , X2 ) ‚Üí zero j (X1 )
would then become g(V, W, U, X, X1 , X2 ), head (W, X), zero(U, X) ‚Üí zero(U, X1 ).
What remains to be defined are the configuration and the acceptance rules. The configuration rules are very similar to the ones used in the previous reduction, hence we leave
them as an exercise. The acceptance rules are as follows:
state(X, sa ) ‚Üí accepting(X)
existential (X), g(V, W, X, X1 , X2 ), accepting(X1 ) ‚Üí accepting(X)
existential (X), g(V, W, X, X1 , X2 ), accepting(X2 ) ‚Üí accepting(X)
universal (X), g(V, W, X, X1 , X2 ), accepting(X1 ), accepting(X2 ) ‚Üí accepting(X)
zeroone(T0 , T1 ), accepting(T0 ) ‚Üí accept.
This completes the description of the set of TGDs Œ£(M‚Ä≤ , I). Note that this set is
guarded and has a constant number of predicates. It can be obtained in logspace from I
and the constant machine description of M. It also faithfully simulates the behavior of the
alternating exponential space machine M‚Ä≤ on input I. It follows that Œ£(M‚Ä≤ , I) |= accept
iff M‚Ä≤ accepts input I. Let Q0 be the BCQ defined as Q0 = {accept}. We then have
D01 ‚à™ Œ£(M‚Ä≤ , I) |= Q0 iff M‚Ä≤ accepts input I. This shows that answering ground atomic
queries on fixed databases under guarded TGDs with a fixed number of predicate symbols
(but unbounded arity) is 2exptime-hard.

7. Polynomial Clouds Criterion
In the previous section we have seen that, in case of bounded arity, query answering under
weakly guarded sets of TGDs is exptime-complete, while query answering under GTGDs
is np-complete. Note that, for unrestricted queries and databases, np-completeness is the
best we can obtain. In fact, even in the absence of constraints, the BCQ answering problem
is np-complete (Chandra & Merlin, 1977).
In this section, we establish a criterion that can be used as a tool for recognizing relevant
cases where query answering is in np even for weakly guarded sets of TGDs that are not
fully guarded. Note that we consider both a setting where the weakly guarded set Œ£ of
157

Calƒ±ÃÄ, Gottlob & Kifer

TGDs is fixed and a setting where classes of TGD sets are considered. For these classes,
we require uniform polynomial bounds.
Definition 7.1. [Polynomial Clouds Criterion] A fixed weakly guarded set Œ£ of TGDs
satisfies the Polynomial Clouds Criterion (PCC ) if both of the following conditions hold:
1. There exists a polynomial œÄ(¬∑) such that for each database D, |clouds(D, Œ£)/‚âÉ | 6
œÄ(|D|). In other words, up to an isomorphism, there are only polynomially many
clouds.
2. There is a polynomial œÄ ‚Ä≤ (¬∑) such that, for each database D and for each atom a:
‚Ä¢ if a ‚àà D then cloud (D, Œ£, a) can be computed in time œÄ ‚Ä≤ (|D|, |Œ£|), and
‚Ä¢ if a 6‚àà D then cloud (D, Œ£, a) can be computed in time œÄ ‚Ä≤ (|D|, |Œ£|) starting with
D, a, and cloud (D, Œ£, b), where b is the predecessor of a in gcf(D, Œ£).
We also say that Œ£ satisfies the PCC with respect to œÄ and œÄ ‚Ä≤ . Note that in the
above, |Œ£| is constant and can be omitted. However, the use of |Œ£| is justified by the
following. A class C of weakly guarded TGD sets satisfies the PCC if there are fixed
polynomials œÄ and œÄ ‚Ä≤ such that each TGD set in C satisfies the PCC uniformly with
respect to œÄ and œÄ ‚Ä≤ (i.e., each TGD set in this class has œÄ, œÄ ‚Ä≤ as a bound).
Theorem 7.2. Let Œ£ be a fixed weakly guarded set of TGDs over a schema R, such that Œ£
enjoys the Polynomial Clouds Criterion. Then:
‚Ä¢ Deciding for a database D and an atomic or fixed Boolean conjunctive query Q whether
D ‚à™ Œ£ |= Q (equivalently, whether chase(D, Œ£) |= Q) is in ptime.
‚Ä¢ Deciding for a database D and a general Boolean conjunctive query Q whether D‚à™Œ£ |=
Q (equivalently, chase(D, Œ£) |= Q) is in np.
Proof. A polynomial algorithm Acheck2 for atomic queries Q works as follows. We start
to produce the chase forest gcf(D, Œ£) using the standard chase. In addition, immediately
after generating any node a and its cloud cloud (D, Œ£, a) (in polynomial time), we will store
can a (a, cloud (D, Œ£, a)) in a buffer, which we call cloud-store. Whenever a branch of the
forest reaches a vertex b such that can b (cloud (D, Œ£, b)) is already in the cloud-store, further
expansion of that branch b is blocked. Since there can be only a polynomial number of
pairs can a (a, cloud (D, Œ£, a)), the algorithm stops after a polynomial number of chase steps,
each step requiring only polynomial time. Now, by Corollary 5.17, the cloud-store already
contains all possible atoms of chase(D, Œ£) and their clouds, up to isomorphism. To check
whether chase(D, Œ£) |= Q holds for an atomic query Q, it is thus sufficient to test whether
every atom c that occurs in the cloud-store matches Q. In summary, Acheck2 runs in ptime.
The algorithm Qcheck2 for conjunctive queries works just like Qcheck, except that it
calls the algorithm Tcheck2 as a subroutine instead of Tcheck. The input to Tcheck2 is D,
Q, and also the cloud-store computed by Acheck2. We further assume that this cloud-store
identifies each entry e = can a (a, cloud (D, Œ£, a)) by a unique integer e# using O(log n) bits
only. Tcheck2 is an alternating algorithm that works essentially like Tcheck, except for the
following modifications:
‚Ä¢ Tcheck always guesses the full cloud S = cloud (D, Œ£, a), instead of possibly guessing a
subcloud. In contrast, Tcheck2 just guesses the entry number e# of the corresponding
entry can a (a, cloud (D, Œ£, a)) of the cloud-store.
158

Taming the Infinite Chase

‚Ä¢ Tcheck2 verifies correctness of the cloud guess in alogspace using D, a, e# , as well
as b and e‚Ä≤# , where b is the main atom of the predecessor configuration and e‚Ä≤ is the
entry in the cloud-store featuring can b (b, cloud (D, Œ£, b)). Note that such verification
is effectively possible due to condition (2) of Definition 7.1.
‚Ä¢ Tcheck2 only needs to compute the main configuration tree‚Äîthe one whose configurations contain ‚ãÜ. The algorithm does not compute the auxiliary branches, since they
are no longer necessary, as the correctness check S is done in a different way.
‚Ä¢ The configurations of Tcheck2 do not need to guess or memorize linear orders ‚â∫ and
the set S + .
Given that Tcheck2 is an alogspace algorithm, Qcheck2 is an npalogspace procedure. Since
npalogspace = npptime = np, query answering is in np. In case of a fixed conjunctive query
Q, since Q has a constant number of squid decompositions, Qcheck2 runs in ptimeptime =
ptime.
Note that the Polynomial Clouds Criterion is not syntactic. Nevertheless, it is useful
for proving that query answering for some weakly guarded sets TGDs is in np, or even
in polynomial time for atomic queries. An application of this criterion is illustrated in
Section 10.
The following is a direct corollary of Theorem 6.1.
Theorem 7.3. (1) Every set Œ£ of GTGDs satisfies the PCC. (2) For any constant k, the
class of all GTGD sets of arity bounded by k satisfies the PCC.
The following result can be obtained by a minor adaptation of the proof of Theorem 7.2.
Theorem 7.4. Let Œ£ be a fixed weakly guarded set of TGDs that enjoys the Polynomial
Clouds Criterion, and let k be a constant. Then:
(1) For a database D and a Boolean conjunctive query of treewidth 6 k, deciding
whether D ‚à™ Œ£ |= Q (equivalently, chase(D, Œ£) |= Q) is in ptime.
(2) The same tractability result holds for acyclic Boolean conjunctive queries.
By analogy to the PCC, one may define various other criteria based on other bounds.
In particular, we can define the Exponential Clouds Criterion (ECC) for classes of TGD
sets, which we will use in the next section, as follows:
Definition 7.5. [Exponential Clouds Criterion] Let C be a class of weakly guarded TGD
sets. C satisfies the Exponential Clouds Criterion (ECC) if both of the following conditions
are satisfied:
1. There is a polynomial œÄ(¬∑) such that for every database D and any set of TGDs Œ£ in
C of size n, |clouds(D, Œ£)/‚âÉ | 6 2œÄ(|D|+n) .
2. There exists a polynomial œÄ ‚Ä≤ (¬∑) such that for every database D, any set of TGDs Œ£ in
C of size n, and any atom a:
‚Ä≤

‚Ä¢ if a ‚àà D, then cloud (D, Œ£, a) can be computed in time 2œÄ (|D|+n) , and
‚Ä≤
‚Ä¢ if a 6‚àà D, then cloud (D, Œ£, a) can be computed in time 2œÄ (|D|+n) from D, a, and
cloud (D, Œ£, b), where b is the predecessor of a in gcf(D, Œ£).
159

Calƒ±ÃÄ, Gottlob & Kifer

We have the following result on sets of TGDs enjoying the ECC:
Theorem 7.6. If Œ£ is a weakly guarded set of TGDs from a class C that enjoys the Exponential Clouds Criterion, then deciding for a database D and a Boolean conjunctive query
Q (atomic or not) whether D ‚à™ Œ£ |= Q is in exptime.
Proof (sketch). The proof is very similar to that for Theorem 7.2. The main difference is
that ptime and alogspace are replaced by exptime and apspace, respectively. We then
get that query answering for atomic queries is in apspace = exptime, and that answering
non-atomic queries is in npapspace = npexptime = exptime. Thus, in this case, there is no
difference between atomic and non-atomic query answering: both are in exptime.

8. TGDs with Multiple-Atom Heads
As mentioned in Section 2, all complexity results proved so far for single-headed TGDs also
carry over to the general case, where multiple atoms may appear in rule heads. We make
this claim more formal here.
Theorem 8.1. All complexity results derived in this paper for sets TGDs whose heads are
single-atoms are equally valid for sets of multi-atom head TGDs.
Proof (sketch). It suffices to show that the upper bounds carry over to the setting of TGDs
with multiple-atom heads. We exhibit a transformation from an arbitrary set of TGDs Œ£
over a schema R to a set of single-headed TGDs Œ£‚Ä≤ over a schema R‚Ä≤ that extends R with
some auxiliary predicate symbols.
The TGD set Œ£‚Ä≤ is obtained from Œ£ by replacing each rule of the form r : body(X) ‚Üí
head 1 (Y), head 2 (Y), . . . , head k (Y), where k > 1 and Y is the set of all the variables that
appear in the head, with the following set of rules:
body(X) ‚Üí V (Y)
V (Y) ‚Üí head 1 (Y)
V (Y) ‚Üí head 2 (Y)
..
.
V (Y) ‚Üí head k (Y),
where V is a fresh predicate symbol, having the same arity as the number of variables in
Y. Note that, in general, neither Y is contained in X not the other way around. It is
easy to see that, except for the atoms of the form V (Y), chase(D, Œ£) and chase(Œ£‚Ä≤ , D)
coincide. The atoms of the form V (Y) have completely new predicates and thus do not
match any predicate symbol in the conjunctive query Q. Therefore, chase(D, Œ£) |= Q iff
chase(Œ£‚Ä≤ , D) |= Q.
Obviously, Œ£‚Ä≤ can be constructed in logspace from Œ£. Therefore, the extension of our
complexity results to the general case is immediate, except for the case of bounded arity.
Notice that the arity of each auxiliary predicate in the above construction depends on the
number of head-variables of the corresponding transformed TGD, which, in general, is not
bounded.
160

Taming the Infinite Chase

In case of bounded-arity WGTGDs, the exptime upper bound can still be derived
by the above transformation by showing that the class of TGD sets Œ£‚Ä≤ obtained by that
transformation satisfies the Exponential Clouds Criterion of Section 7. To see that for each
database D and each such Œ£‚Ä≤ there is only an exponential number of clouds, notice that
every ‚Äúlarge‚Äù atom V (Y) is derived by a rule with a ‚Äúsmall‚Äù weak guard g in its body,
i.e., a weak guard g of bounded arity. The cloud cloud (D, Œ£‚Ä≤ , g) of this weak guard g
clearly determines everything below g in the guarded chase forest; in particular, the cloud
of V (Y). Thus the set clouds(D, Œ£‚Ä≤ ) of all clouds of all atoms is only determined by the
clouds of atoms of bounded arity. For immediately verifiable combinatorial reasons, there
can be only singly-exponentially many such clouds. This shows that |clouds(D, Œ£‚Ä≤ )/‚âÉ | is
singly-exponentially bounded. Therefore, the first condition of Definition 7.5 is satisfied. It
is not too hard to verify the second condition of Definition 7.5, too. Thus, query-answering
based on bounded-arity WGTGDs is in exptime. Given that GTGDs are a subclass of
WGTGDs, the same exptime bound holds for bounded-arity GTGDs, as well.
A completely different proof of the above theorem follows directly from the results
by Gottlob, Manna, and Pieris (2013a) for the class of GTGDs, and from those by Gottlob,
Manna, and Pieris (2013b) for the class of WGTGDs.

9. EGDs
In this section we deal with equality generating dependencies (EGDs), a generalization of
functional dependencies, which, in turn, generalize key dependencies (Abiteboul, Hull, &
Vianu, 1995).
Definition 9.1. Given a relational schema R, an EGD is a first-order formula of the form
‚àÄXŒ¶(X) ‚Üí X‚Ñì = Xk , where Œ¶(X) is a conjunction of atoms over R, and X‚Ñì , Xk ‚àà X. Such
a dependency is satisfied in an instance B if, whenever there is a homomorphism h that
maps the atoms of Œ¶(X) to atoms of B, we have h(X‚Ñì ) = h(Xk ).
It is possible to ‚Äúrepair‚Äù, or chase, an instance according to EGDs by analogy with the
chase based on TGDs. We start by defining the EGD chase rule.
Definition 9.2. [EGD Applicability] Consider an instance B of a schema R, and an EGD
Œ∑ of the form Œ¶(X) ‚Üí Xi = Xj over R. We say that Œ∑ is applicable to B if there is a
homomorphism h such that h(Œ¶(X)) ‚äÜ B and h(Xi ) 6= h(Xj ).
Definition 9.3. [EGD Chase Rule] Let Œ∑ be an EGD of the form Œ¶(X) ‚Üí Xi = Xj and
suppose that it is applicable to an instance B via a homomorphism h. The result of the
application of Œ∑ on B with h is a failure if {h(Xi ), h(Xj )} ‚äÇ ‚àÜ (because of the unique name
assumption). Otherwise, the result of this application is the instance B ‚Ä≤ obtained from B by
replacing each occurrence of h(Xj ) with h(Xi ) if h(Xi ) precedes h(Xj ) in lexicographical
order. If h(Xj ) precedes h(Xi ) then the occurrences of h(Xi ) are replaced with h(Xj )
Œ∑,h

instead. We write B ‚àí‚Üí B ‚Ä≤ to say that B ‚Ä≤ is obtained from B via a single EGD chase step.
Definition 9.4. [Chase sequence with respect to TGDs and EGDs] Let D be a database
and Œ£ = Œ£T ‚à™ Œ£E , where Œ£T is a set of TGDs and Œ£E is a set of EGDs. A (possibly
infinite) chase sequence of D with respect to Œ£ is a sequence of instances B0 , B1 , . . . such
161

Calƒ±ÃÄ, Gottlob & Kifer

œÉi ,hi

that Bi ‚àí‚Üí Bi+1 , where B0 = D and œÉi ‚àà Œ£T ‚à™ Œ£E for all i > 0. A chase sequence is said
to be failing if its last step is a failure. A chase sequence is said to be fair if every TGD or
EGD that is applicable at a certain step is eventually applied.
In case a fair chase sequence happens to be finite, B0 , . . . , Bm , and no further rule application can change Bm , then the chase is well defined as Bm , and is denoted by chase(D, Œ£).
For our purposes, the order of application of TGDs and EGDs is irrelevant. In the following
therefore, when saying ‚Äúthe fair chase sequence‚Äù, we will refer to any fair chase sequence,
chosen according to some order of application of the dependencies.
It is well-known (see Johnson & Klug, 1984) that EGDs cause problems when combined
with TGDs, because even for very simple types of EGDs, such as plain key constraints, the
implication problem for EGDs plus TGDs and the query answering problem are undecidable.
This remains true even for EGDs together with GTGDs. In fact, even though inclusion
dependencies are fully guarded TGDs, the implication problem, query answering, and query
containment are undecidable when keys are used as EGDs and inclusion dependencies as
TGDs (Chandra & Vardi, 1985; Mitchell, 1983; Calƒ±ÃÄ et al., 2003a).
Moreover, while the result of an infinite chase using TGDs is well-defined as the limit of
an infinite, monotonically increasing sequence (or, equivalently, as the least fixed-point of a
monotonic operator), the sequence of sets obtained in the infinite chase of a database under
TGDs and EGDs is, in general, neither monotonic nor convergent. Thus, even though we
can define the chase procedure for TGDs plus EGDs, it is not clear how the result of an
infinite chase involving both TGDs and EGDs should be defined.
For the above reasons, we cannot hope to extend the positive results for weakly guarded
sets of TGDs, or even GTGDs, from the previous sections to include arbitrary EGDs.
Therefore, we are looking for suitable restrictions on EGDs, which would allow us to: (i)
use the (possibly infinite) chase procedure to obtain a query-answering algorithm, and
(ii) transfer the decidability results and upper complexity bounds derived in the previous
sections to the extended formalism.
A class that fulfills both desiderata is a subclass of EGDs, which we call innocuous
relative to a set of TGDs. These EGDs enjoy the property that query answering is insensitive
to them, provided that the chase does not fail. In other words, when Œ£ = Œ£T ‚à™ Œ£E , where
Œ£T is a set of TGDs, Œ£E a set of EGDs, and Œ£E is innocuous relative to Œ£T , we can simply
ignore these EGDs in a non-failing chase sequence. This is possible because, intuitively, such
a non-failing sequence does not generate any atom that is not entailed by chase(D, Œ£T ).
More specifically, we start from the notion of innocuous application of an EGD. Intuitively, when making two symbols equal, an innocuous EGD application makes some atom
a equal to some other existing atom a0 ; this way, as the only consequence of the EGD
application, the original atom a is lost, but no new atom whatsoever is introduced. The
concept of innocuous EGD application is formally defined as follows.
Definition 9.5. [Innocuous EGD application] Consider a (possibly infinite) non-failing
chase sequence D = B0 , B1 , . . ., starting with a database D, with respect to a set Œ£ =
Œ£T ‚à™ Œ£E , where Œ£T is a set of TGDs and Œ£E is a set of EGDs. We say that the EGD
Œ∑,h

application Bi ‚àí‚Üí Bi+1 , where Œ∑ ‚àà Œ£E and i > 0, is innocuous if Bi+1 ‚äÇ Bi .
162

Taming the Infinite Chase

Notice that innocuousness is a semantic, not syntactic, property. It is desirable to have
innocuous EGD applications because such applications cannot trigger new TGD applications, i.e., TGD applications that were not possible before the EGD was applied.
Given that it might be undecidable whether a set of dependencies from a certain class
guarantees innocuousness of all EGD applications, one can either give a direct proof of
innocuousness for a concrete set of dependencies, as we will do in Section 10.2, or define
sufficient syntactic conditions that guarantee innocuousness of EGD applications for an
entire class of dependencies, as done, e.g., by Calƒ±ÃÄ et al. (2012a).
Definition 9.6. Let Œ£ = Œ£T ‚à™ Œ£E , where Œ£T is a set of TGDs and Œ£E a set of EGDs,
where Œ£ = Œ£T ‚à™ Œ£E . Œ£E is innocuous for Œ£T if, for every database D such that the fair
chase sequence of D with respect to Œ£ is non-failing, each application of an EGD in such
sequence of D with respect to Œ£ is innocuous.
Theorem 9.7. Let Œ£ = Œ£T ‚à™ Œ£E , where Œ£T is a set of TGDs and Œ£E a set of EGDs that is
innocuous for Œ£T . Let D be a database such that the fair chase sequence of D with respect
to Œ£ is non-failing. Then D ‚à™ Œ£ |= Q iff chase(D, Œ£T ) |= Q.
Proof. Consider the fair chase sequence B0 , B1 , . . . of D = B0 in the presence of Œ£, where
œÉi ,hi

Bi ‚àí‚Üí Bi+1 for i > 0 and œÉ ‚àà Œ£T ‚à™ Œ£E . Let us define a modified chase procedure which
we call the blocking chase, denoted by blockchase(D, Œ£). The blocking chase uses two sets:
a set C of blocked atoms and a set of (unblocked) atoms A. When started on a database
D such that D |= Œ£E (the case D 6|= Œ£E is not possible as this implies an immediate chase
failure), C is initialized to the empty set (C = ‚àÖ) and A is initialized to D. After the
initialization, the blocking chase attempts to apply the dependencies in Œ£T ‚à™ Œ£E exactly
in the same way as in the standard fair chase sequence, with the following caveats. While
trying an application of hœÉi , hi i:
‚Ä¢ If œÉi is a TGD, and if hi (body(œÉi )) ‚à© C = ‚àÖ, then apply hœÉi , hi i and add the new atom
generated by this application to A.
‚Ä¢ If œÉi is a TGD and hi (body(œÉi )) ‚à© C 6= ‚àÖ, then the application of hœÉi , hi i is blocked,
and nothing is done.
‚Ä¢ If œÉi is an EGD, then the application of hœÉi , hi i proceeds as follows. Add to C all the
facts that in the standard chase disappear in that step (because Bi ‚äÜ Bi‚àí1 , due to the
innocuousness), i.e., add to C the set Bi ‚àí Bi‚àí1 . Thus, instead of eliminating tuples
from A, the blocking chase simply bans them from being used by putting them in C.
Note that, by the construction of blockchase(D, Œ£), whenever the block chase encounters an
EGD œÉi , hœÉi , hi i is actually applicable, so blockchase(D, Œ£) is well-defined. Let us use Ci and
Ai to denote the values of C and A at step i, respectively. Initially, C0 = ‚àÖ and A0 = D as
explained before. Observe that ‚àÖ = C0 ‚äÜ C1 ‚äÜ C2 ‚äÜ ¬∑ ¬∑ ¬∑ and D = A0 ‚äÜ A1 ‚äÜ A2 ‚äÜ ¬∑ ¬∑ ¬∑ are
monotonically increasing sequences that have least upper bounds C ‚àó = ‚à™i Ci and A‚àó = ‚à™i Ai ,
respectively. Clearly, (C ‚àó , A‚àó ) is the least fixpoint of the transformation performed by
blockchase(D, Œ£) (with respect to component-wise set inclusion).
Now, let S be defined as S = A‚àó ‚àí C ‚àó . By the definition of S, we have: S |= Œ£.
Moreover, there is a homomorphism h that maps chase(D, Œ£T ) to S. Note that h is the
limit homomorphism of the sequence h1 , h2 , h3 , . . . (these hi s are the very homomorphisms
163

Calƒ±ÃÄ, Gottlob & Kifer

used while computing the block chase), and can be defined as the set of all pairs (x, y)
such that there exists an i > 0 such that hi (hi‚àí1 (¬∑ ¬∑ ¬∑ h1 (x))) = y and y is not altered by
any homomorphism hj for j > i. Note that for every instance B that contains D, we have
B |= D. In particular, S |= D. Putting everything together, we conclude that S |= D ‚à™ Œ£.
It is also well-known (see Nash et al., 2006) that for any set of atoms M such that
M |= S ‚à™ Œ£T , there is a homomorphism hM such that hM (chase(D, Œ£T )) ‚äÜ M . Now
assume D ‚à™ Œ£ |= Q. Then S |= Q and, because S ‚äÜ chase(D, Œ£T ), we also have that
chase(D, Œ£T ) |= Q. Conversely, if chase(D, Œ£T ) |= Q, then there is a homomorphism g,
such that g(Q) ‚äÜ chase(D, Œ£T ). Therefore, for any set of atoms M such that M |= D ‚à™ Œ£,
since hM (chase(D, Œ£T )) ‚äÜ M , we have hM (g(Q)) ‚äÜ M . The latter means that M |= Q.
We now come to the problem of checking, given a database D and a set Œ£ = Œ£T ‚à™ Œ£E ,
where Œ£T is set of WGTGDs and Œ£E are EGDs innocuous for Œ£T , whether the fair chase
Œ∑,h

sequence (denoted B0 , B1 , . . .) of D with respect to Œ£ fails. Consider an application Bi ‚àí‚Üí
Bi+1 , with Œ∑ ‚àà Œ£E of the form Œ¶(X) ‚Üí X‚Ñì = Xk . When this application causes the chase
to fail, we have that h(X‚Ñì ) and h(Xk ) are distinct values in dom(D). Notice that Bj exists
for j 6 i, while it does not exist for any j > i.
Lemma 9.8. Consider a database D and a set of dependencies Œ£ = Œ£T ‚à™ Œ£E , where Œ£T
is a weakly guarded set of TGDs and Œ£E are EGDs that are innocuous for Œ£T . Then
the fair chase sequence of D with respect to Œ£ fails iff there is an EGD Œ∑ ‚àà Œ£E of the
form Œ¶(X) ‚Üí X‚Ñì = Xk and a homomorphism h such that h(Œ¶(X)) ‚äÜ chase(D, Œ£T ),
h(X‚Ñì ) 6= h(Xk ), and {h(X‚Ñì ), h(Xk )} ‚äÜ dom(D).
Proof (sketch).
‚ÄúIf‚Äù. Let B0 , B1 , . . . be the fair chase sequence of D with respect to Œ£. First, it is not
difficult to show that, since Œ£E is innocuous relative to Œ£T , if the failure occurs at step ‚Ñì
œÉi ,hi

then all EGD applications Bi ‚àí‚Üí Bi+1 , such that œÉi ‚àà Œ£E and i < ‚Ñì ‚àí 1, are innocuous
(see a similar proof by Calƒ±ÃÄ, Console, & Frosini, 2013) in the sequence B0 , . . . , B‚Ñì‚àí1 . From
this, the ‚Äúif‚Äù direction follows straightforwardly.
‚ÄúOnly if‚Äù. By assumption, Œ∑ fails at some Bk , k > 1. Since applications of innocuous
EGDs can only remove tuples from the chase, it is easily seen that, if Œ∑ is applicable to Bk via
an homomorphism h, then it is also applicable to chase(D, Œ£T ) via the same homomorphism
h, which settles the ‚Äúonly-if‚Äù part.
Theorem 9.9. Consider a database D and a set of dependencies Œ£ = Œ£T ‚à™ Œ£E , where Œ£T
are GTGDs (resp., WGTGDs) and Œ£E are EGDs that are innocuous for Œ£T . Checking
whether the fair chase sequence of D with respect to Œ£ fails is decidable, and has the same
complexity as query answering for GTGDs (resp., WGTGDs) alone.
Proof (sketch). Let neq be a new binary predicate, which will serve as inequality. The
extension of neq is defined as dom(D) √ó dom(D) ‚àí {(d, d) | d ‚àà dom(D)} and can be
constructed in time quadratic in |dom(D)|. Now, for every EGD Œ∑ of the form Œ¶(X) ‚Üí
X1 = X2 , where X1 , X2 ‚àà X, we define the following Boolean conjunctive query (expressed
as a set of atoms): QŒ∑ = Œ¶(X) ‚à™ {neq(X1 , X2 )}. Since, by construction, no new facts of
the form neq(œÉ1 , œÉ2 ) are introduced in the chase, it is immediate to see, from Lemma 9.8,
164

Taming the Infinite Chase

that at least one of the above QŒ∑ has a positive answer if and only if the fair chase sequence
of D with respect to Œ£ fails. By Theorem 9.7, answering the query QŒ∑ can be done with
respect to the chase by Œ£T alone, which is decidable.
Let Œ£ = Œ£T ‚à™ Œ£E be as in the above theorem, D be a database, and let Q be a query.
By the above theorem, we can check Œ£ ‚à™ D |= Q with the help of the following algorithm:
1. check whether the fair chase sequence of D with respect to Œ£ fails with the algorithm
described in Theorem 9.9;
2. if the fair chase sequence of D with respect to Œ£ fails, then return ‚Äútrue‚Äù and halt;
3. if D ‚à™ Œ£T |= Q then return ‚Äútrue‚Äù; otherwise return ‚Äúfalse‚Äù.
This gives us the following corollary:
Corollary 9.10. Answering general conjunctive queries under weakly guarded sets of TGDs
and innocuous EGDs is ptime reducible to answering queries of the same class under a
weakly guarded sets of TGDs alone, and thus has the same complexity.

10. Applications
In this section we discuss applications of our results on weakly guarded sets of TGDs to
Description Logic languages and object-oriented logic languages.
10.1 DL-Lite
DL-Lite (Calvanese et al., 2007; Artale et al., 2009) is a prominent family of ontology
languages that has tractable query answering. Interestingly, a restriction of GTGDs called
linear TGDs (which have exactly one body-atom and one head-atom) properly extends
most DL-Lite languages, as shown by Calƒ±ÃÄ et al. (2012a). The complexity of query answering
under linear TGDs is lower than that of GTGDs, and we refer the reader to the work of Calƒ±ÃÄ
et al. (2012a) for more details.
Furthermore, Calƒ±ÃÄ et al. (2012a) also show that the language of GTGDs properly extends
the description logic EL as well as its extension ELf , which allows inverse and functional
roles. The fact that TGDs capture important DL-based ontology languages confirms that
TGDs are useful tools for ontology modeling and querying.
10.2 F-Logic Lite
F-Logic Lite is an expressive subset of F-logic (Kifer et al., 1995), a well-known formalism
introduced for object-oriented deductive languages. We refer the reader to the work by Calƒ±ÃÄ
and Kifer (2006) for details about F-Logic Lite. Roughly speaking, compared to full FLogic, F-Logic Lite excludes negation and default inheritance, and allows only a limited
form of cardinality constraints. F-Logic Lite can be encoded by a set of twelve TGDs and
EGDs, below, which we denote by Œ£FLL :
œÅ1 : type(O, A, T ), data(O, A, V ) ‚Üí member(V, T ).
œÅ2 : sub(C1 , C3 ), sub(C3 , C2 ) ‚Üí sub(C1 , C2 ).
œÅ3 : member(O, C), sub(C, C1 ) ‚Üí member(O, C1 ).
165

Calƒ±ÃÄ, Gottlob & Kifer

œÅ4 : data(O, A, V ), data(O, A, W ), funct(A, O) ‚Üí V = W .
Note that this is the only EGD in this axiomatization.
œÅ5 : mandatory(A, O) ‚Üí ‚àÉV data(O, A, V ).
Note that this TGD has an existentially quantified variable in the head.
œÅ6 : member(O, C), type(C, A, T ) ‚Üí type(O, A, T ).
œÅ7 : sub(C, C1 ), type(C1 , A, T ) ‚Üí type(C, A, T ).
œÅ8 : type(C, A, T1 ), sub(T1 , T ) ‚Üí type(C, A, T ).
œÅ9 : sub(C, C1 ), mandatory(A, C1 ) ‚Üí mandatory(A, C).
œÅ10 : member(O, C), mandatory(A, C) ‚Üí mandatory(A, O).
œÅ11 : sub(C, C1 ), funct(A, C1 ) ‚Üí funct(A, C).
œÅ12 : member(O, C), funct(A, C) ‚Üí funct(A, O).
The results of this paper apply to the above set of constraints, since Œ£FLL is a weakly
guarded set, and the single EGD œÅ4 is innocuous. The innocuousness of œÅ4 is shown by
observing that, whenever the EGD is applied, it turns one atom into another; moreover,
all new data atoms created in the chase (see rule œÅ5 ) have new labeled nulls exactly in the
position data[3], where the symbols to be equated also reside.
We now prove the relevant complexity results. We start by showing that BCQ answering
under F-Logic Lite is np-complete.
Theorem 10.1. Conjunctive query answering under F-Logic Lite rules is np-hard.
Proof (sketch). The proof is by reduction from the 3-colorability problem. Encode a
graph G = (V, E) as a conjunctive query Q which, for each edge (vi , vj ) in E, has two atoms
data(X, Vi , Vj ) and data(X, Vj , Vi ), where X is a unique variable. Let D be the database
D = {data(o, r, g), data(o, g, r), data(o, r, b), data(o, b, r), data(o, g, b), data(o, b, g)}. Then,
G is three-colorable iff D |= Q, which is the case iff D ‚à™ Œ£FLL |= Q. The transformation
from G to (Q, D) is obviously polynomial, which proves the claim.
Theorem 10.2. Conjunctive query answering under F-Logic Lite rules is in np.
Proof (sketch). As mentioned before, we can ignore the only EGD in Œ£FLL since, being
innocuous, it does not interfere with query answering. Let Œ£‚Ä≤FLL denote the set of TGDs
resulting from Œ£FLL by eliminating rule œÅ4 , i.e., let Œ£‚Ä≤FLL = Œ£FLL ‚àí {œÅ4 }. To establish
membership in np, it is sufficient to show that: (1) Œ£‚Ä≤FLL is weakly guarded; (2) Œ£‚Ä≤FLL enjoys
the PCC (see Definition 7.1). Under the above condition, the membership in np can be
proved by exhibiting the following. (i) An algorithm, analogous to Acheck, that constructs
all ‚Äúcanonical‚Äù versions of the atoms of the chase and their clouds (which are stored in a
‚Äúcloud store‚Äù), in polynomial time. Then the algorithm should check whether an atomic
(Boolean) query is satisfied by an atom in the cloud store. (ii) An algorithm, analogous
to Qcheck, that guesses (by calling an analogous version of Tcheck) entire clouds through
guessing the cloud index (a unique integer) in the cloud store. Then the algorithm should
check, in alternating logarithmic space (alogspace), the correctness of the cloud guess.
In that check, it can use only the cloud of the main atom of the predecessor configuration.
The complexity of running this algorithm is shown to be npalogspace = np.
(1) is easy: the affected positions are data[3], member[1], type[1], mandatory[2], funct[2]
and data[1]. It is easy to see that every rule of Œ£‚Ä≤FLL is weakly guarded, and thus Œ£FLL is
weakly guarded.
166

Taming the Infinite Chase

Now let us sketch (2 ). We need to show that Œ£‚Ä≤FLL satisfies the two conditions of
Definition 7.1. We prove that the first condition holds for Œ£‚Ä≤FLL as follows. Let Œ£full
FLL =
Œ£‚Ä≤FLL ‚àí {œÅ5 }. These are all full TGDs (no existentially-quantified variables) and their appli‚Ä≤
cation does not alter the domain. We have chase(D, Œ£‚Ä≤FLL ) = chase(chase(D, Œ£full
FLL ), Œ£FLL ).
full
Let us now have a closer look at D+ = chase(D, Œ£FLL ). Clearly, dom(D+ ) = dom(D). For
each predicate symbol p, let Rel (p) denote the relation consisting of all the p-atoms in D+ .
Let ‚Ñ¶ be the family of all the relations that can be obtained from any of the relations Rel (p)
by performing an arbitrary selection followed by some projection (we forbid disjunctions in
the selection predicate). For example, let c, d ‚àà dom(D). Then ‚Ñ¶ will contain the relations
œÄ1,2 (œÉ{1=c} Rel (data)), œÄ2 (œÉ{1=d‚àß3=c} Rel (data)), and so on, where the numbers represent the
attributes to which selection is applied. Given that D+ is of size polynomial in D and that
the maximum arity of any relation Rel (p) is 3, the set ‚Ñ¶ is of size polynomial in D+ and
thus polynomial in D. It can now be shown that ‚Ñ¶ is preserved in a precise sense, when
going to the final result chase(D+ , Œ£‚Ä≤FLL ): for each relation Rel ‚Ä≤ (p) corresponding to predicate p in the final chase result, when performing a selection on values outside of dom(D)
and projecting on the columns not used in the selection, the set of all tuples of dom(D)elements in the result is a relation in ‚Ñ¶. For example, if v5 is a labeled null, then the set of
all T ‚àà dom(D), such that member(v5 , T ) is an element of the final result, is a relation in
‚Ñ¶. Similarly, if v7 and v8 are new values, the set of all values A, such that data(v7 , A, v8 )
is in the chase, is a relation in ‚Ñ¶. From this it follows that Œ£‚Ä≤FLL satisfies (2). In fact, all
possible clouds are determined by the polynomially many ways of choosing at most three
elements of ‚Ñ¶ for each predicate. The proof of the preservation property can be done by
induction on the i-th new labeled null added. Roughly, for each such labeled null, created
by rule œÅ5 , we just analyze which sets of values (or tuples) are attached to it via rules œÅ4 ,
then œÅ6 , œÅ7 , œÅ8 , œÅ10 , and so on, and conclude that these sets were already present at the
next lower level, and thus, by induction hypothesis, are in ‚Ñ¶.
The second condition of Definition 7.1 is proved by similar arguments.
From Theorems 10.1 and 10.2 we immediately get the following result.
Corollary 10.3. Conjunctive query answering under F-Logic Lite rules is np-complete for
general conjunctive queries, and in ptime for fixed-size or atomic conjunctive queries.

11. Conclusions and Related Work
In this paper we identified a large and non-trivial class of tuple-generating and equalitygenerating dependencies for which the problems of conjunctive query containment and answering are decidable, and provided the relevant complexity results. Applications of our
results span databases and knowledge representation. In particular, we have shown that
this class of constraints subsumes the classical work by Johnson and Klug (1984) as well as
more recent results from Calƒ±ÃÄ and Kifer (2006). Moreover, we are able to capture relevant
ontology formalisms in the Description Logics (DL) family, in particular DL-Lite and EL.
The problem of query containment for non-terminating chase was addressed in the
database context by Johnson and Klug (1984), where the ontological theory contains inclusion dependencies and key dependencies of a particular form. The introduction of the
DL-Lite family of description logics in the works of Calvanese et al. (2007) and Artale et al.
167

Calƒ±ÃÄ, Gottlob & Kifer

(2009) was a significant leap forward in ontological query answering due to the expressiveness of DL-Lite languages and their tractable data complexity. Conjunctive query answering
in DL-Lite has the advantage of being first-order rewritable, i.e., any pair hQ, Œ£i, where Q
is a CQ and Œ£ is a DL-Lite ontology (TBox), can be rewritten as a first-order query QŒ£
such that, for every database (ABox) D, the answer to Q against the logical theory D ‚à™ Œ£
coincides with the answer to QŒ£ against D. Since each first-order query can be written in
SQL, in practical terms this means that a pair hQ, Œ£i can be rewritten as an SQL query
over the original database D.
Rewritability is widely adopted in ontology querying. The works by Calƒ±ÃÄ, Calvanese,
De Giacomo, and Lenzerini (2001), and by Calƒ±ÃÄ, Lembo, and Rosati (2003b) present query
rewriting techniques that deal with Entity-Relationship schemata and inclusion dependencies, respectively. The work by PeÃÅrez-Urbina, Motik, and Horrocks (2010) presents a Datalog rewriting algorithm for the expressive DL ELHIO¬¨ , which comprises a limited form of
concept and role negation, role inclusion, inverse roles, and nominals, i.e., concepts that are
interpreted as singletons. Conjunctive query answering in ELHIO¬¨ is ptime-complete in
data complexity, and the proposed algorithm is also optimal for other ontology languages
such as DL-Lite. Optimizations of rewriting under linear TGDs (TGDs with exactly one
atom in the body) are presented by Gottlob, Orsi, and Pieris (2011), and by Orsi and Pieris
(2011). Gottlob and Schwentick (2012) showed that the rewriting of a conjunctive query
under a set of linear TGDs can be of polynomial size in the query and the TGD set.
Other rewriting techniques for ptime-complete languages (in data complexity) have been
proposed for the description logic EL (Rosati, 2007; Lutz, Toman, & Wolter, 2009; KroÃàtzsch
& Rudolph, 2007). Another approach worth mentioning is a combination of rewriting and
of the chase (see Kontchakov, Lutz, Toman, Wolter, & Zakharyaschev, 2010); this technique
was introduced for DL-Lite in order to tackle the performance problems that arise when
the rewriting according to the ontology is too large.
Recent works concentrate on semantic characterization of sets of TGDs under which
query answering is decidable (Baget et al., 2011a). The notion of first-order rewritability is
tightly connected to that of finite unification set (FUS). A FUS is semantically characterized
as a set of TGDs that enjoy the following property: for every conjunctive query Q, the
rewriting QŒ£ of Q obtained by backward-chaining through unification, according to the
rules in Œ£, terminates. Another semantic characterization of TGDs is that of bounded
treewidth set (BTS), i.e., a set of TGDs such that the chase under such TGDs has bounded
treewidth. As seen in Section 3, every weakly guarded set of TGDs is a BTS. A finite
expansion set (FES) is a set of TGDs that guarantees, for every database, the termination
of the restricted chase, and therefore the decidability of query answering.
The Datalog¬± family (Calƒ±ÃÄ et al., 2011) has been proposed with the purpose of providing
tractable query answering algorithms for more general ontology languages. In Datalog¬± , the
fundamental constraints are TGDs and EGDs. Clearly, TGDs are an extension of Datalog
rules. The absence of value invention (existential quantification in the head), thoroughly
discussed by Patel-Schneider and Horrocks (2007), is the main shortcoming of plain Datalog
in modeling ontologies and even conceptual data formalisms such as the Entity-Relationship
model (Chen, 1976). Sets of GTGDs or WGTGDs are Datalog¬± ontologies. Datalog¬±
languages easily extend the most common tractable ontology languages; in particular, the
168

Taming the Infinite Chase

main DL-Lite languages (see Calƒ±ÃÄ et al., 2012a). The fundamental decidability paradigms
in the Datalog¬± family are the following:
‚Ä¢ Chase termination. When the chase terminates, a finite instance is produced; obviously, by Theorem 2.10, query answering in such a case is decidable. The most notable
syntactic restriction guaranteeing chase termination is weak acyclicity of TGDs, for
which we refer the reader to the milestone paper of Fagin et al. (2005). More general
syntactic restrictions are studied by Deutsch, Nash, and Remmel (2008), Marnette
(2009), Greco, Spezzano, and Trubitsyna (2011), Baget et al. (2011a), and Grau,
Horrocks, KroÃàtzsch, Kupke, Magka, Motik, and Wang (2012). A semantic property
of TGDs, called parsimony, is introduced by Leone, Manna, Terracina, and Veltri
(2012). Parsimony ensures decidability of query answering by termination of a special
version of chase, called parsimonious chase.
‚Ä¢ Guardedness. This is the paradigm we studied in this paper. A thorough study of
the data complexity of query answering under GTGDs and linear TGDs, a subset
of the guarded class, is found in the work by Calƒ±ÃÄ et al. (2012a). The interesting
classes of frontier guarded (FGTGDs) and weakly frontier-guarded TGDs (WFGTGDs) were considered and studied by Baget et al. (2011a), Baget, Mugnier, Rudolph,
and Thomazo (2011b), and KroÃàtzsch and Rudolph (2011). The idea underlying these
classes is that, to obtain decidability, it is sufficient to guard only frontier variables,
that is, variables that occur both in the body and in the head of a rule.8 WFGTGDs are syntactically more liberal and more succinct than WGTGDs, but conjunctive query answering under WFGTGDs is computationally more expensive in case of
bounded arities. It can be seen that querying under WFGTGDs is no more expressive
than querying under WGTGDs. In fact, for every WFGTGD set Œ£ and CQ Q, there
exists a WGTGD set Œ£‚Ä≤ and a CQ Q‚Ä≤ such that for every database D, D ‚à™ Œ£ |= Q iff
D ‚à™ Œ£‚Ä≤ |= Q‚Ä≤ . A generalization of WFGTGDs, called greedy bounded-treewidth TGDs,
was proposed by Baget et al. (2011b), together with a complexity analysis. The guardedness paradigm has been combined with acyclicity by KroÃàtzsch and Rudolph (2011),
where a generalization of both WFGTGDs and weakly acyclic TGDs is proposed.
‚Ä¢ Stickiness. The class of sticky sets of TGDs (or sticky Datalog¬± , see Calƒ±ÃÄ et al., 2012b)
is defined by means of syntactic restriction on the rule bodies, which ensure that each
sticky set of TGDs is first-order rewritable, being a FUS, according to Baget et al.
(2011a). Civili and Rosati (2012) have proposed an extension of sticky sets of TGDs.
The interaction between equality generating dependencies and TGDs has been the subject of several works, starting from the work of Johnson and Klug (1984), which deals with
functional and inclusion dependencies, proposing a class of inclusion dependencies called
key-based, which, intuitively, has no interaction with key dependencies thanks to syntactic
restrictions. The absence of interaction between EGDs and TGDs is captured by the notion
of separability, first introduced by Calƒ±ÃÄ et al. (2003a) for key and inclusion dependencies,
and also adopted, though sometimes not explicitly stated, for instance, by Calƒ±ÃÄ, Gottlob,
and Pieris (2012a), Artale et al. (2009) and Calvanese et al. (2007)‚Äîsee the work by Calƒ±ÃÄ,
Gottlob, Orsi, and Pieris (2012b) for a survey on the topic.
8. FGTGDs were independently discovered by Mantas SÃåimkus while working on his doctoral thesis.

169

Calƒ±ÃÄ, Gottlob & Kifer

As shown by Calƒ±ÃÄ et al. (2012a), stratified negation can be added straightforwardly to
Datalog¬± . More recently, guarded Datalog¬± was extended by two versions of well-founded
negation (see Gottlob, Hernich, Kupke, & Lukasiewicz, 2012; Hernich, Kupke, Lukasiewicz,
& Gottlob, 2013).
In ontological query answering, normally both finite and infinite models of theories are
considered. In some cases, restricting the attention to finite solutions (models) only is not
always equivalent to the general approach. The property of equivalence between query
answering under finite models and query answering under arbitrary models (finite and
infinite) is called finite controllability, and it was proved for restricted classes of functional
and inclusion dependencies by Johnson and Klug (1984). Finite controllability was proved
for the class of arbitrary inclusion dependencies in a pioneering work by Rosati (2011). An
even more general result appears in the work of BaÃÅraÃÅny et al. (2010), where it is shown that
finite controllability holds for guarded theories.
A related previous approach to guarded logic programming is guarded open answer set
programming (Heymans, Nieuwenborgh, & Vermeir, 2005). It is easy to see that a set of
GTGDs can be interpreted as a guarded answer set program, as defined by Heymans et al.
(2005), but guarded answer set programs are more expressive than GTGDs because they
allow negation.
Implementations of ontology-based data access systems take advantage of query answering techniques for tractable ontologies; in particular, we mention DLV‚àÉ (Leone et al., 2012),
Mastro (Savo, Lembo, Lenzerini, Poggi, Rodriguez-Muro, Romagnoli, Ruzzi, & Stella, 2010)
and NYAYA (De Virgilio, Orsi, Tanca, & Torlone, 2012).
Acknowledgments
This is the extended version of results by the same authors, published in the KR 2008 Conference and in the DL 2008 Workshop. Andrea Calƒ±ÃÄ and Georg Gottlob are also affiliated
with the Oxford-Man Institute of Quantitative Finance, University of Oxford, UK. Andrea
Calƒ±ÃÄ acknowledges support by the EPSRC project ‚ÄúLogic-based Integration and Querying
of Unindexed Data‚Äù (EP/E010865/1). Georg Gottlob acknowledges funding from the European Research Council under the European Community‚Äôs Seventh Framework Program
(FP7/2007-2013) / ERC grant agreement DIADEM no. 246858. Michael Kifer was partially supported by the NSF grant 0964196. The authors are grateful to Andreas Pieris,
Marco Manna, Michael Morak and the anonymous reviewers for their valuable comments
and suggestions to improve the paper.

References
Abiteboul, S., Hull, R., & Vianu, V. (1995). Foundations of Databases. Addison-Wesley.
Adler, I., Gottlob, G., & Grohe, M. (2007). Hypertree width and related hypergraph invariants. Eur. Journal of Combinatorics, 28 (8), 2167‚Äì2181.
Aho, A., Sagiv, Y., & Ullman, J. D. (1979). Equivalence of relational expressions. SIAM
Journal of Computing, 8 (2), 218‚Äì246.
Arenas, M., Bertossi, L. E., & Chomicki, J. (1999). Consistent query answers in inconsistent
databases. In Proc of PODS 1999, pp. 68‚Äì79.
170

Taming the Infinite Chase

Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). The DL-lite family
and relations. J. Artif. Intell. Res., 36, 1‚Äì69.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing the EL envelope. In Proc. of IJCAI 2005,
pp. 364‚Äì369.
Baget, J.-F., LecleÃÄre, M., Mugnier, M.-L., & Salvat, E. (2011a). On rules with existential
variables: Walking the decidability line. Artif. Intell., 175 (9‚Äì10), 1620‚Äì1654.
Baget, J.-F., Mugnier, M.-L., Rudolph, S., & Thomazo, M. (2011b). Walking the complexity
lines for generalized guarded existential rules. In Proc. of IJCAI 2011, pp. 712‚Äì717.
BaÃÅraÃÅny, V., Gottlob, G., & Otto, M. (2010). Querying the guarded fragment. In Proc. of
LICS 2010, pp. 1‚Äì10.
Beeri, C., Fagin, R., Maier, D., Mendelzon, A. O., Ullman, J. D., & Yannakakis, M. (1981).
Properties of acyclic database schemes. In Proc. of STOC 1981, pp. 355‚Äì362.
Beeri, C., & Vardi, M. Y. (1981). The implication problem for data dependencies. In
Proc. of ICALP 1981, pp. 73‚Äì85.
Bourhis, P., Morak, M., & Pieris, A. (2013). The impact of disjunction on query answering
under guarded-based existential rules. In Proc. of IJCAI 2013.
Cabibbo, L. (1998). The expressive power of stratified logic programs with value invention.
Inf. Comput., 147 (1), 22‚Äì56.
Calƒ±ÃÄ, A., Calvanese, D., De Giacomo, G., & Lenzerini, M. (2001). Accessing data integration
systems through conceptual schemas. In Proc. of ER 2001, pp. 270‚Äì284.
Calƒ±ÃÄ, A., Console, M., & Frosini, R. (2013). On separability of ontological constraints.
Forthcoming.
Calƒ±ÃÄ, A., Gottlob, G., & Kifer, M. (2008). Taming the infinite chase: Query answering under
expressive relational constraints. In Proc. of KR 2008, pp. 70‚Äì80.
Calƒ±ÃÄ, A., Gottlob, G., & Lukasiewicz, T. (2009). A general datalog-based framework for
tractable query answering over ontologies. In Proc. of PODS 2009, pp. 77‚Äì86.
Calƒ±ÃÄ, A., Gottlob, G., & Lukasiewicz, T. (2012a). A general datalog-based framework for
tractable query answering over ontologies. J. Web Semantics, 14, 57‚Äì83. Extended
version of (Calƒ±ÃÄ, Gottlob, & Lukasiewicz, 2009).
Calƒ±ÃÄ, A., Gottlob, G., Orsi, G., & Pieris, A. (2012b). On the interaction of existential rules
and equality constraints in ontology querying. In Proc. of Correct Reasoning 2012,
pp. 117‚Äì133.
Calƒ±ÃÄ, A., Gottlob, G., & Pieris, A. (2011). New expressive languages for ontological query
answering. In Proc. of AAAI 2011.
Calƒ±ÃÄ, A., Gottlob, G., & Pieris, A. (2012a). Ontological query answering under expressive
entity-relationship schemata. Inf. Syst., 37 (4), 320‚Äì335.
Calƒ±ÃÄ, A., Gottlob, G., & Pieris, A. (2012b). Towards more expressive ontology languages:
The query answering problem. Artif. Intell., 193, 87‚Äì128.
Calƒ±ÃÄ, A., & Kifer, M. (2006). Containment of conjunctive object meta-queries. In Proc. of
VLDB 2006, pp. 942‚Äì952.
171

Calƒ±ÃÄ, Gottlob & Kifer

Calƒ±ÃÄ, A., Lembo, D., & Rosati, R. (2003a). On the decidability and complexity of query
answering over inconsistent and incomplete databases. In PODS 2003, pp. 260‚Äì271.
Calƒ±ÃÄ, A., Lembo, D., & Rosati, R. (2003b). Query rewriting and answering under constraints
in data integration systems. In Proc. of IJCAI 2003, pp. 16‚Äì21.
Calƒ±ÃÄ, A., & Martinenghi, D. (2010). Querying incomplete data over extended er schemata.
TPLP, 10 (3), 291‚Äì329.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning and efficient query answering in description logics: The DL-lite family. J.
Autom. Reasoning, 39 (3), 385‚Äì429.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (2002). Description logics for information
integration. In Computational Logic: Logic Programming and Beyond, Vol. 2408 of
LNCS, pp. 41‚Äì60. Springer.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1998). On the decidability of query
containment under constraints. In Proc. of PODS 1998, pp. 149‚Äì158.
Chandra, A. K., Kozen, D., & Stockmeyer, L. J. (1981a). Alternation. J. of the ACM,
28 (1), 114‚Äì133.
Chandra, A. K., Lewis, H. R., & Makowsky, J. A. (1981b). Embedded implicational dependencies and their inference problem. In Proc. of STOC 1981, pp. 342‚Äì354.
Chandra, A. K., & Merlin, P. M. (1977). Optimal implementation of conjunctive queries in
relational data bases. In Proc. of STOC 1977, pp. 77‚Äì90.
Chandra, A. K., & Vardi, M. Y. (1985). The implication problem for functional and inclusion
dependencies is undecidable. SIAM J. Comput., 14, 671‚Äì677.
Chen, P. P. (1976). The entity-relationship model - toward a unified view of data. Trans.
Database Syst., 1 (1), 9‚Äì36.
Civili, C., & Rosati, R. (2012). A broad class of first-order rewritable tuple-generating
dependencies. In Proc. of Datalog 2.0 2012, pp. 68‚Äì80.
Courcelle, B. (1990). The monadic second-order logic of graphs. I. recognizable sets of finite
graphs. Information and Computation, 85 (1), 12‚Äì75.
Dantsin, E., Eiter, T., Gottlob, G., & Voronkov, A. (2001). Complexity and expressive
power of logic programming. ACM Computing Surveys, 33 (3), 374‚Äì425.
De Virgilio, R., Orsi, G., Tanca, L., & Torlone, R. (2012). NYAYA: A system supporting
the uniform management of large sets of semantic data. In Proc. of ICDE 2012, pp.
1309‚Äì1312.
Deutsch, A., Nash, A., & Remmel, J. B. (2008). The chase revisited. In Proc. of PODS 2008,
pp. 149‚Äì158.
Fagin, R. (1983). Degrees of acyclicity for hypergraphs and relational database schemes.
J. ACM, 30 (3), 514‚Äì550.
Fagin, R., Kolaitis, P. G., Miller, R. J., & Popa, L. (2005). Data exchange: semantics and
query answering. Theor. Comput. Sci., 336 (1), 89‚Äì124.
172

Taming the Infinite Chase

Goncalves, M. E., & GraÃàdel, E. (2000). Decidability issues for action guarded logics. In
Proc. of DL 2000, pp. 123‚Äì132.
Gottlob, G., Hernich, A., Kupke, C., & Lukasiewicz, T. (2012). Equality-friendly wellfounded semantics and applications to description logics. In Proc. of AAAI 2012.
Gottlob, G., Leone, N., & Scarcello, F. (2001). Hypertree decompositions: A survey. In
Proc. of MFCS 2001, pp. 37‚Äì57.
Gottlob, G., Leone, N., & Scarcello, F. (2002). Hypertree decompositions and tractable
queries. J. Comp. Syst. Sci., 64 (3).
Gottlob, G., Leone, N., & Scarcello, F. (2003). Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width. J. Comput. Syst. Sci., 66 (4),
775‚Äì808.
Gottlob, G., Manna, M., & Pieris, A. (2013a). Combining decidability paradigms for existential rules. To appear in TPLP.
Gottlob, G., Manna, M., & Pieris, A. (2013b). Querying hybrid fragments of existential
rules. Forthcoming.
Gottlob, G., & Nash, A. (2006). Data exchange: computing cores in polynomial time. In
Proc. of PODS 2006, pp. 40‚Äì49.
Gottlob, G., Orsi, G., & Pieris, A. (2011). Ontological queries: Rewriting and optimization.
In Proc. of ICDE 2011, pp. 2‚Äì13.
Gottlob, G., & Schwentick, T. (2012). Rewriting ontological queries into small nonrecursive
datalog programs. In Proc. of KR 2012.
GraÃàdel, E. (1999). On the restraining power of guards. J. Symb. Log., 64 (4), 1719‚Äì1742.
Grau, B. C., Horrocks, I., KroÃàtzsch, M., Kupke, C., Magka, D., Motik, B., & Wang, Z.
(2012). Acyclicity conditions and their application to query answering in description
logics. In Proc. of KR 2012.
Greco, S., Spezzano, F., & Trubitsyna, I. (2011). Stratification criteria and rewriting techniques for checking chase termination. PVLDB, 4 (11), 1158‚Äì1168.
Hernich, A., Kupke, C., Lukasiewicz, T., & Gottlob, G. (2013). Well-founded semantics for
extended datalog and ontological reasoning. In Proc. of PODS 2013, pp. 225‚Äì236.
Hernich, A., Libkin, L., & Schweikardt, N. (2011). Closed world data exchange. ACM
Trans. Database Syst., 36 (2), 14‚Äì53.
Heymans, S., Nieuwenborgh, D. V., & Vermeir, D. (2005). Guarded open answer set programming. In Proc. of LPNMR 2005.
Johnson, D. S., & Klug, A. (1984). Testing containment of conjunctive queries under
functional and inclusion dependencies. J. Comp. Syst. Sci., 28, 167‚Äì189.
Kifer, M., Lausen, G., & Wu, J. (1995). Logical foundations of object-oriented and framebased languages. J. ACM, 42, 741‚Äì843.
Koch, C. (2002). Query rewriting with symmetric constraints. In Proc. of FoIKS 2002, pp.
130‚Äì147.
173

Calƒ±ÃÄ, Gottlob & Kifer

Kontchakov, R., Lutz, C., Toman, D., Wolter, F., & Zakharyaschev, M. (2010). The combined approach to query answering in dl-lite. In Proc. of KR 2010.
KroÃàtzsch, M., & Rudolph, S. (2007). Conjunctive queries for EL with composition of roles.
In Proc. of DL 2007.
KroÃàtzsch, M., & Rudolph, S. (2011). Extending decidable existential rules by joining acyclicity and guardedness. In Proc. of IJCAI 2011, pp. 963‚Äì968.
Leone, N., Manna, M., Terracina, G., & Veltri, P. (2012). Efficiently computable datalog;
programs. In Proc. of KR 2012.
Li, L., & Horrocks, I. (2003). A software framework for matchmaking based on semantic
web technology. In Proc. of WWW 2003.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering in the description
logic EL using a relational database system. In Proc. of IJCAI 2009, pp. 2070‚Äì2075.
Maier, D., Mendelzon, A. O., & Sagiv, Y. (1979). Testing implications of data dependencies.
Trans. Database Syst., 4 (4), 455‚Äì469.
Mailharrow, D. (1998). A classification and constraint-based framework for configuration.
Artif. Intell. for Eng. Design, Anal. and Manuf., 12 (4), 383‚Äì397.
Marnette, B. (2009). Generalized schema-mappings: from termination to tractability. In
Proc. of PODS 2009, pp. 13‚Äì22.
Millstein, T., Levy, A., & Friedman, M. (2000). Query containment for data integration
systems. In PODS 2000.
Mitchell, J. C. (1983). The implication problem for functional and inclusion dependencies.
Inf. and Control, 56, 154‚Äì173.
Nash, A., Deutsch, A., & Remmel, J. (2006). Data exchange, data integration, and chase.
Tech. rep. CS2006-0859, UCSD.
Orsi, G., & Pieris, A. (2011). Optimizing query answering under ontological constraints.
PVLDB, 4 (11), 1004‚Äì1015.
Patel-Schneider, P. F., & Horrocks, I. (2007). A comparison of two modelling paradigms in
the semantic web. J. Web Semantics, 5 (4), 240‚Äì250.
PeÃÅrez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering and rewriting
under description logic constraints. J. Appl. Logic, 8 (2), 186‚Äì209.
Qian, X. (1996). Query folding. In Proc. of ICDE 1996, pp. 48‚Äì55.
Rabin, M. O. (1969). Decidability of second-order theories and automata on infinite trees.
Trans. Am. Math. Soc., 141 (1‚Äì35), 4.
Rosati, R. (2007). On conjunctive query answering in EL. In Proc. of DL 2007.
Rosati, R. (2011). On the finite controllability of conjunctive query answering in databases
under open-world assumption. J. Comput. Syst. Sci., 77 (3), 572‚Äì594.
Savo, D. F., Lembo, D., Lenzerini, M., Poggi, A., Rodriguez-Muro, M., Romagnoli, V.,
Ruzzi, M., & Stella, G. (2010). Mastro at work: Experiences on ontology-based data
access. In Proc. of Description Logics.

174

Journal of Artificial Intelligence Research 48 (2013) 23-65

Submitted 04/13; published 10/13

Learning Optimal Bayesian Networks:
A Shortest Path Perspective
Changhe Yuan

changhe.yuan@qc.cuny.edu

Department of Computer Science
Queens College/City University of New York
Queens, NY 11367 USA

Brandon Malone

brandon.malone@cs.helsinki.fi

Department of Computer Science
Helsinki Institute for Information Technology
Fin-00014 University of Helsinki, Finland

Abstract
In this paper, learning a Bayesian network structure that optimizes a scoring function
for a given dataset is viewed as a shortest path problem in an implicit state-space search
graph. This perspective highlights the importance of two research issues: the development
of search strategies for solving the shortest path problem, and the design of heuristic functions for guiding the search. This paper introduces several techniques for addressing the
issues. One is an A* search algorithm that learns an optimal Bayesian network structure
by only searching the most promising part of the solution space. The others are mainly
two heuristic functions. The first heuristic function represents a simple relaxation of the
acyclicity constraint of a Bayesian network. Although admissible and consistent, the heuristic may introduce too much relaxation and result in a loose bound. The second heuristic
function reduces the amount of relaxation by avoiding directed cycles within some groups
of variables. Empirical results show that these methods constitute a promising approach
to learning optimal Bayesian network structures.

1. Introduction
Bayesian networks are graphical models that represent uncertain relations between the
random variables in a domain compactly and intuitively. A Bayesian network is a directed
acyclic graph in which nodes represent random variables, and the arcs or lack of them
represent the dependence/conditional independence relations between the variables. The
relations are further quantified by a set of conditional probability distributions, one for
each variable conditioning on its parents. Overall, a Bayesian network represents a joint
probability distribution over the variables.
Applying Bayesian networks to real-world problems typically requires building graphical
representations of the problems. One popular approach is to use score-based methods to
find high-scoring structures for a given dataset (Cooper & Herskovits, 1992; Heckerman,
1998). Score-based learning has been shown to be NP-hard, however (Chickering, 1996).
Due to the complexity, early research in this area mainly focused on developing approximation algorithms such as greedy hill climbing approaches (Heckerman, 1998; Bouckaert,
1994; Chickering, 1995; Friedman, Nachman, & Pe‚Äôer, 1999). Unfortunately the solutions
found by these methods have unknown quality. In recent years, several exact learning algoc
2013
AI Access Foundation. All rights reserved.

Yuan & Malone

rithms have been developed based on dynamic programming (Koivisto & Sood, 2004; Ott,
Imoto, & Miyano, 2004; Silander & Myllymaki, 2006; Singh & Moore, 2005), branch and
bound (de Campos & Ji, 2011), and integer linear programming (Cussens, 2011; Jaakkola,
Sontag, Globerson, & Meila, 2010; Hemmecke, Lindner, & Studeny, 2012). These methods
are guaranteed to find optimal solutions when able to finish successfully. However, their
efficiency and scalability leave much room for improvement.
In this paper, we view the problem of learning a Bayesian network structure that optimizes a scoring function for a given dataset as a shortest path problem. The idea is to
represent the solution space of a learning problem as an implicit state-space search graph,
such that the shortest path between the start and goal nodes in the graph corresponds to
an optimal Bayesian network. This perspective highlights the importance of two orthogonal
research issues: the development of search strategies for solving the shortest path problem,
and the design of admissible heuristic functions for guiding the search. We present several
techniques to address these issues. Firstly, an A* search algorithm is developed to learn an
optimal Bayesian network by focusing on searching the most promising parts of the solution
space. Secondly, two heuristic functions are introduced to guide the search. The tightness
of the heuristic determines the efficiency of the search algorithm. The first heuristic represents a simple relaxation of the acyclicity constraint of Bayesian networks such that each
variable chooses optimal parents independently. As a result, the heuristic estimate may
contain many directed cycles and result in a loose bound. The second heuristic, named
k-cycle conflict heuristic, is based on the same form of relaxation but tightens the bound
by avoiding directed cycles within some groups of variables. Finally, when traversing the
search graph, we need to calculate the cost for each arc being visited, which corresponds
to selecting optimal parents for a variable out of a candidate set. We present two data
structures for storing and querying the costs of all candidate parent sets. One is a set of
full exponential-size data structures called parent graphs that are stored as hash tables and
can answer each query in constant time. The other is a sparse representation of the parent
graph which only stores optimal parent sets to improve the space efficiency.
We empirically evaluated the A* algorithm empowered with different combinations of
the heuristic functions and parent graph representations on a set of UCI machine learning
datasets. The results show that even with the simple heuristic and full parent graph representation, A* can often achieve better efficiency and/or scalability than existing approaches
for learning optimal Bayesian networks. The k-cycle conflict heuristic and the sparse parent
graph representation further enabled the algorithm to achieve even greater efficiency and
scalability. The results indicate that our proposed methods constitute a promising approach
to learning optimal Bayesian network structures.
The remainder of the paper is structured as follows. Section 2 reviews the problem
of learning optimal Bayesian networks and reviews related work. Section 3 introduces the
shortest path perspective of the learning problem. The formulation of the search graph is
discussed in detail. Section 4 introduces two data structures that we developed to compute
and store optimal parent sets for all pairs of variables and candidate sets. The data structures are used to query the cost of each arc in the search graph. Section 5 presents the
A* search algorithm. We developed two heuristic functions for guiding the algorithm and
studied their theoretical properties. Section 6 presents empirical results for evaluating our
algorithm against several existing approaches. Finally, Section 7 concludes the paper.
24

Learning Optimal Bayesian Networks

2. Background
We first provide a brief summary of related work on learning Bayesian networks.
2.1 Learning Bayesian Network Structures
A Bayesian network is a directed acyclic graph (DAG) G that represents a joint probability
distribution over a set of random variables V = {X1 , X2 , ..., Xn }. A directed arc from Xi to
Xj represents the dependence between the two variables; we say Xi is a parent of Xj . We
use PAj to stand for the parent set of Xj . The dependence relation between Xj and PAj are
quantified using a conditional probability distribution, P (Xj |PAj ). The joint probability
distribution represented by G is factorized as the product
Q of all the conditional probability
distributions in the network, i.e., P (X1 , ..., Xn ) = ni=1 P (Xi |PAi ). In addition to the
compact representation, Bayesian networks also provide principled approaches to solving
various inference tasks, including belief updating, most probable explanation, maximum a
Posteriori assignment (Pearl, 1988), and most relevant explanation (Yuan, Liu, Lu, & Lim,
2009; Yuan, Lim, & Littman, 2011a; Yuan, Lim, & Lu, 2011b).
Given a dataset D = {D1 , ..., DN }, where each data point Di is a vector of values over
variables V, learning a Bayesian network is the task of finding a network structure that
best fits D. In this work, we assume that each variable is discrete with a finite number of
possible values, and no data point has missing values.
There are roughly three main approaches to the learning problem: score-based learning,
constraint-based learning, and hybrid methods. Score-based learning methods evaluate the
quality of Bayesian network structures using a scoring function and selects the one that has
the best score (Cooper & Herskovits, 1992; Heckerman, 1998). These methods basically
formulate the learning problem as a combinatorial optimization problem. They work well
for datasets with not too many variables, but may fail to find optimal solutions for large
datasets. We will discuss this approach in more detail in the next section, as it is the
approach we take. Constraint-based learning methods typically use statistical testings to
identify conditional independence relations from the data and build a Bayesian network
structure that best fits those independence relations (Pearl, 1988; Spirtes, Glymour, &
Scheines, 2000; Cheng, Greiner, Kelly, Bell, & Liu, 2002; de Campos & Huete, 2000; Xie &
Geng, 2008). Constraint-based methods mostly rely on results of local statistical testings,
so they can often scale to large datasets. However, they are sensitive to the accuracy of
the statistical testings and may not work well when there are insufficient or noisy data.
In comparison, score-based methods work well even for datasets with relatively few data
points. Hybrid methods aim to integrate the advantages of the previous two approaches and
use combinations of constraint-based and/or score-based methods for solving the learning
problem (Dash & Druzdzel, 1999; Acid & de Campos, 2001; Tsamardinos, Brown, & Aliferis,
2006; Perrier, Imoto, & Miyano, 2008). One popular strategy is to use constraint-based
learning to create a skeleton graph and then use score-based learning to find a high-scoring
network structure that is a subgraph of the skeleton (Tsamardinos et al., 2006; Perrier et al.,
2008). In this work, we do not consider Bayesian model averaging methods which aim to
estimate the posterior probabilities of structural features such as edges rather than model
selection (Heckerman, 1998; Friedman & Koller, 2003; Dash & Cooper, 2004).
25

Yuan & Malone

2.2 Score-Based Learning
Score-based learning methods rely on a scoring function Score(.) in evaluating the quality of
a Bayesian network structure. A search strategy is used to find a structure G‚àó that optimizes
the score. Therefore, score-based methods have two major elements, scoring functions and
search strategies.
2.2.1 Scoring Functions
Many scoring functions can be used to measure the quality of a network structure. Some
of them are Bayesian scoring functions which define a posterior probability distribution
over the network structures conditioning on the data, and the structure with the highest
posterior probability is presumably the best structure. These scoring functions are best
represented by the Bayesian Dirichlet score (BD) (Heckerman, Geiger, & Chickering, 1995)
and its variations, e.g., K2 (Cooper & Herskovits, 1992), Bayesian Dirichlet score with
score equivalence (BDe) (Heckerman et al., 1995), and Bayesian Dirichlet score with score
equivalence and uniform priors (BDeu) (Buntine, 1991). Other scoring functions often have
the form of trading off the goodness of fit of a structure to the data and the complexity of
the structure. The goodness of fit is measured by the likelihood of the structure given the
data or the amount of information that can be compressed into a structure from the data.
Scoring functions belonging to this category include minimum description length (MDL)
(or equivalently Bayesian information criterion, BIC) (Rissanen, 1978; Suzuki, 1996; Lam
& Bacchus, 1994), Akaike information criterion (AIC) (Akaike, 1973; Bozdogan, 1987),
(factorized) normalized maximum likelihood function (NML/fNML) (Silander, Roos, Kontkanen, & Myllymaki, 2008), and the mutual information tests score (MIT) (de Campos,
2006). All of these scoring functions are decomposable, that is, the score of a network can
be decomposed into a sum of node scores (Heckerman, 1998).
The optimal structure G‚àó may not be unique because multiple Bayesian network structures may share the same optimal score1 . Two network structures are said to belong to the
same equivalence class (Chickering, 1995) if they represent the same set of probability distributions with all possible parameterizations. Score-equivalent scoring functions assign the
same score to structures in the same equivalence class. Most of the above scoring functions
are score equivalent.
We mainly use the MDL score in this work. Let ri be the number of states of Xi , Npai
be the number of data points consistent with PAi = pai , and Nxi ,pai be the number of data
points further constrained by Xi = xi . MDL is defined as follows (Lam & Bacchus, 1994).

M DL(G) =

X

M DL(Xi |PAi ),

i

1. That is why we often use ‚Äúan optimal‚Äù instead of ‚Äúthe optimal‚Äù throughout this paper.

26

(1)

Learning Optimal Bayesian Networks

where
log N
K(Xi |PAi ),
2
X
Nxi ,pai
H(Xi |PAi ) = ‚àí
Nxi ,pai log
,
Npai
xi ,pai
Y
K(Xi |PAi ) = (ri ‚àí 1)
rl .
Xl ‚ààPAi

M DL(Xi |PAi ) = H(Xi |PAi ) +

(2)
(3)
(4)

The goal is then to find a Bayesian network that has the minimum MDL score. However,
our methods are by no means restricted to MDL; any other decomposable scoring function,
such as BIC, BDeu, or fNML, can be used instead without affecting the search strategy.
To demonstrate that, we will test BDeu in the experimental section. One slight difference
between MDL and the other scoring functions is that the latter scores need to be maximized
in order to find an optimal solution. But it is rather straightforward to translate between
maximization and minimization problems by simply changing the sign of the scores. Also,
we sometimes use costs to refer to the scores, as they also represent distances between the
nodes in our search graph.
2.2.2 Local Search Strategies
Given n variables, there are O(n2n(n‚àí1) ) directed acyclic graphs (DAGs). The size of
the solution space grows exponentially in the number of variables. It is not surprising that
score-based structure learning has been shown to be NP-hard (Chickering, 1996). Due to the
complexity, early research focused mainly on developing approximation algorithms (Heckerman, 1998; Bouckaert, 1994). Popular search strategies that were used include greedy hill
climbing, stochastic search, genetic algorithm, etc..
Greedy hill climbing methods typically begin with an initial network, e.g., an empty
network or a randomly generated structure, and repeatedly apply single edge operations,
including addition, deletion, and reversal, until finding a locally optimal network. Extensions to this approach include tabu search with random restarts (Glover, 1990), limiting
the number of parents or parameters for each variable (Friedman et al., 1999), searching
in the space of equivalence classes (Chickering, 2002), searching in the space of variable
orderings (Teyssier & Koller, 2005), and searching under the constraints extracted from
data (Tsamardinos et al., 2006). The optimal reinsertion algorithm (OR) (Moore & Wong,
2003) adds a different operator: a variable is removed from the network, its optimal parents
are selected, and the variable is then reinserted into the network with those parents. The
parents are selected to ensure the new network is still a valid Bayesian network.
Stochastic search methods such as Markov Chain Monte Carlo and simulated annealing
have also been applied to find a high-scoring structure (Heckerman, 1998; de Campos &
Puerta, 2001; Myers, Laskey, & Levitt, 1999). These methods explore the solution space
using non-deterministic transitions between neighboring network structures while favoring
better solutions. The stochastic moves are used in hope to escape local optima and find
better solutions.
Other optimization methods such as genetic algorithms (Hsu, Guo, Perry, & Stilson,
2002; Larranaga, Kuijpers, Murga, & Yurramendi, 1996) and ant colony optimization meth27

Yuan & Malone

ods (de Campos, Fernndez-Luna, Gmez, & Puerta, 2002; Daly & Shen, 2009) have been
applied to learning Bayesian network structures as well. Unlike the previous methods which
work with one solution at a time, these population-based methods maintain a set of candidate solutions throughout their search. At each step, they create the next generation
of solutions randomly by reassembling the current solutions as in genetic algorithms, or
generating the new solutions based on information collected from incumbent solutions as in
ant colony optimization. The hope is to obtain increasingly better populations of solutions
and eventually find a good network structure.
These local search methods are quite robust in the face of large learning problems with
many variables. However, they do not guarantee to find an optimal solution. What is worse,
the quality of their solutions is typically unknown.
2.2.3 Optimal Search Strategies
Recently multiple exact algorithms have been developed for learning optimal Bayesian networks. Several dynamic programming algorithms are proposed based on the observation
that a Bayesian network has at least one leaf (Ott et al., 2004; Singh & Moore, 2005). A
leaf is a variable with no child variables in a Bayesian network. In order to find an optimal
Bayesian network for a set of variables V, it is sufficient to find the best leaf. For any leaf
choice X, the best possible Bayesian network is constructed by letting X choose an optimal
parent set PAX from V\{X} and letting V\{X} form an optimal subnetwork. Then the
best leaf choice is the one that minimizes the sum of Score(X, PAX ) and Score(V\{X})
for a scoring function Score(.). More formally, we have:
Score(V) = min {Score(V \ {X}) + BestScore(X, V \ {X})},
X‚ààV

(5)

where
BestScore(X, V \ {X}) =

min
Score(X, PAX ).
PAX ‚äÜV\{X}

(6)

Given the above recurrence relation, a dynamic programming algorithm works as follows. It first finds optimal structures for single variables, which is trivial. Starting with
these base cases, the algorithm builds optimal subnetworks for increasingly larger variable
sets until an optimal network is found for V. The dynamic programming algorithms can
find an optimal Bayesian network in O(n2n ) time and space (Koivisto & Sood, 2004; Ott
et al., 2004; Silander & Myllymaki, 2006; Singh & Moore, 2005). Recent algorithms have
improved the memory complexity by either trading longer running times for reduced memory consumption (Parviainen & Koivisto, 2009) or taking advantage of the layered structure
present within the dynamic programming lattice (Malone, Yuan, & Hansen, 2011b; Malone,
Yuan, Hansen, & Bridges, 2011a).
A branch and bound algorithm (BB) was proposed by de Campos and Ji (2011) for
learning Bayesian networks. The algorithm first creates a cyclic graph by allowing each
variable to obtain optimal parents from all the other variables. A best-first search strategy
is then used to break the cycles by removing one edge at a time. The algorithm uses an
approximation algorithm to estimate an initial upper bound solution for pruning. The
algorithm also occasionally expands the worst nodes in the search frontier in hope to find
28

Learning Optimal Bayesian Networks

Figure 1: An order graph of four variables.
better networks to update the upper bound. At completion, the algorithm finds an optimal
network structure that is a subgraph of the initial cyclic graph. If the algorithm ran out of
memory before finding the solution, it will switch to using a depth-first search strategy to
find a suboptimal solution.
Integer linear programming (ILP) has also been used to learn optimal Bayesian network
structures (Cussens, 2011; Jaakkola et al., 2010). The learning problem is cast as an integer
linear program over a polytope with an exponential number of facets. An outer bound
approximation to the polytope is then solved. If the solution of the relaxed problem is
integral, it is guaranteed to be the optimal structure. Otherwise, cutting planes and branch
and bound algorithms are subsequently applied to find the optimal structure. Recently a
similar method has been proposed to find an optimal structure by searching in the space of
equivalence classes (Hemmecke et al., 2012).
Several other methods can be considered optimal under the constraints that they enforce
on the network structure. For example, if optimal parents are selected for each variable, K2
finds an optimal network structure for a particular variable ordering (Cooper & Herskovits,
1992). The methods developed in (Ordyniak & Szeider, 2010; Kojima, Perrier, Imoto, &
Miyano, 2010) find an optimal network structure that must be a subgraph of a given super
graph.

3. A Shortest Path Perspective
This section introduces a shortest path perspective of the problem of learning a Bayesian
network structure for a given dataset.
3.1 Order Graph
The state space graph for learning Bayesian networks is basically a Hasse diagram containing
all of the subsets of the variables in a domain. Figure 1 visualizes the state space graph
for a learning problem with four variables. The top-most node with the empty set at layer
29

Yuan & Malone

0 is the start search node, and the bottom-most node with the complete set at layer n is
the goal node, where n is the number of variables in a domain. An arc from U to U ‚à™ {X}
represents generating a successor node by adding a new variable {X} to an existing set of
variables U; U is called a predecessor of U‚à™ {X}. The cost of the arc is equal to the score of
selecting an optimal parent set for X out of U, i.e., BestScore(X, U). For example, the arc
{X1 , X2 } ‚Üí {X1 , X2 , X3 } has a cost equal to BestScore(X3 , {X1 , X2 }). Each node at layer
i has n‚àíi successors as there are this many ways to add a new variable, and i predecessors as
there are this many leaf choices. We define expanding a node U as generating all successors
nodes of U.
With the search graph thus defined, a path from the start node to the goal node is defined
as a sequence of nodes such that there is an arc from each of the nodes to the next node
in the sequence. Each path also corresponds to an ordering of the variables in the order of
their appearance. For example, the path traversing nodes ‚àÖ, {X1 }, {X1 , X2 }, {X1 , X2 , X3 },
{X1 , X2 , X3 , X4 } stands for the variable ordering X1 , X2 , X3 , X4 . That is why we also call
the search graph an order graph. The cost of a path is defined as the sum of the costs of
all the arcs on the path. The shortest path is then the path with the minimum total cost in
the order graph.
Given the shortest path, we can reconstruct a Bayesian network structure by noting
that each arc on the path encodes the choice of optimal parents for one of the variables
out of the preceding variables, and the complete path represents an ordering of all the
variables. Therefore, putting together all the optimal parent choices generates a valid
Bayesian network. By construction, the Bayesian network structure is optimal.
3.2 Finding the Shortest Path
Various methods can be applied to solve the shortest path problem. Dynamic programming
is considered to evaluate the order graph using a top down sweep of the order graph (Silander
& Myllymaki, 2006; Malone et al., 2011b). Layer by layer, dynamic programming finds an
optimal subnetwork for the variables contained in each node of the order graph based on
results from the previous layers. For example, there are three ways to construct a Bayesian
network for node {X1 , X2 , X3 }: using {X2 , X3 } as the subnetwork and X1 as the leaf, using
{X1 , X3 } as the subnetwork and X2 as the leaf, or using {X1 , X2 } as the subnetwork and X3
as the leaf. The top-down sweep makes sure that optimal subnetworks are already found
for {X2 , X3 }, {X1 , X3 }, and {X1 , X2 }. We only need to select optimal parents for the
leaves and identify the leaf that produces the optimal network for {X1 , X2 , X3 }. Once the
evaluation reaches the node in the last layer, a shortest path and, equivalently, an optimal
Bayesian network are found for the global variable set.
A drawback of the dynamic programming approach is its need to compute all the
BestScore(.) of all candidate parent sets for each variable. For n variables, there are
2n nodes in the order graph, and there are also 2n‚àí1 parent scores to be computed for each
variable, totally n2n‚àí1 scores. As the number of variables increases, computing and storing
the order and parent graphs quickly becomes infeasible.
In this paper, we propose to apply the A* algorithm (Hart, Nilsson, & Raphael, 1968)
to solve the shortest path problem. A* uses the heuristic function to evaluate the quality of
search nodes and only expand the most promising search node at each search step. Because
30

Learning Optimal Bayesian Networks

of the guidance of the heuristic functions, A* only needs to explore part of the search
graph in finding the optimal solution. However, in comparison to dynamic programming,
A* has the overhead of calculating heuristic values and maintaining a priority queue. The
actual relative performance between dynamic programming and A* thus depends on the
efficiency in calculating the heuristic values and the tightness of these values (Felzenszwalb
& McAllester, 2007; Klein & Manning, 2003).

4. Finding Optimal Parent Sets
Before introducing our algorithm for solving the shortest path problem, we first discuss how
to obtain the cost BestScore(X, U) for each arc U ‚Üí U ‚à™ {X} that we will visit in the
order graph. Recall that each arc involves selecting optimal parents for a variable from a
candidate set. We need to consider all subsets of the candidate set in finding the subset with
the best score. In this section, we introduce two data structures and related methods for
computing and storing optimal parent sets and scores for all pairs of variable and candidate
parent set.
All exact algorithms for learning Bayesian network structures need to calculate the
optimal parent sets and scores. We present a reasonable approach to the calculation in this
paper. Note, however, our approach is applicable to other algorithms, and vice versa.
4.1 Parent Graph
We use a data structure called parent graph to compute costs for the arcs of the order graph.
Each variable has its own parent graph. The parent graph for variable X is a Hasse diagram
consisting of all subsets of the variables in V \ {X}. Each node U stores the optimal parent
set PAX out of U which minimizes Score(X, PA X ) as well as BestScore(X, U) itself. For
example, Figure 2(b) shows a sample parent graph for X1 that contains the best scores of
all subsets of {X2 , X3 , X4 }. To obtain Figure 2(b), however, we first need to calculate the
preliminary graph in Figure 2(a) that contains the raw score of each subset U as the parent
set of X1 , i.e., Score(X1 , U). As Equation 3 shows, these scores can be calculated based on
the counts for particular instantiations of the parent and child variables.
We use an AD-tree (Moore & Lee, 1998) to collect all the counts from a dataset and
compute the scores. An AD-tree is an unbalanced tree structure that contains two types of
nodes, AD-tree nodes and varying nodes. An AD-tree node stores the number of data points
consistent with a particular variable instantiation; a varying node is used to instantiate the
state of a variable. A full AD-tree stores counts of data points that are consistent with
all partial instantiations of the variables. A sample AD-tree for two variables are shown in
Figure 3. For n variables with d states each, the number of AD-tree nodes in an AD-tree is
(d+1)n . It grows even faster than the size of an order or parent graph. Moore and Lee (1998)
also described a sparse AD-tree which significantly reduces the space complexity. Readers
are referred to that paper for more details. Our pseudo code assumes a sparse AD-tree is
used.
Given an AD-tree, we are ready to calculate the raw scores Score(X1 , .) for Figure 2(a).
There is an exponential number of scores in each parent graph. However, not all parent
sets can possibly be in the optimal Bayesian network; certain parent sets can be discarded
without ever calculating their values according to the following theorems by Tian (2000).
31

Yuan & Malone

Figure 2: A sample parent graph for variable X1 . (a) The raw scores Score(X1 , .) for all
the parent sets. The first line in each node gives the parent set, and the second
line gives the score of using all of that set as the parents for X1 . (b) The optimal
scores BestScore(X1 , .) for each candidate parent set. The second line in each
node gives the optimal score using some subset of the variables in the first line as
parents for X1 . (c) The optimal parent sets and their scores. The pruned parent
sets are shown in gray. A parent set is pruned if any of its predecessors has a
better score.

X1 = *
X2 = *
C = 50
Vary
V
X1

Vary
V
X2

X1 = 0
X2 = *

X1 = 1
X2 = *

X1 = *
X2 = 0

X1 = *
X2 = 1

C = 20

C = 30

C = 25

C = 25

Vary
X2

Vary
X2

X1 = 0
X2 = 0

X1 = 0
X2 = 1

X1 = 1
X2 = 0

X1 = 1
X2 = 1

C = 15

C=5

C = 10

C = 20

Figure 3: An AD-tree.
We use these theorems to compute only the necessary MDL scores. Other scoring functions
such as BDeu also have similar pruning rules (de Campos & Ji, 2011). Algorithm 1 provides
the pseudo code for calculating the raw scores.
Theorem 1 In an optimal Bayesian network based on the MDL scoring function, each
2N
variable has at most ‚åälog( log
N )‚åã parents, where N is the number of data points.
32

Learning Optimal Bayesian Networks

Algorithm 1 Score Calculation Algorithm
Input: AD ‚Äì sparse AD-tree of input data; V ‚Äì input variables.
Output: Score(X, U) for each pair of X ‚àà V and U ‚äÜ V \ {X}
1: function calculateMDLScores(AD, V)
2:
for each Xi ‚àà V do
3:
calculateScores(Xi , AD)
4:
end for
5: end function
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:

function calculateScores(Xi, AD)
2N
for k ‚Üê 0 to ‚åälog( log
‚ä≤ Prune due to Theorem 1
N )‚åã do
for each U such that U ‚äÜ V \ {X}& |U| == k do
‚ä≤ All parent sets of size k
prune ‚Üê f alse
for each Y ‚àà U do
if K(Xi |U) - Score(Xi , U \ {Y }) > 0 then
prune ‚Üê true
‚ä≤ Prune due to Theorem 2
break
end if
end for
if prune ! = true then
Score(Xi , U) ‚Üê log2 N K(Xi |U)
‚ä≤ Complexity term
for each instantiation xi , u of Xi , U do
‚ä≤ Log likelihood term
cF amily ‚Üê GetCount({xi } ‚à™ u,AD)
cP arents ‚Üê GetCount(u, AD)
Score(Xi , U)‚Üê Score(Xi , U) - cF amily ‚àó log cF amily
Score(Xi , U)‚Üê Score(Xi , U) + cF amily ‚àó log cP arents
end for
end if
end for
end for
end function

Theorem 2 Let U and S be two candidate parent sets for X, U ‚äÇ S, and K(Xi |S) ‚àí
M DL(Xi |U) > 0. Then S and all supersets of S cannot possibly be optimal parent sets for
X.
After computing the raw scores, we compute the parent graph according to the following
theorem which has appeared in many earlier papers, e.g., see the work of Teyssier and
Koller (2005), and de Campos and Ji (2010). The theorem simply means that a parent set
is not optimal when a subset has a better score.
Theorem 3 Let U and S be two candidate parent sets for X such that U ‚äÇ S, and
Score(X, U) ‚â§ Score(X, S). Then S is not the optimal parent set of X for any candidate set.
33

Yuan & Malone

Algorithm 2 Computing parent graphs
Input: All necessary Score(X, U), X ‚àà V&U ‚äÜ V \ {X}
Output: Full parent graphs containing BestScore(X, U)
1: function calculateFullParentGraphs(V, Score(., .))
2:
for each X ‚àà V do
3:
for layer ‚Üê 0 to n do
‚ä≤ Propagate best scores down the graph
4:
for each U such that U ‚äÜ V \ {X}& |U| == layer do
5:
calculateBestScore(X, U, Score(., .))
6:
end for
7:
end for
8:
end for
9: end function
10:
11:
12:
13:
14:
15:
16:
17:

function calculateBestScore(X, U, Score(., .))
BestScore(X, U) ‚Üê Score(X, U)
for each Y ‚àà U do
if BestScore(X, U \ {Y }) < BestScore(X, U) then
BestScore(X, U) ‚Üê BestScore(X, U \ {Y })
end if
end for
end function

function getBestScore(X, U)
19:
return BestScore(X, U)
20: end function

‚ä≤ Propagate best scores

‚ä≤ Query BestScore(X, U)

18:

Therefore, when we generate a successor node U‚à™{Y } of U in the parent graph of X, we
check whether Score(X, U ‚à™ {Y }) is smaller than BestScore(X, U). If so, we let the parent
graph node U‚à™{Y } record itself as the optimal parent set. Otherwise if BestScore(X, U) is
smaller, we propagate the optimal parent set in U to U‚à™{Y }. Because of such propagation,
we must have the following (Teyssier & Koller, 2005).
Theorem 4 Let U and S be two candidate parent sets for X such that U ‚äÇ S. We must
have BestScore(X, S) ‚â§ BestScore(X, U).
A pseudo code for propagating the scores and computing the parent graph is outlined in
Algorithm 2. Figure 2(b) shows the parent graph with the optimal scores after propagating
the best scores from top to bottom.
During the search of the order graph, whenever we visit a new arc U ‚Üí U ‚à™ {X}, we
find its score by looking up the parent graph of variable X. For example, if we need to find
optimal parents for X1 out of {X2 , X3 }, we look up the node {X2 , X3 } in X1 ‚Äôs parent graph
to find the optimal parent set and its score. To make the look-ups efficient, we use hash
tables to organize the parent graphs so that the query can be answered in constant time.
34

Learning Optimal Bayesian Networks

parentsX1
scoresX1

{X2 , X3 }
5

{X3 }
6

{X2 }
8

{}
10

Table 1: Sorted scores and parent sets for X1 after pruning parent sets which are not
possibly optimal.
parentsX1
2
parentsX
X1
X3
parentsX1
4
parentsX
X1

{X2 , X3 }
1
1
0

{X3 }
0
1
0

{X2 }
1
0
0

{}
0
0
0

Table 2: The parentsX (Xi ) bit vectors for X1 . A ‚Äú1‚Äù in line Xi indicates that the corresponding parent set includes variable Xi , while a ‚Äú0‚Äù indicates otherwise. Note
that, after pruning, none of the optimal parent sets include X4 .

4.2 Sparse Parent Graphs
The full parent graph for each variable X exhaustively enumerates all subsets of V \ {X}
and stores BestScore(X, U) for all of those subsets. Naively, this approach requires storing
n2n‚àí1 scores and parent sets (Silander & Myllymaki, 2006). Because of Theorem 3, however,
the number of optimal parent sets is often far smaller than the full size. Figure 2(b) shows
that an optimal parent set may be shared by several candidate parent sets. The full parent
graph representation will allocate space for this repetitive information for all candidate sets,
resulting in waste of time and space.
To address these limitations, we introduce a sparse representation of the parent graphs
and related scanning techniques for querying optimal parent sets. As with the full parent
graphs, we begin by calculating and pruning scores as described in the last Section. Due
to Theorems 1 and 2, some of the parent sets can be pruned without being evaluated.
Therefore, we do not have to create the full parent graphs. Also, instead of creating the
Hasse diagrams, we sort all the optimal parent scores for each variable X in a list, and also
maintain a parallel list that stores the associated optimal parent sets. We call these sorted
lists scoresX and parentsX . Table 1 shows the sorted lists for the optimal scores in the
parent graph in Figure 2(b). In essence, this allows us to store and efficiently process only
the scores in Figure 2(c).
To find the optimal parent set for X out of a candidate set U, we can simply scan the
list of X starting from the beginning. As soon as we find the first parent set that is a subset
of U, we find the optimal parent score BestScore(X, U). This is trivially true due to the
following theorem.
Theorem 5 The first subset of U in parentsX is the optimal parent set for X out of U.
Scanning the lists to find optimal parent sets can be inefficient if not done properly.
Since we have to do the scanning for each arc visited in the order graph, any inefficiency in
the scanning can have a large impact on the search algorithm.
35

Yuan & Malone

parentsX1
validX1
3
‚àº parentsX
X1
new
validX1

{X2 , X3 }
1
0
0

{X3 }
1
0
0

{X2 }
1
1
1

{}
1
1
1

Table 3: The result of performing the bitwise operation to exclude all parent sets which
include X3 . A ‚Äú1‚Äù in the validX1 bit vector means that the parent set does not
include X3 and can be used for selecting the optimal parents. The first set bit
indicates the best possible score and parent set.

parentsX1
validX1
3
‚àº parentsX
X1
new
validX1

{X2 , X3 }
0
0
0

{X3 }
0
1
0

{X2 }
1
0
0

{}
1
1
1

Table 4: The result of performing the bitwise operation to exclude all parent sets which
include either X3 or X2 . A ‚Äú1‚Äù in the validnew
X1 bit vector means that the parent
set includes neither X2 nor X3 . The initial validX1 bit vector had already excluded
X3 , so finding validnew
X1 only required excluding X2 .

To ensure the efficiency, we propose the following scanning technique. For each variable
X, we first initialize a working bit vector of length kscoresX k called validX to be all 1s. This
indicates that all the parent scores in scoresX are usable. Then, we create n ‚àí 1 bit vectors
also of length kscoresX k, one for each variable in V \ {X}. The bit vector for variable Y is
denoted as parentsYX and contains 1s for all the parent sets that contain Y and 0s for others.
Table 2 shows the bit vectors for the example in Table 1. Then, to exclude variable Y as a
candidate parent, we perform the bit operation validnew
‚Üê validX & ‚àº parentsYX . The new
X
validX bit vector now contains 1s for all the parent sets that are subsets of V \ {Y }. The
first set bit corresponds to BestScore(X, V \ {Y }). Table 3 shows an example of excluding
X3 from the set of possible parents for X1 , and the first set bit in the new bit vector
corresponds to BestScore(X1 , V \ {X3 }). If we further want to exclude X2 as a candidate
parent, the new bit vector from the last step becomes the current bit vector for this step,
2
and the same bit operation is applied: validnew
‚Üê validX & ‚àº parentsX
X
X1 . The first set
bit of the result corresponds to BestScore(X1 , V \ {X2 , X3 }). Table 4 demonstrates this
operation. Also, it is important to note that we exclude one variable at a time. For example,
if, after excluding X3 , we wanted to exclude X4 rather than X2 , we could take validnew
‚Üê
X
4
validX & ‚àº parentsX
.
These
operations
are
described
in
the
createSparseParentGraph
and
X
getBestScore functions in Algorithm 3.
Because of the pruning of duplicate scores, the sparse representation requires much less
memory than storing all the possible parent sets and scores. As long as kscores(X)k <
C(n ‚àí 1, n2 ), it also requires less memory than the memory-efficient dynamic programming
algorithm (Malone et al., 2011b).
Experimentally, we show that kscoresX k is almost
36

Learning Optimal Bayesian Networks

Algorithm 3 Sparse Parent Graph Algorithms
Input: All necessary Score(X, U), X ‚àà V&U ‚äÜ V \ {X}
Output: Sparse parent graphs containing optimal parent sets and scores
1: function createSparseParentGraph(X, Score(., .))
2:
for X ‚àà V do
3:
scorest , parentst ‚Üêsort(Score(X, ¬∑))
‚ä≤ Sort scores, preferring low cardinality
4:
scoresX , parentsX ‚Üê ‚àÖ
‚ä≤ Initialize possibly optimal scores
5:
for i = 0 ‚Üí |scorest | do
6:
prune ‚Üê f alse
7:
for j = 0 ‚Üí |scoresX | do
‚ä≤ Check if a better subset pattern exists
8:
if contains(parentst(i), parentsX (j))&scoresX (i) ‚â§ scorest (i) then
9:
prune ‚Üê true
10:
Break
11:
end if
12:
end for
13:
if prune ! = true then
14:
Append scoresX , parentsX with parentst(i), parentst (i)
15:
end if
16:
end for
17:
for i = 0 ‚Üí |scoresX | do
‚ä≤ Set bit vectors for efficient querying
18:
for each Y ‚àà parentsX (i) do
19:
set(parentsYX (i))
20:
end for
21:
end for
22:
end for
23: end function
24:
25:
26:
27:
28:
29:
30:
31:

function getBestScore(X, U)
valid ‚Üê allScoresX
for each Y ‚àà V \ U do
valid ‚Üê valid& ‚àº parentsYX
end for
f sb ‚Üê f irstSetBit(valid)
return scoresX [f sb]
end function

‚ä≤ Query BestScore(X, U)

‚ä≤ Return the first score with a set bit

always smaller than C(n ‚àí 1, n2 ) by several orders of magnitude. So this approach offers
(usually substantial) memory savings compared to previous best approaches.
The sparse representation has an extra benefit of improving the time efficiency as well.
With the full representation, we have to create the complete exponential-size parent graphs,
even though many nodes in a parent graph share the same optimal parent choices. With the
sparse representation, we can avoid creating those nodes, which makes creating the sparse
parent graphs much more efficient.
37

Yuan & Malone

5. An A* Search Algorithm
We are now ready to tackle the shortest path problem in the order graph. This section
presents our search algorithm as well as two admissible heuristic functions for guiding the
algorithm.
5.1 The Algorithm
We apply a well known state space search method, the A* algorithm (Hart et al., 1968), to
solve the shortest path problem in the order graph. The main idea of the algorithm is to
use an evaluation function f to measure the quality of search nodes and always expand the
one that has the lowest f cost during the exploration of the order graph. For a node U,
f (U) is decomposed as the sum of an exact past cost, g(U), and the estimated future cost,
h(U). The g(U) cost measures the shortest distance from the start node to U, while the
h(U) cost estimates how far away U is from the goal node. Therefore, the f cost provides
an estimated total cost of the best possible path which passes through U.
A* uses an open list (usually as a priority queue) to store the search frontier, and a
closed list to store the expanded nodes. Initially the open list only contains the start node,
and the closed list is empty. At each search step, the node with the lowest f -cost from the
open list, say U, is selected for expansion to generate its successor nodes. Before expanding
U, however, we need to first check whether it is the goal node. If yes, a shortest path to
the goal has been found; we can construct a Bayesian network from the path and terminate
the search.
If U is not the goal, we expand it to generate the successor nodes. Each successor
S considers one possible way of adding a new variable, say X, as a leaf to an existing
subnetwork over the variables in U, that is S = U ‚à™ {X}. The g cost of S is calculated
as the sum of the g-cost of U and the cost of the arc U ‚Üí S. The arc cost as well as the
optimal parent set PAX for X out of U are retrieved from X‚Äôs parent graph. The h cost of
S is computed from a heuristic function which we will describe shortly. We record in S the
following information2 : g cost, h cost, X, and PAX .
It is clear from the order graph that there are multiple paths to any node. We should
perform duplicate detection for S to see whether a node representing the same set of variables
has already been generated before. If we do not check for duplicates, the search space blows
up from an order graph with a size 2n to an order tree with a size n!. We first check whether
a duplicate already exists in the closed list. If so, we further check whether the duplicate
has a better g cost than S. If yes, we discard S immediately, as it represents a worse path.
Otherwise, we remove the duplicate from the closed list, and place S in the open list. What
happens is we have found a better path with a lower g cost, so we reopen the node for future
search.
If no duplicate is found in the closed list, we also need to check the open list. If no
duplicate is found, we will simply add S to the open list. Otherwise, we will compare the
g costs of the duplicate and S. If the duplicate has a lower g cost, S will be discarded.
Otherwise, we will replace the duplicate with S. Again, the lower g cost means a better
path is found.
2. We can also delay the calculation of h until after duplicate detection to avoid unnecessary calculations
for nodes that will be pruned.

38

Learning Optimal Bayesian Networks

Algorithm 4 A* Search Algorithm
Input: full or sparse parent graphs containing BestScore(X, U)
Output: an optimal Bayesian network G
1: function main(D)
2:
start ‚Üê ‚àÖ
3:
Score(start) ‚Üê 0 P
4:
push(open, start, Y ‚ààV BestScore(Y, V \ {Y })
5:
while !isEmpty(open) do
6:
U ‚Üêpop(open)
7:
if U is goal then
‚ä≤ A shortest path is found
8:
print(‚ÄúThe best score is ‚Äù + Score(V))
9:
G ‚Üê construct a network from the shortest path
10:
return G
11:
end if
12:
put(closed, U)
13:
for each X ‚àà V \ U do
‚ä≤ Generate successors
14:
g ‚Üê BestScore(X, U) + Score(U)
15:
if contains(closed, U ‚à™ {X}) then
‚ä≤ Closed list DD
16:
if g < Score(U ‚à™ {X}) then
‚ä≤ reopen node
17:
delete(closed, U ‚à™ {X})
18:
push (open, U ‚à™ {X}, g + h)
19:
Score(U ‚à™ {X}) ‚Üê g
20:
end if
21:
else
22:
if contains(open, U ‚à™ {X}) & g < Score(U ‚à™ {X}) then‚ä≤ Open list DD
23:
update(open, U ‚à™ {X}, g + h)
24:
Score(U ‚à™ {X}) ‚Üê g
25:
end if
26:
end if
27:
end for
28:
end while
29: end function

After all the successor nodes have been generated, we will place node U in the closed
list, which indicates that node is already expanded. Expanding the top node in the open
list is called one search step. The A* algorithm performs the step repeatedly until the goal
node is selected for expansion. At that moment a shortest path from the start state to the
goal state has been found.
Once the shortest path is found, we can reconstruct the optimal Bayesian network
structure by starting from the goal node and tracing back the shortest path until reaching
the start node. Since each node on the path stores a leaf variable and its optimal parent set,
putting all the optimal parent sets together generates a valid Bayesian network structure.
A pseudo code of the A* algorithm is shown in Algorithm 4.
39

Yuan & Malone

5.2 A Simple Heuristic Function
The A* algorithm provides different theoretical guarantees depending on the properties of
the heuristic function h. The function h is admissible if the h cost is never greater than
the true cost to the goal; in other words, it is optimistic. Given an admissible heuristic
function, the A* algorithm is guaranteed to find the shortest path once the goal node is
selected for expansion (Pearl, 1984). Let U be a node in the order graph. We first consider
the following simple heuristic function h.
Definition 1
h(U) =

X

BestScore(X, V\{X}).

(7)

X‚ààV\U

The heuristic function allows each remaining variable to choose optimal parents from all
the other variables. Its design reflects the principle that the exact cost of a relaxed problem
can be used as an admissible bound for the original problem (Pearl, 1984). In this case, the
original problem is to learn a Bayesian network that is a directed acyclic graph. Equation 7
relaxes the problem by ignoring the acyclicity constraint, so all directed cyclic graphs are
allowed. The heuristic function is easily proven admissible in the following theorem. The
proofs of all the theorems in this paper can be found in Appendix A.
Theorem 6 h is admissible.
It turns out that h has an even nicer property. A heuristic function is consistent if, for
any node U and a successor S, h(U) ‚â§ h(S) + c(U, S), where c(U, S) stands for the cost
of the arc U ‚Üí S. Given a consistent heuristic, the f cost is monotonically non-decreasing
following any path in the order graph. As a result, the f cost of any node is less than or
equal to the f cost of the goal node. It follows immediately that a consistent heuristic is
guaranteed to be admissible. With a consistent heuristic, the A* algorithm is guaranteed
to find the shortest path to any node U once U is selected for expansion. If a duplicate is
found in the closed list, the duplicate must have the optimal g cost, so the new node can be
discarded immediately. We show in the following that the simple heuristic in Equation 7 is
also consistent.
Theorem 7 h is consistent.
The heuristic may seem expensive to compute as it requires computing BestScore(X, V\
{X}) for each variable X. However, these scores can be easily found by querying the parent
graphs and are stored in an array for repeated use. It takes linear time to calculate the
heuristic for the start node. Any subsequent computation of h, however, only takes constant
time because we can simply subtract the best score of the newly added variable from the
heuristic value of the parent node.
5.3 An Improved Admissible Heuristic
The simple heuristic function defined in Equation 7, referred to as hsimple hereafter, relaxes
the acyclicity constraint of Bayesian networks completely. As a result, hsimple may introduce
many directed cycles and result in a loose bound. We introduce another heuristic in this
section to tighten the heuristic. We first use a toy example to motivate the new heuristic,
and then describe two specific approaches to computing the heuristic.
40

Learning Optimal Bayesian Networks

X1

X2

X3

X4

Figure 4: A directed graph representing the heuristic estimate for the start search node.

5.3.1 A Motivating Example
With hsimple , the heuristic estimate of the start node in an order graph allows each variable
to choose optimal parents from all the other variables. Suppose the optimal parent sets for
X1 , X2 , X3 , X4 are {X2 , X3 , X4 }, {X1 , X4 }, {X2 }, {X2 , X3 } respectively. These parent
choices are shown as the directed graph in Figure 4. Since the acyclicity constraint is
ignored, directed cycles are introduced, e.g., between X1 and X2 . However, we know the
final solution cannot have cycles; three cases are possible between X1 and X2 : (1) X2 is a
parent of X1 (so X1 cannot be a parent of X2 ), (2) X1 is a parent of X2 , or (3) neither of
the above is true. Based on Theorem 4, the third case cannot provide a better value than
the first two cases because one of the variables must have fewer candidate parents.
Between (1) and (2), it is unclear which one is better, so we take the minimum of them
to get a lower bound. Consider case (1). We have to delete the arc X1 ‚Üí X2 to rule out
X1 as a parent of X2 . Then we have to let X2 rechoose optimal parents from the remaining
variables {X3 , X4 }, that is, we must check all parent sets not including X1 . The deletion
of the arc alone cannot produce the new bound because the best parent set for X2 out of
{X3 , X4 } is not necessarily {X4 }. The total bound of X1 and X2 is computed by summing
together the original bound of X1 and the new bound of X2 . We call this total bound
b1 . Case (2) is handled similarly; we call that total bound b2 . Because the joint cost for
X1 and X2 , c(X1 , X2 ), must be optimistic, we compute it as the minimum of b1 and b2 .
Effectively we have considered all possible ways to break the cycle and obtained a tighter
heuristic value. The new heuristic is clearly admissible, as we still allow cycles among other
variables.
Often, hsimple introduces multiple cycles into a heuristic estimate. Figure 4 also has a
cycle between X2 and X4 . This cycle shares X2 with the earlier cycle between X1 and X2 ;
we say the cycles overlap. One way to break both cycles is to set the parent set of X2 to be
{X3 }; however, it introduces a new cycle between X2 and X3 . As described in more detail
shortly, we partition the variables into exclusive groups and only break cycles within each
group. In this example, if X2 and X3 are in different groups, we do not break the cycle.
41

Yuan & Malone

5.3.2 The K-Cycle Conflict Heuristic
The above idea can be generalized to compute the joint cost for any variable group with
size up to k by avoiding cycles within the group. Then for any node U in the order graph,
we calculate its heuristic value by partitioning the variables V \ U into several exclusive
groups and sum their costs together. We name the resulting technique the k-cycle conflict
heuristic. Note that the simple heuristic hsimple is a special case of this new heuristic, as it
simply contains costs for the individual variables (k=1).
The new heuristic is an application of the additive pattern database technique (Felner,
Korf, & Hanan, 2004). Pattern databases (Culberson & Schaeffer, 1998) is an approach to
computing an admissible heuristic for a problem by solving a relaxed problem. Consider
the 15-puzzle problem. 15 square tiles numbered from 1 to 15 are randomly placed in a 4
by 4 box with one position left empty. Each such configuration of the tiles is called a state.
The goal is to slide the tiles one at a time into a destination configuration. A tile can slide
into the empty position only if it is beside that position. The 15 puzzle can be relaxed to
only contain the tiles 1-8 with the other tiles removed. Because of the relaxation, multiple
states of the original problem map to one state in the abstract state space of the relaxed
problem as they share the positions of the remaining tiles. Each abstract state is called
a pattern; the cost of the pattern is equal to the smallest cost for sliding the remaining
tiles into their destination positions. The cost provides a lower bound for any state in the
original state space which maps to that pattern. The costs of all patterns are stored in a
pattern database.
We can relax a problem in different ways and obtain multiple pattern databases. If
the solutions to several relaxed problems are independent, the problems are said to be
exclusive. For the 15-puzzle, we can also relax it to only contain tiles 9-15. This relaxation
can be solved independently from the previous one because they do not share any puzzle
movements. For any concrete state in the original state space, the positions of tiles 1-8
map it to a pattern in the first pattern database, and the positions of tiles 9-15 map it to a
different pattern in the second pattern database. The costs of these patterns can be added
together to obtain an admissible heuristic, hence the name additive pattern databases.
For our learning problem, a pattern is defined as a group of variables, and its cost is
the optimal joint cost of these variables while avoiding directed cycles between them. The
decomposability of the scoring function implies that the costs of two exclusive patterns can
be added together to obtain an admissible heuristic.
We do not have to explicitly break cycles in computing the cost of a pattern. The
following theorem offers a straightforward approach to doing so.
Theorem 8 The cost of the pattern U, c(U), is equal to the shortest distance from V \ U
to the goal node in the order graph.
Again consider the example in Figure 4. The cost of pattern {X1 , X2 } is equal to the
shortest distance between {X3 , X4 } and the goal in the order graph in Figure 1.
Furthermore, the difference between c(U) and the sum of the simple heuristic values of
all variables in U indicates the amount of improvement brought by avoiding cycles within
the pattern. The differential score, called Œ¥h , can thus be used as a quality measure for
ordering the patterns and for choosing patterns that are more likely to result in a tighter
heuristic.
42

Learning Optimal Bayesian Networks

5.3.3 Dynamic K-Cycle Conflict Heuristic
There are two slightly different versions of the k-cycle conflict heuristic. In the first version
named dynamic k-cycle conflict heuristic, we compute the costs for all groups of variables
with size up to k and store them in a single pattern database. According to Theorem 8,
this heuristic can be computed by finding the shortest distances between all the nodes in
the last k layers of the order graph and the goal.
We compute the heuristic by using a breadth-first search to do a backward search in
the order graph for k layers. The search starts from the goal node and expands the order
graph backward layer by layer. A reverse arc U ‚à™ {X} ‚Üí U has the same cost as the arc
U ‚Üí U ‚à™ {X}, i.e., BestScore(X, U). The reverse g cost of U is updated whenever a new
path with a lower cost is found. Breadth-first search ensures that node U will obtain its
exact reverse g cost once the previous layer is expanded. The g cost is the cost of the pattern
V \ U. We also compute the differential score, Œ¥h , for each pattern at the same time. A
pattern which does not have a better differential score than any of its subset patterns will be
discarded. The pruning can significantly reduce the size of a pattern database and improve
its query efficiency. The algorithm for computing the dynamic k-cycle conflict heuristic is
shown in Algorithm 5.
Once the heuristic is created, we can calculate the heuristic value for each search node
as follows. For node U, we partition the remaining variables V \ U into a set of exclusive
patterns, and sum their costs together as the heuristic value. Since we only prune superset
patterns, we can always find such a partition. However, there are potentially many ways of
partition. Ideally we want to find the one with the highest total cost, which represents the
tightest heuristic value. The problem of finding the optimal partition can be formulated
as maximum weighted matching problem (Felner et al., 2004). For k = 2, we can define an
undirected graph in which each vertex represents a variable, and each edge between two
variables represents the pattern containing the same variables and has a weight equal to
the cost of the pattern. The goal is to select a set of edges from the graph so that no two
edges share a vertex and the total weight of the edges is maximized. The matching problem
can be solved in O(n3 ) time, where n is the number of vertices (Papadimitriou & Steiglitz,
1982).
For k > 2, we have to add hyperedges to the matching graph for connecting up to
k vertices to represent larger patterns. The goal becomes to select a set of edges and
hyperedges to maximize the total weight. However, the three-dimensional or higher-order
maximum weighted matching problem is NP-hard (Garey & Johnson, 1979). That means
we have to solve an NP-hard problem when calculating each heuristic value.
To alleviate the potential inefficiency, we greedily select patterns based on their quality.
Consider node U with unsearched variables V \ U. We choose the pattern with the highest
differential cost from all the patterns that are subsets of V \ U. We repeat this step for the
remaining variables until all the variables are covered. The total cost of the chosen patterns
is used as the heuristic value for U. The hdynamic function of Algorithm 5 gives pseudocode
for computing the heuristic value.
The dynamic k-cycle conflict heuristic introduced above is an example of the dynamically partitioned pattern database (Felner et al., 2004) because the patterns are dynamically
selected during the search algorithm. We refer to it as dynamic pattern database for short.
43

Yuan & Malone

Algorithm 5 Dynamic k-cycle Conflict Heuristic
Input: full or sparse parent graphs containing all BestScore(X, U)
Output: A pattern database P D with patterns up to size k
1: function createDynamicPD(k)
2:
P D0 (V) ‚Üê 0
3:
Œ¥h (V) ‚Üê 0
4:
for l = 1 ‚Üí k do
‚ä≤ Perform BFS for k levels
5:
for each U ‚àà P Dl‚àí1 do
6:
expand(U, l)
7:
checkSave(U)
8:
P D(V \ U) ‚Üê P Dl‚àí1 (U)
9:
end for
10:
end for
11:
for each X ‚àà P D \ save do
‚ä≤ Remove superset patterns with no improvement
12:
delete P D(X)
13:
end for
14:
sort(P D : Œ¥h )
‚ä≤ Sort patterns in decreasing costs
15: end function
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:

function expand(U, l)
for each X ‚àà U do
g ‚Üê P Dl‚àí1 (U) + BestScore(X, U \ {X})
if g < P Dl (U \ {X}) then P Dl (U \ {X}) ‚Üê g
end for
end function

‚ä≤ Duplicate detection

function checkSave(U)
P
Œ¥h (U) ‚Üê g ‚àí Y ‚ààV\U BestScore(Y, V \ {Y })
for each X ‚àà V \ U do
‚ä≤ Check improvement over subset patterns
if Œ¥h (U) > Œ¥h (U ‚à™ {X}) then save(U)
end for
end function
function hdynamic (U)
h‚Üê0
R‚ÜêU
for each S ‚àà P D do
if S ‚äÇ R then
R‚ÜêR\S
h ‚Üê h + P D(S)
end if
end for
return h
end function

‚ä≤ Calculate heuristic value for U

‚ä≤ Greedily find best subset pattern of R

44

Learning Optimal Bayesian Networks

A potential drawback of dynamic pattern databases is that, even with the greedy
method, computing a heuristic value is still much more expensive than the simple heuristic
in Equation 7. Consequently, the search time can be longer even though the tighter pattern
database heuristic results in more pruning and fewer expanded nodes.
5.3.4 Static K-Cycle Conflict Heuristic
To address the inefficiency of dynamic pattern database in computing heuristic values, we
introduce another version named static k-cycle conflict heuristic based on the statically
partitioned pattern database technique (Felner et al., 2004). The idea is to partition the
variables into several static exclusive groups, and create a separate pattern database for
each group. Consider a problem with variables {X1 , ..., X8 }. We divide the variables into
two groups, {X1 , ..., X4 } and {X5 , ..., X8 }. For each group, say {X1 , ..., X4 }, we create a
pattern database that contains the costs of all subsets of {X1 , ..., X4 } and store them as a
hash table. We refer to this heuristic as the static pattern database for short.S
We create static pattern databases as follows. For a static grouping V = i Vi , we need
to compute a pattern database for each group Vi that resembles an order graph containing
all subsets of Vi . We use a breadth first search to create the graph starting S
from the node
Vi . The cost for an arc U‚à™{X} ‚Üí U in this graph is equal to BestScore(X, ( j6=i Vj )‚à™U),
which means that the variables in the other groups are valid candidate parents. To ensure
efficient retrieval, these static pattern databases are stored as hashtables; nothing is pruned
from them. Algorithm 6 gives pseudocode for creating static pattern databases.
It is much simpler to use static pattern databases to compute a heuristic value. Consider
the search node {X1 , X4 , X8 }; the unsearched variables are {X2 , X3 , X5 , X6 , X7 }. We simply
divide these variables into two patterns {X2 , X3 } and {X5 , X6 , X7 } according to the static
grouping, look them up in the respective pattern databases, and sum the costs together
as the heuristic value. Moreover, since each search step just processes one variable, only
one pattern is affected and requires a new score lookup. Therefore, the heuristic value can
be calculated incrementally. The hstatic function of Algorithm 6 provides pseudocode for
naively calculating this heuristic value.
5.3.5 Properties of The K-Cycle Conflict Heuristic
Both versions of the k-cycle conflict heuristic remain admissible. Although they can avoid
cycles within each pattern, they cannot prevent cycles across different patterns. The following theorem proves the result.
Theorem 9 The k-cycle conflict heuristic is admissible.
Understanding the consistency of the new heuristic is slightly more complex. We first
look at the static pattern database as it does not involve selecting patterns dynamically.
The following theorem shows that the static pattern database is still consistent.
Theorem 10 The static pattern database version of the k-cycle conflict heuristic remains
consistent.
In the dynamic pattern database, each search step needs to solve a maximum weighted
matching problem and select a set of patterns to compute the heuristic value. In the
45

Yuan & Malone

Algorithm 6 Static k-cycle Conflict Heuristics
S
Input: full or sparse parent graphs containing BestScore(X, U), i Vi ‚Äì a partition of V
Output: A full pattern database P D i for each Vi
1: function createStaticPD(Vi )
2:
P D0i (‚àÖ) ‚Üê 0  
3:
for l = 1 ‚Üí Vi  do
‚ä≤ Perform BFS over Vi
i
4:
for each U ‚àà P Dl‚àí1 do
5:
expand(U, l, Vi )
i (U)
6:
P D i (U) ‚Üê P Dl‚àí1
7:
end for
8:
end for
9: end function
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:

function expand(U, l, Vi )
for each X ‚àà Vi \ U do
S
i (U) + BestScore(X, U
g ‚Üê P Dl‚àí1
j6=i Vj )
i
i
if g < P Dl (U ‚à™ X) then P Dl (U ‚à™ X) ‚Üê g
end for
end function
function hstatic (U)
h‚Üê0
for each Vi ‚äÇ V do
h ‚Üê h + P D i (U ‚à© Vi )
end for
return h
end function

‚ä≤ Duplicate detection

‚ä≤ Sum over each P D i separately

following, we show that the dynamic k-cycle conflict heuristic is also consistent by closely
following that of Theorem 4.1 in the work of Edelkamp and Schrodl (2012).
Theorem 11 The dynamic pattern database version of the k-cycle conflict heuristic remains consistent.
However, the above theorem assumes the use of the shortest distances between the nodes
in the abstract space. Because we use a greedy method to solve the maximum weighted
matching problem, we can no longer guarantee to find the shortest paths. As a result, we
may lose the consistency property of the dynamic pattern database. It is thus necessary for
A* to reopen a duplicate node in the closed list if a better path is found.

6. Experiments
We evaluated the A* search algorithm on a set of benchmark datasets from the UCI repository (Bache & Lichman, 2013). The datasets have up to 29 variables and 30, 162 data
points. We discretized all variables into two states using the mean values and deleted all
46

Learning Optimal Bayesian Networks

1.00E+10
1.00E+09

Full

Largest Layer

Sparse

1.00E+08
1.00E+07

Size

1.00E+06
1.00E+05
1.00E+04
1.00E+03
1.00E+02
1.00E+01
1.00E+00

Figure 5: The number of parent sets and their scores stored in the full parent graphs
(‚ÄúFull‚Äù), the largest layer of the parent graphs in memory-efficient dynamic programming (‚ÄúLargest Layer‚Äù), and the sparse representation (‚ÄúSparse‚Äù).

the data points with missing values. Our A* search algorithm is implemented in Java3 . We
compared our algorithm against the branch and bound (BB)4 (de Campos & Ji, 2011), dynamic programming (DP)5 (Silander & Myllymaki, 2006), and integer linear programming
(GOBNILP) algorithms6 (Cussens, 2011). We used the latest versions of these software or
source code at the time of the experiments as well as their default parameter settings; it
was version 1.1 for GOBNILP and 2.1.1 for SCIP. BB and DP do not calculate MDL, but
they use the BIC score, which uses an equivalent calculation as MDL. Our results confirmed
that the algorithms found Bayesian networks that either are the same or belong to the same
equivalence class. The experiments were performed on a 2.66 GHz Intel Xeon with 16GB
of RAM and running SUSE Linux Enterprise Server version 10.
6.1 Full vs Sparse Parent Graphs
We first evaluated the memory savings made possible by the sparse parent graphs in comparison to the full parent graphs. In particular, we compared the maximum number of
scores that have to be stored for all variables at once by each algorithm. A typical dynamic programming algorithm stores scores for all possible parent sets of all variables. The
memory-efficient dynamic programming (Malone et al., 2011b) stores all possible parent
sets only in one layer of the parent graphs for all variables, so the size of the largest layer of
3. A software package with source code named URLearning (‚ÄúYou Are Learning‚Äù) implementing the A*
algorithm can be downloaded at http://url.cs.qc.cuny.edu/software/URLearning.html.
4. http://www.ecse.rpi.edu/‚àºcvrl/structlearning.html
5. http://b-course.hiit.fi/bene
6. http://www.cs.york.ac.uk/aig/sw/gobnilp/

47

Yuan & Malone

all parent graphs is an indication of its space requirement. The sparse representation only
stores the optimal parent sets for all variables.
Figure 5 shows the memory savings by the sparse representation on the benchmark
datasets. It is clear that the number of optimal parent scores stored by the sparse representation is typically several orders of magnitude smaller than the full representation.
Furthermore, due to Theorem 1, increasing the number of data points increases the maximum number of candidate parents. Therefore, the number of candidate parent sets increases
as the number of data points increases; however, many of the new parent sets are pruned
in the sparse representation because of Theorem 3. The number of variables also affects
the number of candidate parent sets. Consequently, the number of optimal parent scores
increases as a function of the number of data points and the number of variables. As the
results show, the amount of pruning is data-dependent, though, and not easily predictable.
In practice, we find the number of data points to affect the number of unique scores much
more than the number of variables.
6.2 Pattern Database Heuristics
The new pattern database heuristic has two versions: static and dynamic pattern databases;
each of them can be parameterized in different ways. We tested various parameterizations
of the new heuristics on the A* algorithm on two datasets named Autos and Flag. We chose
these two datasets because they have a large enough number of variables and can better
demonstrate the effect of pattern database heuristics. For the dynamic pattern database, we
varied k from 2 to 4. For the static pattern databases, we tried groupings 9-9-8 and 13-13 for
the Autos dataset and groupings 10-10-9 and 15-14 for the Flag dataset. We obtained the
groupings by simply dividing the variables in the datasets into several consecutive blocks.
The results based on the sparse parent graphs are shown in Figure 6. We did not show
the results of full parent graphs because A* ran out of memory on both datasets when
full parent graphs were used. With the sparse representations, A* achieved much better
scalability, and was able to solve both Autos with any heuristic and Flag with some of the
best heuristics when using sparse parent graphs. Hereafter our experiments and results
assume the use of sparse parent graphs.
Also, the pattern database heuristics improved the efficiency and scalability of A* significantly. A* with either the simple heuristic or the static pattern database with grouping
10-10-9 ran out of memory on the Flag dataset. The other pattern database heuristics enabled A* to finish successfully. The dynamic pattern database with k = 2 helped to reduce
the number of expanded nodes significantly on both datasets. Setting k = 3 helped even
more. However, further increasing k to 4 resulted in increased search time, and sometimes
even an increased number of expanded nodes (not shown). We believe that a larger k always
results in a better pattern database; the occasional increase in expanded nodes is because
the greedy strategy we used to choose patterns did not fully utilize the better heuristic. The
longer search time is more understandable though, because it is less efficient to compute
a heuristic value in larger pattern databases, and the inefficiency gradually overtook the
benefit. Therefore, k = 3 seems to be the best parametrization for the dynamic pattern
database in general. For the static pattern databases, we were able to test much larger
48

Learning Optimal Bayesian Networks

1.00E+04

Running Time

Size of Pattern Database

1.00E+05

1.00E+03
1.00E+02
1.00E+01
1.00E+00

500
450
400
350
300
250
200
150
100
50
0

Autos

1.00E+04

Running Time

Size of Pattern Database

1.00E+05

1.00E+03
1.00E+02
1.00E+01
1.00E+00

500
450
400
350
300
250
200
150
100
50
0

X

X

F lag
Figure 6: A comparison of A* enhanced with different heuristics (hsimple , hdynamic with k =
2, 3, and 4, and hstatic with groupings 9-9-8 and 13-13 for the Autos dataset and
groupings 10-10-9 and 15-14 for the Flag dataset). ‚ÄúSize of Pattern Database‚Äù
means the number of patterns stored. ‚ÄúRunning Time‚Äù means the search time
(in seconds) using the indicated pattern database strategy. An ‚ÄúX‚Äù means out of
memory.

groups because we do not need to enumerate all groups up to a certain size. The results
suggest that fewer larger groups tend to result in tighter heuristic.
The sizes of the static pattern databases are typically much larger than the dynamic
pattern databases. However, the time needed to create the pattern databases is still negligible in comparison to the search time in all cases. It is thus cost effective to try to compute
larger but affordable-size static pattern databases to achieve better search efficiency. Our
results show that the best static pattern databases typically helped A* to achieve better
efficiency than the dynamic pattern databases, even when the number of expanded nodes
is larger. The reason is that calculating the heuristic values is much more efficient when
using static pattern databases.
49

Yuan & Malone

10000
BB Scoring

DP Scoring

A* Scoring

Scoring Time

1000

100

10

1

0.1

Figure 7: A comparison of the scoring time of the BB, DP, and A* algorithms. Each label
of the X-axis consists of a dataset name, the number of variables, and the number
of data points.

6.3 A* with the Simple Heuristic
We first tested A* with the hsimple heuristic. Each competing algorithm has roughly two
phases, computing optimal parent sets/scores (scoring phase) and searching for a Bayesian
network structure (searching phase). We therefore compare the algorithms based on two
parts of running time: scoring time and search time. Figure 7 shows the scoring times
of BB, DP, and A*. GOBNILP was not included because it assumes the optimal scores
are provided as input. Each label in the horizontal axis shows a dataset, the number of
variables, and the number of data points. The results show that the AD-tree method used
in our A* algorithm seems to be the most efficient approach to computing the parent scores.
The scoring part of DP is often more than an order of magnitude slower than others. This
result is somewhat misleading, however. The scoring and searching parts of DP are more
tightly integrated than the other algorithms. As a result, most of the work in DP is done in
the scoring part; little work is left for the search. As we will show shortly, the search time
of DP is typically very short.
Figure 8(a) reports the search time of all the algorithms. Some of the benchmark
datasets are so difficult that some algorithms take too long or even fail to find the optimal
solutions. We therefore terminate an algorithm early if it runs for more than 7,200 seconds
on a dataset. The results show that BB only succeeded on two of the datasets, Voting and
Hepatitis, within the time limit. On both datasets, the A* algorithm is several orders of
magnitude faster than BB. The major difference between A* and BB is the formulation
of the search space. BB searches in the space of directed cyclic graphs, while A* always
maintains a directed acyclic graph during the search. The results indicate that it is better
to search in the space of directed acyclic graphs.
The results also show that the search time needed by the DP algorithm is often shorter
than A*. As we explained earlier, the reason is that all the heavy lifting in DP is done in
50

Learning Optimal Bayesian Networks

10000
BB

DP

GOBNILP

A*

Search Time

1000

100

10

1

X X

X

X

X

X

X

X

X X

X

(a)
10000

Total Running Time

DP Total Time

A* Total Time

1000

100

10

1

(b)
Figure 8: A comparison of the (a) search time (in seconds) for BB, DP, GOBNILP, and A*
and (b) total running time for DP and A*. An ‚ÄúX‚Äù means that the corresponding
algorithm did not finish within the time limit (7,200 seconds) or ran out of memory
in the case of A*.
.
the scoring part. If we add the scoring and search time together, as shown in Figure 8(b),
A* is several times faster than DP on all the datasets except Adult and Voting (Again,
GOBNILP is left out because it only has the search part). The main difference between A*
and DP is that A* only explores part of the order graph, while dynamic programming fully
evaluates the graph. However, each step of the A* search algorithm has some overhead
cost for computing the heuristic function and maintaining a priority queue. One step
51

Yuan & Malone

of A* is more expensive than a similar dynamic programming step. If the pruning does
not outweigh its overhead, A* can be slower than dynamic programming. Both Adult
and Voting have a large number of data points, which makes the pruning technique in
Theorem 1 less effective. Although the DP algorithm does not perform any pruning, due
to its simplicity, the algorithm can be highly streamlined and optimized in performing all
its calculations. That is why the DP algorithm was faster than A* search on these two
datasets. However, our A* algorithm was more efficient than DP on all the other datasets.
For these datasets, the number of data points is not that large in comparison to the number
of variables. The pruning significantly outweighs the overhead of A*. As an example,
A* runs faster on the Mushroom dataset when comparing total running time even though
Mushroom has over 8,000 data points.
The comparison between GOBNILP and A* shows that they each has its own advantages. A* was able to find optimal Bayesian networks for all the datasets well within the
time limit. GOBNILP failed to learn optimal Bayesian networks for three of the datasets,
including Letter, Image, and Mushroom. The reason is that GOBNILP formulates the
learning problem as an integer linear program whose variables correspond to the optimal
parent sets of all variables. Even though these datasets do not have many variables, they
have many optimal parent sets, so the integer programs for them have too many variables to
be solvable within the time limit. On the other hand, the results also show that GOBNILP
was quite efficient on many of the other datasets. Even though a dataset may have many
variables, GOBNILP can solve it efficiently as long as the number of optimal parent sets is
small. It is much more efficient than A* on datasets such as Hepatitis and Heart, although
the opposite is true on datasets such as Adult and Statlog.
6.4 A* with Pattern Database Heuristics
Since static pattern databases seem to work better than dynamic pattern databases in most
cases, we tested A* with static pattern database (A*,SP) against A*, DP, and GOBNILP
on all the datasets used in Figure 8 as well as several larger datasets. We used the simple
static grouping of ‚åà n2 ‚åâ ‚àí ‚åä n2 ‚åã for all the datasets, where n is the number of variables. The
results of BB are excluded because it did not solve any additional dataset. The results are
shown in Figure 9.
The benefits brought by the pattern databases for A* are rather obvious. For the
datasets on which A* was able to finish, A*,SP was typically up to an order of magnitude
faster. In addition, A*,SP was able to solve three larger datasets: Sensor, Autos, and Flag,
while A* failed on all of them. The running time on each of those datasets is pretty short,
which indicates that once the memory consumption of the parent graphs was reduced, A*
was able to use more memory for the order graph and solve the search problems rather
easily.
DP was able to solve one more dataset, Autos, which A* was not able to solve. It is
somewhat surprising given that A* has pruning capability. The explanation is that A*
stores all search information in RAM, so it will fail once the RAM is exhausted. The DP
algorithm described by Silander and Myllymaki (2006) stores its intermediate results as
computer files on hard disks, so it was able to scale to larger datasets than A*.
52

Learning Optimal Bayesian Networks

1000

Search Time

DP

GOBNILP

A*

A*, SP

100

10

1

X

X

X

XXX

X

X XX X X

Figure 9: A comparison of the search time (in seconds) for DP, GOBNILP, A*, and A*,SP.
An ‚ÄúX‚Äù means that the corresponding algorithm did not finish within the time
limit (7,200 seconds) or ran out of memory in the case of A*.

GOBNILP was able to solve Autos, Horse, and Flag, but failed on Sensors. The Sensors
dataset has 5, 456 data points. The number of optimal parent sets is too large, almost
106 as shown in Figure 5. GOBNILP begins to have difficulty solving datasets with more
than 8, 000 optimal parent scores in our particular computing environment. But again,
GOBNILP is quite efficient for datasets that it was able to solve such as Autos and Flag.
It is the only algorithm that can solve the Horse dataset. From Figure 5, it is clear that
the reason is the number of optimal parent sets is small for this dataset.
6.5 Pruning by A*
To gain more insight on the performance of A*, we also looked at the amount of pruning
by A* in different layers of an order graph. We plot in Figure 10 the detailed numbers
of expanded nodes versus the numbers of unexpanded nodes at each layer of the order
graph for two datasets: Mushroom and Parkinsons. We use these datasets because they are
the largest datasets that can be solved by both A* and A*,SP, but they manifest different
pruning behaviors. The top two figures show the results for the A* with the simple heuristic,
and the bottom two show the A*,SP algorithm.
On Mushroom, the plain A* only needed to expand a small portion of the search nodes in
each layer, which indicates the heuristic function is quite tight on this dataset. The effective
pruning started as early as in the 6th layer. For Parkinsons, however, the plain A* was not
as successful in pruning the nodes. In the first 13 layers, the heuristic function appeared to
be too loose. A* had to expand most nodes in these layers. The heuristic function became
tighter for the latter layers and enabled A* to prune an increasing percentage of the search
nodes. With the help of pattern database heuristic, however, A*,SP helped prune many
53

1.60E+06
Expanded

1.40E+06

Unexpanded

ExpandedvsUnexpandedNodes

ExpandedvsUnexpandedNodes

Yuan & Malone

1.20E+06
1.00E+06
8.00E+05
6.00E+05
4.00E+05
2.00E+05
0.00E+00
0

2

4

6

8

10

12 14
Layer

16

18

20

1.60E+06
Expanded

1.40E+06
1.20E+06
1.00E+06
8.00E+05
6.00E+05
4.00E+05
2.00E+05
0.00E+00
0

22

(a) A* on Mushroom

2

4

6

8

10 12 14
Layer

16

18

20

22

18

20

22

(b) A* on Parkinsons
1.60E+06

1.60E+06
Expanded

Unexpanded

ExpandedvsUnexpandedNodes

ExpandedvsUnexpandedNodes

Unexpanded

1.40E+06
1.20E+06
1.00E+06
8.00E+05
6.00E+05
4.00E+05
2.00E+05
0.00E+00
0

2

4

6

8

10 12
Layer

14

16

18

20

22

(c) A*,SP on Mushroom

Expanded

Unexpanded

1.40E+06
1.20E+06
1.00E+06
8.00E+05
6.00E+05
4.00E+05
2.00E+05
0.00E+00
0

2

4

6

8

10 12 14
Layer

16

(d) A*,SP on Parkinsons

Figure 10: The number of expanded and unexpanded nodes by A* at each layer of the order
graph on Mushroom and Parkinsons when using different heuristics.

more search nodes on Parkinsons; the pruning became effective as early as in the 6th layer.
The A*,SP also helped prune more nodes on Mushroom, although the benefit is not as clear
because A* was already quite effective on this dataset.
6.6 Factors Affecting Learning Difficulty
Several factors may affect the difficulty of a dataset for the Bayesian network learning
algorithms, including the number of variables, the number of data points, and the number
of optimal parent sets. We analyzed the correlation between those factors and the search
times of the algorithms. We replaced each occurrence of out of time with 7,200 in order
to make the analysis possible (we caution though that it may results in underestimation).
Figure 11 shows the results. We excluded the results of BB because it only finished on two
datasets. For DP, A*, and A*,SP, the most important factor in determining their efficiency
is the number of variables, as the correlations between their search time and the numbers
of variables were all greater than 0.58. However, there seems to be a negative correlation
between their search time with the number of data points. Intuitively, increasing the number
of data points should make a dataset more difficult. The explanation is that there is preexisting negative correlation between the number of data points and the number of variables
for the datasets we tested; our analysis shows that the correlation between them is ‚àí0.61.
54

Learning Optimal Bayesian Networks

1

Variables

Data!Records

Optimal!Parent!Sets

0.8

Correlation

0.6
0.4
0.2
0
0.2

DP

GOBNILP

A*

A*,!SP

0.4
0.6

Figure 11: The correlation between the search time of the algorithms and several factors
that may affect the difficulty of a learning problem, including the number of
variables, the number of data points in a dataset, and the number of optimal
parent sets.

Since the search time has a strong positive correlation with the number of variables, the
seemingly negative correlation between the search time and the number of data points
becomes less surprising.
In comparison, the efficiency of GOBNILP is most affected by the number of optimal
parent sets; their correlation is as high as close to 0.8. Also, there is a positive correlation
between the number of data points and its efficiency. It is because, as we explained earlier,
more data points often leads to more optimal parent sets. Finally, the correlation with the
number of variables is almost zero, which means the difficulty of a dataset for GOBNILP
is not determined by the number of variables.
These insights are quite important, as they provide a guideline for choosing a suitable
algorithm given the characteristic of a dataset. If there are many optimal parent sets but
not many variables, A* is the better algorithm; if the other way around is true, GOBNILP
is better.
6.7 Effect of Scoring Functions
Our analyses so far are based mainly on the MDL score. Other decomposable scoring
functions can also be used in the A* algorithm, as the correctness of the search strategies
and heuristic functions are not affected by the scoring function. However, different scoring
functions may have different properties. For example, Theorem 1 is a property of the MDL
score. We cannot use this pruning technique for other scoring functions. Consequently, the
number of optimal parent sets, the tightness of the heuristic, and the practical performance
of various algorithms may be affected.
To verify the hypothesis, we also tested the BDeu scoring function (Heckerman, 1998)
with the equivalent sample size set to be 1.0. Since the scoring phase is common for all
exact algorithms, we focus this experiment on comparing the number of optimal parent
sets resulted from the scoring functions, and the search time by A*,SP and GOBNILP
55

Yuan & Malone

Optimal PS, MDL

Optimal PS, Bdeu

Size

10000000
1000000
100000
10000
1000
100
10
1

(a)
10000
GOBNILP, MDL

GOBNILP, BDeu

A*, MDL

A*, BDeu

Search Time

1000

100

10

1

XX

XX

X

XX

XX

X

(b)
Figure 12: A comparison of (a) the number of optimal parent sets, and (b) the search time
by A*,SP and GOBNILP on various datasets for two scoring functions, MDL
and BDeu.

on the datasets; Horse and Flag were not included because their optimal parent sets were
unavailable. Figure 12 shows the results.
The main observation is that the number of optimal parent sets does differ for MDL
and BDeu. BDeu score tends to allow for larger parent sets than MDL and results in a
larger number of optimal parent sets for most of the datasets. The difference was around
an order of magnitude on datasets such as Imports and Autos.
The comparison on the search time shows that A*,SP is not affected as much as GOBNILP. Because of the increase in the number of optimal parent sets, the efficiency in finding
an optimal parent set is affected, but A*,SP was only slowed down slightly on most of the
datasets. The only significant change is on the Mushroom dataset. It took A*,SP about 2
seconds to solve the dataset when using MDL, but 115 seconds using BDeu. In comparison,
GOBNILP was affected much more. It was able to solve datasets Imports and Autos effi56

Learning Optimal Bayesian Networks

ciently when using MDL, but failed to solve them within 3 hours using BDeu. It remained
unable to solve Letter, Image, Mushroom, and Sensors within the time limit.

7. Discussions and Conclusions
This paper presents a shortest-path perspective of the problem of learning optimal Bayesian
networks that optimize a given scoring function. It uses an implicit order graph to represent
the solution space of the learning problem such that the shortest path between the start
and goal nodes in the graph corresponds to an optimal Bayesian network. This perspective
highlights the importance of two orthogonal directions of research. One direction is to
develop search algorithms for solving the shortest path problem. The main contribution
we made on this line is an A* algorithm for solving the shortest path problem in learning
an optimal Bayesian network. Guided by heuristic functions, the A* algorithm focuses on
searching the most promising parts of the solution space in finding the optimal Bayesian
network.
The second equally important research direction is the development of search heuristics.
We introduced two admissible heuristics for the shortest path problem. The first heuristic
estimates the future cost by completely relaxing the acyclicity constraint of Bayesian networks. It is shown to be not only admissible but also consistent. The second heuristic, the
k-cycle conflict heuristic, is developed based on the additive pattern database technique.
Unlike the simple heuristic in which each variable is allowed to choose optimal parents independently, the new heuristic tightens the estimation by enforcing the acyclicity constraint
within some small groups of variables. There are two specific approaches to computing the
new heuristic. One approach named dynamic k-cycle conflict heuristic computes the costs
for all groups of variables with size up to k. During the search, we dynamically partition
remaining variables into exclusive patterns in calculating the heuristic value. The other
approach named static k-cycle conflict heuristic partitions the variables into several static
exclusive groups, and computes a separate pattern database for each group. We can sum
the costs of the static pattern databases to obtain an admissible heuristic. Both heuristics
remain admissible and consistent, although the consistency of the dynamic k-cycle conflict
may be sacrificed due to a greedy method we used to select the patterns.
We tested the A* algorithm empowered with different search heuristics on a set of UCI
machine learning datasets. The results show that both the pattern database heuristics
contributed to significant improvements in the efficiency and scalability of the A* algorithm. The results also show that our A* algorithm is typically more efficient than dynamic
programming that shares a similar formulation. In comparison to GOBNILP, an integer
programming algorithm, A* is less sensitive to the number of optimal parent sets, number
of data points, or scoring functions, but is more sensitive to the number of variables in the
datasets. With those advantages, we believe our methods represent a promising approach
to learning optimal Bayesian network structures.
Exact algorithms for learning optimal Bayesian networks are still limited to relatively
small problems. Further scaling up the learning is needed, e.g., by incorporating domain or
expert knowledge in the learning. It also means that approximation methods are still useful
in domains with many variables. Nevertheless, the exact algorithms are valuable because
they can serve as the basis to evaluate different approximation methods so that we have
57

Yuan & Malone

some quality assurance. Also, it is a promising research direction to develop algorithms
that have the best properties of both approximation and exact algorithms, that is, they
can find good solutions quickly and, if given enough resources, can converge to an optimal
solution (Malone & Yuan, 2013).

Acknowledgments
This research was supported by NSF grants IIS-0953723, EPS-0903787, IIS-1219114 and
the Academy of Finland (Finnish Centre of Excellence in Computational Inference Research
COIN, 251170). Part of this research has previously been presented in IJCAI-11 (Yuan,
Malone, & Wu, 2011) and UAI-12 (Yuan & Malone, 2012).

Appendix A. Proofs
The following are the proofs of the theorems in this paper.
A.1 Proof of Theorem 5
Proof: Note that the optimal parent set for X out of U has to be a subset of U, and the
subset has to have the best score. Sorting all the unique parent scores makes sure that the
first found subset must satisfy both requirements stated in the theorem.
‚ú∑
A.2 Proof of Theorem 6
Proof: Heuristic function h is clearly admissible, because it allows each remaining variable
to choose optimal parents from all the other variables in V. The chosen parent set must
be a superset of the parent set for the same variable in the optimal directed acyclic graph
consisting of the remaining variables. Due to Theorem 4, the heuristic results in a lower
bound cost.
‚ú∑
A.3 Proof of Theorem 7
Proof: For any successor node S of U, let Y ‚àà S \ U. We have
X
h(U) =
BestScore(X, V\{X})
X‚ààV\U

‚â§

X

BestScore(X, V\{X})

X‚ààV\U,X6=Y

+BestScore(Y, U)
= h(S) + c(U, S).
The inequality holds because fewer variables are used to select optimal parents for Y . Hence,
h is consistent.
‚ú∑
A.4 Proof of Theorem 8
Proof: The theorem can be proven by noting that avoiding cycles between the variables
in U is equivalent to finding an optimal ordering of the variables with the best joint score.
58

Learning Optimal Bayesian Networks

The different paths from V \ U to the goal node correspond to the different orderings of
the variables, among which the shortest path hence corresponds to the optimal ordering. ‚ú∑
A.5 Proof of Theorem 9
Proof: For node U, assume the remaining variables V \ U are partitioned into exclusive
sets V1 , ..., Vp . Because of the decomposability of the scoring function, we have h(U) =
p
P
c(Vi ). When computing c(Vi ), we do not allow directed cycles within Vi . All the
i=1

variables in V \ Vi are valid candidate parents, however. The cost of each pattern, c(Vi ),
must be optimal by the definition of pattern databases. By the same argument used in the
proof of Theorem 6, the h(U) cost cannot be worse than the total cost of V \ U, that is, the
cost of the optimal directed acyclic graph consisting of these variables (with U as allowable
parents also). Otherwise, we can simply arrange the variables in the patterns in the same
order as in the optimal directed acyclic graph to get the same cost. Therefore, the heuristic
is still admissible.
Note that the previous argument only relies on the optimality of the pattern costs, not
on which patterns are chosen. The greedy strategy used in dynamic pattern database only
affects which patterns are selected. Therefore, this theorem holds for both dynamic and
static pattern databases.
‚ú∑
A.6 Proof of Theorem 10
Proof: Recall that using static pattern databases with node partitions V = ‚à™i Vi , the
heuristic value for a node U is as follows.
h(U) =

X

c((V \ U) ‚à© Vi ),

i

where (V \U)‚à© Vi is the pattern in the ith static pattern database. Then, for any successor
node S of U, let Y ‚àà S \ U. Without lost of generality, let Y ‚àà (V \ U) ‚à© Vj . The heuristic
value for node S is then
h(S) =

X

c((V \ U) ‚à© Vi ) + c((V \ U) ‚à© (Vj \ {Y })).

i6=j

Also, the cost between U and S is
c(U, S) = BestScore(Y, U).
From the definition of pattern database, we know that c((V\U)‚à©Vj ) is the best possible
joint score for the variables in the pattern after U are searched. Therefore, we have
c((V \ U) ‚à© Vj ) ‚â§ c(V \ U) ‚à© Vj \ {Y }) + BestScore(Y, (‚à™i6=j Vi ) ‚à™ (Vj \ (V \ U))
‚â§ c((V \ U) ‚à© (Vj \ {Y })) + BestScore(Y, U).
The last inequality holds because U ‚äÇ (‚à™i6=j Vi ) ‚à™ (Vj \ (V \ U)). The following then
immediately follows.
h(U) ‚â§ h(S) + c(U, S).
59

Yuan & Malone

Hence, the static k-cycle conflict heuristic is consistent.
‚ú∑
A.7 Proof of Theorem 11
Proof: The heuristic values calculated from the dynamic pattern database can be considered as shortest distances between nodes in an abstract space. The abstract space consists
of the same set of nodes, i.e., all subsets of V. However, additional arcs are added between
a node and nodes with up to k additional variables.
Consider a shortest path p between any two nodes U and goal V in the original solution
space. The path remains a valid path, but may no longer be the shortest path between U
and V because of the additional arcs.
Let gœÜ (U, V) be the shortest distance between U and V in the abstract space. For any
successor node S of U, we must have the following.
gœÜ (U, V) ‚â§ gœÜ (U, S) + gœÜ (S, V).

(8)

Now, recall that gœÜ (U, V) and gœÜ (S, V) are the heuristic values for the original solution
space, and gœÜ (U, S) is equal to the arc cost c(U, S) in the original space. We therefore have
the following.
h(U) ‚â§ c(U, S) + h(S).
(9)
Hence, the dynamic k-cycle conflict heuristic is consistent.

‚ú∑

References
Acid, S., & de Campos, L. M. (2001). A hybrid methodology for learning belief networks:
BENEDICT. International Journal of Approximate Reasoning, 27 (3), 235‚Äì262.
Akaike, H. (1973). Information theory and an extension of the maximum likelihood principle.
In Proceedings of the Second International Symposium on Information Theory, pp.
267‚Äì281.
Bache, K., & Lichman, M.
http://archive.ics.uci.edu/ml.

(2013).

UCI

machine

learning

repository.

Bouckaert, R. R. (1994). Properties of Bayesian belief network learning algorithms. In
Proceedings of the Tenth Conference on Uncertainty in Artificial Intelligence, pp.
102‚Äì109, Seattle, WA. Morgan Kaufmann.
Bozdogan, H. (1987). Model selection and Akaike‚Äôs information criterion (AIC): The general
theory and its analytical extensions. Psychometrika, 52, 345‚Äì370.
Buntine, W. (1991). Theory refinement on Bayesian networks. In Proceedings of the seventh
conference (1991) on Uncertainty in artificial intelligence, pp. 52‚Äì60, San Francisco,
CA, USA. Morgan Kaufmann Publishers Inc.
Cheng, J., Greiner, R., Kelly, J., Bell, D., & Liu, W. (2002). Learning Bayesian networks
from data: an information-theory based approach. Artificial Intelligence, 137 (1-2),
43‚Äì90.
60

Learning Optimal Bayesian Networks

Chickering, D. (1995). A transformational characterization of equivalent Bayesian network
structures. In Proceedings of the 11th annual conference on uncertainty in artificial
intelligence (UAI-95), pp. 87‚Äì98, San Francisco, CA. Morgan Kaufmann Publishers.
Chickering, D. M. (1996). Learning Bayesian networks is NP-complete. In Learning from
Data: Artificial Intelligence and Statistics V, pp. 121‚Äì130. Springer-Verlag.
Chickering, D. M. (2002). Learning equivalence classes of Bayesian-network structures.
Journal of Machine Learning Research, 2, 445‚Äì498.
Cooper, G. F., & Herskovits, E. (1992). A Bayesian method for the induction of probabilistic
networks from data. Machine Learning, 9, 309‚Äì347.
Culberson, J. C., & Schaeffer, J. (1998). Pattern databases. Computational Intelligence,
14, 318‚Äì334.
Cussens, J. (2011). Bayesian network learning with cutting planes. In Proceedings of the
Twenty-Seventh Conference Annual Conference on Uncertainty in Artificial Intelligence (UAI-11), pp. 153‚Äì160, Corvallis, Oregon. AUAI Press.
Daly, R., & Shen, Q. (2009). Learning Bayesian network equivalence classes with ant colony
optimization. Journal of Artificial Intelligence Research, 35, 391‚Äì447.
Dash, D., & Cooper, G. (2004). Model averaging for prediction with discrete Bayesian
networks. Journal of Machine Learning Research, 5, 1177‚Äì1203.
Dash, D. H., & Druzdzel, M. J. (1999). A hybrid anytime algorithm for the construction
of causal models from sparse data. In Proceedings of the Fifteenth Annual Conference
on Uncertainty in Artificial Intelligence (UAI‚Äì99), pp. 142‚Äì149, San Francisco, CA.
Morgan Kaufmann Publishers, Inc.
de Campos, C. P., & Ji, Q. (2011). Efficient learning of Bayesian networks using constraints.
Journal of Machine Learning Research, 12, 663‚Äì689.
de Campos, C. P., & Ji, Q. (2010). Properties of Bayesian Dirichlet scores to learn Bayesian
network structures. In Fox, M., & Poole, D. (Eds.), AAAI, pp. 431‚Äì436. AAAI Press.
de Campos, L. M. (2006). A scoring function for learning Bayesian networks based on
mutual information and conditional independence tests. Journal of Machine Learning
Research, 7, 2149‚Äì2187.
de Campos, L. M., Fernndez-Luna, J. M., Gmez, J. A., & Puerta, J. M. (2002). Ant colony
optimization for learning Bayesian networks. International Journal of Approximate
Reasoning, 31 (3), 291‚Äì311.
de Campos, L. M., & Huete, J. F. (2000). A new approach for learning belief networks
using independence criteria. International Journal of Approximate Reasoning, 24 (1),
11 ‚Äì 37.
61

Yuan & Malone

de Campos, L. M., & Puerta, J. M. (2001). Stochastic local algorithms for learning belief
networks: Searching in the space of the orderings. In Benferhat, S., & Besnard, P.
(Eds.), ECSQARU, Vol. 2143 of Lecture Notes in Computer Science, pp. 228‚Äì239.
Springer.
Edelkamp, S., & Schrodl, S. (2012). Heuristic Search - Theory and Applications. Morgan
Kaufmann.
Felner, A., Korf, R., & Hanan, S. (2004). Additive pattern database heuristics. Journal of
Artificial Intelligence Research, 22, 279‚Äì318.
Felzenszwalb, P. F., & McAllester, D. A. (2007). The generalized A* architecture. Journal
of Artificial Intelligence Research, 29, 153‚Äì190.
Friedman, N., & Koller, D. (2003). Being Bayesian about network structure: A Bayesian
approach to structure discovery in Bayesian networks. Machine Learning, 50 (1-2),
95‚Äì125.
Friedman, N., Nachman, I., & Pe‚Äôer, D. (1999). Learning Bayesian network structure from
massive datasets: The ‚Äúsparse candidate‚Äù algorithm. In Laskey, K. B., & Prade, H.
(Eds.), Proceedings of the Fifteenth Conference Conference on Uncertainty in Artificial
Intelligence (UAI-99), pp. 206‚Äì215. Morgan Kaufmann.
Garey, M. R., & Johnson, D. S. (1979). Computers and Intractability: A Guide to the
Theory of NP-Completeness. W. H. Freeman & Co., New York, NY, USA.
Glover, F. (1990). Tabu search: A tutorial. Interfaces, 20 (4), 74‚Äì94.
Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). A formal basis for the heuristic determination of minimum cost paths. IEEE Trans. Systems Science and Cybernetics, 4 (2),
100‚Äì107.
Heckerman, D., Geiger, D., & Chickering, D. M. (1995). Learning Bayesian networks: The
combination of knowledge and statistical data. Machine Learning, 20, 197‚Äì243.
Heckerman, D. (1998). A tutorial on learning with Bayesian networks. In Holmes, D., & Jain,
L. (Eds.), Innovations in Bayesian Networks, Vol. 156 of Studies in Computational
Intelligence, pp. 33‚Äì82. Springer Berlin / Heidelberg.
Hemmecke, R., Lindner, S., & Studeny, M. (2012). Characteristic imsets for learning
Bayesian network structure. International Journal of Approximate Reasoning, 53 (9),
1336‚Äì1349.
Hsu, W. H., Guo, H., Perry, B. B., & Stilson, J. A. (2002). A permutation genetic algorithm
for variable ordering in learning Bayesian networks from data. In Langdon, W. B.,
Cant-Paz, E., Mathias, K. E., Roy, R., Davis, D., Poli, R., Balakrishnan, K., Honavar,
V., Rudolph, G., Wegener, J., Bull, L., Potter, M. A., Schultz, A. C., Miller, J. F.,
Burke, E. K., & Jonoska, N. (Eds.), GECCO, pp. 383‚Äì390. Morgan Kaufmann.
62

Learning Optimal Bayesian Networks

Jaakkola, T., Sontag, D., Globerson, A., & Meila, M. (2010). Learning Bayesian network
structure using LP relaxations. In Proceedings of the 13th International Conference on
Artificial Intelligence and Statistics (AISTATS), pp. 358‚Äì365, Chia Laguna Resort,
Sardinia, Italy.
Klein, D., & Manning, C. D. (2003). A* parsing: Fast exact Viterbi parse selection. In
Proceedings of the Human Language Conference and the North American Association
for Computational Linguistics (HLT-NAACL), pp. 119‚Äì126.
Koivisto, M., & Sood, K. (2004). Exact Bayesian structure discovery in Bayesian networks.
Journal of Machine Learning Research, 5, 549‚Äì573.
Kojima, K., Perrier, E., Imoto, S., & Miyano, S. (2010). Optimal search on clustered
structural constraint for learning Bayesian network structure. Journal of Machine
Learning Research, 11, 285‚Äì310.
Lam, W., & Bacchus, F. (1994). Learning Bayesian belief networks: An approach based on
the MDL principle. Computational Intelligence, 10, 269‚Äì293.
Larranaga, P., Kuijpers, C. M. H., Murga, R. H., & Yurramendi, Y. (1996). Learning
Bayesian network structures by searching for the best ordering with genetic algorithms. IEEE Transactions on Systems, Man, and Cybernetics, Part A, 26 (4), 487‚Äì
493.
Malone, B., & Yuan, C. (2013). Evaluating anytime algorithms for learning optimal Bayesian
networks. In Proceedings of the 29th Conference on Uncertainty in Artificial Intelligence (UAI-13), pp. 381‚Äì390, Seattle, Washington.
Malone, B., Yuan, C., Hansen, E., & Bridges, S. (2011a). Improving the scalability of optimal Bayesian network learning with frontier breadth-first branch and bound search. In
Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence (UAI-11),
pp. 479‚Äì488, Barcelona, Catalonia, Spain.
Malone, B., Yuan, C., & Hansen, E. A. (2011b). Memory-efficient dynamic programming
for learning optimal Bayesian networks. In Proceedings of the 25th AAAI Conference
on Artificial Intelligence (AAAI-11), pp. 1057‚Äì1062, San Francisco, CA.
Moore, A., & Lee, M. S. (1998). Cached sufficient statistics for efficient machine learning
with large datasets. Journal of Artificial Intelligence Research, 8, 67‚Äì91.
Moore, A., & Wong, W.-K. (2003). Optimal reinsertion: A new search operator for accelerated and more accurate Bayesian network structure learning. In International
Conference on Machine Learning, pp. 552‚Äì559.
Myers, J. W., Laskey, K. B., & Levitt, T. S. (1999). Learning Bayesian networks from
incomplete data with stochastic search algorithms. In Laskey, K. B., & Prade, H.
(Eds.), Proceedings of the Fifteenth Conference Conference on Uncertainty in Artificial
Intelligence (UAI-99), pp. 476‚Äì485. Morgan Kaufmann.
63

Yuan & Malone

Ordyniak, S., & Szeider, S. (2010). Algorithms and complexity results for exact Bayesian
structure learning. In Gruwald, P., & Spirtes, P. (Eds.), Proceedings of the 26th
Conference Conference on Uncertainty in Artificial Intelligence (UAI-10), pp. 401‚Äì
408. AUAI Press.
Ott, S., Imoto, S., & Miyano, S. (2004). Finding optimal models for small gene networks.
In Pacific Symposium on Biocomputing, pp. 557‚Äì567.
Papadimitriou, C. H., & Steiglitz, K. (1982). Combinatorial optimization: algorithms and
complexity. Prentice-Hall, Inc., Upper Saddle River, NJ, USA.
Parviainen, P., & Koivisto, M. (2009). Exact structure discovery in Bayesian networks with
less space. In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial
Intelligence, Montreal, Quebec, Canada. AUAI Press.
Pearl, J. (1984). Heuristics: intelligent search strategies for computer problem solving.
Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA.
Pearl, J. (1988). Probabilistic reasoning in intelligent systems: networks of plausible inference. Morgan Kaufmann Publishers Inc.
Perrier, E., Imoto, S., & Miyano, S. (2008). Finding optimal Bayesian network given a
super-structure. Journal of Machine Learning Research, 9, 2251‚Äì2286.
Rissanen, J. (1978). Modeling by shortest data description. Automatica, 14, 465‚Äì471.
Silander, T., & Myllymaki, P. (2006). A simple approach for finding the globally optimal Bayesian network structure. In Proceedings of the 22nd Annual Conference on
Uncertainty in Artificial Intelligence (UAI-06), pp. 445‚Äì452. AUAI Press.
Silander, T., Roos, T., Kontkanen, P., & Myllymaki, P. (2008). Factorized normalized
maximum likelihood criterion for learning Bayesian network structures. In Proceedings
of the 4th European Workshop on Probabilistic Graphical Models (PGM-08), pp. 257‚Äì
272.
Singh, A., & Moore, A. W. (2005). Finding optimal Bayesian networks by dynamic programming. Tech. rep. CMU-CALD-05-106, Carnegie Mellon University.
Spirtes, P., Glymour, C., & Scheines, R. (2000). Causation, prediction, and search (second
edition). The MIT Press.
Suzuki, J. (1996). Learning Bayesian belief networks based on the minimum description
length principle: An efficient algorithm using the B&B technique. In International
Conference on Machine Learning, pp. 462‚Äì470.
Teyssier, M., & Koller, D. (2005). Ordering-based search: A simple and effective algorithm
for learning Bayesian networks. In Proceedings of the Twenty-First Annual Conference
on Uncertainty in Artificial Intelligence (UAI-05), pp. 584‚Äì590. AUAI Press.
64

Learning Optimal Bayesian Networks

Tian, J. (2000). A branch-and-bound algorithm for MDL learning Bayesian networks. In
UAI ‚Äô00: Proceedings of the 16th Conference on Uncertainty in Artificial Intelligence,
pp. 580‚Äì588, San Francisco, CA, USA. Morgan Kaufmann Publishers Inc.
Tsamardinos, I., Brown, L., & Aliferis, C. (2006). The max-min hill-climbing Bayesian
network structure learning algorithm. Machine Learning, 65, 31‚Äì78.
Xie, X., & Geng, Z. (2008). A recursive method for structural learning of directed acyclic
graphs. Journal of Machine Learning Research, 9, 459‚Äì483.
Yuan, C., Lim, H., & Littman, M. L. (2011a). Most relevant explanation: Computational
complexity and approximation methods. Annals of Mathematics and Artificial Intelligence, 61, 159‚Äì183.
Yuan, C., Lim, H., & Lu, T.-C. (2011b). Most relevant explanation in Bayesian networks.
Journal of Artificial Intelligence Research (JAIR), 42, 309‚Äì352.
Yuan, C., Liu, X., Lu, T.-C., & Lim, H. (2009). Most Relevant Explanation: Properties,
algorithms, and evaluations. In Proceedings of 25th Conference on Uncertainty in
Artificial Intelligence (UAI-09), pp. 631‚Äì638, Montreal, Canada.
Yuan, C., & Malone, B. (2012). An improved admissible heuristic for learning optimal
Bayesian networks. In Proceedings of the 28th Conference on Uncertainty in Artificial
Intelligence (UAI-12), pp. 924‚Äì933, Catalina Island, CA.
Yuan, C., Malone, B., & Wu, X. (2011). Learning optimal Bayesian networks using A*
search. In Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI-11), pp. 2186‚Äì2191, Helsinki, Finland.

65

