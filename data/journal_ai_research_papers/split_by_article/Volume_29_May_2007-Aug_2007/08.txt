Journal of Artificial Intelligence Research 29 (2007) 269-307

Submitted 8/06; published 7/07

Semantic Matchmaking as Non-Monotonic Reasoning: A
Description Logic Approach
Tommaso Di Noia
Eugenio Di Sciascio

t.dinoia@poliba.it
disciascio@poliba.it

SisInfLab - Politecnico di Bari, Bari, Italy

Francesco M. Donini

donini@unitus.it

Universita della Tuscia, Viterbo, Italy

Abstract
Matchmaking arises when supply and demand meet in an electronic marketplace, or
when agents search for a web service to perform some task, or even when recruiting agencies
match curricula and job proles. In such open environments, the objective of a matchmaking process is to discover best available oers to a given request.
We address the problem of matchmaking from a knowledge representation perspective,
with a formalization based on Description Logics. We devise Concept Abduction and Concept Contraction as non-monotonic inferences in Description Logics suitable for modeling
matchmaking in a logical framework, and prove some related complexity results. We also
present reasonable algorithms for semantic matchmaking based on the devised inferences,
and prove that they obey to some commonsense properties.
Finally, we report on the implementation of the proposed matchmaking framework,
which has been used both as a mediator in e-marketplaces and for semantic web services
discovery.

1. Introduction
The promise of the Semantic Web initiative is to revolutionize the way information is coded,
stored, and searched on the Internet (Berners-Lee, Hendler, & Lassila, 2001). The basic
idea is to structure information with the aid of markup languages, based on the XML
language, such as RDF and RDFS1 , and OWL2 . These languages have been conceived
for the representation of machine-understandable, and unambiguous, description of web
content through the creation of domain ontologies, and aim at increasing openness and
interoperability in the web environment.
Widespread availability of resources and services enablesamong other advantages
the interaction with a number of potential counterparts. The bottleneck is that it is dicult
nding matches, possibly the best ones, between parties.
The need for a matchmaking process arises when supply and demand have to meet in a
marketplace, or when web services able to perform some task have to be discovered, but also
when recruiting agencies match curricula and job proles or a dating agency has to propose
partners to a customer of the agency. Requests and oers may hence be generic demands
and supplies, web services, information, tangible or intangible goods, and a matchmaking
process should nd for any request an appropriate response. In this paper we concentrate
1. http://www.w3.org/RDF/
2. http://www.w3.org/TR/owl-features/
c
2007
AI Access Foundation. All rights reserved.

fiDi Noia, Di Sciascio & Donini

on automated matchmaking, basically oriented to electronic marketplaces and service discovery, although principles and algorithms are denitely general enough to cover also other
scenarios. We assume, as it is reasonable, that both requests and oers are endowed of
some kind of description. Based on these descriptions the target of the matching process
is nding, for a given request, best matches available in the oers set, and also, given an
oer, determine best matching requests in a peer-to-peer fashion. We may hence think of an
electronic mediator as the actor who actively tries to carry out the matchmaking process.
Obviously descriptions might be provided using unstructured text, and in this case such an
automated mediator should revert to adopting either basic string matching techniques or
more sophisticated Information Retrieval techniques.
The Semantic Web paradigm calls for descriptions that should be provided in a structured form based on ontologies, and we will assume in what follows that requests and oers
are given with reference to a common ontology. It should be noticed that even when requests
and oers are described in heterogeneous languages, or using dierent ontologies modelling
the same domain, schema/data integration techniques may be employed to make them
comparable, as proposed e.g., by Madhavan, Bernstein, and Rahm (2001), and Shvaiko and
Euzenat (2005); but once they are reformulated in a comparable way, one is still left with
the basic matchmaking problems: given a request, are there compatible oers? If there are
several compatible oers, which, and why, are the most promising ones?
Matchmaking has been widely studied and several proposals have been made in the past;
we report on them in Section 2. Recently, there has been a growing eort aimed at the
formalization with Description Logics (DLs) (Baader, Calvanese, Mc Guinness, Nardi, &
Patel-Schneider, 2003) of the matchmaking process (e.g., Di Sciascio, Donini, Mongiello, &
Piscitelli, 2001; Trastour, Bartolini, & Priest, 2002; Sycara, Wido, Klusch, & Lu, 2002; Di
Noia, Di Sciascio, Donini, & Mongiello, 2003b; Li & Horrocks, 2003; Di Noia, Di Sciascio,
Donini, & Mongiello, 2003c, 2003a, among others). DLs, in fact, allow to model structured
descriptions of requests and oers as concepts, usually sharing a common ontology. Furthermore DLs allow for an open-world assumption. Incomplete information is admitted,
and absence of information can be distinguished from negative information. We provide a
little insight on DLs in Section 3.
Usually, DL-based approaches exploit standard reasoning services of a DL system
subsumption and (un)satisabilityto match potential partners in an electronic transaction. In brief, if a supply is described by a concept Sup and a demand by a concept Dem,
unsatisability of the conjunction of Sup and Dem (noted as Sup  Dem) identies the incompatible proposals, satisability identies potential partnersthat still have to agree on
underspecied constraintsand subsumption between Sup and Dem (noted as Sup  Dem)
means that requirements on Dem are completely fullled by Sup.
Classication into compatible and incompatible matches can be useless in the presence of
several compatible supplies; some way to rank most promising ones has to be identied; also
some explanation on motivation of such a rank could be appreciated. On the other hand,
when there is lack of compatible matches one may accept to turn to incompatible matches
that could still be interesting, by revising some of the original requirements presented in
the request, as far as one could easily identify them.
In other words some method is needed to provide a logic-based score for both compatible
and incompatible matches and eventually provide a partial/full ordering, allowing a user
270

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

or an automated agent to choose most promising counteroers. Furthermore it should be
possible, given a score, to provide logical explanations of the resulting score, thus allowing
to understand the rank result and ease further interaction to rene/revise the request.
Although this process is quite simple for a human being it is not so in a logic-based fully
automated framework. We believe there is a need to dene non-monotonic reasoning services
in a DLs setting, to deal with approximation and ranking, and in this paper we propose
the use of Concept Abduction (Di Noia et al., 2003a) and Concept Contraction (Colucci,
Di Noia, Di Sciascio, Donini, & Mongiello, 2003), as services amenable to answer the above
highlighted issues in a satisfactory way. Contributions of this paper include:
 a logical framework to express requests and oers in terms of concept descriptions,
and properties that should hold in a matchmaking facilitator;
 Concept Abduction as a logical basis for ranking compatible counteroers to a given
oer and provide logical explanations of the ranking result;
 Concept Contraction as a logical basis for ranking incompatible matches, aimed at
discovering most promising near misses, and provide logical explanations of the
ranking result;
 algorithms implementing the formalized inferences for matchmaking purposes and
complexity results for a class of matchmaking problems;
 description of our system implementing semantic matchmaking services, and experimental evaluation.
The remaining of the paper is structured as follows: next Section reports on background
work on the subject. Then (Section 3) we briey revise Description Logics basics. To make
the paper self-contained we recall (Section 4) our logic-based framework for matchmaking,
pointing out properties that matchmaking algorithms and systems should guarantee. In
Sections 5 and 6 we present Concept Abduction and Concept Contraction, the two inference
services we devised to compute semantic matchmaking, and present suitable denitions
of the problem along with some complexity results. Then in Section 7 we describe our
matchmaker, and present (Section 7.1) an evaluation of results computed by the system
compared with human users behavior, and with a standard full text retrieval approach.
Conclusions close the paper.

2. Related Work on Matchmaking
Matchmaking has been investigated in recent years under a number of perspectives and for
dierent purposes, with a renovated interest as the information overload kept growing with
the Web widespreading use. We try here to summarize some of the relevant related work.
Vague query answering, proposed by Motro (1988), was an initial eort to overcome limitations of relational databases, using weights attributed to several search variables. More
recent approaches along these lines aim at extending SQL with preference clauses, in
order to softly matchmake data in structured databases (Kieling, 2002). Finin, Fritzson,
McKay, and McEntire (1994) proposed KQML as an agent communication language oriented to matchmaking purposes. Kuokka and Harada (1996) investigated matchmaking
271

fiDi Noia, Di Sciascio & Donini

as a process that allowed potential producers/consumers to provide descriptions of their
products/needs, either directly or through agents mediation, to be later unied by an engine identifying promising matches. Two engines were developed, the SHADE system,
which again used KQML, and as description language KIF, with matchmaking anyway not
relying on any logical reasoning, and COINS, which adopted classical unstructured-text information retrieval techniques, namely the SMART IR system. Similar methods were later
re-considered in the GRAPPA system (Veit, Muller, Schneider, & Fiehn, 2001). Classiedads matchmaking, at a syntactic level, was proposed by Raman, Livny, and Solomon (1998)
to matchmake semi-structured descriptions advertising computational resources in a fashion
anticipating Grid resources brokering. Matchmaking was used in SIMS (Arens, Knoblock,
& Shen, 1996) to dynamically integrate queries; the approach used KQML, and LOOM
as description language. LOOM is also used in the subsumption matching addressed by
Gil and Ramachandran (2001). InfoSleuth (Jacobs & Shea, 1995), a system for discovery
and integration of information, included an agent matchmaker, which adopted KIF and
the deductive database language LDL++. Constraint-based approaches to matchmaking
have been proposed and implemented in several systems, e.g., PersonaLogic3 , Kasbah4 and
systems by Maes, Guttman, and Moukas (1999), Karacapilidis and Moraitis (2001), Wang,
Liao, and Liao (2002), Strobel and Stolze (2002).
Matchmaking as satisability of concept conjunction in DLs was rst proposed in the
same venue by Gonzales-Castillo, Trastour, and Bartolini (2001) and by Di Sciascio et al.
(2001), and precisely dened by Trastour et al. (2002). Sycara, Paolucci, Van Velsen, and
Giampapa (2003) introduced a specic language for agent advertisement in the framework
of the Retsina Multiagent infrastructure. A matchmaking engine was developed (Sycara
et al., 2002; Paolucci, Kawamura, Payne, & Sycara, 2002), which carries out the process on
ve possible levels. Such levels exploit both classical text-retrieval techniques and semantic
match using -subsumption. Nevertheless, standard features of a semantic-based system,
as satisability check are unavailable. It is noteworthy that in this approach, the notion
of plug-in match is introduced, to overcome in some way the limitations of a matching approach based on exact matches. The approach of Paolucci et al. (2002) was later extended
by Li and Horrocks (2003), where two new levels for matching classication were introduced.
A similar classication was proposedin the same venueby Di Noia et al. (2003c), along
with properties that a matchmaker should have in a DL-based framework, and algorithms to
classify and semantically rank matches within classes. Benatallah, Hacid, Rey, and Toumani
(2003) proposed the Dierence Operator in DLs for semantic matchmaking. The approach
uses Concept Dierence, followed by a covering operation optimized using hypergraph techniques, in the framework of web services discovery. We briey comment on the relationship
between Concept Dierence and Concept Abduction at the end of Section 5. An initial DLbased approach, adopting penalty functions ranking, has been proposed by Cal, Calvanese,
Colucci, Di Noia, and Donini (2004), in the framework of dating systems. An extended
matchmaking approach, with negotiable and strict constraints in a DL framework has been
proposed by Colucci, Di Noia, Di Sciascio, Donini, and Mongiello (2005), using both Concept Contraction and Concept Abduction. Matchmaking in DLs with locally-closed world
3. http://www.PersonaLogic.com
4. http://www.kasbah.com

272

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

assumption applying autoepistemic DLs has been proposed by Grimm, Motik, and Preist
(2006).
The need to work in someway with approximation and ranking in DL-based approaches
to matchmaking has also recently led to adopting fuzzy-DLs, as in Smart (Agarwal &
Lamparter, 2005) or hybrid approaches, as in the OWLS-MX matchmaker (Klusch, Fries,
Khalid, & Sycara, 2005). Such approaches, anyway, relaxing the logical constraints, do not
allow any explanation or automated revision service.
Finally, it should be pointed out that matching in DLs, widely treated by Baader,
Kusters, Borgida, and Mc Guinness (1999) has no relation to matchmaking. In fact, in that
work expressions denoting concepts are considered, with variables in expressions. Then
a match is a substitution of variables with expressions that makes a concept expression
equivalent to another. Also the more general setting of concept rewriting in DLs has no
direct relation with matchmakingsee the discussion in Remark 1.

3. Description Logics Basics
In this Section we summarize the basic notions and denitions about Description Logics
(DLs), and about Classic, the knowledge representation system our application is inspired
by. We provide hereafter a brief guided-tour of DLs main characteristics, while the interested
reader can refer to the comprehensive handbook by Baader et al. (2003).
3.1 Description Logics
Description Logicsa.k.a. Terminological Logicsare a family of logic formalisms for Knowledge Representation. All DLs are endowed of a syntax, and a semantics, which is usually
model-theoretic. The basic syntax elements of DLs are:
 concept names, e.g., Computer, CPU, Device, Software,
 role names, like hasSoftware, hasDevice
 individuals, that are used for special named elements belonging to concepts.
Intuitively, concepts stand for sets of objects, and roles link objects in dierent concepts,
as the role hasSoftware that links computers to software. We are not using individuals in
our formalization, hence from now on we skip the parts regarding individuals.
Formally, a semantic interpretation is a pair I = (, I ), which consists of the domain
 and the interpretation function I , which maps every concept to a subset of , and every
role to a subset of   .
Basic elements can be combined using constructors to form concept and role expressions,
and each DL has its distinguished set of constructors. Every DL allows one to form a
conjunction of concepts, usually denoted as ; some DL include also disjunction  and
complement  to close concept expressions under boolean operations.
Roles can be combined with concepts using
 existential role quantication:
e.g., Computer  hasSoftware.WordProcessor
which describes the set of computers whose software include a word processor, and
273

fiDi Noia, Di Sciascio & Donini

 universal role quantication
e.g., Server  hasCPU.Intel
which describes servers with only Intel processors on board.
Other constructs may involve counting, as
 number restrictions:
e.g., Computer  ( 1 hasCPU)
expresses computers with at most one CPU, and
e.g., Computer  ( 4 hasCPU)
describes computers equipped with at least four CPUs.
Many other constructs can be dened, increasing the expressive power of the DL, up to
n-ary relations (Calvanese, De Giacomo, & Lenzerini, 1998).
In what follows, we call atomic concepts the union of concept names, negated concept
names, and unqualied number restrictions. We dene length of a concept C as the number
of atomic concepts appearing in C. We denote the length of C as |C|. Observe that we
consider 	 and  to have zero length. We dene the Quantication Nesting (QN) of a
concept as the following positive integer: the QN of an atomic concept is 0, the QN of a
universal role quantication R.F is 1 plus the QN of F , and the QN of a conjunction
C1  C2 is the maximum between the QNs of conjoined concepts C1 and C2 .
Expressions are given a semantics by dening the interpretation function over each
construct. For example, concept conjunction is interpreted as set intersection: (C  D)I =
C I  DI , and also the other boolean connectives  and , when present, are given the usual
set-theoretic interpretation of union and complement. The interpretation of constructs
involving quantication on roles needs to make domain elements explicit: for example,
(R.C)I = {d1   | d2   : (d1 , d2 )  RI  d2  C I }
3.2 TBoxes
Concept expressions can be used in axiomsthat can be either inclusions (symbol: ), or
denitions (symbol: )which impose restrictions on possible interpretations according
to the knowledge elicited for a given domain. For example, we could impose that monitors
can be divided into CRT and LCD using the two inclusions: Monitor  LCDMonitor 
CRTMonitor and CRTMonitor  LCDMonitor. Or, that computers for a domestic use have
only one operating system as HomePC  ( 1 hasOS). Denitions are useful to give a
meaningful name to particular combinations, as in Server  Computer  ( 2 hasCPU).
Historically, sets of such axioms are called a TBox (Terminological Box). There are
several possible types of TBoxes. General TBoxes are made by General Concept Inclusions
(GCI) of the form C  D, where both C and Dem can be any concept of the DL. For
general TBoxes, the distinction between inclusions and denitions disappears, since any
denition C  D can be expressed by two GCIs C  D, D  C. On the contrary, in
simple TBoxesalso called schemas by Calvanese (1996), and by Buchheit, Donini, Nutt,
and Schaerf (1998)only a concept name can appear on the left-hand side (l.h.s.) of an
axiom, and a concept name can appear on the l.h.s. of at most one axiom. Schemas can be
274

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

cyclic or acyclic, where cyclicity refers to the dependency graph GT between concept names,
dened as follows: every concept name is a node in GT , and there is an arc from concept
name A to concept name B if A appears on the l.h.s. of an axiom, and B appears (at any
level) in the concept on the right-hand side. T is acyclic if GT is, and it is cyclic otherwise.
We call an acyclic schema a simple TBox (Baader et al., 2003, Ch.2). The depth of a simple
TBox T is the length of the longest path in GT . Only for simple TBoxes, unfolding has
been dened as the following process (see Appendix A for a denition): for every denition
A  C, replace A with C in every concept; for every inclusion A  C, replace A with A  C
in every concept. Clearly, such a process trasforms every concept into an equivalent one,
where the TBox can be forgotten. However, for some TBoxes, unfolding can yield concepts
of exponential size w.r.t. the initial concepts. When such an exponential blow-up does not
happen, we call the TBox bushy but not deep (Nebel, 1990).
The semantics of axioms is based on set containment and equality: an interpretation I
satises an inclusion C  D if C I  DI , and it satises a denition C  D when C I = DI .
A model of a TBox T is an interpretation satisfying all axioms of T .
Observe that we make a distinction between equivalence  (used in axioms) and equality
= symbols. We use equality to instantiate generic concept symbols with the concepts they
stand for, e.g., when we write ... where C = A  R.B... we mean that the concept
symbol C stands for the concept expression A  R.B in the text.
3.3 Reasoning Services
DL-based systems usually provide two basic reasoning services:
1. Concept Satisability: given a TBox T and a concept C, does there exist at least one
model of T assigning a non-empty extension to C? We abbreviate satisability of a
concept C w.r.t. a TBox T as C T .
2. Subsumption: given a TBox T and two concepts C and D, is C I always contained in
D I for every model Iof T ? We abbreviate subsumption between C and D w.r.t. T
as C T D.
Since C is satisable i C is not subsumed by , complexity lower bounds for satisability
carry over (for the complement class) to subsumption, and upper bounds for subsumption
carry over to satisability. On the other hand, since C is subsumed by D i C  D is
unsatisable, subsumption is reducible to satisability in DLs admitting general concept
negation, but not in those DLs in which D is outside the languageas in the DLs of the
next Section.
3.4 The System Classic
The system Classic (Borgida, Brachman, McGuinness, & A. Resnick, 1989; Borgida &
Patel-Schneider, 1994) has been originally developed as a general Knowledge Representation
system, and has been successfully applied to conguration (Wright, Weixelbaum, Vesonder,
Brown, Palmer, Berman, & Moore, 1993) and program repositories management (Devambu,
Brachman, Selfridge, & Ballard, 1991).
Its language has been designed to be as expressive as possible while still admitting
polynomial-time inferences for bushy but not deep TBoxes. So it provides intersection of
275

fiDi Noia, Di Sciascio & Donini

name
top
bottom
intersection
universal
quantication
number
restrictions

concrete syntax
TOP
(and C D)

syntax
	

C D

semantics
I

I
C  DI

(all R C)

R.C

{d1 | d2 : (d1 , d2 )  RI  d2  C I }

(at-least n R)
(at-most n R)

( n R)
( n R)

{d1 | {d2 | (d1 , d2 )  RI }  n}
{d1 | {d2 | (d1 , d2 )  RI }  n}

Table 1: Syntax and semantics of some constructs of Classic
name
denition
inclusion
disjoint
group

system notation
(createConcept A C false)
(createConcept A C true)
(createConcept A1 C symbol)
...
(createConcept Ak C symbol)

syntax
AC
AC
disj(A1 , . . . ,Ak )

semantics
AI = C I
AI  C I
for i = 1, . . . , k AIi  C I
and for j = i + 1, . . . , k
AIi  AIj = 

Table 2: Syntax and semantics of the TBox Classic assertions (symbol is a name denoting
the group of disjoint concepts)

concepts but no union, universal but not existential quantication over roles, and number
restrictions over roles but no intersection of roles, since each of these combinations is known
to make reasoning np-hard (Donini, Lenzerini, Nardi, & Nutt, 1991; Donini, 2003).
For simplicity, we only consider a subset of the constructs, namely, conjunction, number
restrictions, and universal role quantications, summarized in Table 1. We abbreviate the
conjunction ( n R)  ( n R) as (= n R). We omit constructs ONE-OF(), FILLS(,)
that refer to individuals, and construct SAME-AS(,) equating llers in functional roles.
The subset of Classic we refer to is known as ALN (Attributive Language with unqualied
Number restrictions) (Donini, Lenzerini, Nardi, & Nutt, 1997b). When number restrictions
are not present, the resulting DL is known as AL (Schmidt-Schau & Smolka, 1991). ALN
provides a minimal set of constructs that allow one to represent a concept taxonomy, disjoint
groups, role restrictions (AL), and number restrictions (N ) to represent restriction son the
number of llers of a role.
Regarding axioms in a TBox, Classic allows one to state a simple TBox of assertions
of the form summarized in Table 2, where A, A1 , . . . ,Ak are all concept names. Axioms
in the TBox are subject to the constraints that every concept name can appear at most
once as the l.h.s. in a TBox, and every concept name cannot appear both on the l.h.s. of a
denition and in a disjointness assertion.
Every Classic concept can be given a normal form. Here we consider the normal form
only for the constructs of ALN that we used in the ontologies and applications. Intuitively,
the normal form pre-computes all implications of a concept, includingpossiblyits unsatisability. The normal form can be reached, up to commutativity of the operator ,
using well-known normalization rules, that we report in Appendix A to make the paper
276

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

self-contained. The normal form of an unsatisable concept is simply . Every satisable
concept C can be divided into three components: Cnames C Call . The component Cnames
is the conjunction of all concept names A1 , . . . ,Ah . The component C is the conjunction
of all number restrictions, no more than two for every role (the maximum at-least and the
minimum at-most for each role), including for every conjunct of C of the form R., the
number restriction ( 0 R) in C . The component Call conjoins all concepts of the form
R.D, one for each role R, where D is again in normal form. We call such form Conjunctive Normal FormCNF, in analogy with Propositional Logicand we observe that CNF
is unique (also said canonical), up to commutativity of conjunction.
Moreover, the TBox in Classic can be embedded into the concepts, by expanding
denitions, and adding the right-hand-side concepts of inclusions, and adding the negation
of disjoint concept namessee Appendix A for more details. For instance, suppose that a
TBox contains:
1. the denition Server  Computer  ( 2 hasCPU),
2. the inclusion Computer  ( 1 hasStorageDevice),
3. and the disjointness assertion disj(AMD, Intel).
Then, the concept ServerhasCPU.Intel can be rewritten into Computer( 2 hasCPU)
( 1 hasStorageDevice)hasCPU.(IntelAMD), which is equivalent to the former w.r.t.
models of the TBox. Observe that the concept name Computer is kept in the rewriting,
since the inclusion gives only a necessary condition ( 1 hasStorageDevice). The latter
concept can be safely conjoined to Computermaking the inclusion unnecessarybut cannot replace it since ( 1 hasStorageDevice) is not a sucient condition for Computer.
Instead, Computer  ( 2 hasCPU) replaces Server since it is a necessary and sucient
condition for it. The disjoint assertion generates Intel  AMD as the range for hasCPU..
Once this rewriting has been carried over all concepts, the TBox can be safely ignored when
computing subsumption (and satisability). In general, this unfolding may lead to an exponential blow-up of the TBox, making the entire computation (unfolding+subsumption) take
exponential time (and space) in the size of the initial concepts and TBox. Yet exponentialtime computation for subsumption is likely to be unavoidable, since even without rewriting,
taking the TBox into account makes subsumption np-hard (Nebel, 1990).
The normal form of concepts can take the TBox embedding into account (see Appendix A.2). In this case, the component Cnames of a Classic concept C contains concept
names Cnames+ and negations of concept names Cnames . In the following, we denote the
CNF of a concept C w.r.t. a simple TBox T as CNF (C, T ). Again, in general, the size
of CNF (C, T ) may be exponential w.r.t. the size of C and T . However, when T is xed,
CNF (C, T ) has polynomial-size w.r.t. the size of C i.e., the exponential increase comes only
from the TBox unfolding. In fact, if k is the maximum size of an unfolded concept name
(a constant if T is xed), the size of CNF (C, T ) can be at most k times the size of C. We
use this argument later in the paper, to decouple the complexity analysis of our reasoning
methods for matchmaking from the complexity raised by the TBox.
To ease presentation of what follows in the next Sections, we adopt a simple reference
ontology, pictured in Figure 1, which is used throughout the paper. To keep the representation within ALN , we modeled memory quantities with number restriction, e.g., 20GB as
277

fiDi Noia, Di Sciascio & Donini



CRTmonitor
LCDmonitor




Monitor 








=




DVDRecorder 





FloppyDisk
 StorageDevice 





HardDisk

Linux
Solaris
Windows2000
WindowsXp




















OperatingSystem 





Browser 




 Device

 Software

WordProcessor


PDA
PC

 Computer
=

Computer  ( 1 hasStorageDevice)  hasStorageDevice.StorageDevice 
hasSoftware.Software  ( 1 ram)
HomePC  PC  ( 1 hasSoftware) 
(= 1 hasOS)  ( 1 hasMonitor)  hasMonitor.Monitor
Server  Computer  ( 2 hasCPU) 
ram.( 512 mb)  hasStorageDevice.( 20000 mb)
Figure 1: Reference Ontology used for examples
( 20000 mb). For reasoners specialized for ALN , this is not a problem, since a number n
is never expanded as n llers (Borgida & Patel-Schneider, 1994; Donini et al., 1997b). For
more expressive DLs, Concrete Domains (Lutz, 1999) should be employed to represent such
quantities.

4. Semantic Matchmaking Using Description Logics
Matchmaking is a widely used term in a variety of frameworks, comprising severalquite
dierentapproaches. We begin this Section trying to provide a generic and sound denition of matchmaking.
Matchmaking is an information retrieval task whereby queries (a.k.a. demands) and resources (a.k.a. supplies) are expressed using semi-structured data
in the form of advertisements, and task results are ordered (ranked) lists of those
resources best fullling the query.
This simple denition implies thatdierently from classical unstructured-text Information
Retrieval systemssome structure in the advertisements is expected in a matchmaking
278

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

system, and matchmaking does not consider a xed database-oriented relational structure.
Furthermore, usually database systems provide answers to queries that do not include a
relevance ranking, which should be instead considered in a matchmaking process.
Semantic matchmaking is a matchmaking task whereby queries and resources
advertisements are expressed with reference to a shared specication of a conceptualization for the knowledge domain at hand, i.e., an ontology.
From now on, we concentrate on semantic matchmaking in marketplaces, adopting specic
terminology, to ease presentation of the approach. Nevertheless our approach applies to
generic matchmaking of semantically annotated resources.
We note that all denitions in this Section apply to every DL that can be used to
describe a marketplace (supplies, demands, background knowledge). We denote by L such
a generic DL. We suppose that a common ontology for supplies and demands is established,
as a TBox T in L. Now a match between a supply and a demand could be evaluated
according to T .
First of all, we remark that a logic-based representation of supplies and demands calls
for generally Open-world descriptions, that is, the absence of a characteristic in the description of a supply or demand should not be interpreted as a constraint of absence. Instead,
it should be considered as a characteristic that could be either rened later, or left open
if it is irrelevant for a user. Note that by generally open we mean that some specic
characteristic might be declared to be closed. However, such a closure should be made
piecewise, using some known declarative tool devised in Knowledge Representation for nonmonotonic reasoning, such as Defaults in DLs (Baader & Hollunder, 1992), Autoepistemic
DLs (Donini, Nardi, & Rosati, 1997a), Circumscription in DLs (Bonatti, Lutz, & Wolter,
2006) etc.
An analysis of recent literature allows to categorize the semantic matchmaking process
between a supply Sup and a demand Dem w.r.t. a TBox T in ve distinct classes:
 exact match: Sup T Dem, i.e., Sup T Dem and Dem T Sup, which amounts
to a perfect match, regardlessin a semantic based environmentof syntactic dierences, i.e., Sup and Dem are equivalent concepts (Di Sciascio et al., 2001; GonzalesCastillo et al., 2001).
 full match: Sup T Dem, which amounts to the demand being completely fullled
by the available supply, i.e., Sup has at least all features required by Dem, but not
necessarily vice versa, being the matchmaking process not symmetric (Di Noia et al.,
2003c); this kind of match is also named subsume match by Li and Horrocks (2003).
 plug-in match: Dem T Sup; it corresponds to demand Dem being sub-concept of
supply Sup,i.e., Dem is more specic than Sup (Sycara et al., 2002; Li & Horrocks,
2003).
 potential match: DemSup T , which corresponds to supply and demand having
something in common and no conicting characteristics (Di Noia et al., 2003c). This
relation is also named intersection-satisable by Li and Horrocks (2003).
279

fiDi Noia, Di Sciascio & Donini

 partial match: Dem  Sup T , which amounts to the presence of conict between
the demand and the available supply (Di Noia et al., 2003c). This relation is also
named disjoint by Li and Horrocks (2003)5 .
We stress that demands could be classied in the same way w.r.t. a given supply, when
its the suppliers turn to look into the marketplace to nd potential buyers. Hence, in the
rest of the paper we use the term oer denoted by the symbol Dto mean either a supply
Sup or a demand Dem, and the term counteroer denoted by Cto mean, respectively,
the demand Dem or the supply Sup that could match D.
Such a classication is still a coarse one, relying directly on known logical relations
between formulae. In fact, the result of matchmaking should be a rank of counteroers,
according to some criteriapossibly explicitso that a user trusting the system would
know whom to contact rst, and in case of failure, whom next, and so on. Such a ranking
process should satisfy some criteria that a Knowledge Representation approach suggests.
We formulate ranking requirements by referring to properties of penalty functions.
Definition 1 Given a DL L, two concepts C, D  L, and a TBox T in L, a penalty
function is a three-arguments function p(C, D, T ), that returns a null or positive integer.
We use penalty functions to rank counteroers C for a given demand (or supply) D w.r.t. a
TBox T . Intuitively, for two given counteroers C1 , C2 in the marketplace, if p(C1 , D, T ) <
p(C2 , D, T ) then the issuer of oer D should rank C1 better than C2 when deciding whom to
contact rst. Clearly, a 0-penalty should be ranked best, and counteroers with the same
penalties should be ranked breaking ties. The rst property we recall is Non-symmetric
evaluation of proposals.
Definition 2 A penalty function p(, , ) is non-symmetric if there exist concepts C, D and
a TBox T such that p(C, D, T ) = p(D, C, T ).
This property is evident when all constraints of D are fullled by C but not vice versa.
Hence, C should be among the top-ranked counteroers in the list of potential partners of
D, while D should not necessarily appear at the top in the list of potential partners of C.
So, a penalty function p(, , ) should not be expected to be a metric distance function.
Secondly, if logic is used to give some meaning to descriptions of supplies and demands,
then proposals with the same meaning should be equally penalized, independently of their
syntactic descriptions.
Definition 3 A penalty function p(, , ) is syntax independent if for every triple of concepts C1 , C2 , D, and TBox T , when T |= C1  C2 then p(C1 , D, T ) = p(C2 , D, T ), and the
same holds also for the second argument , i.e., p(D, C1 , T ) = p(D, C2 , T )
5. We note that preferring the term partial match instead of disjoint, we stress that the match may
still be recoverable, while disjoint is usually meant as a hopeless situation. Moreover, disjoint and
intersection satisable refer to the set-theoretic semantics of concepts in Description Logics, which
is quite hidden and far from the original problems of matchmaking. In a word, they are technologyoriented and not problem-oriented. For instance, if one used Propositional Logic, or Three-valued Logic
for modeling matchmaking, those terms would make no sense.

280

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

Clearly, when the logic admits a normal form of expressionsas CNF or DNF for propositional logic, or the normal form of concepts for DLs dened in the previous Sectionusing
such a normal form in the computation of p(, , ) ensures by itself syntax independence.
Penalties should enjoy some desirable properties w.r.t. subsumption. For reasons explained below, we divide penalty functions for ranking potential matches from those for
ranking partial (conicting) matches.
Definition 4 A penalty function for potential matches is monotonic over subsumption
whenever for every issued oer D, for every pair of counteroers C1 and C2 , and TBox T ,
if C1 and C2 are both potential matches for D w.r.t. T , and (C1 T C2 ), then p(C1 , D, T ) 
p(C2 , D, T )
Intuitively, the above denition could be read of as: if C1 T C2 then C1 should be penalized
(and then ranked) either the same, or better than C2 . In a phrase, A ranking of potential
matches is monotonic over subsumption if more specic means better. A dual property
could be stated for the second argument: if D1 T D2 then a counteroer C is less likely to
fulll all characteristics required by D1 than D2 . However, since our scenario is: given an
issuer of a proposal D looking for a match in the marketplace, rank all possible counteroers
C1 , C2 , . . . , from the best one to the worst, we do not deal here with this duality between
rst and second argument of p(, , ).
When turning to partial matches, in which some properties are already in conict between supply and demand, the picture reverses. Now, adding another characteristic to an
unsatisfactory proposal may only worsen this ranking (when another characteristic is violated) or keep it the same (when the new characteristic is not in conict). Note that this
ranking should be kept dierent from the ranking for potential matches. After all, accepting
to discard one or more characteristics that we required is much worse than deciding which
proposal try rst among some potential ones.
Definition 5 A penalty function for partial matches is antimonotonic over subsumption
whenever for every issued oer D, for every pair of counteroers C1 and C2 , and TBox T ,
if C1 and C2 are both partial matches for D w.r.t. T , and (C1 T C2 ), then p(C1 , D, T ) 
p(C2 , D, T )
Intuitively, if C1 T C2 then C1 should be penalized (and then ranked) either the same,
or worse than C2 . In other words, A ranking of partial matches is antimonotonic over
subsumption if more specic means worse. The same property should hold also for the
second argument, since concept conjunction is commutative.
When we need to distinguish between a penalty function for potential matches and one
for partial matches, we put a subscript  in the former (as p ) and a subscript  for the
latter (as in q ).
Clearly, the above requirements are very general, and leave ample room for the denition
of penalty functions. A more subtle requirement would be that penalties should not change
when irrelevant details are added, e.g., if a second-hand computer is requested in a demand
Dem, with no specication for the brand of the CPU, then a supply Sup should be penalized
the same as another oer Sup hasCPU.Intel. However, instead of delving into irrelevance
and other logic-related issues directly from penalties, we now borrow well-known logical
281

fiDi Noia, Di Sciascio & Donini

reasoning frameworks in propositional knowledge representation. Such a detour will give us
a sound and declarative way of dening penalties, dealing with irrelevance as a byproduct,
and more generally bring well-studied non-standard reasoning techniques into matchmaking.

5. Concept Abduction
Abduction (Peirce, 1955) is a well known form of commonsense reasoning, usually aimed at
nding an explanation for some given symptoms or manifestations. Here we introduce Concept Abduction in DLs, showing how it can model potential matchmaking in a DL setting.
Following the notation proposed by Eiter and Gottlob (1995), we recall that a Propositional
Abduction Problem is a triple H, M, T  where H (Hypotheses) and M (Manifestations)
are sets of literals, and T (Theory) is a set of formulae. A solution for H, M, T  is an Explanation E  H such that T  E is consistent, and T  E |= M . We adapt this framework
to DLs as follows.
Definition 6 Let L be a DL, C, D, be two concepts in L, and T be a set of axioms in
L, where both C and D are satisable in T . The Concept Abduction Problem (CAP) for
a given L, C, D, T , is nding, if possible, a concept H  L such that C  H T , and
C  H T D.
We use P as a symbol for a generic CAP, and we denote with SOL(P) the set of all
solutions to a CAP P. Observe that in the denition, we limit the inputs of a CAP to
satisable concepts C and D, since C unsatisable implies that the CAP has no solution
at all, while D unsatisable leads to counterintuitive results (e.g., C would be a solution
in that case). As Propositional Abduction extends implication, Concept Abduction extends concept subsumption. But dierently from propositional abduction, we do not make
any distinction between manifestations and hypotheses, which is usual when abduction is
used for diagnosis. In fact, when making hypotheses about e.g., properties of goods in
e-marketplaces, there is no point in making such a distinction. This uniformity implies that
there is always the trivial solution D to a non-trivial CAP L, C, D, T , as stated more
formally as follows.
Proposition 1 Let L be a DL, let C, D be concepts in L, and T an L-TBox. Then CD T
 if and only if D  SOL(L, C, D, T ).
Proof. If C  D is satisable in T , then D fullls both requirements of Def. 6, the rst
one by hypothesis and the second one because C  D T D is a tautology. On the other
hand, if D  SOL(L, C, D, T ) then C  D T  by denition.
A simple interpretation of this property in our application domain, i.e., matchmaking,
is that if we hypothesize for the counteroer C exactly all specications in D, then the
counteroer trivially meets given specicationsif it was compatible anyway. However, not
all solutions to a CAP are equivalent when using Concept Abduction for matchmaking. To
make a simple example, suppose that already C T D. Then, both H1 = D and H2 = 	
(among others) are solutions of L, C, D, T . Yet, the solution H2 = 	 tells the issuer of
D that C already meets all of Ds specications, while the solution H1 = D is the least
282

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

informative solution from this point of view. Hence, if we want to use abduction to highlight
most promising counteroers, minimal hypotheses must be dened.
Definition 7 Let P =L, C, D, T  be a CAP. The set SOL (P) is the subset of SOL(P)
whose concepts are maximal under T . The set SOL (P) is the subset of SOL(P) whose
concepts have minimum length.
Clearly, being maximal w.r.t. T is still a minimality criterion, since it means that no
unnecessary hypothesis is assumed. It can be proved that the two measures are incomparable.
Proposition 2 There exists a CAP P such that the two sets SOL (P) and SOL (P) are
incomparable.
Proof. It is sucient to consider D = A1  A2  A3 , C = A1 , and T = {B  A2  A3 }. The
logic is even propositional. Then A2  A3  SOL (L, C, D, T ), B  SOL (L, C, D, T ),
and neither solution is in the other set.
The proof highlights that, although -minimality could be preferable for conciseness, it
is heavily dependent on T . In fact, for every concept H  SOL(P), it is sucient to add the
axiom A  H to get a -minimal solution A. On the other hand, also T -maximality has
some drawbacks: if concept disjunction  is present in L, then there is a single T -maximal
solution of P, that is equivalent to the disjunction of all solutions in SOL(P)not a very
useful solution. Making an analogy with Abduction-based Diagnosis (Console, Dupre, &
Torasso, 1991), we could say that the disjunction of all possible explanations is not a very
informative explanation itselfalthough it is maximal w.r.t. implication. We note that
nding a -minimal solution is np-hard for a TBox of depth 1, by a simple reduction from
Set Covering (Colucci, Di Noia, Di Sciascio, Donini, & Mongiello, 2004).
Remark 1 It is interesting to analyze whether concept minimal-rewriting techniquesas
dened by Baader, Kusters, and Molitor (2000)could be employed for computing some
minimal concept abduction, trying to rewrite C  D. The answer is denitely negative for
minimal length abduction: the length-minimal solution B in the proof of Proposition 2
could not be obtained by rewriting C  D = A1  A1  A2  A3 . In fact, A1  B is not
an equivalent rewriting of the former concept. Regarding T -maximality the answer is
more indirect. In fact, present rewriting techniques do not keep a subconcept xed in the
rewriting process. So consider a CAP in which D = A1 , C = A2 , and T = {B  A1  A2 }.
The only equivalent minimal rewriting of C  D is then B, in which a solution cannot be
identied since B cannot be separated into a concept Cthe original oneand a concept
H that is a solution of the CAP. It is open whether future extensions of rewriting might
keep a concept xed, and cope with this problem.
A third minimality criterion is possible for DLs which admit CNF, as for L = ALN .
Definition 8 Let P =L, C, D, T  be a CAP in which L admits CNF, and assume that
concepts in SOL(P) are in CNF. The set SOL (P) is the subset of SOL(P) whose concepts
are minimal conjunctions, i.e., if C  SOL (P) then no sub-conjunction of C (at any level
of nesting) is in SOL(P). We call such solutions irreducible.
283

fiDi Noia, Di Sciascio & Donini

It turns out that -minimality includes both T -maximality and -minimality.
Proposition 3 For every CAP P in which L admits a CNF, both SOL (P) and SOL (P)
are included in SOL (P).
Proof. By contraposition, if a concept H is not -minimal then there is another concept
H  a sub-conjunction of Hwhich is an -minimal solution. But |H  | < |H|, hence H is
not length-minimal. The same for T -maximality: since every sub-conjunction of a concept
H in CNF subsumes H, if H is not -minimal it is not T -maximal either.
The proof of Proposition 2 can be modied to show that minimum-length abduced
concepts are not unique: it is sucient to add another axiom B   A2  A3 to obtain
another minimum-length solution B  . A less obvious result is that also subsumptionmaximal solutions are not unique, at least in non-simple TBoxes: Let P = L, C, D, T 
with T = {A2  A3  A1 }, C = A3 , D = A1 . Then both A1 and A2 are T -maximal
solutions.
5.1 Irreducible Solutions in ALN -simple TBoxes
We assume here that the TBox T of a CAP P = L, C, D, T  is always a simple one. Finding
an irreducible solution is easier than nding a -minimal or a T -maximal solution, since a
greedy approach can be used to minimize the set of conjuncts in the solution. For example,
starting from C  D, we could delete one redundant conjunct at a time (at any level of
role quantication nesting) from D, using |D| calls to a subsumption-check procedure.
However, such an algorithm would be interesting only for theoretical purposes. Instead, we
adapt a structural subsumption algorithm (Borgida & Patel-Schneider, 1994) that collects
all concepts H that should be conjoined to C in order for C  H to be subsumed by D.
The algorithm operates on concepts in CNF. In the following algorithm, we abbreviate the
fact that a concept A appears as a conjunct of a concept C with A  C (thus extending the
meaning of  to conjunctions of concepts).
Algorithm ndIrred (P);
input: a CAP P = L, C, D, T , with L =ALN , simple T , C and D in CNF w.r.t. T
output: concept H  SOL (P) (where H = 	 means that C  D)
variables: concept H
begin
H := 	;
0. if D  C T 
return ;
1. for every concept name A in D
1.1
if A  C
then H := H  A;
2. for every concept ( n R)  D
2.1
such that there is no concept ( m R)  C with m  n
H := H  ( n R);
3. for every concept ( n R)  D
284

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

such that there is no concept ( m R)  C with m  n
H := H  ( n R);
4. for every concept R.E  D
4.1
if there exists R.F  C
4.1.1
then H := H  R.ndIrred (ALN , F, E, T );
4.1.2
else H := H  R.E;
/* now H  SOL(P), but it might be reducible */
5. for every concept Hi  H
if H without Hi is in SOL(P)
then delete Hi from H;
6. return H;
end.
3.1

Theorem 1 Given a CAP P, if ndIrred (P) returns the concept H, with H  , then H
is an irreducible solution of P.
Proof. We rst prove that before Step 5, the computed concept H is in SOL(P), that is,
both C  H T  and C  H T D hold. In fact, observe that CNF (D, T )  H, since all
conjuncts of H come from some conjunct of CNF (D, T ). Hence, D T H since CNF (D, T )
is equivalent to D in the models of T . Adding C to both sides of the subsumption yields
C  D T C  H, and since we assume that C  D T , also C  H T . This proves the
rst condition for H  SOL(P). Regarding the condition C  H T D, suppose it does not
hold: then, at least one conjunct of CNF (D, T ) should not appear in CNF (C  H, T ). But
this is not possible by construction, since H contains every conjunct which is in CNF (D, T )
and not in CNF (C, T ). Therefore, we conclude that H  SOL(P). Once we proved that
the H computed before Step 5 is a solution of P, we just note that Step 5 deletes enough
conjuncts to make H an irreducible solution.
The rst part of algorithm (before Step 5) easily follows well-known structural subsumption algorithms (Borgida & Patel-Schneider, 1994). Step 5 applies a greedy approach, hence
the computed solution, although irreducible, might not be minimal.
We explain the need for the reducibility check in Step 5 with the help of the following
example.
Example 1 Let T = {A1  A2 , A3  A4 }, and let C = A3 , D = A1  A4 . Then L is the
propositional part of AL. The normal form for C is C  = A3  A4 , while D = A1  A2  A4 .
Then before Step 5 the algorithm computes H = A1  A2 , which must still be reduced to
A1 . It is worth noticing that H is already subsumption-maximal since H T A1 . However,
-minimality is a syntactic property, which requires removal of redundant conjuncts.
As for complexity, we aim at proving that nding an irreducible solution is not more
complex than subsumption in ALN . A polynomial algorithm (w.r.t. the sizes of C, D
and T ) cannot be expected anyway, since subsumption in AL (the sublanguage of ALN
without Number Restrictions) with a simple T is conp-hard (Nebel, 1990; Calvanese, 1996).
However, Nebel (1990) argues that the unfolding of the TBox is exponential in the depth of
285

fiDi Noia, Di Sciascio & Donini

the hierarchy T ; if the depth of T grows as O(log |T |) as the size of T increasesa bushy
but not deep TBoxthen its unfolding is polynomial, and so is the above algorithm.
More generally, suppose that T is xed: this is not an unrealistic hypothesis for our
marketplace application, since T represents the ontology of the domain, that we do not
expect to vary while supplies and demands enter and exit the marketplace. In that case, we
can analyze the complexity of ndIrred considering only C and D for the size of the input
of the problem.
Theorem 2 Let P = L, C, D, T  be a CAP, with L =ALN , and T a simple TBox. Then
nding an irreducible solution to P is a problem solvable in time polynomial in the size of
C and D.
We note that the problem of the exponential-size unfolding might be mitigated by Lazy
Unfolding (Horrocks & Tobies, 2000). Using this technique, concept names in the TBox are
unfolded only when needed.
5.2 Abduction-Based Ranking of Potential Matches
We dene a penalty function p for potential matches based on the following intuition: the
ranking of potential matches should depend on how many hypotheses have to be made on
counteroers in order to transform them into full matches.
Definition 9 Given a simple TBox T in ALN , we dene a penalty function for the potential match of a counteroer C given an oer D, where both C and D are concepts in
ALN , as follows:
.
p (C, D, T ) = |ndIrred (ALN , CNF (C, T ), CNF (D, T ), )|

(1)

Note that, when computing p , a concept H is actually computed by ndIrred as an
intermediate step. This makes it easy to devise an explanation facility, so that the actual
obtained ranking can be immediately enriched with its logical explanation; thus improving
users trust and interaction with the matchmaking system.
We now prove that p is in accordance with properties higlighted in the previous Section.
Since the computation of Formula (1) starts by putting concepts C, D in normal form, we
recall that the normal form of C can be summarized as Cnames  C  Call , and similarly for
D. Without ambiguity, we use the three components also as sets of the conjoined concepts.
Theorem 3 The penalty function p is (i) non-symmetric, (ii) syntax independent, and
(iii) monotonic over subsumption.
Proof.
(i) Non-symmetricity is easily proved by providing an example: p (A, 	, ) =
p (	, A, ). In fact, ndIrred (ALN , A, 	, ) nds H1 = 	 as a solution (A  	 without
further hypothesis) while ndIrred (ALN , 	, A, ) nds H2 = A. Recalling that |	| = 0,
while |A| = 1, we get the rst claim.
(ii) Syntax independence follows from the fact that normal forms are used in Formula (1),
and as already said normal forms are unique up to commutativity of conjunction.
286

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

(iii) Monotonicity over subsumption is proved by analyzing the conditions for subsumption in ALN . A concept C  is subsumed by a concept C whenever all conditions below
hold. For each condition, we analyze the changes in the behavior of ndIrred , proving that
the provided solution H just adds other conjuncts. Recall that monotonicity over subsumption is applied only to potential matches, hence we assume that both C and C  are
consistent with D. Since ndIrred is recursive, the proof is also by induction on the quantication nesting (QN) of C  . For C  having QN equal to 0, C  can only be a conjunction
of atomic conceptsnames, negated names, number restrictions. Then the conditions for
subsumption are the following:
 The rst condition is that Cnames+  C  names+ . Hence, in Step 1.1 of ndIrred , the
number of concept names that are added to H  with respect to names added to H
can only decrease, and so |H  |  |H| considering names. Regarding negated names,
observe that they do not contribute to the solution of ndIrred , since they come from
a disjointness axiom and a positive name (that contributes).
 The second condition is that for every number restriction in C , either the same
number restriction appears in C   , or it is strengthened (an at-least increases, an atmost decreases) in C   . Hence, number restrictions added by Steps 2.1 and 3.1 to H 
can be either as many as those added to H, or less. Again, also considering number
restrictions |H  |  |H|.
The above two cases prove the basis of the induction (C  with QN equal to 0). Suppose now
the claim holds for concepts C  with QN n or less, and let C  have a QN of n + 1. Clearly,
in this case C  has at least one universal role quanticationcall it R.F  . The condition
for subsumption between C  and C is the following:
 Either for every universal role quantication R.F in C over the same role R, it must
hold F  T F , or there is no universal role quantication on R in C. In the former
case, observe that ndIrred is recursively called6 in Step 4.1.1 with arguments F , E,
and F  , E; we call I and I  , respectively, the solutions returned by ndIrred . Observe
that the QN of F  is n or less, hence by inductive hypothesis |I  |  |I|. Since Step 4.1.1
adds R.I  and R.I to H  and H, again |H  |  |H|. If instead there is no universal
role quantication on R in C, Step 4.1.2 adds R.E to H. If also C  does not contain
any role quantication on R, then Step 4.1.2 adds R.E also to H  , then H  cannot
be longer than H in this case. If a role quantication R.F  is in C  , then Step 4.1.1
makes a recursive call with arguments F  , E. In this case, the solution returned I 
has length less than or equal to |E|, hence the length of H  cannot be longer than the
length of H also in this case.
In summary, if C  T C then in no case the length of H  increases with respect to the
length of H. This proves the monotonicity over subsumption of p .
Intuitively, we could say that monotonicity over subsumption for potential matches means
the more specic C is, the lower its penalty, the better its ranking w.r.t. D. More
6. findIrred is called only once, because concepts in CNF have at most one universal role quantication
over any role R.

287

fiDi Noia, Di Sciascio & Donini

preciselybut less intuitivelywe should say that the rank of C w.r.t. D cannot worsen
when C is made more specic. Hence, given an oer D, a TBox T , a sequence of increasingly specic counteroers C1 T C2 T C3 T    are assigned to a sequence of
non-increasing penalties p (C1 , D, T )  p (C2 , D, T )  p (C3 , D, T )  . . . We now prove
that such sequences are well-founded, with bottom element zero, reached in case of subsumption.
Proposition 4 p (C, D, T ) = 0 if and only if C T D.
Proof.
Recall from Section 3.1 that 	 and  are the only concepts of length zero, and
ndIrred returns  if and only if C and D are not in a potential match (Step 0 in ndIrred ).
Hence, p (C, D, T ) = 0 if and only if the concept whose length is computed in Formula (1)
is 	. By construction of ndIrred , 	 is returned by the call
ndIrred (ALN , CNF (C, T ), CNF (D, T ), ) if and only if CNF (C, T )  CNF (D, T ), which
holds (see Borgida & Patel-Schneider, 1994) if and only if C T D.
Moreover, we could also prove that adding to C details that are irrelevant for D leaves the
penalty unaected, while adding to C details that are relevant for D lowers Cs penalty.
Note also that in Formula (1) we take T into account in the normal form of C, D, but
then we forget itwe use an empty TBoxwhen calling ndIrred . We explain such a choice
with the aid of an example.
Example 2 Given T = {A  A1  A2 }, let D = A be a Demand with the two following
supplies: C1 = A2 , C2 = 	. Observe that CNF (D, T ) = A  A1  A2 , CNF (C1 , T ) =
A2 , CNF (C2 , T ) = 	. If we used the following formula to compute the penalty
.
p (C, D, T ) = |ndIrred (ALN , C, D, )|

(2)

and ran the algorithm ndIrred (ALN , C1 , D, T ) and ndIrred (ALN , C2 , D, T ), before
Step 5 we would get, respectively,
H1 = A1  A
H2 = A1  A2  A
and after Step 5 ndIrred would return H1 = H2 = A, hence C1 and C2 would receive
the same penalty. However, we argue that C1 is closer to D than C2 is, because it contains a characteristic (A2 ) implicitly required by D, while C2 does not. If instead we call
ndIrred (ALN , CNF (C1 , T ), CNF (D, T ), ) and
ndIrred (ALN , CNF (C2 , T ), CNF (D, T ), ), we get the solutions H1 and H2 aboveand
Step 5 does not delete any conjunct, since T = . Therefore, C1 gets penalty 2, while C2
gets penalty 3, highlighting what is more specied in C1 w.r.t. C2 .
More generally, we can say that the reducibility step (Step 5 in ndIrred ) attens a solution
to its most specic conjuncts, leaving to the TBox the implicit representation of other
characteristics, both the ones already present in the supply and those not present. Therefore,
making an empirical decision, we consider the TBox in the normal form of C and D, but
we exclude it from further reductions in Step 5 of ndIrred .
288

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

Remark 2 Although the denition of Concept Abduction could appear similar to Concept
Dierence, it is not so. We note that generically speaking, the name Concept Abduction
appeals to logic, while Concept Dierence appeals to algebra (although Dierence has
multiple solutions when L includes universal role quantication). More precisely, we recall
(Teege, 1994) that dierence is dened as: C  D = max {E  L : (E  D)  C} provided
that C  D. A more specialized denition of dierence (Brandt, Kusters, & Turhan, 2002)
refers only to DLs ALC and ALE. It is dened as: C  D = min {E  L : (E  D) 
(C  D)}where C, E  ALC, D  ALE, and minimality is w.r.t. a preorder  on a specic
normal form which extends CNF to ALC. No TBox is taken into account.
Instead, the solution of a CAP L, C, D, T  does not require that C T D, but only that
C  D T . In general, when D T C if we let H = D  C in a CAP P = L, C, D, T 
we get those solutions for which C  H  Dwhich obviously are not all solutions to P.
Hence D  C  SOL(P), but not vice versa (see the proof of Proposition 2 for an example).
When C T D this comparison is not even possible, since D  C is undened. However, in
a generic setting, e.g., in an e-commerce scenario, subsumption between demand and supply
is quite uncommon; most of oers are such that neither subsumes the other. Because of this
greater generality, for our specic application to matchmaking, Concept Abduction seems
more suited than Concept Dierence to make a basis for a penalty function.

6. Concept Contraction
If D  C is unsatisable in T , but the demander accepts to retract some of Ds constraints,
partially matching supplies may be reconsidered. However, other logic-based approaches
to matchmaking by Trastour et al. (2002), Sycara et al. (2002), Li and Horrocks (2003)
usually exclude the case in which the concept expressing a demand is inconsistent with the
concept expressing a supply, assuming that all requirements are strict ones. In contrast,
we believe that inconsistent matches can still be useful, especially in e-marketplaces. In
fact, partial (a.k.a. disjoint) matches can be the basis for a negotiation process, allowing
a user to specify negotiable requirementssome of which could be bargained in favor of
other. Such a negotiation process can be carried out in various ways adopting approaches
to matchmaking not based on logic (e.g., Strobel & Stolze, 2002), but also, as shown in
practice by Colucci et al. (2005), using Belief Revision. In fact, the logical formalization
of conicting matches, aimed at nding still interesting inconsistent matches without
having to revert to text-based or hybrid approaches, can be obtained exploiting denitions
typical of Belief Revision. In accordance with Gardenfors (1988) formalization, revision of
a knowledge base K with a new piece of knowledge A is a contraction operation, which


such that KA
|= A, followed by the addition of A
results in a new knowledge base KA

to KA usually modeled by conjunction. We call Concept Contraction our adaptation of
Belief Revision to DLs.
Starting with C  D unsatisable in a TBox T , we model with Concept Contraction
how, retracting requirements in C, we may still obtain a concept K (for Keep) such that
K  D is satisable in T . Clearly, a user is interested in what he/she must negotiate on to
start the transactiona concept G (for Give up) such that C  G  K.
289

fiDi Noia, Di Sciascio & Donini

For instance, with reference to the ontology in Figure 1, if a user demands Dem and a
supplier oers Sup, where Dem and Sup are described as follows:
Dem = HomePC  hasMonitor.LCDmonitor
Sup = HomePC  hasMonitor.CRTmonitor
it is possible to check that Sup  Dem is unsatisable. This is a partial match. Yet, in this
case, if the demander gives up the concept G = hasMonitor.LCDmonitor and keeps the
concept K = HomePC, K  Sup is satisable, hence K now potentially matches Sup.
More formally we model a Concept Contraction problem as follows.
Definition 10 (Concept Contraction) Let L be a DL, C, D, be two concepts in L, and
T be a set of axioms in L, where both C and D are satisable in T . A Concept Contraction
Problem (CCP), denoted as L, C, D, T , is nding a pair of concepts G, K  L  L such
that T |= C  GK, and K D is satisable in T . We call K a contraction of C according
to D and T .
We use Q as a symbol for a CCP, and we denote with SOLCCP (Q) the set of all
solutions to a CCP Q. Observe that as for concept abduction, we rule out cases where
either C or D are unsatisable, as they correspond to counterintuitive situations. We note
that there is always the trivial solution G, K = C, 	 to a CCP. This solution corresponds
to the most drastic contraction, that gives up everything of C. On the other hand, when
C  D is satisable in T , the best possible solution is 	, C, that is, give up nothing.
As Concept Abduction extends Subsumption, Concept Contraction extends satisability
in particular, satisability of a conjunction C  D. Hence, results about the complexity of
deciding Satisability of a given concept carry over to Contraction.
Proposition 5 Let L be a DL containing AL, and let Concept Satisability w.r.t. a TBox
in L be a problem C-hard for a complexity class C. Then deciding whether a given pair of
concepts G, K is a solution of a CCP Q =L, C, D, T  is C-hard.
Proof. A concept E  L is satisable w.r.t. a TBox T if and only if the CCP L, C, D, T 
has the solution 	, C, where C = R.E and D = R.	. Then, L should contain at least
universal role quantication (to express R.E), unqualied existential role quantication
(to express R.	), conjunction (to express that C  G  K) and at least the unsatisable
concept  (otherwise every concept is satisable, and the problem trivializes). The minimal, known DL containing all such constructs is the DL AL.
This gives a lower bound on the complexity of Concept Contraction, for all DLs that
include AL. For DLs not including AL, note that if the proof showing C-hardness of
satisability involves a concept with a topmost  symbol, the same proof could be adapted
for Concept Contraction.
Obviously, a user in a marketplace is likely to be willing to give up as few things as
possible, so some minimality in the contraction G must be dened. We skip for conciseness
the denitions of a minimal-length contraction and subsumption-maximal contraction, and
dene straightforwardly conjunction-minimal contraction for DLs that admit a normal form
made up of conjunctions.
290

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

Definition 11 Let Q =L, C, D, T  be a CCP in which L admits a CNF. The set SOLCCP (Q)
is the subset of SOLCCP (Q) with the following property: if G, K  SOLCCP (Q) then
for no sub-conjunction G of G it holds G , K  SOLCCP (Q). We call such solutions
irreducible.
6.1 Number-Restriction Minimal Contractions
In what follows we focus on a specic class of irreducible solutions for a CCP ALN , C, D, T 
exposing interesting characteristics from a user-oriented point of view in a matchmaking
scenario. Before dening such a class we explain the rationale behind its investigation using
the following example.
Example 3 Suppose we have the following situation:
demand Dem = HomePC  hasMonitor.LCDmonitor
supply Sup = Server  hasMonitor.CRTmonitor
As T |= Dem  Sup   the demander can contract Dem in order to regain the satisability
with Sup. Two solutions for the CCP Q = ALN , Dem, Sup, T  are:


 G

= HomePC
K = PC  ( 1 hasSoftware)  (= 1 hasOS)


 hasMonitor.LCDmonitor



G = hasMonitor.LCDmonitor
K = HomePC

In G , K  the demander should give up the specication on HomePC; in G , K  the
demander should give up only some specications on the monitor type while keeping the
rest.
Observe that both solutions are in the previously dened class SOLCCP (Q), but from
a user-oriented point of view, G , K  seems the most reasonable solution to Q. Giving
up the HomePC concept in Demand then ( 1 hasMonitor) because of the axiom on
HomePCthe demander keeps all the specications on requested components, but they are
vacuously true, since K  Sup implies hasMonitor. i.e., no component is admitted.
In order to make our intuition more precise, we introduce the number-restriction-minimal
solutions for Q, whose set we denote SOLCCPN (Q). Intuitively, a solution G, K for Q is
in SOLCCPN (Q) when an at-least restriction ( n R) is in G only if it directly conicts
with an at-most restriction ( m R) (with m < n) in D. Solutions in which the atleast restriction is given up because of conicting universal role quanticationse.g., R.A
and R.Aare not in SOLCCPN (Q). Since this characteristic of number-restrictionminimal solutions should be enforced at any level of nesting, we rst introduce the role
path of a concept in ALN . Here we need to distinguish between a concept A and its
(dierent) occurrences in another concept, e.g., B = A  R.A. In theory, we should mark
each occurrence with a number, e.g., A1  R.A2 ; however, since we need to focus on one
occurrence at a time, we just mark it as A.
291

fiDi Noia, Di Sciascio & Donini

Definition 12 Given a concept B in ALN , and an occurrence A of an atomic (sub)concept
A in B, a role path for A in B, A (B) is a string such that:
 A (A) = , where  denotes the empty string
 A (B1  B2 ) = A (Bi ), where Bi , i  {1, 2}, is the concept in which the occurrence
of A appears
 A (R.B) = R  A (B), where  denotes string concatenation
The role path A (B) represents the role nesting of a concept A occurrence into a concept
B. Note that A (B) is the same for any commutation of conjunctions in B, and for any
rearrangement of universal role quanticationsif A was not atomic, this would not be
true7 . Using the previous denition we can now dene SOLCCPN (Q).
Definition 13 Let Q = ALN , C, D, T  be a CCP. The set SOLCCPN (Q) is the subset
of solutions G, K in SOLCCP (Q) such that if ( n R) occurs in G then there exists
( m R), with m < n, occurring in CNF (D, T ) and ( n R) (G) = ( m R) (CNF (D, T )).
We now illustrate an algorithm ndContract that returns a solution G, K  SOLCCPN (Q)
for Q = ALN , CNF (C, T ), CNF (D, T ), , that is, it compares two ALN -concepts C, and
D, both already in CNF w.r.t. a TBox T , and computes a number-restriction minimal contraction G, K of C w.r.t. D without considering the TBox.
Algorithm ndContract (C, D);
input ALN concepts C, D, both already in CNF
output number-restriction minimal contraction G, K,
where G, K = 	, C means that C  D is satisable
variables concepts G, K, G , K 
begin
1. if C = 
then return , 	; /* see comment 1 */
2. G := 	; K := 	  C; /* see comment 2 */
3. for each concept name A  Knames+
if there exists a concept A  Dnames
then G := G  A; delete A from K;
4. for each concept ( x R)  K
such that there is a concept ( y R)  D with y < x
G := G  ( x R); delete ( x R) from K;
5. for each concept ( x R)  K
such that there is a concept ( y R)  D with y > x
G := G  ( x R); delete ( x R) from K;
6. for each concept R.F  Kall
if there exist R.E  Dall and (
either ( x R)  K with x  1
7. For readers that are familiar with the concept-centered normal form of concepts (Baader et al., 2003),
we note that A (B) is a word for UA in the concept-centered normal form of B.

292

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

or ( x R)  D with x  1 )
then let G , K   be the result of ndContract (F, E) in
G := G  R.G ;
replace R.F in K with R.K  ;
7. return G, K;
end.
Let us comment on the algorithm:
1. the case in Step 1 cannot occur at the top level, since we assumed C and D be satisable in the denition of CCP. However,  may occur inside a universal quantication
e.g., C = R.hence, the case of Step 1 may apply in a recursive call of ndContract ,
issued from Step 6 of an outer call.
2. in Step 2, the conjunction 	  C is assigned to K in order to leave 	 in K if every
other concept is removed by the subsequent steps.
We denote by G , K  solutions for the CCP Q = ALN , CNF (C, T ), CNF (D, T ), . In
this simplied CCP Q , we completely unfold T in both C and D and then forget it.
Theorem 4 The pair G, K computed by ndContract (C, D) is a number-restrictionminimal contraction for Q = ALN , CNF (C, T ), CNF (D, T ), .
Proof.
We rst prove that G, K is a solution for Q , namely, that (i) G  K  C,
and that (ii) K  D is satisable. We prove (i) by induction. For the base cases, observe
that the claim is true in Step 2 by construction, and that in Steps 35 when a conjunct
is deleted from K, it is also added to G. Hence the claim holds when no recursive call is
made. For the inductive case, assume the claim holds for each recursive call in Step 6, that
is, G  K   F for every concept R.F  Kall . Let Gn , Kn be the values of variables G, K
before the execution of Step 6, and let Kn be the concept Kn without R.F . Then, after
Step 6 it is:
G  K = (by assigment)


Gn  R.G  Kn  R.K   (by denition of )
Gn  Kn  R.(G  K  )  (by inductive hypothesis)
Gn  Kn  R.F  (by denition of Kn )
Gn  Kn  (since the base case holds before Step 6)
C
Regarding (ii), the proof is again by induction, where the inductive hypothesis is that
K   E is satisable. Basically, we construct an interpretation (, I ) with an element x
such that x  (K  D)I , and show that we can keep constructing I without contradictions,
since contradicting concepts have been deleted from K. In the inductive case, we assume
the existence of an interpretation ( , J ) for K   E such that y    (K   E)J , and then
ff


build a joint interpretation ( , I ) by letting  =   , I  = I  J  {x, y  RI }.
We now prove that G, K is a number-restriction-minimal solution for Q . The proof
is by induction on the Quantication Nesting (QN) of C, dened in Section 3.1. Observe
that an at-least restriction is deleted from K only in Step 4 of ndContract . For the base
caseQN (C) = 0, no recursive callobserve that the role path of a retracted concept
293

fiDi Noia, Di Sciascio & Donini

( n R) in G is , same as the role path of the concept ( m R) in D causing Step 4 to
be executed. Hence, the claim holds in the base case. For the inductive case, assume that
the claim holds for all concepts with QNs smaller than QN (C). Observe that the concept
F in Step 6 is such a concept, since its QN is smaller by at least 1. Hence, if an (occurrence
of an) at-least restriction ( x R), with role path ( x R) (F ) is deleted in F , there exists
a conicting at-most restriction in E with the same role path. Since both F and E occur
inside the scope of a concept R.F , R.E respectively, the claim still holds with role path
( x R) (C) = R  ( x R) (F ).

6.2 Contraction-Based Ranking of Partial Matches
We now dene a penalty function p for partial matches based on the following intuition:
the partial matches should be ranked based on how many characteristics should be retracted
from each C to make them potential matches.
Algorithm penaltyPartial (C, D);
input ALN concepts C, D, both already in CNF
output a penalty for the partial match between C and D
where zero means that C  D is satisable
variables integer n
begin
1. if C = 
then return |D|; /* see Comment 1 */
2. n = 0;
3. for each concept name A  Cnames+
if there exists a concept A  Dnames
then n := n + 1;
4. for each concept ( x R)  C
such that there is a concept ( y R)  D with y < x
n := n + 1;
5. for each concept ( x R)  C
such that there is a concept ( y R)  D with y > x
n := n + 1;
6. for each concept R.F  Call
if there exist R.E  Dall and (
either (( x R)  C and ( y R)  D with x  y) /* see Comment 2 */
or ( x R)  D with x  1 )
then n := n + penaltyPartial (F, E);
7. return n;
end.
The above algorithm has a structure very similar to ndContract : whenever ndContract
removes concepts from K, penaltyPartial adds penalties to n. The two dierences are
explained in the following comments:
294

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

1. Step 1 adds the whole length of D when C = . This addition ensures antimonotonicity in the presence of , as explained in Example 4 below.
2. Step 6 has in penaltyPartial the additional condition and ( y R)  D with x  y.
This condition is necessary because penaltyPartial does not actually remove concepts,
but just counts them. If an at-least restriction in C is in contrast with an at-most
restriction in D , then ndContract removes it from K, while penaltyPartial just adds
1 to n. Yet, when the condition in Step 6 is evaluated, ndContract nds it false just
because the at-least restriction has been removed, while penaltyPartial would nd it
true, were it not for the additional condition.
We now use the outcome of penaltyPartial to dene a penalty function for partial matches.
Definition 14 Given a simple TBox T in ALN , let the penalty function p for the partial
match of a counteroer C given an oer D, where both C and D are concepts in ALN , be
as follows.
.
(3)
p (C, D, T ) = penaltyPartial (CNF (C, T ), CNF (D, T ))
Note that since penaltyPartial closely follows ndContract and ndIrred , in fact Formula (3)
is more similar to Formula (1) in Denition 9 than it might appear. Implicitly, we solve
Q = ALN , CNF (C, T ), CNF (D, T ), , and then use the result in the computation of the
penalty function, with a main dierence in Step 1, though. We explain such a dierence
with the help of an example.
Example 4 Let Dem 1 and Dem 2 be two demands, where Dem 2 T Dem 1 , and let Sup be
a supply, all modeled using the ontology T in Figure 1 as in the following:
Dem 1 = PC  hasMonitor.CRTmonitor
Dem 2 = PC  hasMonitor.
Sup = HomePC  hasMonitor.LCDmonitor
Computing ndContract and penaltyPartial for both CNF (Dem 1 , T ) and CNF (Dem 2 , T )
w.r.t. CNF (Sup, T ) we obtain:
ndContract (CNF (Dem 1 , T ), CNF (Sup, T )) = hasMonitor.CRTmonitor,
PC  hasMonitor.Monitor
penaltyPartial (CNF (Dem 1 , T ), CNF (Sup, T )) = 1
ndContract (CNF (Dem 2 , T ), CNF (Sup, T )) = hasMonitor., PC
penaltyPartial (CNF (Dem 2 , T ), CNF (Sup, T )) = 3
In summary, the concept  conicts with every other concept, yet when a concept
R. is given up, its length is zero (or any other constant), hence the length of G cannot
be directly used as an antimonotonic penalty function. This explains the importance of
Step 1 in the above algorithm.
We can show the following formal correspondence between p and the Concept Contraction
dened in the previous Section.
295

fiDi Noia, Di Sciascio & Donini

Theorem 5 Let Q = ALN , C, D, T  be a CCP, and let G , K  the solution to Q returned by ndContract (CNF (C, T ), CNF (D, T )). If G does not contain any occurrence of
the concept , then
p (C, D, T ) = |G |
Proof. The function p is based on penaltyPartial , and by inspection, whenever penaltyPartial
increments n, ndContract adds an atomic concept to G . The only exception is in Step 1
of penaltyPartial , which adds |D| while ndContract adds  to G . However, this case is
explicitly outside the claim.
We now prove that p is in accordance with properties highlighted in the previous Section.
Theorem 6 The penalty function p is (i) non-symmetric, (ii) syntax independent, and
(iii) antimonotonic over subsumption.
Proof.
(i) Non-symmetry is proven by example: let C = ( 1 R)  R.A, D =
( 2 R)  R.A. For simplicity, T = , and observe that both C and D are already in
CNF. We now show that p (C, D, ) = p (D, C, ). In fact, in the former case, observe that
C must give up everything: the at-most restriction because it is in contrast with the at-least
restriction, and A inside universal quantication because it is in contrast with R.A in
D. Hence, penaltyPartial returns 2 = (1 from Step 5) + (1 from Step 1 of the recursive
call). Hence, p (C, D, ) = 2. In the latter case, instead, once the at-least restriction is
given up (and penaltyPartial adds 1 to n in Step 4), since role llers are no more imposed,
the universal quantication is now compatible (the condition of the if in Step 6 is false).
Hence p (D, C, ) = 1.
(ii) syntax independency is an immediate consequence of the fact that Formula (3)
uses normal forms for concepts. Since normal forms are unique up to commutativity of
conjunctionthat can be xed by imposing some order to conjunctions, e.g., lexicographic
the claim holds.
(iii) antimonotonicity can be proved by induction on the QN of a generic concept C 
subsumed by C; we go through all conditions for subsumption, analyzing the changes in
the behavior of the algorithm from C to C  . Recall that our goal is now to prove that
p (C  , D, T )  p (C, D, T ). In order to make a clear distinction between the two computations, we let n be the (instance of the) variable used in the call to penaltyPartial (C  , D),
while n is used in the call to penaltyPartial (C, D). To ease notation, we assume that C, C 
are already in CNF.
 First of all, it could be the case that C  = . In this case, n = |D| from Step 1 of
penaltyPartial . On the other hand, observe that penaltyPartial (C, D)  |D| because
either C =  too, or every increase in n corresponds to an atomic concept in Dby
inspection of Steps 35, and this recursively in Step 6. Therefore, the claim holds for
this base case.
 Cnames  C  names . For this case, it is obvious that Step 3 in penaltyPartial can only
make more increments to n w.r.t. n, since for C  the number of iterations of the for
each increases.
296

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

 for every number restriction in C , either the same number restriction appears in C   ,
or it is strengthened (an at-least increases, an at-most decreases) in C   . Note that
strengthening a number restriction in C  can only turn from false to true the condition
for the increment of n in Steps 45. For instance, passing from ( x R)  C to
( x R)  C   with x  x, if there is ( y R)  D then y < x implies y < x . A
similar argument holds for the at-most. Moreover, number restrictions that appear
only in C   can only increase the number of iterations of Steps 45, hence n can only
increase w.r.t. n and the claim holds.
The above three cases prove the basis of the induction (C  with QN equal to 0). We now
prove the case for universal role quantication, assuming that the claim holds for QNs less
than QN (C  ).
 for every R.F   C  all , either R is not universally quantied in Call , or there is
R.F  Call such that F  is subsumed by F (with F  = F as a special case of subsumption). Roles which are not universally quantied in Call but are quantied in C  all ,
can only increase the number of iterations of Step 6, hence n can only increase due to
their presence. For roles that have a more specic restriction F  , the inductive hypothesis is assumed to hold, since QN (F  ) < QN (C  ). Hence p (F  , E, T )  p (F, E, T ).
This is equivalent to penaltyPartial (F  , E)  penaltyPartial (F, E). Moreover, if the
condition in Step 6 is true in the call penaltyPartial (C, D), then it is also true in
 , and ( x R)  C  , hence if the recursive
penaltyPartial (C  , D), since R.F   Call

call penaltyPartial (F, E) is issued, then also penaltyPartial (F  , E) is issued, increasing
n at least as much as n is increased, by inductive hypothesis. Hence the claim holds
also in the inductive case.

7. The Matchmaking System
The DLs-based approach to semantic matchmaking illustrated in previous Sections has been
implemented in the ALN reasoning engine MaMaS (MatchMaking Service). It features all
classical inference services of a DL reasoner, but also implements algorithms for the nonstandard services for matchmaking presented in previous Sections.
MaMaS is a multi-user, multi-ontology Java servlet based system; it is available as an
HTTP service at: http://dee227.poliba.it:8080/MAMAS-tng/DIG, and exposes a DIG
1.18 compliant interface. The basic DIG 1.1 has been extended to cope with non standard
services, and we briey describe here such additions.
New elements:
 Match type detection: <matchType>E1 E2</matchType>- computes the match type
according to the following classication: Exact (equivalence), Full, Plug-in, Potential,
Partial.
8. DIG 1.1 is the new standardized DL systems interface developed by the Description Logic Implementation
Group (DIG) (Haarslev & Moller, 2003).

297

fiDi Noia, Di Sciascio & Donini

 Concept Abduction: <abduce>E1 E2</abduce> - implements ndIrred .
 Concept Contraction: <contract>E1 E2</contract>- implements ndContract .
 Ranking Score: <rank type="potential">E1 E2</rank>
<rank type="partial">E1 E2</rank>- computes p (C, D, T ) and p (C, D, T ) as
presented in previous Sections.
New attributes for <newKB/>
 shared: the only values to be used are true and false. In MaMaS, when a new
knowledge base is created, each KB uri is associated with the IP address of the client
host (owner) instantiating the KB. If the shared attribute is set to false, only the
owner is authorized to submit tells statements and change the KB as well as to submit
asks. In this case, requests from IP addresses dierent from the owners one can be
only asks. If the shared attribute is set to true, then no restriction is set on both
tells and asks statements. True is the default value.
 permanent: the only values to be used are true and false. In MaMaS, if a KB is
not used for more than 300 seconds, the KB is automatically released. If a user wants
to maintain the KB indenitely, the permanent attribute must be set to true; false
is the default value.
It should also be pointed out that MaMaS only supports simple-TBox, that is, concept
axioms have a concept name on the left side9 .
We have been using MaMaS as matching engine in various applications, including emarketplaces, (see e.g., Colucci, Di Noia, Di Sciascio, Donini, Ragone, & Rizzi, 2006;
Colucci et al., 2005) and semantic web services discovery (Ragone, Di Noia, Di Sciascio,
Donini, Colucci, & Colasuonno, 2007). We do not delve in details of such applications here,
and refer the interested reader to the cited references.
7.1 Experimental Evaluation
The hypothesis we seek to conrm in this Section is that our approach performs eectively
in a wide range of matchmaking scenarios, i.e., it is able to model commonsense human
behavior in analyzing and ranking, given a request, available oers. Hence the experimental
framework relies on comparison of system behavior versus the judgement of human users.
Furthermore, although our system may allow the use of weights to increase the relevance of
concepts, in the following results refer to the basic unweighted version of the system, to
avoid biasing of results due to weights introduction.
The scenarios we tested our approach on were three: apartments rental, date/partner
nding, skill management for recruiting agencies. Several ontology design methodologies
have been proposed (Jones, Bench-Capon, & Visser, 1998); we adopted the one proposed
by N.F. Noy and D.L. McGuinness (2001).
9. Notice that since MaMaS supports ALN , only atomic negation can be expressed and then <disjoint/>
groups must contain only concepts specialized by an <impliesc> axiom (sub-concept axiom). Dened
concepts <equalc/> (same-class) are not admitted in a disjoint group.

298

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

For all three scenarios we carried out a thorough domain analysis, starting with a large
set of advertisements taken from newspapers or from descriptions of on-line agencies, and
designed ontologies describing the domain. In particular:
 Apartments rental ontology is made up of 146 concepts (primitive + dened) and 33
roles.
 Date/partner matching ontology is made up of 131 concepts (primitive + dened)
and 29 roles.
 Skill matching ontology is made up of 308 concepts (primitive + dened) and 38 roles.
For each scenario we selected several announcements. The total number used in the experiments with human users is 180 (120 oers, 60 requests) for the apartments rental, 215
(140 oers, 75 requests) for the skill matching. 100 advertisements for the Date matching
scenario were also selected, yet for these we did not actually distinguish among requests
and oers as announcements were in the form of proles, although they included preferences
for dating partner. All announcements were in natural language and they were manually
translated in DL syntax. We then created, for each domain, 50 sets of questionnaires.
Questionnaires were in the form of one request (a demand or a supply) and 10 oering advertisements. Three groups of ten randomly selected volunteers, were then asked to order,
according to their judgement advertisements, with respect to the given requests. Having
obtained average users rankings, we run the same sets of advertisements with our system,
which gave us a set of system provided rankings. System rankings that included partial
matching advertisements were simply ordered below worst potential matching advertisement. We adopted, as reference, a standard Vector Space Model (VSM) (Salton & Gill,
1983) system. We used terms in our ontologies attening the ontology descriptions, as dimensions of three separate vector spaces, and determined weights using classical T F  IDF
measure. Similarity results were computed using the well-known Cosine similarity measure
(Salton & Gill, 1983).
To summarize results we adopted the Rnorm (Bollmann, Jochum, Reiner, Weissmann,
& Zuse, 1985) as quality measure of our system eectiveness. Rnorm is dened as follows.
Given Sup, a nite set of descriptions with a user-dened preference relation  that is
complete and transitive, let usr be the rank ordering of Sup induced by users preference
relation, and let sys be the system-provided ranking. Rnorm is then dened as:
Rnorm (sys ) =

S+  S
1
 (1 +
)
+
2
Smax

where S + is the number of descriptions pairs where a better description is ranked by the
system ahead of a worse one; S  is the number of pairs where a worse description is ranked
+
is the maximum possible number of S + . It should be noticed
ahead of a better one and Smax
+

that the calculation of S , S , and Smax is based on the ranking of descriptions pairs in
sys relative to the ranking of corresponding descriptions pairs in usr . Rnorm values are
in the range [0,1]; a value of 1 corresponds to a system-provided ordering of the available
descriptions that is either identical to the one provided by the human users or has a higher
degree of resolution, lower values correspond to a proportional disagreement between the
two. For the three scenarios considered, results are presented in table 3.
299

fiDi Noia, Di Sciascio & Donini

Domain
Apartments rental
Date/partner matching
Skill matching

MaMaS
0.87
0.79
0.91

VSM
0.48
0.41
0.46

Table 3: Rnorm values: MaMaS: Semantic matchmaking results, VSM: Vector Space Model
results

Although they present a variability, which we believe is partly due to the ability to
capture the domain in the ontologies design, they show that our approach provides rankings
that are close to human commonsense behavior and are far better than those obtained with
unstructured text retrieval tools.

8. Conclusion
We have addressed the matchmaking problem between descriptions from a DL perspective.
We have analyzed semantic-based matchmaking process and devised general commonsense
properties a matchmaker should have. We have also pointed out that classical inference
services of DLs, such as satisability and subsumption, are needed and useful, but may be
not sucient to cope with challenges posed by matchmaking in an open environment.
Motivated by this we have studied Concept Abduction and Contraction as novel nonmonotonic inferences in DLs suitable for modeling semantic-based matchmaking scenarios.
We analyzed minimality criteria, and proved simple complexity results. We also presented
reasonable algorithms for classifying and ranking matches based on the devised inferences
in terms of penalty functions, and proved that they obey to properties individuated.
Although several other measures may be determined to compute a score for most
promising matches our proposal has logical foundations and we have empyrically shown it
is able to well simulate commonsense human reasoning. Obviously, as any other semanticbased approach, also our own has to rely on well-designed ontologies able to model the
application domain being considered.
Based on the theoretical work we have implemented a fully functional matchmaking
facilitator, oriented to both generic e-marketplace advertisements and to semantic-based
web-service discovery, which exploits state of art technologies and protocols, and it is, to
the best of our knowledge, the only running system able to cope with Concept Abduction
and Concept Contraction problems.
With specic reference to earlier work of the authors on the subject, Di Sciascio et al.
(2001) dened matchmaking as satisability of concept conjunction. Denitions of potential
match and near-miss i.e., partial match, in terms of abduction and belief-revision were outlined, and the need for ranking of matches motivated, in the work of Di Sciascio, Donini, and
Mongiello (2002). Di Noia et al. (2003b, 2003c) proposed a semantic-based categorization of
matches, logic-based ranking of matches within categories, and properties ranking functions
should have, in the framework of E-marketplaces. An extended and revised version of such
works is in (Di Noia, Di Sciascio, Donini, & Mongiello, 2004). Di Noia et al. (2003a) intro300

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

duced Concept Abduction in DLs and presented algorithms to solve a Concept Abduction
Problem in ALN . Colucci et al. (2003) proposed both Concept Abduction and Concept
Contraction as inferences suitable for semantic-matchmaking and explanation services. Cal
et al. (2004) proposed a basic approach adopting penalty functions ranking, in the framework of dating systems. Colucci et al. (2004) proposed initial results and algorithms based
on truth-prexed tableau to solve Concept Abduction and Contraction problems in ALN .
Colucci et al. (2005) showed that such services can be usefully adopted both for semanticmatchmaking and for nding negotiation spaces in an E-Commerce setting. The use of the
proposed inference services for renement purposes in the semantic-matchmaking process
has been outlined in the work of Colucci et al. (2006).
Our current research is oriented to the investigation of algorithms for more expressive
DLs and the development of a tableaux-based system for the proposed inference services.

Acknowledgments
We are grateful to the anonymous reviewers for comments and suggestions that improved the
quality of this paper. We thank Andrea Cal and Diego Calvanese for useful discussions, and
in particular for suggesting the term penalty function. Simona Colucci, Azzurra Ragone,
Marina Mongiello and all the people at SisInfLab gave us invaluable help and suggestions.
This research has been supported by EU FP-6 IST STREP TOWL co. 026896.

Appendix A. Rules for Normal Form
The normal form of a concept can be obtained by repeatedly applying the rules of the two
following Sections, until no rule is applicable at any level of nesting of concepts inside R.C.
A.1 Rules Involving Subconcepts
In the following rules, the  symbol on the l.h.s. should be considered as an associative and
commutative operator; hence, for instance, when writing ( n R)  ( m R) in the second
rule, this should be read as the concepts ( n R) and ( m R) appear in any order inside
a conjunction of two or more concepts.

C   
( n R)  ( m R)   if n > m
A  A  
( n R)  ( m R)  ( n R) if n > m
( n R)  ( m R)  ( n R) if n < m
R.D1  R.D2  R.(D1  D2 )
R.  R.  ( 0 R)
301

fiDi Noia, Di Sciascio & Donini

A.2 Rules Involving the Concept and the TBox

A  A  C if A  C  T
A  C if A  C  T
A  A  B1      Bk if disj (A, B1 , . . . , Bk )  T
Usually the concept resulting from the application of the above rules is referred to as an
expansion, or unfolding of a TBox.
A.3 Properties of the Normal Form
Let C be a concept in Classic, and let C  be any concept obtained from C by repeatedly
appying the above rules. Let |C|, |C  | denote the size of C, C  respectively. It can be proved
(Borgida & Patel-Schneider, 1994) that:
1. if |C  | is polynomially bounded in |C|, then C  can be computed in time O(|C|2 );
2. every concept resulting from the application of the rules is equivalent to C, w.r.t.
models of the TBox.
As a consequence of the latter property, C is unsatisable i its normal form is . Then,
as a consequence of the former property, unsatisability can be decided in polynomial time
(Borgida & Patel-Schneider, 1994). The fact that |C  | is polynomially bounded in |C| has
been intuitively related by Nebel (1990) to the form of TBoxes, that should be bushy but
not deep. A more precise denition has been given by Colucci et al. (2004).

References
Agarwal, S., & Lamparter, S. (2005). smart - a semantic matchmaking portal for electronic
markets. In Proceedings of the 7th International IEEE Conference on E-Commerce
Technology 2005.
Arens, Y., Knoblock, C. A., & Shen, W. (1996). Query Reformulation for Dynamic Information Integration. Journal of Intelligent Information Systems, 6, 99130.
Baader, F., Calvanese, D., Mc Guinness, D., Nardi, D., & Patel-Schneider, P. (Eds.). (2003).
The Description Logic Handbook. Cambridge University Press.
Baader, F., & Hollunder, B. (1992). Computing extensions of terminological default theories.
In Proceedings of ECAI Workshop on Knowledge Representation and Reasoning, pp.
3052.
Baader, F., Kusters, R., Borgida, A., & Mc Guinness, D. (1999). Matching in Description
Logics. Journal of Logic and Computation, 9 (3), 411447.
Baader, F., Kusters, R., & Molitor, R. (2000). Rewriting concepts using terminologies.
In Proceedings of the Seventh International Conference on Principles of Knowledge
Representation and Reasoning (KR2000), pp. 297308.
302

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

Benatallah, B., Hacid, M.-S., Rey, C., & Toumani, F. (2003). Request Rewriting-Based Web
Service Discovery. In International Semantic Web Conference, Vol. 2870 of Lecture
Notes in Computer Science, pp. 242257. Springer.
Berners-Lee, T., Hendler, J., & Lassila, O. (2001). The semantic web. Scientic American,
248 (4), 3443.
Bollmann, P., Jochum, F., Reiner, U., Weissmann, V., & Zuse, H. (1985). The LIVEProject-Retrieval experiments based on evaluation viewpoints. In Proceedings of the
8th Annual International ACM/SIGIR Conference on Research and Development in
Information Retrieval, pp. 213214. ACM, New York.
Bonatti, P., Lutz, C., & Wolter, F. (2006). Description logics with circumscription. In
Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR2006), pp. 400410.
Borgida, A., Brachman, R. J., McGuinness, D. L., & A. Resnick, L. (1989). CLASSIC: A
Structural Data Model for Objects. In Proceedings of the ACM SIGMOD International
Conference on Management of Data, pp. 5967.
Borgida, A., & Patel-Schneider, P. F. (1994). A Semantics and Complete Algorithm for
Subsumption in the CLASSIC Description Logic. Journal of Articial Intelligence
Research, 1, 277308.
Brandt, S., Kusters, R., & Turhan, A. (2002). Approximation and dierence in description logics. In Proceedings of the Eight International Conference on Principles of
Knowledge Representation and Reasoning (KR2002), pp. 203214. MK.
Buchheit, M., Donini, F., Nutt, W., & Schaerf, A. (1998). A rened architecture for terminological systems: Terminology = schema + views. Articial Intelligence, 99 (2),
209260.
Cal, A., Calvanese, D., Colucci, S., Di Noia, T., & Donini, F. M. (2004). A description logic
based approach for matching user proles. In Proceedings of the 17th International
Workshop on Description Logics (DL04), Vol. 104 of CEUR Workshop Proceedings.
Calvanese, D. (1996). Reasoning with Inclusion Axioms in Description Logics. In Proceedings
of the Twelfth European Conference on Articial Intelligence (ECAI96), pp. 303307.
John Wiley & Sons.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1998). On the Decidability of Query
Containment under Constraints. In Proceedings of the Seventeenth ACM SIGACT
SIGMOD SIGART Symposium on Principles of Database Systems (PODS98), pp.
149158.
Colucci, S., Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2003). Concept Abduction and Contraction in Description Logics. In Proceedings of the 16th International
Workshop on Description Logics (DL03), Vol. 81 of CEUR Workshop Proceedings.
Colucci, S., Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2004). A Uniform
Tableaux-Based Approach to Concept Abduction and Contraction in ALN. In Proceedings of the 17th International Workshop on Description Logics (DL04), Vol. 104
of CEUR Workshop Proceedings.
303

fiDi Noia, Di Sciascio & Donini

Colucci, S., Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2005). Concept
Abduction and Contraction for Semantic-based Discovery of Matches and Negotiation
Spaces in an E-Marketplace. Electronic Commerce Research and Applications, 4 (4),
345361.
Colucci, S., Di Noia, T., Di Sciascio, E., Donini, F., Ragone, A., & Rizzi, R. (2006). A
semantic-based fully visual application for matchmaking and query renement in B2C
e-marketplaces. In 8th International conference on Electronic Commerce, ICEC 06,
pp. 174184. ACM Press.
Console, L., Dupre, D., & Torasso, P. (1991). On the Relationship between Abduction and
Deduction. Journal of Logic and Computation, 1 (5), 661690.
Devambu, P., Brachman, R. J., Selfridge, P. J., & Ballard, B. W. (1991). LASSIE: A
Knowledge-Based Software Information System. Communications of the ACM, 34 (5),
3649.
Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2003a). Abductive matchmaking
using description logics. In Proceedings of the Eighteenth International Joint Conference on Articial Intelligence (IJCAI 2003), pp. 337342.
Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2003b). Semantic matchmaking
in a P-2-P electronic marketplace. In Proc. Symposium on Applied Computing (SAC
03), pp. 582586. ACM.
Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2003c). A system for principled
Matchmaking in an electronic marketplace. In Proc. International World Wide Web
Conference (WWW 03), pp. 321330. ACM, New York.
Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2004). A system for principled Matchmaking in an electronic marketplace. International Journal of Electronic
Commerce, 8 (4), 937.
Di Sciascio, E., Donini, F., & Mongiello, M. (2002). Knowledge representation for matchmaking in P2P e-commerce. In Atti dellVIII Convegno dellAssociazione Italiana di
Intelligenza Articiale, Siena.
Di Sciascio, E., Donini, F., Mongiello, M., & Piscitelli, G. (2001). A Knowledge-Based System for Person-to-Person E-Commerce. In Proceedings of the KI-2001 Workshop on
Applications of Description Logics (ADL-2001), Vol. 44 of CEUR Workshop Proceedings.
Donini, F. M. (2003). Complexity of reasoning. In Description Logics Handbook, chap. 3.
Cambridge University Press.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1991). The Complexity of Concept Languages. In Allen, J., Fikes, R., & Sandewall, E. (Eds.), Proceedings of the
Second International Conference on the Principles of Knowledge Representation and
Reasoning (KR91), pp. 151162. Morgan Kaufmann, Los Altos.
Donini, F. M., Nardi, D., & Rosati, R. (1997a). Autoepistemic description logics. In Proc.
of IJCAI 97, pp. 136141.
304

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1997b). The complexity of concept
languages. Information and Computation, 134, 158.
Eiter, T., & Gottlob, G. (1995). The Complexity of Logic-Based Abduction. Journal of the
ACM, 42 (1), 342.
Finin, T., Fritzson, R., McKay, D., & McEntire, R. (1994). KQML as an Agent Communication Language. In Proceedings of the Third International Conference on Information
and Knowledge Management (CIKM94), pp. 456463. ACM.
Gardenfors, P. (1988). Knowledge in Flux: Modeling the Dynamics of Epistemic States.
Bradford Books, MIT Press, Cambridge, MA.
Gil, Y., & Ramachandran, S. (2001). PHOSPHORUS: a Task based Agent Matchmaker.
In Proc. International Conference on Autonomous Agents 01, pp. 110111. ACM.
Gonzales-Castillo, J., Trastour, D., & Bartolini, C. (2001). Description Logics for Matchmaking of Services. In Proceedings of the KI-2001 Workshop on Applications of Description Logics (ADL-2001), Vol. 44. CEUR Workshop Proceedings.
Grimm, S., Motik, B., & Preist, C. (2006). Matching Semantic Service Descriptions with
Local Closed-World Reasoning. In European Semantic Web Conference, pp. 575589.
Haarslev, V., & Moller, R. (2003). The dig description logic interface. In Proceedings of the
International Workshop on Description Logics (DL-2003), Vol. 81 of CEUR Workshop
Proceedings.
Horrocks, I., & Tobies, S. (2000). Reasoning with axioms: Theory and practice.. In Proceedings of the Seventh International Conference on Principles of Knowledge Representation and Reasoning (KR2000), pp. 285296.
Jacobs, N., & Shea, R. (1995). Carnot and Infosleuth  Database Technology and the Web.
In Proceedings of the ACM SIGMOD International Conference on Management of
Data, pp. 443444. ACM.
Jones, D., Bench-Capon, T., & Visser, P. (1998). Methodologies for ontology development.
In J. Cuena, editor, Proc. 15th IFIP World Computer Congress, pp. 6275, London,
UK. Chapman and Hall.
Karacapilidis, N., & Moraitis, P. (2001). Building an Agent-Mediated Electronic Commerce
System with Decision Analysis Features. Decision Support Systems, 32, 5369.
Kieling, W. (2002). Foundations of preferences in database systems. In Proceedings of the
Twentyeight International Conference on Very Large Data Bases (VLDB 2002).
Klusch, M., Fries, B., Khalid, M., & Sycara, K. (2005). Owls-mx: Hybrid owl-s service
matchmaking. In Proceedings of 1st Intl. AAAI Fall Symposium on Agents and the
Semantic Web.
Kuokka, D., & Harada, L. (1996). Integrating Information Via Matchmaking. Journal of
Intelligent Information Systems, 6, 261279.
Li, L., & Horrocks, I. (2003). A Software Framework for Matchmaking Based on Semantic
Web Technology. In Proc. International World Wide Web Conference (WWW 03),
pp. 331339. ACM, New York.
305

fiDi Noia, Di Sciascio & Donini

Lutz, C. (1999). Reasoning with concrete domains. In Dean, T. (Ed.), Proceedings of the
Sixteenth International Joint Conference on Articial Intelligence (IJCAI99), pp.
9095, Stockholm, Sweden. Morgan Kaufmann, Los Altos.
Madhavan, J., Bernstein, P., & Rahm, E. (2001). Generic schema matching with cupid. In
Proceedings of the Twentyseventh International Conference on Very Large Data Bases
(VLDB 2001), pp. 4958.
Maes, P., Guttman, R., & Moukas, A. (1999). Agents that Buy and Sell. Communications
of the ACM, 42 (3), 8191.
Motro, A. (1988). VAGUE: A User Interface to Relational Databases that Permits Vague
Queries. ACM Transactions on Oce Information Systems, 6 (3), 187214.
Nebel, B. (1990). Terminological Reasoning is Inherently Intractable. Articial Intelligence,
43, 235249.
N.F. Noy and D.L. McGuinness (2001). Ontology Development 101: A Guide to Creating
Your First Ontology. Stanford Knowledge Systems Laboratory Technical Report KSL01-05.
Paolucci, M., Kawamura, T., Payne, T., & Sycara, K. (2002). Semantic Matching of Web
Services Capabilities. In The Semantic Web - ISWC 2002, No. 2342 in Lecture Notes
in Computer Science, pp. 333347. Springer-Verlag.
Peirce, C. . (1955). Abduction and induction. In Philosophical Writings of Peirce, chap. 11.
J. Buchler.
Ragone, A., Di Noia, T., Di Sciascio, E., Donini, F., Colucci, S., & Colasuonno, F. (2007).
Fully Automated Web Services Discovery and Composition through Concept Covering
and Concept Abduction. International Journal of Web Services Research (JWSR),
4 (3).
Raman, R., Livny, M., & Solomon, M. (1998). Matchmaking: distributed resource management for high throughput computing. In Proceedings of IEEE High Performance
Distributed Computing Conf., pp. 140146.
Salton, G., & Gill, M. M. (1983). Introduction to Modern Information Retrieval. McGrawHill, New York.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive Concept Descriptions with Complements. Articial Intelligence, 48 (1), 126.
Shvaiko, P., & Euzenat, J. (2005). A survey of schema-based matching approaches. Journal
on Data Semantics, 4, 146171.
Strobel, M., & Stolze, M. (2002). A Matchmaking Component for the Discovery of Agreement and Negotiation Spaces in Electronic Markets. Group Decision and Negotiation,
11, 165181.
Sycara, K., Paolucci, M., Van Velsen, M., & Giampapa, J. (2003). The RETSINA MAS
infrastructure. Autonomous agents and multi-agent systems, 7, 2948.
Sycara, K., Wido, S., Klusch, M., & Lu, J. (2002). LARKS: Dynamic Matchmaking Among
Heterogeneus Software Agents in Cyberspace. Autonomous agents and multi-agent
systems, 5, 173203.
306

fiSemantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach

Teege, G. (1994). Making the dierence: A subtraction operation for description logics. In
Proceedings of the Fourth International Conference on the Principles of Knowledge
Representation and Reasoning (KR94), pp. 540550. MK.
Trastour, D., Bartolini, C., & Priest, C. (2002). Semantic Web Support for the Business-toBusiness E-Commerce Lifecycle. In Proc. International World Wide Web Conference
(WWW) 02, pp. 8998. ACM.
Veit, D., Muller, J., Schneider, M., & Fiehn, B. (2001). Matchmaking for Autonomous
Agents in Electronic Marketplaces. In Proc. International Conference on Autonomous
Agents 01, pp. 6566. ACM.
Wang, H., Liao, S., & Liao, L. (2002). Modeling Constraint-Based Negotiating Agents.
Decision Support Systems, 33, 201217.
Wright, J. R., Weixelbaum, E. S., Vesonder, G. T., Brown, K. E., Palmer, S. R., Berman,
J. I., & Moore, H. H. (1993). A Knowledge-Based Congurator that Supports Sales,
Engineering, and Manufacturing at AT&T Network Systems. AI Magazine, 14 (3),
6980.

307

fi