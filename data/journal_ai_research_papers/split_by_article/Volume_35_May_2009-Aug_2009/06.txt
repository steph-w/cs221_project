Journal of Artificial Intelligence Research 35 (2009) 623-675

Submitted 10/08; published 08/09

Compiling Uncertainty Away in Conformant Planning
Problems with Bounded Width
Hector Palacios

hlp@ldc.usb.ve

Universitat Pompeu Fabra
Roc Boronat, 138
08018 Barcelona, SPAIN

Hector Geffner

hector.geffner@upf.edu

ICREA & Universitat Pompeu Fabra
Roc Boronat, 138
08018 Barcelona, SPAIN

Abstract
Conformant planning is the problem of finding a sequence of actions for achieving a goal
in the presence of uncertainty in the initial state or action effects. The problem has been
approached as a path-finding problem in belief space where good belief representations and
heuristics are critical for scaling up. In this work, a different formulation is introduced for
conformant problems with deterministic actions where they are automatically converted
into classical ones and solved by an off-the-shelf classical planner. The translation maps
literals L and sets of assumptions t about the initial situation, into new literals KL/t that
represent that L must be true if t is initially true. We lay out a general translation scheme
that is sound and establish the conditions under which the translation is also complete. We
show that the complexity of the complete translation is exponential in a parameter of the
problem called the conformant width, which for most benchmarks is bounded. The planner
based on this translation exhibits good performance in comparison with existing planners,
and is the basis for T0 , the best performing planner in the Conformant Track of the 2006
International Planning Competition.

1. Introduction
Conformant planning is a form of planning where a goal is to be achieved when the initial
situation is not fully known and actions may have non-deterministic effects (Goldman &
Boddy, 1996; Smith & Weld, 1998). Conformant planning is computationally harder than
classical planning, as even under polynomial restrictions on plan length, plan verification
remains hard (Haslum & Jonsson, 1999; Baral, Kreinovich, & Trejo, 2000; Turner, 2002;
Rintanen, 2004). While few practical problems are purely conformant, the ability to find
conformant plans is needed in contingent planning where conformant situations are a special
case and where relaxations into conformant planning yield useful heuristics (Hoffmann &
Brafman, 2005).
The problem of conformant planning can be formulated as a path-finding problem in
belief space where a sequence of actions that map a given initial belief state into a target
belief is sought (Bonet & Geffner, 2000). A belief state represents the set of states that
are deemed possible, and actions, whether deterministic or not, map one belief state into
c
2009
AI Access Foundation. All rights reserved.

fiPalacios & Geffner

another. This formulation, that underlies most current conformant planners (Hoffmann &
Brafman, 2006; Bryce, Kambhampati, & Smith, 2006; Cimatti, Roveri, & Bertoli, 2004)
must address two problems: the problem of representing beliefs in a compact way, and the
problem of obtaining effective heuristics over beliefs. The first problem has been approached
through logical representations that make use of SAT or OBDD technology, that while
intractable in the worst case, scale up better than plain state representations. The second
problem, on the other hand, has been more complex, with heuristics for searching in belief
space not being as successful so far as the heuristics developed for classical planning (Bonet
& Geffner, 2001; Hoffmann & Nebel, 2001).
In this work, we introduce a different approach to conformant planning where problems
are automatically compiled into classical problems and solved by a classical planner. The
translation maps sets of literals t about the initial situation and literals L into new literals
KL/t that express that if t is true in the initial situation, L must be true. We lay out first a
general translation scheme that is sound and then establish the conditions under which the
translation is also complete. Also, we show that the complexity of the complete translation
is exponential in a parameter of the problem that we call the conformant width, which
for most benchmark domains is bounded, implying that the complete translation in those
cases is polynomial. The planner based on this translation exhibits good performance in
comparison with existing conformant planners and is the basis for T0 , the best performing
planner in the Conformant Track of the 2006 International Planning Competition.
The translation-based approach provides a solution to the two problems faced by conformant planners that search in belief space: the belief representation and the heuristic over
beliefs. In the translation-based approach, the beliefs are represented by the literals KL/t
that stand for conditionals, a representation that is polynomial and complete for conformant problems with bounded width. In addition, and since belief states are represented as
plain states, the heuristic over beliefs is a classical heuristic. From a computational point
of view, though, there is no explicit search in belief-space: conformant problems P are
converted into classical problems K(P ) at the knowledge-level (Petrick & Bacchus, 2002),
whose solutions, computed by a classical planner, encode the conformant solutions for P .
Our formulation is limited to conformant problems that are deterministic and where
all uncertainty lies in the initial situation. We address nonetheless the issues that must be
handled in order to generalize the translation-based approach to non-deterministic domains
and report empirical results over non-deterministic domains as well.
The paper is organized as follows. We define first the syntax and semantics of conformant
planning problems P (Section 2), and consider a simple sound but incomplete translation
K0 (Section 3). We then consider a more general translation scheme KT,M where T and
M are two parameters, a set of tags t encoding assumptions about the initial situation,
and a set of merges m encoding valid disjunctions of tags (Section 4), and analyze several
instances of this scheme that follow from particular choices of the sets of tags and merges:
a complete but exponential translation KS0 where tags are associated with the possible
initial states of the problem (Section 5), and a polynomial translation Ki for a fixed integer
i  0 that is complete for problems with conformant width bounded by i (Section 6).
We provide then an alternative explanation for this compact but complete translation by
showing that in problems with bounded width, the exponential number of possible initial
states S0 includes always a polynomial number of critical initial states S00 such that plans
624

fiCompiling Uncertainty Away in Conformant Planning Problems

that conform with S00 conform also with S0 (Section 7). We finally present the conformant
planner T0 (Section 8), an empirical evaluation of the planner (Section 9), an extension to
non-deterministic actions (Section 10), and a discussion of related work (Section 11). This
is followed by a brief summary (Section 12) and the formal proofs (Appendix).
This work is a revision and extension of the formulation presented by Palacios and
Geffner (2007), which in turn is based on ideas first sketched also by Palacios and Geffner
(2006).

2. The Conformant Problem P
We define next the syntax and semantics of the conformant planning problems considered.
2.1 Syntax
Conformant planning problems P are represented as tuples of the form P = hF, I, O, Gi
where F stands for the fluent symbols in the problem, I is a set of clauses over F defining
the initial situation, O stands for a set of (ground) operators or actions a, and G is a set of
literals over F defining the goal. Every action a has a precondition P re(a) given by a set
of fluent literals, and a set of conditional effects C  L where C is a set of fluent literals
and L is a fluent literal.
All actions are assumed to be deterministic and hence all uncertainty lies in the initial
situation. Thus, the language for the conformant problem P excluding the uncertainty in
the initial situation, is Strips extended with conditional effects and negation. Moreover, if
there is no uncertainty in the initial situation, as when all fluents appear in unit clauses in
I, P is equivalent to a classical planning problem.
We refer to the conditional effects C  L of an action a as the rules associated with
a, and sometimes write them as a : C  L. When convenient, we also join several effects
associated with the same action and condition as in a : C  L  L0 and write C  L as
true  L when C is empty. Finally, for a literal L, L denotes the complement of L.
2.2 Semantics
A state s is a truth assignment over the fluents F in P = hF, I, O, Gi and a possible initial
state s of P is a state that satisfies the clauses in I.
For a state s, we write I(s) to refer to the set of atoms (positive literals) that are true
in s, and write P/s to refer to the classical planning problem P/s = hF, I(s), O, Gi which
is like the conformant problem P except for the initial state that is fixed to s.
An action sequence  = {a0 , a1 , . . . , an } is a classical plan for P/s if the action sequence
 is executable in the state s and results in a goal state sG ; i.e., if for i = 0, . . . , n, the
preconditions of the action ai are true in si , si+1 is the state that results from doing action
ai in the state si , and all goal literals are true in sn+1 .
Finally, an action sequence  is a conformant plan for P iff  is a classical plan for P/s
for every possible initial state s of P .
Conformant planning is computationally harder than classical planning, as plan verification remains hard even under polynomial restrictions on plan length (Haslum & Jonsson,
1999; Baral et al., 2000; Turner, 2002; Rintanen, 2004). The most common approach to
625

fiPalacios & Geffner

conformant planning is based on the belief state formulation (Bonet & Geffner, 2000). A
belief state b is the non-empty set of states that are deemed possible in a given situation,
and every action a executable in b, maps b into a new belief state ba . The conformant
planning task becomes a path-finding problem in a graph where the nodes are belief states
b, the source node b0 is the belief state corresponding to the initial situation, and the target
belief states bG are those where the goals are true.
We assume throughout that I is logically consistent, so that the set of possible initial
states is not empty, and that P itself is consistent, so that the bodies C and C 0 of conflicting
effects a : C  L and a : C 0  L associated with the same action a are mutually exclusive
or mutex. For further details on this; see Part B of the Appendix.

3. A Basic Translation K0
A simple translation of the conformant problem P into a classical problem K(P ) can be
obtained by replacing the literals L by literals KL and KL aimed at capturing whether
L is known to be true and known to be false respectively.
Definition 1 (Translation K0 ). For a conformant planning problem P = hF, I, O, Gi, the
translation K0 (P ) = hF 0 , I 0 , O0 , G0 i is a classical planning problem with
 F 0 = {KL, KL | L  F }
 I 0 = {KL | L is a unit clause in I}
 G0 = {KL | L  G}
 O0 = O but with each precondition L for a  O replaced by KL, and each conditional
effect a : C  L replaced by a : KC  KL and a : KC  KL,
where the expressions KC and KC for C = L1 , L2 . . . are abbreviations of the formulas
KL1 , KL2 . . . and KL1 , KL2 . . . respectively.
The intuition behind the translation is simple: first, the literal KL is true in the initial
state I 0 if L is known to be true in I; otherwise it is false. This removes all uncertainty
from K0 (P ), making it into a classical planning problem. In addition, for soundness, each
rule a : C  L in P is mapped into two rules: a support rule a : KC  KL, that ensures
that L is known to be true when the condition is known to be true, and a cancellation
rule a : KC  KL that guarantees that KL is deleted (prevented to persist) when
action a is applied and C is not known to be false. The use of support and cancellation rules
for encoding the original rules at the knowledge-level is the only subtlety in the translation.
The translation K0 (P ) is sound as every classical plan that solves K0 (P ) is a conformant
plan for P , but is incomplete, as not all conformant plans for P are classical plans for K(P ).
The meaning of the KL literals follows a similar pattern: if a plan achieves KL in K0 (P ),
then the same plan achieves L with certainty in P , yet a plan may achieve L with certainty
in P without making the literal KL true in K0 (P ).1
Proposition 2 (Soundness of K0 (P )). If  is a classical plan for K0 (P ), then  is a
conformant plan for P .
1. Formal proofs can be found in the appendix.

626

fiCompiling Uncertainty Away in Conformant Planning Problems

As an illustration, consider the conformant problem P = hF, I, O, Gi with F = {p, q, r},
I = {q}, G = {p, r}, and actions O = {a, b} with effects
a : q  r , a : p  p , b : q  p .
For this problem, the action sequence  = {a, b} is a conformant plan for P while the action
sequence  0 = {a} is not. Indeed,  is a classical plan for P/s for any possible initial state
s, while  0 is not a classical plan for the possible initial state s0 where p is true (recall that
s is a possible initial state of P if s satisfies I so that neither p nor r are assumed to be
initially false in this problem).
From Definition 1, the translation K0 (P ) = hF 0 , I 0 , O0 , G0 i is a classical planning problem
with fluents F 0 = {Kp, Kp, Kq, Kq, Kr, Kr}, initial situation I 0 = {Kq}, goals G0 =
{Kp, Kr}, and actions O0 = {a, b} with effects
a : Kq  Kr , a : Kp  Kp , b : Kq  Kp,
that encode supports, and effects
a : Kq  Kr , a : Kp  Kp , b : Kq  Kp,
that encode cancellations.
Proposition 2 implies, for example, that  0 = {a}, which is not a conformant plan for
P , cannot be a classical plan for K(P ) either. This is easy to verify, as while the support
a : Kq  Kr achieves the goal Kr as Kq is true in I 0 , the cancellation a : Kp  Kp
associated with the same action, preserves Kp false for the other goal p.
While the translation K0 is not complete, meaning that it fails to capture all conformant plans for P as classical plans, its completeness can be assessed in terms of a weaker
semantics. In the so-called 0-approximation semantics (Baral & Son, 1997), belief states b
are represented by 3-valued states where fluents can be true, false, or unknown. In this incomplete belief representation, checking whether an action a is applicable in a belief state b,
computing the next belief state ba , and verifying polynomial length plans are all polynomial
time operations. In particular, a literal L is true it the next belief state ba iff a) action a
has some effect C  L such that all literals in C are true in b, or b) L is true in b and for all
effects C 0  L of action a, the complement of some literal L0  C 0 is true in b. An action
sequence  is then a conformant plan for P according to the 0-approximation semantics if
the belief sequence generated by  according to the 0-approximation semantics makes the
action sequence applicable and terminates in a belief state where the goals are true. It is
possible to prove then that:
Proposition 3 (K0 (P ) and 0-Approximation). An action sequence  is a classical plan for
K0 (P ) iff  is a conformant plan for P according to the 0-approximation semantics.
This correspondence is not surprising though as both the 0-approximation semantics
and the K0 (P ) translation throw away the disjunctive information and restrict the plans to
those that make no use of the uncertain knowledge. Indeed, the states s0 , s1 , . . . generated
by the action sequence  = {a0 , a1 , . . .} over the classical problem K0 (P ) encode precisely
627

fiPalacios & Geffner

the literals that are known to be true according to the 0-approximation; namely, L is true
at time i according to the 0-approximation iff the literal KL is true in the state si .
Proposition 3 does not mean that the basic translation K0 and the 0-approximation
semantics are equivalent but rather that they both rely on equivalent belief representations.
The translation K0 delivers also a way to get valid conformant plans using a classical
planner. The translation-based approach thus addresses both the representational and the
heuristic issues that arise in conformant planning.
As an illustration of Proposition 3, given a conformant problem P with I = {p, r} and
actions a and b with effects a : p  q, a : r  v, and b : q  v, the plan  = {a, b} is valid
for achieving the goal G = {q, v} according to both K0 (P ) and the 0-approximation, while
the plan  = {b} is not valid according to either. At the same time, if the initial situation
is changed to I = {p  q}, neither approach sanctions the plan  = {a} for G = {q}, even if
it is a valid conformant plan. For this, some ability to reason with disjunctions is needed.
An extension of the basic translation K0 that allows a limited form of disjunctive reasoning is presented by Palacios and Geffner (2006). The extension is based on the introduction
of new literals L/Xi used for encoding the conditionals Xi  L. Below, the basic translation
K0 is extended in a different manner that ensures both tractability and completeness over
a large class of problems.

4. General Translation Scheme KT,M
The basic translation K0 is extended now into a general translation scheme KT,M where T
and M are two parameters: a set of tags t and a set of merges m. We will show that for
suitable choices of these two parameters, the translation KT,M , unlike the translation K0 ,
can be both sound and complete.
A tag t  T is a set (conjunction) of literals L from P whose truth value in the initial
situation is not known. The tags t are used to introduce a new class of literals KL/t in
the classical problem KT,M (P ) that represent the conditional if t is true initially, then L is
true, an assertion that could be written as K(t0  L) in a temporal modal logic. We use
the notation KL/t rather than L/t as used by Palacios and Geffner (2006), because there
is a distinction between KL/t and KL/t: roughly KL/t means that the conditional
K(t0  L) is not true, while KL/t means that the conditional K(t0  L) is true.
Likewise, a merge m is a non-empty
W collection of tags t in T that stands for the Disjunctive Normal Form (DNF) formula tm t. A merge m is valid when one of the tags t  m
must be true in I; i.e., when
_
I |=
t .
tm

A merge m for a literal L in P will translate into a merge action with a single effect
^
KL/t  KL
tm

that captures a simple form of reasoning by cases.
While a valid merge can be used for reasoning about any literal L in P , computationally
it is convenient (although not logically necessary) to specify that certain merges are to be
used with some literals L and not with others. Thus, formally, M is a collection of pairs
628

fiCompiling Uncertainty Away in Conformant Planning Problems

(m, L), where m is a merge and L is a literal in P . Such a pair means that m is a merge for
L. We group all the merges m for a literal L in the set ML , and thus, M can be understood
as the collection of such sets ML for all L in P . For simplicity, however, except when it
may cause a confusion, we will keep referring to M as a plain set of merges.
We assume that the collection of tags T always includes a tag t that stands for the
empty collection of literals, that we call the empty tag and denote it as . If t is the empty
tag, we denote KL/t simply as KL.
The translation KT,M (P ) is the basic translation K0 (P ) conditioned with the tags t in
T and extended with the actions that capture the merges in M :
Definition 4 (Translation KT,M ). Let P = hF, I, O, Gi be a conformant problem, then
KT,M (P ) is the classical planning problem KT,M (P ) = hF 0 , I 0 , O0 , G0 i with
 F 0 = {KL/t, KL/t | L  F and t  T }
 I 0 = {KL/t | I, t |= L}
 G0 = {KL | L  G}
 O0 = {a V
: KC/t  KL/t, a : KC/t  KL/t | a : C  L in P } 
{am,L : [ tm KL/t]  KL  XL | L  P, m  ML }
where KL is a precondition of action a in KT,M (P ) if L is a precondition of a in P , KC/t
and KC/t stand for KL1 /t, KL2 /t,
V . . . , and KL1 /t, KL2 /t, . . . respectively, when
C = L1 , L2 , . . ., and XL stands for L0 KL0 with L0 ranging over the literals L0 mutex
with L in P .
The translation KT,M (P ) reduces to the basic translation
K0 (P ) when M is empty and
V
T contains only the empty tag. The extra effects XL = L0 KL0 in the merge actions am,L
are needed only to ensure that the translation KT,M (P ) is consistent when P is consistent,
and otherwise can be ignored. Indeed, if L and L0 are mutex in a consistent P , the invariant
KL/t  KL0 /t holds in KT,M (P ) for non-empty tags t, and hence a successful merge for
L can always be followed by a successful merge for L0 . In the rest of the paper we will
thus assume that both P and KT,M (P ) are consistent, and ignore such extra merge effects,
but we will come back to them in Appendix B for proving the consistency of KT,M (P ) from
the consistency of P .
For suitable choices of T and M , the translation KT,M (P ) will be sound and complete.
Before establishing these results, however, let us make these notions precise.
Definition 5 (Soundness). A translation KT,M (P ) is sound if for any classical plan  that
solves the classical planning problem KT,M (P ), the plan  0 that results from  by dropping
the merge actions is a conformant plan for P .
Definition 6 (Completeness). A translation KT,M (P ) is complete if for any conformant
plan  0 that solves the conformant problem P , there is a classical plan  that solves the
classical problem KT,M (P ) such that  0 is equal to  with the merge actions removed.
The general translation scheme KT,M is sound provided that all merges are valid and
all tags are consistent (literals in a tag are all true in some possible initial state):
629

fiPalacios & Geffner

Theorem 7 (Soundness KT,M (P )). The translation KT,M (P ) is sound provided that all
merges in M are valid and all tags in T are consistent.
Unless stated otherwise, we will assume that all merges are valid and all tags consistent,
and will call such translations, valid translations.
As a convention for keeping the notation simple, in singleton tags like t = {p}, the curly
brackets are often dropped. Thus, literals KL/t for t = {p} are written as KL/p, while
merges m = {t1 , t2 } for singleton tags t1 = {p} and t2 = {q}, are written as m = {p, q}.
Example. As an illustration, consider the problem of moving an object from an origin to a
destination using two actions: pick(l), that picks up an object from a location if the hand is
empty and the object is in that location, and drop(l), that drops the object at a location if
the object is being held. For making the problem more interesting, let us also assume that
the action pick(l) drops the object being held at l if the hand is not empty. These are all
conditional effects and there are no action preconditions. Assuming that there is a single
object, these effects can be written as:
pick(l) : hold, at(l)  hold  at(l)
pick(l) : hold  hold  at(l)
drop(l) : hold  hold  at(l) .
Consider now an instance P of this domain, where the hand is initially empty and the
object, initially at either l1 or l2 , must be moved to l3 ; i.e., P = hF, I, O, Gi with
I = {hold , at(l1 )  at(l2 ) , at(l1 )  at(l2 ) , at(l3 )}
and
G = {at(l3 )} .
The action sequence
1 = {pick(l1 ), drop(l3 ), pick(l2 ), drop(l3 )}
is a conformant plan for this problem, where an attempt to pick up the object at location
l1 is followed by a drop at the target location l3 , ensuring that the object ends up at l3 if
it was originally at l1 . This is then followed by an attempt to pick up the object at l2 and
a drop at l3 .
On the other hand, the action sequence 2 that results from 1 by removing the first
drop action
2 = {pick(l1 ), pick(l2 ), drop(l3 )}
is not a conformant plan, since if the object was originally at l1 , it would end up at l2 after
the action pick(l2 ). In the notation introduced above, 1 is a classical plan for the classical
problem P/s for the two possible initial states s, while 2 is a classical plan for the problem
P/s but only for the state s where the object is initially at l2 .
630

fiCompiling Uncertainty Away in Conformant Planning Problems

Consider now the classical problem KT,M (P ) = hF 0 , I 0 , O0 , G0 i that is obtained from P
when T = {at(l1 ), at(l2 )}2 and M contains the merge m = {at(l1 ), at(l2 )} for the literals
hold and at(l3 ). From its definition, the fluents F 0 in KT,M (P ) are of the form KL/t and
KL/t for L  {at(l), hold}, l  {l1 , l2 }, and t  T , while the initial situation I 0 is
I 0 = {Khold, Khold/at(l), Kat(l3 ), Kat(l3 )/at(l), Kat(l)/at(l), Kat(l0 )/at(l)}
for l, l0  {l1 , l2 } and l0 6= l, and the goal G0 is
G0 = {Kat(l3 )} .
The effects associated to the actions pick(l) and drop(l) in O0 are the support rules
pick(l) : Khold, Kat(l)  Khold  Kat(l)
pick(l) : Khold  Khold  Kat(l)
drop(l) : Khold  Khold  Kat(l)
for each one of the three locations l = li , that condition each rule in O with the empty tag,
along with the support rules:
pick(l) : Khold/at(l0 ), Kat(l)/at(l0 )  Khold/at(l0 )  Kat(l)/at(l0 )
pick(l) : Khold/at(l0 )  Khold/at(l0 )  Kat(l)/at(l0 )
drop(l) : Khold/at(l0 )  Khold/at(l0 )  Kat(l)/at(l0 )
that condition each rule in O with the tags at(l0 )  T , for l0  {l1 , l2 }. The corresponding
cancellation rules are:
pick(l) : Khold, Kat(l)  Khold  Kat(l)
pick(l) : Khold  Khold  Kat(l)
drop(l) : Khold  Khold  Kat(l)
and
pick(l) : Khold/at(l0 ), Kat(l)/at(l0 )  Khold/at(l0 )  Kat(l)/at(l0 )
pick(l) : Khold/at(l0 )  Khold/at(l0 )  Kat(l)/at(l0 )
drop(l) : Khold/at(l0 )  Khold/at(l0 )  Kat(l)/at(l0 ) .
In addition, the actions in O0 include the merge actions am,hold and am,at(l3 ) that follow
from the merge m = {at(l1 ), at(l2 )} in M for the literals hold and at(l3 ):
am,hold : Khold/at(l1 ), Khold/at(l2 )  Khold
am,at(l3 ) : Kat(l3 )/at(l1 ), Kat(l3 )/at(l2 )  Kat(l3 ) .
2. The empty tag is assumed in every T and thus it is not mentioned explicitly.

631

fiPalacios & Geffner

It can be shown then that the plan
10 = {pick(l1 ), drop(l3 ), pick(l2 ), drop(l3 ), am,at(l3 ) }
solves the classical problem KT,M (P ) and hence, from Theorem 7, that the plan 1 obtained
from 10 by dropping the merge action, is a valid conformant plan for P (shown above). We
can see how some of the literals in KT,M (P ) evolve as the actions in 10 are executed:
0:
1:
2:
3:
4:
5:

Kat(l1 )/at(l1 ), Kat(l2 )/at(l2 )
Khold/at(l1 ), Kat(l2 )/at(l2 )
Kat(l3 )/at(l1 ), Kat(l2 )/at(l2 )
Kat(l3 )/at(l1 ), Khold/at(l2 )
Kat(l3 )/at(l1 ), Kat(l3 )/at(l2 )
Kat(l3 )

true
true
true
true
true
true

in I 0
after
after
after
after
after

pick(l1 )
drop(l3 )
pick(l2 )
drop(l3 )
merge am,at(l3 ) .

We can also verify in the same manner that the action sequence 20
20 = {pick(l1 ), pick(l2 ), am,hold , drop(l3 )}
is not a classical plan for KT,M (P ), the reason being that the atom Khold/at(l1 ) holds after
the first pick up action but not after the second. This is due to the cancellation rule:
pick(l2 ) : Khold/at(l1 )  Khold/at(l1 )  Kat(l2 )/at(l1 )
that expresses that under the assumption at(l1 ) in the initial situation, hold and at(l2 )
are not known to be true after the action pick(l2 ), if under the same assumption, hold
was not known to be true before the action.

5. A Complete Translation: KS0
A complete instance of the translation scheme KT,M can be obtained in a simple manner
by setting the tags to the possible initial states of the problem P and by having a merge
for each precondition and goal literal L that includes all these tags. We call the resulting
exhaustive translation KS0 :
Definition 8 (Translation KS0 ). For a conformant problem P , the translation KS0 (P ) is
an instance of the translation KT,M (P ) where
 T is set to the union of the empty tag and the set S0 of all possible initial states of P
(understood as the maximal sets of literals that are consistent with I), and
 M is set to contain a single merge m = S0 for each precondition and goal literal L in
P.
The translation KS0 is valid and hence sound, and it is complete due the correspondence
between tags and possible initial states:
Theorem 9 (Completeness of KS0 ). If  is a conformant plan for P , then there is a
classical plan  0 for KS0 (P ) such that  is the result of dropping the merge actions from  0 .

632

fiCompiling Uncertainty Away in Conformant Planning Problems

#S0
Problem
adder-01
blocks-02
blocks-03
bomb-10-1
bomb-10-5
bomb-10-10
bomb-20-1
coins-08
coins-09
coins-10
coins-11
comm-08
comm-09
comm-10
corners-square-16
corners-square-24
corners-square-28
corners-square-116
corners-square-120
square-center-16
square-center-24
log-2-10-10
log-3-10-10
ring-5
ring-6
safe-50
safe-70
safe-100
sortnet-07
sortnet-08
sortnet-09
sortnet-10
uts-k-08
uts-k-10

18
18
231
1k
1k
1k
1M
1k
1k
1k
1M
512
1k
2k
4
4
4
4
4
256
576
1k
59k
1,2k
4,3k
50
70
100
256
512
1k
2k
16
20

KS0
time
len
> 2h
0,2
23
59,2
80
5,9
19
11,3
15
18,3
10
> 2.1GB
20,2
27
19,9
25
21,5
31
> 2.1GB
18,3
61
77,7
68
> 2.1GB
0,2
102
0,7
202
1,2
264
581,4 3652
> 2.1GB
13,1
102
> 2.1GB
183,5
85
> 2h
12,6
17
> 2.1GB
0,5
50
1,4
70
6
100
2,9
28
9,8
36
77,7
45
> 2.1GB
0,6
46
1,2
58

POND
time len
0,4
26
0,4
26
126,8 129
1
19
3
15
8
10
4139
39
2
28
5
26
5
28
> 2h
1
53
1
59
1
65
1131
67
> 2h
> 2h
> 2h
> 2h
1322
61
> 2h
> 2h
> 2h
6
20
33
27
9
50
41
70
> 2.1GB
480
25
> 2h
> 2h
> 2h
24
47
2219
67

CFF
time
len
> 2h
> 2h
> 2h
0
19
0
15
0
10
0
39
0
28
0
26
0,1
38
1
78
0
53
0
59
0
65
13,1
140
321
304
> 2h
> 2h
> 2h
> 2h
> 2h
1,6
83
4,7
108
4,3
31
93,6
48
29,4
50
109,9
70
1252,4 100
SNH
SNH
SNH
SNH
4,4
46
16,5
58

Table 1: KS0 translation fed into FF planner compared with POND and Conformant FF
(CFF) along both times and reported plan lengths. #S0 stands for number of
initial states, SNH means goal syntax not handled (by CFF). Times reported in
seconds and rounded to the closest decimal.

633

fiPalacios & Geffner

For problems P whose actions have no preconditions, the argument is simple: if  is
a conformant plan for P then  must be a classical plan for P/s for each possible initial
state s, but then if  achieves the (goal) literal Gi in P/s for each s,  must achieve the
literal KGi /s in KS0 (P ) for each s as well, so that  followed by the merge action for Gi ,
must achieve the literal KGi . In the presence of action preconditions, this argument must
be applied inductively on the plan length, but the idea remains the same (see the proof
in the appendix for details): a correspondence can be established between the evolution of
the fluents L in each problem P/s and the evolution of the fluents KL/s in the problem
KS0 (P ).
The significance of the exhaustive KS0 translation is not only theoretical. There are
plenty of conformant problems that are quite hard for current planners even if they involve
a handful of possible initial states. An example of this is the Square-Center-n task (Cimatti
et al., 2004), where an agent has to reach the center of an empty square grid with certainty,
not knowing its initial location. There are four actions that move the agent one unit in each
direction, except when in the border of the grid, where they have no effects. In the standard
version of the problem, the initial position is fully unknown resulting in n2 possible initial
states, yet the problem remains difficult, and actually beyond the reach of most planners,
for small values of n, even when the uncertainty is reduced to a pair of possible initial states.
The reason is that the agent must locate itself before heading for the goal. The domain
Corners-Square-n in Table 1 is a variation of Square-Center-n where the possible initial
states are the four corners of the grid.
Table 1 shows results for a conformant planner based on the KS0 (P ) translation that
uses FF (Hoffmann & Nebel, 2001) for solving the resulting classical problem, and compares
it with two of the planners that entered the Conformant track of the 2006 Int. Planning
Competition (Bonet & Givan, 2006): POND (Bryce et al., 2006) and Conformant FF
(Hoffmann & Brafman, 2006) (the other two planners in the competition were translationbased: T0 , based on the formulation developed in this paper, and K(P ), based on an earlier
and more restricted formulation due to Palacios & Geffner, 2006). Clearly, the approach
based on the KS0 (P ) translation does not scale up to problems with many possible initial
states, yet when the number of such states is small, it does quite well.

6. Complete Translations that May be Compact Too
In order to have complete translations that are polynomial, certain assumptions about the
formulas in the initial situation I need to be made. Otherwise, just checking whether a
goal is true in I is intractable by itself, and therefore a polynomial but complete translation
would be impossible (unless P = NP). We will thus assume that I is in prime implicate (PI)
form (Marquis, 2000), meaning that I includes only the inclusion-minimal clauses that it
entails but no tautologies. It is known that checking whether a clause follows logically from
a formula I in PI form reduces to checking whether the clause is subsumed by a clause in
I or is a tautology, and hence is a polynomial operation. The initial situations I in most
benchmarks is in P I form or can easily be cast into PI form as they are normally specified
by means of a set of non-overlapping oneof (X1 , . . . , Xn ) expressions that translate into
clauses X1      Xn and binary clauses Xi  Xj for i 6= j where any resolvent is a
tautology.
634

fiCompiling Uncertainty Away in Conformant Planning Problems

6.1 Conformant Relevance
The translation KS0 (P ) is complete but introduces a number of literals KL/t that is exponential in the worst case: one for each possible initial state s0 . This raises the question: is
it possible to have complete translations that are not exhaustive in this sense? The answer
is yes and in this section we provide a simple condition that ensures that a translation
KT,M (P ) is complete. It makes use of the notion of relevance:3
Definition 10 (Relevance). The conformant relevance relation L  L0 in P , read L is
relevant to L0 , is defined inductively as
1. L  L
2. L  L0 if a : C  L0 is in P with L  C for some action a in P
3. L  L0 if L  L00 and L00  L0
4. L  L0 if L  L00 and L00  L0 .
The first clause stands for reflexivity, the third for transitivity, the second captures conditions that are relevant to the effect, and the fourth, the conditions under which L preempts
conditional effects that may delete L0 . If we replace 4 by
4 L  L0 if L  L0
which is equivalent to 4 in the context of 13, the resulting definition is the one by Son and
Tu (2006), where the notion of relevance is used to generate a limited set of possible partial
initial states over which the 0-approximation is complete (see Section 11 for a discussion on
the relation between tags and partial initial states).
Notice that according to the definition, a precondition p of an action a is not taken to
be relevant to an effect q. The reason is that we want the relation L  L0 to capture the
conditions under which uncertainty about L is relevant to the uncertainty about L0 . This is
why we say this is a relation of conformant relevance. Preconditions must be known to be
true in order for an action to be applied, so they do not introduce nor propagate uncertainty
into the effects of an action.
If we let CI stand for the set of clauses representing uncertainty about the initial situation, namely, the non-unit clauses in I along with the tautologies L  L for complementary
literals L and L not appearing as unit clauses in I, the notion of (conformant) relevance
can be extended to clauses as follows:
Definition 11 (Relevant Clauses). A clause c  CI is relevant to a literal L in P if all
literals L0  c are relevant to L. The set of clauses in CI relevant to L is denoted as CI (L).
Having a representation of the uncertainty in the initial situation that is relevant to a
literal L, it is possible to analyze the completeness of a translation KT,M in terms of the
relation between the merges m for the literals L, on one hand, and the sets of clauses CI (L)
that are relevant to L on the other.
3. While we follow an earlier account (Palacios & Geffner, 2007), many of the definitions and theorems
differ in a number of details (for example, the notion of relevance depends on the rules in P but not on
the clauses in the initial situation). The changes are aimed at making the resulting formulation simpler
and cleaner.

635

fiPalacios & Geffner

6.2 Covering Translations
It may appear that a translation KT,M would be complete when
W the merges m for precondition and goal literals L, understood as the DNF formulas tm t, contain as much
information, and thus are equivalent to the CNF formula CI (L) that captures the fragment
of the initial situation I that is relevant to L. This intuition is partially correct, but misses
one important point; namely that not every DNF formula equivalent to CI (L) will do: the
DNF representation captured by the merges must be vivid enough. For example, if CI (L)
is the single clause x  x, completeness requires a tag for x, a tag for x, and a merge
m = {x, x} for L containing the two tags, even if the clause x  x is a tautology and is
thus equivalent to the DNF formula true.
For defining the types of tags and merges that are required for completeness then,
let us first define the closure S  of a set of literals S, relative to a conformant problem
P = hF, I, O, Gi, as the set of literals that follow from S and I:
S  = {L | I, S |= L} .
Let us also say that S is consistent if S  does not contain a pair of complementary literals.
The type of merges m required for precondition and goal literals L are then those that
do not only imply CI (L) but that satisfy it as well. The notion of satisfaction associates a
consistent set of literals S with the partial truth assignment that is implicit in the closure
S  of S, and is extended to account for the conditions under which a DNF formula (e.g., a
merge for L) satisfies a CNF formula (e.g., CI (L)).
Definition 12 (Satisfaction).
1. A consistent set of literals S satisfies a clause L1 L2 

    Lm if S contains one of the literals Li , i = 1, . . . , m.
2. A consistent set of literals S satisfies a collection of clauses C if S satisfies each clause
in C.
3. A collection S of consistent sets of literals satisfies a collection of clauses C if each set
S in S satisfies C.
The type of merges required for completeness are then simply the valid merges m that
satisfy the set of clauses CI (L). We call them covering merges:
Definition 13 (Covering Merges). A valid merge m in a translation KT,M (P ) covers a
literal L if m satisfies CI (L).
For example, if CI (L) is given by the clauses that result from a oneof (x1 , . . . , xn ) expression, i.e. x1  x2      xn and xi  xj for all i and j, 1  i, j  n, i 6= j, then the
merge m = {x1 , . . . , xn } covers the literal L, as each xi not only includes xi but also xj
for all j 6= i, and thus xi satisfies CI (L).
W
If for a merge m = {t1 , . . . , tn }, we denote by m the DNF formula ti m ti , where each
tag ti is replaced by its closure ti , then it is simple to prove that if m covers the literal L,
m entails CI (L). A merge m that covers L is thus a DNF formula that is strong enough
to imply the CNF formula CI (L) (through the closure), weak enough to be entailed by I,
and vivid enough to satisfy CI (L).
636

fiCompiling Uncertainty Away in Conformant Planning Problems

As a further illustration, if CI (L) is given by the tautologies p  p and q  q, and
I = CI (L), the merge m1 = {p, p} implies CI (L) but does not satisfy CI (L). Likewise, the
merge m2 = {{p, q}, {p, q}} satisfies CI (L) but is not entailed by I. Finally, the merge
m3 = {{p, q}, {p, q}, {p, q}, {p, q}} satisfies CI (L) and is entailed by I, and thus is a
valid merge that covers L.
If a valid translation KT,M (P ) contains a merge m that covers L for each precondition
and goal literal L in P , we say that the translation covers P or just that it is a covering
translation:
Definition 14 (Covering Translation). A covering translation is a valid translation
KT,M (P ) that includes one merge that covers L, for each precondition and goal literal L
in P .
A central result of the paper is that covering translations are complete:
Theorem 15 (Completeness). Covering translations KT,M (P ) are complete; i.e., if  is a
conformant plan for P , then there is a classical plan  0 for KT,M (P ) such that  is  0 with
the merge actions removed.
In other words, complete translations KT,M (P ) result when the tags and merges in T
and M capture the information in the initial situation that is relevant to each precondition
and goal literal in a suitable manner.
Theorem 15 can be used in two ways: for proving the completeness of a translation, by
checking that the covering condition holds, and for constructing complete translations, by
enforcing the covering condition. In addition, while our interest in this paper is on conformant planning with no optimality guarantees, the theorem is useful for optimal conformant
planning as well, whether the cost of plans is defined as their length (action costs equal to
1) or as the sum of non-uniform action costs. In both cases, the theorem ensures that the
problem of optimal conformant planning gets mapped into a problem of optimal classical
planning provided that the cost of the merge actions in KT,M (P ) is made sufficiently small.
As an illustration of Theorem 15, consider the conformant problem P with initial situation I = {x1      xm }, goal G = L, and actions ai , i = 1, . . . , m, each with effect xi  L.
The number of possible initial states for this problem is exponential in m, as the disjunction
among the xi s is not exclusive. So, the translation KS0 (P ) is complete but exponential in
size. On the other hand, consider the translation KT,M (P ) where T = {x1 , . . . , xm } and
M contains the single valid merge m = {x1 , . . . , xm } for L. It is simple to verify that this
merge covers the goal L (satisfies CI (L) = I), and hence that the translation KT,M (P ) is
covering, and by Theorem 15, complete, while being polynomial in m.
Notice that testing whether a valid translation KT,M (P ) is a covering translation can
be done in polynomial time, as in particular, computing the set of literals t from every tag
t in T is a tractable operation provided that I is in PI form; indeed, I, t |= L0 iff I |= t  L0
iff t  L0 is a tautology or is subsumed by a clause in I.
6.3 Translation Kmodels
It is straightforward to show that the exponential translation KS0 considered in Section 3,
where (non-empty) tags stand for the possible initial states, is covering and hence complete
637

fiPalacios & Geffner

according to Theorem 15. It is possible, however, to take further advantage of Theorem 15
for devising a complete translation that is usually more compact. We call it Kmodels.
Definition 16. The translation Kmodels(P ) is obtained from the general scheme KT,M (P )
by defining
 M to contain one merge m for each precondition and goal literal L given by the models
of CI (L) that are consistent with I,4 and
 T to contain the tags in all such merges along with the empty tag.
The translation Kmodels is equivalent to KS0 when for all the precondition and goal
literals L, CI (L) = I; i.e., when all the clauses in I are relevant to L. Yet, in other cases,
the first translation is exponential in the number of variables appearing in one such CI (L)
set (the one with the largest number of such variables), while the second is exponential in
the number of unknown variables in I. For example, if there are n precondition and goal
literals Li , i = 1, . . . , n in P such that for each one, CI (Li ) is a unique oneof (xi1 , . . . , xim )
expression, the merge for the literal Li in KS0 (P ) will contain the mn models of the n one-of
expressions in I, while the merge for Li in Kmodels(P ) will just contain the m models of
the single oneof (xi1 , . . . , xim ) expression in CI (Li ). The translation Kmodels can thus be
exponentially more compact than the exhaustive KS0 translation while remaining sound
and complete:
Theorem 17. The translation Kmodels(P ) is sound and complete.
In the worst case, however, Kmodels is also an exponential translation. We thus consider
next polynomial translations and the conditions under which they are complete.
6.4 Conformant Width
We address now the conditions under which a compact, covering translation can be constructed in polynomial time. For this, we define a structural parameter that we call the
conformant width of a problem P , that in analogy to the notion of width used in graphical
models (Dechter, 2003), will provide an upper bound on the time and space complexity
required for generating a covering translation. More precisely, the complexity of this construction will be exponential in the conformant width of the problem P that cannot exceed
the number of fluents in P but can be much lower.
In principle, we would like to define the width w(P ) as the maximum tag size required
in a translation KT,M (P ) to be a covering translation. Such a definition, however, would
not give us the complexity bounds that we want, as just checking the validity of a merge
with tags of bounded size is an intractable operation, whether the initial situation I is in
prime implicate form or not.5 So we need to define width in a different way. First, let the
cover of a set of clauses be defined as follows:
4. The models of CI (L) are to be understood as conjuntions of literals.
5. The problem of checking whether I entails a DNF formula whose terms may have more than 2 literals
is coNP-hard even if I is equivalent to true. Indeed, if  is a 3-CNF formula;  is contradictory iff its
negation  (which is in 3-DNF) is valid, which in turn is true iff  is implied by I. Actually, for a
general I in prime implicate form, the problem remains coNP-hard even if the terms of the DNF formula
contain at most 2 literals. We thank Pierre Marquis for pointing these results to us.

638

fiCompiling Uncertainty Away in Conformant Planning Problems

Definition 18 (Cover). The cover c(C) of a set of clauses C, relative to a conformant
problem P with initial situation I, is the collection of all minimal sets of literals S consistent
with I such that S contains a literal of each clause in C.
Two important properties of the cover c(C) of a set of clauses C are that c(C) stands for
a DNF formula that is logically equivalent to the CNF formula C given I, and that c(C) can
be computed in polynomial time if the size of C is bounded by a constant. Moreover, c(C)
not only implies C but satisfies C as well. Thus in particular, if C is the collection of clauses
CI (L) that are relevant to the literal L, the cover c(CI (L)) of CI (L) is a valid merge that
covers L. From this and the completeness of covering translations, it follows that a complete
translation KT,M (P ) can be constructed in polynomial time if the size |CI (L)| of the sets of
clauses CI (L) for all precondition and goal literals L in P is bounded. Unfortunately, this
condition rarely seems to hold, yet there is a weaker sufficient condition that does: namely,
it is often possible to find a subset C of clauses that are either in CI (L) or are tautologies
such that c(C) satisfies CI (L) and thus covers the literal L. We thus define the width of
the literal L as the size of the smallest such set (cardinality-wise). For this, we denote by
CI (L) the set of clauses CI (L) extended with tautologies of the form p  p for fluents p
such that either p or p appears in CI (L) (if both appear in CI (L) then p  p is in CI (L)
from its definition).
Definition 19 (Width of Literal). The conformant width of a literal L in P , written w(L),
is the size of the smallest (cardinality-wise) set of clauses C in CI (L) such that c(C) satisfies
CI (L).
A consequence of this definition is that the width of a literal must lie in the interval
0  w(L)  n, where n is the number of fluents in P whose status in the initial situation
is not known. Indeed, if CI (L) is empty, w(L) = 0, while for any set of clauses CI (L), the
cover c(C) of the set C of tautologies in CI (L) must satisfy CI (L), and thus w(L)  |C|  n.
Similarly, if CI (L) contains a single clause x1      xm or the clauses x1      xm and
xi  xj that correspond to the oneof (x1 , . . . , xm ) expression, it is simple to prove that
w(L) = 1 with the singleton C = {x1   xm } generating the cover c(C) = {{x1 }, . . . , {xn }}
that satisfies CI (L). Finally, if CI (L) contains the two tautologies pp and qq, w(L) = 2
as the smallest C in CI (L) whose cover satisfies CI (L) is CI (L) itself.
The width of a problem is the width of the precondition or goal literal with maximum
width:
Definition 20 (Width of Problem). The conformant width of a problem P , written as
w(P ), is w(P ) = maxL w(L), where L ranges over the precondition and goal literals in P .
We show below that for problems with bounded width, complete translations can be
constructed in polynomial time, and moreover, that almost all existing conformant benchmarks have bounded width, and more precisely, width equal to 1. In such a case, the
resulting translations will use tags that are never greater in size than w(P ), so that for
problems with width 1, tags will be single literals.
Like for the (tree)width of graphical models, computing the width of a problem P is
exponential in w(P ), so the recognition of problems with small width can be carried out
quite efficiently:
639

fiPalacios & Geffner

Proposition 21 (Determining Width). The width w(P ) of P can be determined in time
that is exponential in w(P ).
In particular, we can test if w(P ) = 1 by considering one by one each of the sets C
that includes a single clause from CI (L), verifying whether c(C) satisfies CI (L) or not. If
w(P ) 6 1, then the same verification must be carried out by setting C to each set of i
clauses in CI (L) for increasing values of i. For a fixed value of i, there is a polynomial
number of such clause sets C and the verification of each one can be done in polynomial
time. Moreover, from the arguments above regarding w(L), w(P ) can never exceed the
number of unknown fluents in the problem:
Proposition 22 (Bounds on Width). The width of P is such that 0  w(P )  n, where n
is the number of fluents whose value in the initial situation is not known.
6.5 Polynomial Translation Ki
The translation Ki , where the parameter i is a non-negative integer, is an instance of
the general KT,M scheme designed to be sound, polynomial for a fixed i, and complete for
problems with width w(P )  i. Thus, for example, the translation K1 is sound, polynomial,
and complete for problems with width 1.
Definition 23 (Translation Ki ). The translation Ki (P ) is obtained from the general
scheme KT,M (P ) where
 M is set to contain one merge m = c(C) for each precondition and goal literal L in P
if there is a set C of at most i clauses in CI (L) such that m covers L. If no such set
exists, one merge m = c(C) for L is created for each set C of i clauses in CI (L), and
no merges are created for L if CI (L) is empty;
 T is the collection of tags appearing in those merges and the empty tag.
The translation Ki (P ) applies to problems P of any width, remaining in all cases exponential in i but polynomial in the number of fluents, actions, and clauses in P . In addition,
the translation Ki (P ) is sound, and for problems with width bounded by i, complete.
Theorem 24 (Properties Ki ). For a fixed i, the translation Ki (P ) is sound, polynomial,
and if w(P )  i, covering and complete.
Soundness is the result of the merges being all valid by construction, as the covers c(C)
for any C in CI (L) are entailed by C and hence by I. The complexity is polynomial for a fixed
i, because there is a polynomial number of clause sets C of size i in CI (L), and constructing
the cover c(C) for each one of them, is a polynomial operation. Finally, completeness follows
from the definition of width: if w(P )  i, then there is a set of clauses C in CI (L) with
size |C| no greater than i whose cover satisfies CI (L), and thus M in Ki (P ) must contain a
merge m = c(C) for L that covers L.
Notice that for i = 0, the translation Ki (P ) reduces to the basic K0 (P ) translation
introduced in Section 3 that has no tags (other than the empty tag) and no merges. Before,
we assessed the completeness of this translation in terms of the 0-approximation semantics.
Theorem 24 provides an alternative interpretation: the translation K0 (P ) is complete for
640

fiCompiling Uncertainty Away in Conformant Planning Problems

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

Domain-Parameter
Safe-n combinations
UTS-n locs
Ring-n rooms
Bomb-in-the-toilet-n bombs
Comm-n signals
Square-Center-n  n grid
Cube-Center-n  n  n cube
Grid-n shapes of n keys
Logistics n pack m locs
Coins-n coins m locs
Block-Tower-n Blocks
Sortnet-n bits
Adder n pairs of bits
Look-and-Grab m objs from n  n locs
1-dispose m objs from n  n locs

# Unknown Fluents
n
n
4n
n
n
2n
3n
nm
nm
nm
n  (n  1) + 3n + 1
n
2n
nnm
nnm

Width
1
1
1
1
1
1
1
1
1
1
n  (n  1) + 3n + 1
n
2n
m
m

Table 2: Width of parameterized domains
problems P with zero width. These are the problems for which the set of clauses CI (L)
relevant to a precondition or goal literal L is empty. This makes precise the intuition
mentioned above that the K0 (P ) translation is complete for problems where the uncertain
information in I is not relevant. In such cases, none of the clauses in the initial situation I
make it into the sets of relevant clauses CI (L) for preconditions and goal literals L.
As an illustration of Theorem 24, consider again the conformant problem P with initial
situation I = {x1      xm }, goal G = {L}, and actions ai , i = 1, . . . , m, each with
effect xi  L. For this problem, the singleton set of clauses C = CI (L) = I is such that
c(C) = {{x1 }, . . . , {xm }} covers CI (L). Then, since there is no other precondition or goal
literal, K1 (P ) includes the single merge m = c(C) for L with the singleton tags ti = {xi },
that we write simply as m = {x1 , . . . , xm }. The translation K1 (P ) is polynomial in m,
and since w(P ) = 1, by Theorem 24 it is complete. Notice that for this same example, the
translations KS0 (P ) and Kmodels(P ) are identical and exponential in m (the number of
models of I and CI (L)).
6.6 Width of Conformant Benchmarks
The practical value of the notion of width becomes apparent when the width of existing
benchmarks is considered. Table 2 summarizes the width of many of the existing benchmark
domains for conformant planning. The domains all depend on certain parameters n or m
that capture the size of the instances (e.g., size of a grid, number of objects, etc).6 A domain
has a bounded width when its width does not grow with the size of its instances, and has
width equal to i when all of its instances have width i regardless of the parameter values.
As it can be seen from the table, the width of most existing benchmarks is 1. In all
these cases, this means that the sets CI (L) of clauses that are relevant to a precondition or
6. The names of the parameterized domains in the table do not coincide with the names of the instances
as currently used. E.g. Comm-n in IPC5 refers to a Communication instance but not necessarily to an
instance with n signals.

641

fiPalacios & Geffner

goal literal L contain a single clause (often a tautology p  p or a disjunction x1  . . .  xm )
or a single oneof (x1 , . . . , xm ) expression (that translates into the disjunction x1      xm
and clauses xi  xk ). As shown above, w(L), and therefore, w(P ), is equal to 1 in theses
cases.
On the other extreme are domains such as Blocks, Sortnet, and Adder, all of which
have maximal widths; i.e., widths that are equivalent to the number of fluents whose status in the initial situation is not known. This is because all fluents interact through the
action conditions (not the preconditions). The numbers for Blocks in Table 2, thus follow
from the number of fluents involved; namely, the fluents on(x, y), clear(x), ontable(x), and
holding(x).
Finally, the domains 1-dispose and Look-and-Grab (Palacios & Geffner, 2006, 2007)
where m objects with unknown locations in a grid of n by n must be collected by a robot
whose gripper can hold one object at a time, have width equal to m, meaning that the
width of these domains grows with the number of objects but not with the size of the grid.
This is because in this case, the clauses about the possible locations of the m objects are
all relevant to the condition hand empty of the pick up actions.
Let us point out that the completeness of the translation Ki (P ) for problems P with
width w(P ) bounded by i, establishes a correspondence between the conformant plans
for P and the classical plans for KT,M (P ). For solving P , however, this correspondence
is not needed; it suffices for Ki (P ) to be solvable; a plan for Ki (P ) will then encode a
conformant plan for P , even if Ki (P ) does not capture all conformant plans for P . From
this perspective, it makes sense to refer to the smallest value of the i parameter for which
the classical problem Ki (P ) is solvable, as the effective width of P , denoted we (P ). It turns
out that while we (P ) cannot be larger than w(P ), it may be much smaller. An interesting
example of this comes from the Sortnet-n domain (Bonet & Geffner, 2000). Sortnet-n is
considered a challenging domain in conformant planning with very few planners able to
scale up to even small values of n (the number of entries to be sorted in a sorting network).
The domain has width n, and in the compact encoding used in IPC5, the input vector is
represented by a set of bits, exploiting the fact that sorting vectors of numbers reduces to
sorting vector of bits (0s and 1s). The domain cannot be solved by the K1 translation that
FF reports correctly as unsolvable after a brief unsuccessful search. On the other hand,
it is possible to reformulate the domain, replacing the unary high(i) and low(i) predicates
by binary predicates less(i, j) that compare two vector entries. We call this reformulation
Sort-2-n. While the encoding Sort-n is linear in n, the encoding Sort-2-n is quadratic in n,
and in both cases, the problem width is maximum, given by the number of fluents whose
status in the initial situation is unknown. Yet, while the more compact Sort-n encoding is
not solvable by the K1 translation, K1 suffices to solve the problem over the expanded Sort2-n encoding that actually can also be solved by K0 . Thus the effective width of Sort-2-n
is 0. Interestingly, provided the K0 translation of Sort-2-n, instances can be solved with up
to 20 entries. On the other hand, conformant planners such as Conformant-FF and POND
can solve Sort-2-n instances for n no greater than 3.
642

fiCompiling Uncertainty Away in Conformant Planning Problems

7. Tags and Initial States
A deeper understanding of the results above can be obtained by relating tags with possible
initial states. By looking more closely at this relation in the context of covering translations,
we will be able to answer the question of how a polynomial number of contexts (tags) can
play the role of an exponential number of possible initial states in problems with bounded
width.
For this, let us first recall a notation introduced in Section 2.2, where for a state s, we
wrote I(s) to refer to the set of atoms encoding s (i.e, p  I(s) iff p is true in s) and P/s
to refer to the classical planning problem P/s = hF, I(s), O, Gi that is like the conformant
problem P = hF, I, O, Gi but with the initial state fixed to s.
Let us now extend this notation and say that an action sequence  conforms with a set
of states S given the conformant problem P iff  is a plan for the classical problem P/s for
each s  S. Clearly, a conformant plan for P is nothing else but an action sequence that
conforms with the set S0 of possible initial states of P , yet the notion of conforms allows
us to abstract away the initial situation I and make precise the notion of a basis:
Definition 25 (Basis for P ). A set of states S 0 is a basis for a conformant problem P =
hF, I, O, Gi if S 0 is a subset of the set S0 of possible initial states of P and every plan that
conforms with S 0 conforms with the set of possible initial states S0 .
In words, if S 0 is a basis for P , it is not necessary to consider all the states in S0 for
computing the conformant plans for P ; it suffices to consider just the states in S 0 . We aim
to show that if the width of P is bounded, then P has a polynomial basis S 0 even if S0 has
exponential size. Moreover, the states s in such a basis are in close correspondence with
the tags appearing in a covering translation.
As an illustration, consider a problem P with actions ai , i = 1, . . . , n, and effects
ai : xi  L. Let G = {L} be the goal and I = {x1      xn } the initial situation. The
set S0 of all possible initial states are the truth valuations over the xi atoms where at least
one of these atoms is true. There are 2n  1 such states. On the other hand, one can show
that the set S00 of n valuations in which exactly one of these atoms is true provides a basis
for P ; i.e., the plans that conform with these n possible initial states, are exactly the plans
that conform with the complete set of 2n  1 possible initial states in S0 .
The reduction in the number of possible initial states that must be considered for computing conformant plans results from two monotonicity properties that we formulate using
the notation rel(s, L) to refer to the set of literals L0 that are true in the state s and are
relevant to the literal L:
rel(s, L) = {L0 | L0  s and L0 is relevant to L} .
Proposition 26 (Monotonicity 1). Let s and s0 be two states and let  be an action sequence
applicable in the classical problems P/s and P/s0 . Then if  achieves a literal L in P/s0
and rel(s0 , L)  rel(s, L),  achieves the literal L in P/s.
Proposition 27 (Monotonicity 2). If S and S 0 are two collections of states such that for
every state s in S and every precondition and goal literal L in P , there is a state s0 in S 0
such that rel(s0 , L)  rel(s, L), then if  is a plan for P that conforms with S 0 ,  is a plan
for P that conforms with S.
643

fiPalacios & Geffner

From these properties, it follows that
Proposition 28. S 0 is a basis for P if for every possible initial state s of P and every
precondition and goal literal L in P , S 0 contains a state s0 such that rel(s0 , L)  rel(s, L).
This proposition allows us to verify the claim made in the example above that the set S00 ,
that contains a number of states that is linear in n, is a basis for P that has an exponential
number of possible initial states. Indeed, such a problem has no precondition and a single
goal literal L, and for every state s that makes more than one atom xi true (these are the
literals relevant to L), there is a state s0 in S00 that makes only one of those atoms true, and
hence for which the relation rel(s0 , L)  rel(s, L) holds.
The question that we address now is how to build a basis that complies with the condition
in Proposition 28 given a covering translation KT,M (P ). For this, let m = {t1 , . . . , tn } be
a merge in M that covers a precondition or goal literal L, and let S[ti , L] denote the set of
possible initial states s of P such that rel(s, L)  ti ; i.e., S[ti , L] contains the possible initial
states of P that make all the literals L0 that are relevant to L false, except for those in the
closure ti of ti . We show first that if I is in prime implicate form, S[ti , L] is a non-empty
set:7
Proposition 29. If the initial situation I is in prime implicate form and m = {t1 , . . . , tn }
is a valid merge that covers a literal L in P , then the set S[ti , L] of possible initial states s
of P such that rel(s, L)  ti is non-empty.
Let then s[ti , L] stand for an arbitrary state in S[ti , L]. We obtain the following result:
Theorem 30. Let KT,M (P ) be a covering translation for a problem P with an initial
situation in PI form, and let S 0 stand for the collection of states s[ti , L] where L is a
precondition or goal literal of P and ti is a tag in a merge that covers L. Then S 0 is a basis
for P .
This is an important result for three reasons. First, it tells us how to build a basis for P
given the tags ti in a covering translation KT,M (P ). Second, it tells us that the size of the
resulting basis is linear in the number of precondition and goal literals L and tags ti . And
third, it makes the role of the tags ti in the covering translation KT,M (P ) explicit, providing
an intuition for why it works: each tag ti in a merge that covers a literal L represents one
possible initial state; namely, a state s[ti , L] that makes false all the literals L0 that are
relevant to L except those in ti . If a plan conforms with those critical states, then it will
conform with all the possible initial states by monotonicity (Proposition 27). It follows then
in particular that:
Theorem 31. If P is a conformant planning problem with bounded width, then P admits
a basis of polynomial size.
Namely, conformant problems P with width bounded by a non-negative integer i admit
polynomial translations that are complete, because the plans that conform with the possibly
exponential number of initial states of P correspond with the plans that conform with
7. Recall that we are assuming throughout that the initial situation I is logically consistent and that the
tags t are consistent with I.

644

fiCompiling Uncertainty Away in Conformant Planning Problems

a subset of critical initial states that are polynomial in number (namely, those in the
polynomial basis). Thus, one complete polynomial translation for such problems is the
Ki translation; another one, is the KS0 translation but with the tags associated with those
critical initial states only rather than with all the initial states.
As an illustration, for the problem P above with actions ai and effects ai : xi  L,
goal G = {L}, and initial situation I = {x1      xn }, the K1 (P ) translation with tags xi ,
i = 1, . . . , n, and the merge m = {x1 , . . . , xn } for the goal literal L, is a covering translation.
Theorem 30 then states that a basis S 0 for P results from the collection of states si that
make each tag xi true, and all the literals that are relevant to L that are not in xi false (i.e.,
all xk atoms for k 6= i). This is precisely the basis for P that we had above that includes
the states that make a single atom xi true for i = 1, . . . , n: the plans that conform with this
basis are then exactly the plans that conform with the whole collection of possible initial
states of P . This basis has a size that is polynomial in m though, while the number of
possible initial states of P is exponential in m.

8. The Planner T0
The current version of the conformant planner T0 is based on two instances of the general
translation scheme KT,M (P ) whose outputs are fed into the classical planner FF v2.3.8 One
instance is polynomial but not necessarily complete; the other is complete but not necessarily
polynomial. For the incomplete translation, T0 uses K1 that is complete for problems with
width no greater than 1, and as argued above, can result in solvable instances for problems
of larger widths. For the complete translation, the Kmodels translation is used instead
with a simple optimization: if the K1 translation produces a single merge m that covers L,
then this merge m is used for L instead of the potentially more complex one determined by
Kmodels. This is a mere optimization as the resulting translation remains complete. The
other merges in Kmodels, that result from the models of the set of clauses CI (L) that are
consistent with I, are computed using the SAT solver relsat v2.20 (Bayardo Jr. & Schrag,
1997). In the current default mode in T0 , which is the one used in the experiments below,
the two translations K1 and Kmodels are used in sequence: FF is called first upon the
output of K1 and if this fails, it is called upon the output of Kmodels. In the experiments
below, we indicate the cases when Kmodels was invoked.
The translations used in T0 accommodate certain simplifications and two additional
actions that capture other types of deductions. The simplifications have to do with the fact
that the translations considered are all uniform in the sense that all literals L in P and
all rules C  L are conditioned by each of the tags t in T . From a practical point of
view, however, this is not needed. The simplifications address this source of inefficiency. In
particular:
 literals KL/t are not created when the closure t contains no literal relevant to L.
In such a case, the invariance KL/t  KL holds, and thus, every occurrence of the
literal KL/t in KT,M (P ) is replaced by KL.
8. The conformant planner T0 along with all the benchmarks considered in the paper are available at
http://www.ldc.usb.ve/hlp/software.

645

fiPalacios & Geffner

 support rules a : KC/t  KL/t for non-empty tags t are not created when L is not
relevant to a literal L0 with a merge that contains t, as in such a case, the literal
KL/t cannot contribute to establish a precondition or goal. Similarly, cancellation
rules a : KC/t  KL/t for non-empty tags t are not created when L is not
relevant to a literal L0 with a merge that contains t.
 support and cancellation rules a : KC/t  KL/t and a : KC/t  KL/t are
grouped as a : KC/t  KL/t  KL/t when for every fluent L0 relevant to L, either
L0 or L0 is entailed by I and t. In such a case, there is no incomplete information
about L given t in the initial situation, and thus the invariant KL/t or KL/t holds,
and KC/t is equivalent to KC/t.
Two other types of sound deductive rules are included in the translations:
 a rule a : KC  KL is added if a : C, L  L is a rule in P for an action a, and no
rule in P has the form a : C 0  L,
 rules KL1 , . . . , KLi1 , KLi+1 , . . . , KLn  KLi for i = 1, . . . , n are added to a
new unique action with no precondition, when L1      Ln is a static clause in P (a
clause in P is static if true in the initial situation and provably true after any action).
These rules are versions of the action compilation and static disjunctions rules (Palacios &
Geffner, 2006, 2007), and they appear to help in certain domains without hurting in others.
The version of T0 reported below does not assume that the initial situation I of P is
in prime implicate form but it rather renders it in PI form by running a version of Tisons
algorithm (1967), a computation that in none of the benchmarks solved took more than 48
seconds.
The translators in T0 are written in OCaml while the code for parsing the PDDL files
is written in C++.

9. Experimental Results
We considered instances from three sources: the Conformant-FF distribution, the conformant track of the 2006 International Planning Competition (IPC5), and relevant publications (Palacios & Geffner, 2006, 2007; Cimatti et al., 2004). The instances were run on a
cluster of Linux boxes at 2.33 GHz with 8GB. Each experiment had a cutoff of 2h or 2.1GB
of memory. Times for T0 include all the steps, in particular, computation of prime implicates, translation, and search (done by FF). We also include results from the Conformant
Track of the recent 2008 International Planning Competition (IPC6).
Goals that are not sets of literals but sets of clauses are transformed in T0 in a standard
way: each goal clause C : L1      Lm is modeled by a new goal atom GC , and a new
action that can be executed once is added with rules Li  GC , i = 1, . . . , m.9
9. An alternative way to represent such CNF goals is by converting them into DNF first and having an
action End map each of its non-mutex terms into a dummy goal LG . This alternative encoding pays
off in some cases, such as in the Adder-01 instance that does not get solved in the default CNF goal
encoding (see below).

646

fiCompiling Uncertainty Away in Conformant Planning Problems

Problem
bomb-100-100
square-center-96
sortnet-09
blocks-03
dispose-16-1
look-and-grab-8-1-1
sgripper-30

P
#Acts #Atoms #Effects
10100
404
40200
4
196
760
46
68
109
32
30
152
1217
1479
2434
352
358
2220
487
239
1456

Time
2
35,1
8,3
4
163,6
6,9
21,5

K1 (P )
PDDL
#Acts #Atoms #Effects Size
10201
1595
50500
2,9
7
37248
75054
3,8
56
29707
154913
5,1
37
11370
35232
0,7
1218 133122
3458
0,3
353
8708
118497
7,8
860
1127
12769
1

Table 3: Translation data for selected instances: #Acts, #Atoms, and #Effects stand for
the number of actions, fluents, and conditional effects. Time is the translation
time in seconds rounded to the closest decimal, and PDDL Size is the size of the
PDDL file in Megabytes.

Table 3 shows data concerning the translation of a group of selected instances. As it can
be seen, the number of conditional effects grows considerably in all cases, and sometimes
the translation may take several seconds.
Tables 4, 5, 6, 7, and 8, show the plan times and lengths obtained on a number of
benchmarks by T0 , POND 2.2 (Bryce et al., 2006), Conformant FF (Hoffmann & Brafman,
2006), MBP (Cimatti et al., 2004) and KACMBP (Bertoli & Cimatti, 2002). These last
two planners do not accept problems in the standard syntax (based on PDDL), so only a
limited number of experiments were performed on them. The general picture is that T0
scales up well in most domains, the exceptions being Square-Center and Cube-Center in
Table 5, where KACMBP scales up better, Sortnet in Table 6, where KACMBP and MBP
scale up better; and Adder in Table 6, where POND is the only planner able to solve one
instance.
The problems in Table 4 are encodings from the Conformant-FF repository: Bomb-x-y
refers to the Bomb-in-the-toilet problem with x packages, y toilets, and clogging; Logistics-ij-k is a variation of the classical version with uncertainty about initial location of packages;
Ring-n is about closing and locking windows in a ring of n rooms without knowing the
current room; and Safe-n is about opening a safe with n possible combinations. All these
problems have width 1. T0 does clearly best on the last two domains, while in the first two
domains, Conformant-FF does well too.
Table 5 reports experiments on four grid domains: Cube-Center-n refers to the problem
of reaching the center of a cube of size n3 from a completely unknown location; SquareCenter-n is similar but involves square with n2 possible locations; Corners-Cube-n and
Corners-Square-n are variations of these problems where the set of possible initial locations
is restricted to the Cube and Square corners respectively. MBP and KACMBP appear to be
effective in these domains, although KACMBP doesnt scale up well in the corner versions.
T0 solves most of the problems, but in the corner versions, the quality of the plans is poor.
These problems have also width 1.
Table 6 reports experiments over problems from the 2006 International Planning Competition (Bonet & Givan, 2006). The domains Coins, Comm and UTS have all width 1.
The others have max width given by the number of unknown fluents in the initial situation.
647

fiPalacios & Geffner

Problem
bomb-20-1
bomb-20-5
bomb-20-10
bomb-20-20
bomb-100-1
bomb-100-5
bomb-100-10
bomb-100-60
bomb-100-100
logistics-4-3-3
logistics-2-10-10
logistics-3-10-10
logistics-4-10-10
ring-4
ring-5
ring-6
ring-7
ring-8
ring-30
safe-10
safe-30
safe-50
safe-70
safe-100

T0
time
0,1
0,1
0,1
0,1
0,5
0,7
1,1
4,25
9,4
0,1
1
1,5
2,5
0,1
0,1
0,1
0,1
0,1
13,4
0,1
0,1
0,4
1,12
2,5

len
49
35
30
20
199
195
190
140
100
35
84
108
125
13
17
20
30
39
121
10
30
50
70
100

POND
time len
4139 39
> 2h
> 2h
> 2h





56
40
> 2h
> 2h
> 2h
1
18
6
20
33
27
444
33
> 2h

0
10
2
30
9
50
41
70
> 2.1GB

CFF
time
len
0
39
0
35
0
30
0
20
56,7
199
52,9
195
46,8
190
9,4
140
1
100
0
37
1,6
83
4,7
108
4,4
121
0,4
18
4,3
31
93,6
48
837
71
> 2h

0
10
1,4
30
29,4
50
109,9
70
1252,4 100

MBP
time len
> 2h
> 2h
> 2h
> 2h





> 2h
> 2h
> 2h
> 2h
0
11
0,1
14
0,6
17
3,8
20
40
23
> 2h
0,1
10
> 2h
> 2h
> 2h
> 2h

KACMBP
time len
0
40
0,2
40
0,5
40
2
40
1,9
200
4,3
200
16,4 200
> 2h
> 2h
> 2.1GB
> 2.1GB
> 2.1GB
> 2.1GB
0
26
0,1
58
0,2
99
0,5
204
2
432
> 2.1GB
0
10
0,2
30
0,7
50
2,4
70
8,6
100

Table 4: Experiments over well known benchmarks. Times reported in seconds and rounded
to the closest decimal.  means time or memory out for smaller instances.

648

fiCompiling Uncertainty Away in Conformant Planning Problems

Problem
square-center-8
square-center-12
square-center-16
square-center-24
square-center-92
square-center-96
square-center-100
square-center-120
cube-center-5
cube-center-7
cube-center-9
cube-center-11
cube-center-15
cube-center-19
cube-center-63
cube-center-67
cube-center-87
cube-center-91
cube-center-119
corners-square-12
corners-square-16
corners-square-20
corners-square-24
corners-square-28
corners-square-36
corners-square-40
corners-square-72
corners-square-76
corners-square-80
corners-square-120
corners-cube-15
corners-cube-16
corners-cube-19
corners-cube-20
corners-cube-23
corners-cube-24
corners-cube-27
corners-cube-52
corners-cube-55

T0
time
len
0,2
21
0,2
33
0,3
44
0,8
69
45,3
273
50,2
285
> 2.1GB
> 2.1GB
0,1
18
0,1
27
0,2
33
0,3
45
0,5
63
0,8
81
28,5
279
41,6
297
137,5 387
> 2.1GB
> 2.1GB
0,1
64
0,2
102
0,3
148
0,5
202
0,7
264
1,7
412
2,5
498
26,1 1474
30,5 1632
38,2 1798
223,6 3898
0,8
147
0,9
174
2,5
225
2,7
258
6,3
319
6,7
358
14,6
429
448
1506
> 2.1GB

POND
time len
2
41
12
52
1322 61
> 2h
> 2h



1
22
2
43
3
47
29
87
880 109
> 2h
> 2h




11
44
1131 67
> 2h
> 2h







907 105
3168 115
> 2h
> 2h






CFF
time
len
70,6
50
> 2h
> 2h





8,2
45
> 2h
> 2h








1,7
82
13,1
140
73,7
214
321
304
MPL






134,5 284
439,4 214
868,4 456
3975,6 332
MPL





MBP
time
len
0
24
0
36
0
48
0
72
0,9
276
0,9
288
1,1
300
1,9
360
0
28
0
33
0,1
54
0,2
59
0,2
69
1,6
111
28
285
> 2.1GB
> 2.1GB


0
36
0
48
0,3
60
0,6
72
1,1
84
1,5
108
7,8
120
118,8 216
371
228
649,6 240
> 2.1GB
3,7
69
12,5
72
549,5 111
1061,9 90
> 2h
> 2h




KACMBP
time
len
0
28
0
42
0
56
0
84
0,3
322
0,3
336
0,3
350
0,4
420
0
25
0
35
0
45
0
55
0
75
0,1
95
0,5
315
0,7
335
1,2
435
1,2
455
2,1
595
0,2
106
0,6
158
3
268
7,5
346
20,7
502
3308,8 808
> 2h
> 2h



174,1 391
270,5 316
1503,1 488
2759
625
6265,9 899
> 2h
> 2h



Table 5: Experiments over grid problems. Times reported in seconds and rounded to the
closest decimal. MPL for CFF means that plan exceeds maximal plan length
(500 actions).  means time or memory out for smaller instances.

649

fiPalacios & Geffner

Problem
adder-01
adder-02
blocks-01
blocks-02
blocks-03
coins-10
coins-12
coins-15
coins-16
coins-17
coins-18
coins-19
coins-20
coins-21
comm-07
comm-08
comm-09
comm-10
comm-15
comm-16
comm-20
comm-25
sortnet-06
sortnet-07
sortnet-08
sortnet-09
sortnet-10
sortnet-11
uts-k-04
uts-k-05
uts-k-06
uts-k-07
uts-k-08
uts-k-09
uts-k-10
uts-l-07
uts-l-08
uts-l-09
uts-l-10

T0
time len
> 2h
> 2h
0,1
5
0,3
23
82,6
80
0,1
26
0,1
67
0,1
79
0,3
113
0,2
96
0,2
97
0,2
105
0,2
107
> 2h
0,1
54
0,1
61
0,1
68
0,1
75
0,1
110
0,2
138
0,8
278
2,3
453
0,6
21
2,5
28
9,6
36
76,8
45
> 2.1GB
> 2.1GB
0,1
23
0,1
29
0,2
35
0,4
41
0,6
47
0,9
53
1,3
59
0,2
70
0,3
80
0,6
93
0,7
97

POND
time len
1591
5
> 2h
0,1
4
0,4
26
126,8 129
5
28
> 2h
> 2h






0
47
1
53
1
59
1
65
6
95
> 2h
> 2.1GB

18
20
480
25
> 2h
> 2h


2
22
4
28
10
34
13
40
24
47
> 2h
2219
67
201
58
937
67
> 2h
> 2h

CFF
time len
SNH
SNH
0
6
> 2h
> 2h
0,1
38
0,8
72
3
89
33,3 145
1,4
94
6,2
118
16,5 128
20,6 143
> 2h
0
47
0
53
0
59
0
65
0,2
95
0,4
119
6,4
239
56,1 389
SNH
SNH
SNH
SNH
SNH
SNH
0,1
22
0,3
28
0,8
34
1,9
40
4,4
46
8,6
52
16,5
58
0,2
41
0,4
47
0,8
53
1,6
59

MBP
time
len
NR
NR
NR
NR
NR
> 2h
> 2h







0,2
55
0,2
71
0,2
77
0,3
85
0,9
115
1,6
151
50,9
340
> 2h
0
17
0
20
0
28
0
36
0,1
37
0,1
47
5,4
32
1247,3 38
1704,8 50
> 2h
> 2h


10,5
89
41,1
106
1176
137
> 2h

KACMBP
time
len
NR
NR
NR
NR
NR
4,2
106
3654,7 674
> 2h
> 2h





63,6
53
1966,8 53
> 2h
> 2h




0
21
0
28
0
36
0
45
0,1
55
0,1
66
1,5
30
195,4
42
> 2h
> 2h



> 2h
> 2h



Table 6: Experiments over problems from IPC5. Times reported in seconds and rounded
to the closest decimal. SNH for CFF means that goal syntax not handled, while
NR for MBP and KACMBP that these planners were not run due to lack of
translations from PDDL.  means time or memory out for smaller instances.

650

fiCompiling Uncertainty Away in Conformant Planning Problems

Problem
dispose-4-1
dispose-4-2
dispose-4-3
dispose-8-1
dispose-8-2
dispose-8-3
dispose-12-1
dispose-12-2
dispose-12-3
dispose-16-1
dispose-16-2
look-and-grab-4-1-1
look-and-grab-4-1-2
look-and-grab-4-1-3
look-and-grab-4-2-1
look-and-grab-4-2-2
look-and-grab-4-2-3
look-and-grab-4-3-1
look-and-grab-4-3-2
look-and-grab-4-3-3
look-and-grab-8-1-1
look-and-grab-8-1-2
look-and-grab-8-1-3
look-and-grab-8-2-1
look-and-grab-8-2-2
look-and-grab-8-2-3
look-and-grab-8-3-1
look-and-grab-8-3-2
look-and-grab-8-3-3

T0
time
len
0,1
59
0,1
110
0,3
122
2,7
426
18,4
639
197,1 761
78
1274
2555 1437
> 2.1GB
382
1702
> 2.1GB
0,3
30
0,5
4
0,61
4
35
12
49,41
4
60,02
4
> 2.1GB
213,3
4
> 2.1GB
58,2
242
75,3
90
55,89
58
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h

POND
time len
9
55
36
70
308 102
> 2.1GB
> 2.1GB






3098 16
> 2h
> 2h
> 2.1GB
> 2h
> 2h
> 2.1GB












CFF
time
len
0,1
39
0,2
56
0,6
73
339,1 227
2592,1 338
> 2h
ME
> 2.1GB



> 2h
Mcl
Mcl
> 2h
Mcl
Mcl
> 2h
> 2h
> 2h










MBP
time len
> 2h
> 2h









> 2h
0,02
5
0,01
5
> 2h
0,02
5
0,02
5
> 2h
0,02
5
0,02
5
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h

KACMBP
time len
17,1
81
> 2h
> 2h








0,6
54
0,0
6
0,0
6
0,63
40
0,01
6
0,01
6
0,98
60
0,02
6
0,01
6
> 2h
> 2h
> 2h
> 2h
> 2h
1195 178
> 2h
> 2h
17,9
58

Table 7: Problems from Palacios and Geffner (2006, 2007): Times reported in seconds and
rounded to the closest decimal.  means time or memory out for smaller instances.
ME and Mcl mean too many edges and too many clauses respectively.

T0 dominates in all these domains except in Adder where POND is the only planner able
to solve an instance, and Sortnet, where MBP and KACMBP do very well, possibly due to
use of the cardinality heuristic and OBDD representations. T0 fails on Adder because FF
gets lost in the search. Looking at this problem more closely, we found that FF could solve
the (translation of the) first instance in less than a minute provided that the CNF goal for
this problem is encoded in DNF as explained in footnote 9, page 646. The domains Adder,
Blocks, and Sortnet in the table, along with the domain Look-and-Grab in the next table,
are the only domains considered where FF run on the K1 translation reports no solution
after a brief search, triggering then the use of the complete Kmodels translation. In all the
other cases where Kmodels was used, the K1 translation had an unreachable goal fluent and
there was no need to try FF on it.
651

fiPalacios & Geffner

Problem
push-to-4-1
push-to-4-2
push-to-4-3
push-to-8-1
push-to-8-2
push-to-8-3
push-to-12-1
push-to-12-2
push-to-12-3
1-dispose-8-1
1-dispose-8-2
1-dispose-8-3

T0
time
len
0,2
78
0,3
85
0,6
87
81,8
464
457,9
423
1293,1 597
> 2h
> 2h
> 2.1GB
82,2
1316
> 2.1GB
> 2.1GB

POND
time len
5
50
171
58

> 2h
> 2h
> 2h



> 2.1GB
> 2.1GB


CFF
time len
0,3
46
0,7
47
1,6
48
> 2.1GB
> 2.1GB
> 2.1GB



> 2h
> 2h


Table 8: Other problems from Palacios and Geffner (2006, 2007). MBP and KACMBP
were not tried on these problems as they use a different syntax. Times reported
in seconds and rounded to the closest decimal.  means time or memory out for
smaller instances.

The problems reported in Table 7 and Table 8 are variations of a family of grid problems
(Palacios & Geffner, 2006, 2007). Dispose is about retrieving objects whose initial location is
unknown and placing them in a trash can at a given, known location; Push-to is a variation
where objects can be picked up only at two designated positions in the grid to which all
objects have to be pushed to: pushing an object from a cell into a contiguous cell moves
the object if it is in the cell. 1-Dispose is a variation of Dispose where the robot hand being
empty is a condition for the pick up actions to work. As a result, a plan for 1-Dispose has to
scan the grid, performing pick ups in every cell, followed by excursions to the trash can, and
so on. The plans can get very long (a plan is reported with 1316 actions). Look-and-Grab
has an action that picks up the objects that are sufficiently close if any, and after each pickup must dump the objects it collected into the trash before continuing. For the problem
P-n-m in the table, n is the grid size and m is the number of objects. For Look-n-Grab,
the third parameter is the radius of the action: 1 means that the hand picks up all the
objects in the 8 surrounding cells, 2 that that the hand picks up all the objects in the 15
surrounding cells, and so on. The domains in Tables 7 and 8 have width 1 except 1-Dispose
and Look-n-Grab. This is because, the hand being empty is a fluent that is relevant to
the goal, and clauses about the location of objects are all relevant to hand empty. In all
these domains T0 appears to do better than the other planners. The Kmodels translation
was triggered only in the instances Look-and-Grab-n-m-r for m > 1 (the width of these
instances, as mentioned in Section 6.6, is m, independent of grid size).
We also report some additional data in Table 9, comparing the search that results from
the use of the FF planner over the classical translations in T0 , to the search carried out
by Conformant-FF over the original conformant problems. Conformant-FF is a conformant
planner built on top of FF that searches explicitly in belief space. The table illustrates the
two problems faced by belief-space planners mentioned in the introduction and the handle
652

fiCompiling Uncertainty Away in Conformant Planning Problems

Problem
bomb-100-1
bomb-100-100
Safe-100
logistics-4-10-10
square-center-8
square-center-12
cube-center-5
cube-center-7
blocks-01
blocks-02
coins-20
comm-25
uts-k-10
dispose-8-1
dispose-8-2
dispose-8-3
look-and-grab-4-1-1

Nodes
5149
100
100
356
4634
39000
2211
81600
46
1420
1235
517
58
1107
1797
2494
4955

CFF
Time
32,9
0,8
1747,4
4,42
59,3
>5602,5
8,2
>5602,5
0,0
>5602,5
20,6
56,1
16,5
339,1
2592,1
>5602,5
>5602,5

Nodes/sec
156,5
125
0,1
80,5
78,1
7
269,6
14,6
4600
0,3
60
9,2
3,5
3,3
0,7
0,4
0,9

Nodes
5250
201
102
774
46
72
74
105
47
86
783
1777
62
11713
87030
580896
79

FF in T0
Time Nodes/sec
0,41
12804,9
7,53
26,7
0
25500
0,47
1646,8
0,05
920
0,03
2400
0,01
7400
0,0
5250
0
11750
0,0
4300
0,04
19575
0,43
4132,6
0,34
182,4
0,78
15016,7
14,32
6077,5
190,2
3054,1
0,1
790

Table 9: CFF over Conformant Problems vs. FF over Translations: Nodes stand for number
of nodes evaluated, Time is expressed in seconds, and Nodes/sec stands for average
number of nodes per second. Numbers shown in bold when either CFF or FF
evaluate significantly less nodes (an order-of-magnitude reduction or more). Times
preceded by > are time outs.

653

fiPalacios & Geffner

over them that results from the translation-based approach. The belief representation and
update problem appears in the overhead of maintaining and evaluating the beliefs, and
shows in the number of nodes that are evaluated per second: while CFF evaluates a few
hundred nodes per second; FF evaluates several thousands. At the same time, the heuristic
used in CFF in the conformant setting, appears to be less informed that the heuristic used
by FF over the classical translations. In domains like Square-Center-n, Cube-Center-n,
Blocks, and Look-and-Grab, FF needs orders-of-magnitude less nodes than CFF to find a
plan, while the oppositive is true in Dispose-n-m where FF evaluates many more nodes
than CFF. Nonetheless, even then, due to the overhead involved in carrying the beliefs, FF
manages to solve problems that CFF cannot solve. For example, the instance Dispose-8-3
is solved by T0 after evaluating more than half a million nodes, but times out in CFF after
evaluating less than three thousand nodes.
Tables 10 and 11 provide details on the results of the Conformant Track of the 2008
International Planning Competition (IPC6) (Bryce & Buffet, 2008), held almost at the time
where the original version of this paper was submitted, with planner binaries submitted to
the organizers a few months before. The version of T0 in IPC6 was different from the
version of T0 used in IPC5, where it was the winning entry, and different also from the
version reported in this paper. In relation, to the former, T0 IPC6 was a cleaner but
complete reimplementation; in relation to the latter, T0 IPC6 handled problems with width
greater than 1 in a different way. As explained in the previous section, the current version
of T0 , uses K1 as the basic translation regardless of the width of the problem, switching to
Kmodels when the search over K1 fails. In the version of T0 at IPC6, the basic translation
was a combination of K0 and K1 ; more precisely, merges for literals L with width w(L) = 1,
were generated according to K1 , but merges for literals L with width w(L) 6= 1 were not
generated at all. The result was that the basic translation in T0 in IPC6 was lighter than
the basic translation of the current version of T0 but could fail on problems with width
higher than 1 that the latter can solve. Retrospectively, this was not a good choice, but it
didnt have much of an impact on the results. There was however a bug in the program
that prevented two width-1 domains, Forest and Dispose, to be recognized as such, and
thus resulted in the use of the Kmodels translation, that is complete for all widths, but does
not scale up that well.
The other two conformant planners entered into IPC6 where CpA(H) and CpA(C);
these are belief-space planners that represent beliefs as DNF formulas, and use simple
belief-state heuristics for guiding the search (Tran, Nguyen, Pontelli, & Son, 2008, 2009).
The belief progression in these planners is done quite effectively, by progressing each term
in turn, according to the 0-approximation semantics. The potential blow up comes from the
number of terms in the DNF formula encoding the initial belief state. Rather than choosing
the terms of the initial belief state as the possible initial states, these planners limit the
terms in the DNF formula to a collection of partial initial states that do not assign any
truth value to the literals that are deemed irrelevant. The resulting belief representation is
complete but may still result in an exponential number of terms (Son & Tu, 2006). In order
to reduce further the number of terms in this initial DNF formula, independent one-of
expressions are combined. For example, two independent one-of clauses oneof (x1 , x2 ) and
oneof (y1 , y2 ) which would give rise to 4 possible initial states and DNF terms, are combined
into the single one-of expression oneof (x1  y1 , x2  y2 ), that results into 2 possible initial
654

fiCompiling Uncertainty Away in Conformant Planning Problems

Domain
Blocks
Adder
UTS Cycle
Forest
Raos keys
Dispose

# Instances
4
4
27
9
29
90

CpA(H)
4
1
2
1
2
76

CpA(C)
3
1
2
1
2
59

T0 IPC6
3
1
3
8
1
20

Table 10: Data from the Conformant Track of the recent IPC6 Competition: Number of
problems solved by each of the conformant planners, with time out of 20 mins.
In bold, entry for planner that performed best in each domain. The data is from
Bryce and Buffet (2008)

states and terms. These one-of expressions are independent when they can be shown not
to interact in the problem. The technique appears to be related to the notion of critical
initial states considered in Section 7, where it was shown that plans that conform with all
critical initial states must conform also with all possible initial states. The heuristics used
by CpA(H) and CpA(C) are combinations of the cardinality heuristic, that measures the
number of states in a belief state, the total sum heuristic, that adds the heuristic distances
to the goal from each possible state, and the number of satisfied goals, that counts the
number of top goals achieved. These heuristics are all very simple, yet they work well on
some benchmarks.
Tables 10 and 11 show data obtained from the IPC6 organizers from the planner logs.
The first table appears in the IPC6 report (Bryce & Buffet, 2008), where the new domains
Forest and Raos keys are explained, and shows the number of problems solved by each
planner, displaying in bold the planner that did best in each domain. The planner CpA(H),
was declared the winner, as it was declared best in three domains (Blocks, Raos keys,
Dispose), with T0 doing best in two domains (UTS Cycle and Forest), and CpA(C) doing
best in one (Adder).
Table 11 shows additional details on some of the instances; in particular, the total time
taken to solve the instance and the length of the plans for each of the three planners.
In terms of domain coverage, the planners do similarly on most domains, except in
Forest, where T0 solved most of the instances and CPA(H) solved few (8/9 vs. 1/9), and
Dispose, where CPA(H) solved most of the instances and T0 solved few (76/90 vs. 20/90).
In terms of time and plan quality, CpA(H) and CpA(C) appear to be slightly faster
than T0 on Blocks, but produce much longer plans. In Dispose, T0 scales up better than
CpA(H) and CpA(C) over the size of the grids, and worse on the number of objects.
Indeed, only T0 manages to solve the largest grid but for a single object (Dispose-10-01),
and only CpA(H) and CpA(C) solve instances with more than 2 objects in the largest grids.
As in most cases, plan lengths produced by T0 are shorter; e.g., the plan for Dispose-04-03
contains 125 actions for T0 , 314 for CpA(H), and 320 for CpA(C).
Dispose is actually a domain where the cardinality heuristic does very well in the generation of plans, even if the plans tend to be rather long. As discussed above, in this domain,
an agent has to scan a grid collecting a set of objects at unknown locations, and each time
655

fiPalacios & Geffner

the action of picking up an object from a cell that may contain the object is made (except
for the first time), the cardinality of the belief state is reduced. Indeed, if initially an object
may be at positions p1 , p2 , . . . , pn , after a pick up at p1 , the object can be in positions
p2 , . . . , pn or in the gripper, after a pick up at p2 , the object can be in positions p3 , . . . , pn or
in the gripper, and so on, each pick up action decreasing the cardinality of the belief state,
until becoming a singleton belief where the object must be in the gripper with certainty.
The problem with the version of T0 used in IPC6 in the Dispose domain, was not only
that FF explores too many states in the search, but as explained above, that it used the
expensive Kmodels translation instead of the lighter K1 translation that is complete for
this domain that has width 1. With this bug fixed, T0 solves 60 rather than 20 of the 90
Dispose instances, still failing on some of the larger grids with many objects, but producing
much shorter plans. For example, Dispose-06-8 is solved with a plan with 470 actions, while
CpA(H) and CpA(C) solve it with plans with 2881 and 3693 actions respectively. The
same bug surfaced in the Forest domain, but it just prevented the solution of one instance
only. Forest, Dispose, and UTS Cycle have all conformant widths equal to 1, while the
other domains have all larger widths (see Table 2 for the widths of Blocks and Adder).
The second domain in IPC6 where FF got lost in the search was Adder, where indeed, T0
did not solve any instance. The instance that is shown to be solved by T0 in the competition
report, appears to be a mistake. Similarly, the fourth instance of blocks, that is reported as
solved by CPA(H), may be a mistake too; indeed, no plan for such an instance can be found
in the logs, and T0 reports that the goal is unreachable in the Kmodels translation that
is complete. According to T0 , instance four of Raos key is unsolvable too. On the other
hand, T0 failed on the larger UTS Cycle and Raos key instances during the translation.
In the the first, the resulting PDDLs are too large and cant be loaded into FF; in the
second, the number of init clauses turns out to be quite large (above 300), giving rise to
a still larger set of prime implicates (above 5000) that caused the translator to run out of
memory. The second instance of Raos keys, however, is rather small and T0 didnt solve it
due to a different bug. With this bug fixed, T0 solves it in 0.3 seconds, producing a plan
with 53 actions, which compares well with the solutions produced by CpA(H) and CpA(C)
in 0.7 and 1.9 seconds, with 85 and 99 steps, respectively.

10. Non-Deterministic Actions
The translation schemes considered are all limited to problems with deterministic actions
only. Nonetheless, as we illustrate below, these schemes can be applied to non-deterministic
actions as well provided suitable transformations are included. We cover these transformations briefly as a matter of illustration only.
Consider a conformant problem P with non-deterministic action effects a : C  oneof (S1 ,
S2 , . . . , Sm ), where each Si is a set (conjunction) of literals, and the transformed problem
P 0 , where these effects are mapped into deterministic rules of the form a : C, hi  Si , with
the expression oneof (h1 , . . . , hm ) added to the initial situation of P 0 . In P 0 , the hidden hi
variables are used for encoding the uncertainty on the possible outcomes Si of the action a.
It is easy to show that the non-deterministic conformant problem P and the deterministic conformant problem P 0 are equivalent provided that only plans for P and P 0 are
considered where the non-deterministic action a from P are executed at most once. Namely,
656

fiCompiling Uncertainty Away in Conformant Planning Problems

Problem

Instance

Blocks

1
2
3
4
1
1
2
3
1
2
3
4
5
6
7
8
1
2
4,1
4,2
4,3
4,4
6,1
6,2
6,3
6,4
8,1
8,2
8,3
10,1
10,2

Adder
UTS Cycle

Forest

Raos keys
Dispose

CpA(H)
time
len
0
4
0,1
28
5,9
411
143,9 257
8,5
3
0,8
3
25,3
6

CpA(C)
time
len
0
7
0,1
35
6,3
157
8,3
0,6
24,7

3
3
6

3,6

24

11,6

18

0,1
0,7
0,3
0,7
1,3
2
4,7
10,4
17,7
27,6
40,1
86,7
86,7

28
85
80
197
314
431
270
643
1016
1389
753
1851
1851

0
1,9
0,4
0,9
1,8
2,8
4,5
42,2
97,9
172,5
40,3
524,6

29
99
88
206
320
434
187
735
1228
1721
518
1962

T0 IPC6
time len
0,1
5
0,1
23
17,8
83

0,1
0,7
5,4
0,2
1,3
2,2
12,1
14,4
69,7
355,1

3
7
10
16
45
78
129
115
200
256

0

16

0,1
3,6
528,3

77
110
125

0,9
217,7

204
329

7,4

326

45

683

Table 11: Running time and plan length from IPC6 logs. Time in seconds. Blanks stand
for time or memory out. Only 13 of the 90 Dispose-n-m instances shown, At
IPC6, size n of grid ranged from 2 to 10, while number m of objects, from 1 to
10. T0 scales up best on n and worst on m.

657

fiPalacios & Geffner

a correspondence exists between the conformant plans for P that use such actions at most
once with the conformant plans for P 0 that use the same actions at most once too. On the
other hand, a conformant plan for P 0 where these actions are done many times will not
necessarily represent a conformant plan for P . Indeed, if a non-deterministically moves an
agent up or right in a square grid n  n, starting in the bottom left corner, n actions a in
a row would leave the agent at either the top left corner or the bottom right corner in P 0 ,
and anywhere at Manhattan distance n from the origin in P. The divergence between P
and P 0 , however, does not arise if non-deterministic actions are executed at most once.
Building on this idea, a non-deterministic conformant planner can be obtained from a
deterministic conformant planner in the following way. For the non-deterministic problem
P , let P1 be the problem P 0 above, with the additional constraint that the actions a in
P1 arising from the non-deterministic actions in P can be executed at most once. This
is easily achieved by adding a precondition enabled(a) to a that is true initially and that
a sets to false. Let then P2 represent the deterministic conformant problem where each
non-deterministic action a in P is mapped into 2 deterministic actions, each executable
only once, and each having its own hidden fluents h1 , . . . , hm with the oneof (h1 , . . . , hm )
expression in the initial situation. Similarly, let Pi be the deterministic problem that results
from encoding each non-deterministic action in P with i deterministic copies.
From this encoding, a simple iterative conformant planner for non-deterministic problems P can be defined in terms of a conformant planner for deterministic problems by
invoking the latter upon P1 , P2 , P3 , and so on, until a solution is reported. The reported
solution uses each copy of a non-deterministic action at most once, and thus encodes a
solution to the original problem.
We have implemented this strategy on top of T0 with an additional refinement that
takes advantage of the nature of the KT,M translation, where assumptions about the initial
situation are maintained explicitly in tags. Basically, non-deterministic actions a in Pi are
allowed to be executed more than once provided that all the literals KL/hi that depend
on a particular outcome of these actions (Si ) are erased. This is implemented by means
of an additional reset(a) action in Pi whose unconditional effect is enabled(a) (i.e., the
action a can then be done again) and whose conditional effects are KL  KL/hi and
KL  KL/hi for i = 1, . . . , m. Namely, literals KL/hi where the truth of L depends
on a particular non-deterministic outcome (Si ) are erased, except when L is true with no
assumptions; i.e. when KL is true. Then non-deterministic actions a can be executed more
than once in a plan provided that each occurrence of a, except for the first one, is preceded
by a reset(a) action.
Table 12 compares the resulting non-deterministic planner with MBP and KACMBP
on a number of non-deterministic problems considered in the MBP and KACMBP papers.
We have just added an additional domain, Slippery Gripper (sgripper), that is similar to
classical Gripper where a number of balls have to be moved from room A to B, except
that the robot cannot move from A to B directly, but has a non-deterministic move action
move(A, C, D) that moves the robot from A to either C or D. A typical plan for moving
two balls from A to B is to pick them at A, move to C or D, move from C to B, and from
D to B, finally dropping the balls at B.
For the deterministic conformant planner (T0 ) used in the non-deterministic setting we
added the following modification: merges are not introduced only for precondition and goal
658

fiCompiling Uncertainty Away in Conformant Planning Problems

Problem
sgripper-10
sgripper-20
sgripper-30
btuc-100
btuc-150
btuc-200
btuc-250
btuc-300
bmtuc-10-10
bmtuc-20-10
bmtuc-20-20
bmtuc-50-10
bmtuc-50-50
bmtuc-100-10
bmtuc-100-50
bmtuc-100-100
nondet-ring-5
nondet-ring-10
nondet-ring-15
nondet-ring-20
nondet-ring-50
nondet-ring-1key-5
nondet-ring-1key-10
nondet-ring-1key-15
nondet-ring-1key-20
nondet-ring-1key-25
nondet-ring-1key-30

T0
time len
1,4
48
16,7
93
90
138
2,9
200
9,2
300
23
400
44,6 500
82
600
0,1
20
0,1
40
0,3
40
0,9
100
3,3
100
4,9
200
14,9 200
30,2 200
18,3
19
> 2h
> 2h


> 2h
> 2.1GB





MBP
time
len
> 2h
> 2h

> 2h
> 2h



65,9
29
> 2h
> 2h





0
18
2,1
38
1298,9 58
> 2h

0,1
33
11,2
122
5164,4 87
> 2.1GB



KACMBP
time
len
0,6
68
5,4
148
23,3
228
2
200
7,9
300
16,9
400
33,2
500
62,1
600
0,2
20
0,6
40
2,2
40
3,6
100
2722,4 100
25,1
200
> 2h
> 2h
0,1
32
0,5
112
2,4
242
7,3
422
603,1 2552
0,2
42
4
197
33,7
375
246,5 1104
1417,5 2043
> 2h

Table 12: Non-deterministic problems. All problems except sgripper are from MBP and
KACMBP. These problems were modified to render a simple translation into
PDDL; in particular, complex preconditions were moved in as conditions. Times
reported in seconds and rounded to the closest decimal.  means time or memory
out for smaller instances.

literals but for all literals. The reason is that in this setting it pays to remove the uncertainty
of all literals when the reset mechanism is used. Indeed, provided with this simple change
and the reset mechanism, in none of the problems we had to move beyond P1 (a single copy
of each non-deterministic action) even if in all the domains non-deterministic actions are
required many times in the plans (e.g., if there are more than 2 balls in room A).
As it can be seen from the table, T0 does better than MBP on these collection of nondeterministic domains, although not as well as KACMBP, in particular, in the NonDetRing and Non-Det-Ring-1Key domains. In any case, the results obtained with T0 on these
domains are quite meaningful. In all cases where T0 failed to solved a problem, the reason
was that the classical planner (FF) got lost in the search for plans, something that may
improve with further advances in classical planning technology.

659

fiPalacios & Geffner

11. Related Work
Most recent conformant planners such as CFF, POND, and MBP cast conformant planning
as an heuristic search problem in belief space (Bonet & Geffner, 2000). Compact belief
representations and informed heuristic functions, however, are critical for making these approach work. As an effective belief representation, these planners use SAT and OBDDs
techniques that while intractable in the worst case often exhibit good behavior on average.
As heuristics, on the other hand, they use fixed cardinality heuristics that count the number
of states that are possible for a given belief state (a tractable operation on OBDD representations) or heuristics obtained from a relaxed planning graph suitably extended to take
uncertain information into account. These heuristics appear to work well in some domains
but not in others. From this perspective, the translation-based approach provides a handle
on the two problems: belief states in P become plain states in the translation KT,M (P ),
that is then solved using classical heuristics. We have also established the conditions under
which this belief representation is compact and complete.
A sound but incomplete approach to planning with incomplete information is advanced
by Petrick and Bacchus (2002) that represent belief states as formulas. In order to make
belief updates efficient though, several approximations are introduced, and in particular,
while existing disjunctions can be carried from one belief to the next, no new disjunctions
are added. This imposes a limitation on the type of problems that can be handled. The
two other limitations of this approach are that domains must be crafted by hand, and that
no control information is derived from the domains so that the search for plans is blind.
Our approach can be understood as providing a solution to these two problems too: on
the one hand, the move to the knowledge-level is done automatically, on the other, the
problem lifted to the knowledge-level is solved by classical planners able to search with
control information derived automatically from the new representation.
A third thread of work related to our approach arises from the so-called 0-approximation
semantics (Baral & Son, 1997). In the 0-approximation semantics, belief states b are represented not by sets of states but by a single 3-valued state where fluents can be true, false, or
unknown. In Proposition 3 above, a correspondence was established between the plans for
P that are conformant according to the 0-approximation semantics and the classical plans
for the translation K0 (P ), which in turns is an instance of the more general translation
Ki (P ) that is complete for problems with width i = 0. The semantics of the translation
K0 is thus related to the 0-approximation semantics, yet the K0 translation delivers something more: a computational method for obtaining conformant plans that comply with the
0-approximation semantics using a classical planner.
The 0-approximation and the basic K0 translation are too weak for dealing with the
existing benchmarks. The translations Ki extend K0 for problems of higher width by
replacing the set of fluents KL by fluents KL/t where the tags t encode assumptions about
the initial situation. The extensions of the 0-approximation semantics in the context of
conformant planning have taken a different form: switching from a single 3-valued state
for representing beliefs to sets of 3-valued states, each 3-valued state progressed efficiently
and independently of the others (Son, Tu, Gelfond, & Morales, 2005). The initial set of
3-valued states is obtained by forcing states to assign a boolean truth-value (true or false)
to a number of fluents. Crucial for this approach to work is the number of such fluents;
660

fiCompiling Uncertainty Away in Conformant Planning Problems

belief representation and update are exponential in it. The conditions that ensure the
completeness of this extension of the 0-approximation semantics can be expressed in terms
of a relevance analysis similar to the one underlying our analysis of width (Son & Tu,
2006): the fluents that must be set to true or false in each initial 3-valued state are those
appearing in a clause in CI (L) for a precondition or goal literal L. In particular, if in the
initial situation there are n tautologies pi pi , each relevant to a precondition or goal literal
L, then the number of initial 3-valued states required for completeness is exponential in n, as
each has to make each fluent pi true or false. The difference with our approach can be seen
when each of the tautologies pi  pi is relevant to a unique precondition or goal literal Li .
In such a case, the number of 3-valued or partial states required for completeness remains
exponential in n, while the resulting problem has width 1 and thus can be solved with the
K1 translation that involves tags with a single literal. In other words, while the tags used
in our translation scheme encode the local contexts required by the different literals in the
problem, the initial 3-valued states (Son & Tu, 2006) encode their possible combinations in
the form of global contexts. These global contexts correspond to the consistent combinations
of such local contexts, which may thus be exponential in number even if the problem has
bounded width. The planners CpA(H) and CpA(C), discussed above in the context of
the Conformant Track of the recent 2008 Int. Planning Competition (IPC6), build on this
approach, but reduce the number of partial initial states required using a technique that can
replace many one-of expressions by a single one (Tran et al., 2008, 2009); a simplification
related to the notion of critical initial states discussed in Section 7.
Another difference with the 3-valued approach (Son et al., 2005; Son & Tu, 2006), is
that the translation approach not only addresses the representation of beliefs but also the
computation of conformant plans: once a conformant problem P is translated into a problem
KT,M (P ), it can be solved by a classical planner. The approaches that have been defined on
top of the 0-approximation semantics, like the knowledge-level approach to planning with
incomplete information by Petrick and Bacchus (2002), need a way to guide the search for
plans in the simplified belief space. While the search by Petrick and Bacchus (2002) is blind
(iterative deepening), the search by Son et al. (2005), Son and Tu (2006) is guided by a
combination of simple heuristics such as cardinality or subgoal counting.

12. Summary
While few practical problems are purely conformant, the ability to find conformant plans is
needed in contingent settings where conformant situations are an special case. In this paper,
we have introduced a new approach to conformant planning where conformant problems P
are converted into classical planning problems KT,M (P ) that are then solved by a classical
planner. We have also studied the conditions under which this general translation is sound
and complete. The translation depends on two parameters: a set of tags, referring to local
contexts in the initial situation, and a set of merges that stand for valid disjunctions of
tags. We have seen how different translations, such as KS0 and Kmodels, can be obtained
from suitable choices of tags and merges, and have introduced a measure of complexity in
conformant planning called conformant width, and a translation scheme Ki that is polynomial for a fixed i and complete for problems with width bounded by i. We have also shown
that most conformant benchmarks have width 1, have developed a conformant planner T0
661

fiPalacios & Geffner

based on these translations, and have shown that this planner exhibits a good performance
in comparison with existing conformant planners. Recently, we have explored the use of
these ideas in the more general setting of contingent planning (Albore, Palacios, & Geffner,
2009).

Acknowledgments
We thank Alex Albore for help with the syntax of MBP and KACMBP, and Pierre Marquis
for kindly answering a question about the complexity of a deductive task. We also thank
the anonymous reviewers for useful comments. H. Geffner is partially supported by grant
TIN2006-15387-C03-03.

Appendix A. Proofs
P below stands for a conformant planning problem P = hF, I, O, Gi and KT,M (P ) =
hF 0 , I 0 , O0 , G0 i for its translation. Propositions and theorems in the body of the paper
appear in the appendix with the same numbers; while new lemmas and propositions have
numbers preceded by the letters A and B (for Appendix A and B). The conformant problem
P and the classical problems P/s and KT,M (P ) that arise from P are all assumed to be
consistent. Consistency issues are important, and they are addressed in more detail in the
second part of this appendix where it is shown that if P is consistent, KT,M (P ) is consistent
too (Appendix B). For a consistent classical problem P 0 , the standard progression lemma
applies; namely, a literal L is achieved by an applicable action sequence +1 = , a, where
 is an action sequence and a is an action iff A)  achieves C for a rule a : C  L in P 0 ,
or B)  achieves L and the negation L0 of a literal L0 in the body C 0 of each rule in P 0 of
the form a : C 0  L (see Theorem B.2 below).
Lemma A.1. Let  be an action sequence applicable in both P and K0 (P ). Then if 
achieves KL in K0 (P ),  achieves L in P .
Proof. By induction on the length of . If  is empty and  achieves KL in K0 (P ), then
KL must be in I 0 , and hence L must be in I, so that  achieves L in P .
Likewise, if +1 = , a achieves KL in K0 (P ) then A) there is rule a : KC  KL in
K0 (P ), such that  achieves KC in K0 (P ); or B)  achieves KL in K0 (P ) and for each
rule a : KC 0  KL in K0 (P ),  achieves KL0 in K0 (P ) for some L0 in C 0 .
If A) is true, then P must contain a rule a : C  L, and by inductive hypothesis, 
must achieve C in P , and therefore, +1 = , a must achieve L in P . If B) is true, by
inductive hypothesis,  must achieve L in P along with L0 for some literal L0 in the body
C 0 of each rule a : C 0  L, and thus +1 = , a must achieve L in P too.
Lemma A.2. If an action sequence  is applicable in K0 (P ), then  is applicable in P .
Proof. If  is empty, this is trivial. Likewise, if +1 = , a is applicable in K0 (P ),  is
applicable in K0 (P ), and thus by inductive hypothesis,  is applicable in P . Also since,
, a is applicable in K0 (P ),  must achieve the literals KL in K0 (P ) for each precondition
L of a, but then from Lemma A.1,  must achieve the literals L for the same preconditions
in P , and thus, the sequence +1 = , a is applicable in P .
662

fiCompiling Uncertainty Away in Conformant Planning Problems

Proposition 2 If  is a classical plan for K0 (P ), then  is a conformant plan for P .
Proof. Direct from Lemma A.2 once we consider a problem P 0 similar to P but with a new
dummy action aG whose preconditions are the goals G of P . Then if  is a plan for K0 (P ),
, aG is applicable in K0 (P 0 ), and by Lemma A.2, , aG is applicable in P 0 , which implies
that  is applicable in P and achieves G, and thus, that  is a plan for P .
Proposition 3 An action sequence  is a classical plan for K0 (P ) iff  is a conformant
plan for P according to the 0-approximation semantics.
Proof. Let us say that an action sequence  = a0 , . . . , an is 0-applicable in P and 0-achieves
a literal L in P if the belief sequence b0 , . . . , bn+1 generated according to the 0-approximation
semantics is such that the preconditions of the actions ai in  are true in bi , and the goals
are true in bn+1 respectively. From the definition of the 0-approximation semantics (and
the consistency of P ), an applicable action sequence  thus 0-achieves a literal L in P iff 
is empty and L  I, or  =  0 , a and A) a : C  L is an effect of P and  0 0-achieves each
literal L0 in C, or B)  0 0-achieves L and for all effects a : C 0  L in P ,  0 0-achieves L0
for some L0  C 0 . These, however, are the conditions under which  achieves the literal KL
in K0 (P ) once a sequence 0-achieving a literal L in P  is replaced by a sequence achieving
the literal KL in K0 (P ). Thus, an action sequence  that is applicable in K0 (P ) and
0-applicable in P achieves a literal KL in K0 (P ) iff  0-achieves the literal L in P , while 
is applicable to K0 (P ) iff it is 0-applicable to P , with the last part following from the first
using induction on the plan length.
Definition A.3. For an action a in P , define a to be the action sequence where a is
followed by all merges in KT,M (P ) in arbitrary order. Similarly, if  = a0 , . . . , ai is an
action sequence in P , define   to be the action sequence   = a0 , . . . , an in KT,M (P ).
Lemma A.4. Let  be an action sequence such that  is applicable in P and   is applicable
in a valid translation KT,M (P ). If   achieves KL/t in KT,M (P ), then  achieves L in
P/s for all possible initial states s that satisfy t.
Proof. For an empty , if   achieves KL/t, from the definition of KT,M (P ) and since
I |= t  L, L must be in any such s, and thus  must achieve L in P/s.

Likewise, if +1 = , a and t is not the empty tag, +1
=   , a achieves KL/t in

KT,M (P ) iff A)  achieves KC/t in KT,M (P ) for a rule a : KC/t  KL/t in KT,M (P ),
or B)   achieves KL/t, and for any rule a : KC 0 /t  KL/t,   achieves KL0 /t in
KT,M (P ) for some L0 in C 0 (merge actions do not delete positive literals KL/t).
If A, by inductive hypothesis,  achieves C in P/s for each possible initial state s that
satisfies t, and hence +1 = , a achieves L in P/s from the rule a : C  L that must be in
P . If B, by inductive hypothesis,  achieves L and L0 in P/s, for some L0 in the body of
each rule a : C 0  L in P , and thus +1 = , a achieves L in P/s.
V
For the empty tag t = , a third case must be considered: a merge action t0 m KL/t0 
 =   , a achieving KL in K
KL in a may be the cause for the action sequence +1
T,M (P ).



In such a case, the sequence  , a, and hence  , a , must achieve KL/t0 for each (nonempty) t0  m in KT,M (P ), and hence from the inductive hypothesis and the two cases
above, the sequence , a must achieve L in P/s for each possible initial state s that satisfies
663

fiPalacios & Geffner

any such t0 . Yet, since the merge m is valid, all possible initial states s must satisfy one
such t0 , and thus  must achieve L in P/s for all possible initial states s, that are the initial
states that satisfy t = .
Lemma A.5. If   is applicable in a valid translation KT,M (P ), then  is applicable in P .
 =   , a is applicable in K
Proof. If  is empty, this is direct. For +1 = , a, if +1
T,M (P ),

then  is applicable in KT,M (P ), achieving KL for each precondition L of a, and hence
from the inductive hypothesis,  is applicable in P , and from Lemma A.4,  must achieve
L for each precondition L of a, and thus +1 = , a is applicable in P .

Theorem 7 The translation KT,M (P ) is sound provided that all merges in M are valid
and all tags in T are consistent.
Proof. Consider the problem P 0 that is similar to P but with a new dummy action aG
whose preconditions are the goals G of P . We have then that   is a plan for KT,M (P ) iff
1 , aG is applicable in KT,M (P 0 ), which from Lemma A.5 implies that , aG is applicable
in P 0 , which means that  is a plan for P .
Lemma A.6. Let  be an action sequence such that  is applicable in P and   is applicable
in KS0 (P ). If  achieves L in P/s for some possible initial state s,   achieves KL/s in
KS0 (P ).
Proof. If  is empty and  achieves L in P/s, then L  s, and since I |= s  L, KL/s must
be in I 0 and thus   achieves KL/s in KS0 (P ).
Likewise, if +1 = , a achieves L in P/s then A) there is rule a : C  L such that
 achieves C in P/s; or B)  achieves L and for any rule a : C 0  L,  achieves L0 in
KS0 (P ) for some L0  C 0 .
If A), by inductive hypothesis,   achieves KC/s in KS0 (P ) and, from rule a : KC/s 
 =   , a achieves KL/s (merges in a do
KL/s,   , a must achieve KL/s, and thus, +1
not delete positive literals KL/t).
If B), by inductive hypothesis,   achieves KL/s and KL0 /s in KS0 (P ) for some L0
in the body of each rule a : C 0  L in P , and therefore   , a achieves KL/s, and so does
 =   , a .
+1
Lemma A.7. If  is applicable in P ,   is applicable in KS0 (P ).
Proof. If  is empty, this is trivial. If +1 = , a is applicable in P , then  must be
applicable in P and must achieve each precondition L of a in P/s for every possible initial
state s, s  S0 . From the inductive hypothesis,   must then be applicable in KS0 (P ),
and from Lemma A.6, it V
must achieve the literals KL/s for all s  S0 , and then, the last
merge action with effect sS0 KL/s  KL in   must achieve KL, and so does   , and
therefore,   , a is applicable in KS0 (P ).
Theorem 9 If  is a conformant plan for P , then there is a classical plan  0 for KS0 (P )
such that  is the result of dropping the merge actions from  0 .
664

fiCompiling Uncertainty Away in Conformant Planning Problems

Proof. Direct from Lemma A.7 if we consider a problem P 0 similar to P but with a new
action aG whose preconditions are the goals G of P . If  is a plan for P , the sequence , aG
is applicable in P 0 , and from Lemma A.7,   , aG is applicable in KS0 (P 0 ), and thus   is a
plan for KS0 (P ).
Definition A.8. rel(s, L) stands for the set of literals L0 in s that are relevant to L in P :
rel(s, L) = {L0 | L0  s and L0 is relevant to L} .
Definition A.9. t stands for the deductive closure of t under I:
t = { L | I, t |= L} .
Theorem A.10. Let m = {t1 , . . . , tn } be a covering merge for a literal L in a valid translation KT,M (P ) for a problem P whose initial situation is in prime implicate form. Then
for each tag ti in m there must be a possible initial state s of P such that rel(s, L)  ti .
Proof. Assume otherwise that each state s satisfying I makes true a literal Ls relevant to
L such that Ls 6 ti . If we then take c to be the disjunction of such literals Ls over all the
states s that satisfy I, we obtain that I entails c, which since I is in prime implicate form,
means that c contains a tautology c0 or is subsumed by a clause c00 in I. But, in either case,
this is a contradiction, as all the literals in c0 or c00 are relevant to L, and hence ti , where ti
is part of the covering merge m, must contain a literal in either c0 or c00 , and hence in c.
Lemma A.11. Let  be an action sequence such that  is applicable in P and   is applicable in a covering translation KT,M (P ). Then, if  achieves L in P/s for some possible
initial state s and there is a tag t in T such that rel(s, L)  t ,   achieves KL/t in
KT,M (P ).
Proof. If  is empty and  achieves L in P/s, then L is in s and thus, in rel(s, L). Since
rel(s, L)  t , then L  t , and thus KL/t is in the initial situation I 0 of KT,M (P ), and
  achieves KL/t in KT,M (P ). Likewise, if +1 = , a achieves L in P/s, then A) there
is a rule a : C  L in P such that  achieves C in P/s, or B)  achieves L in P/s and
for each rule a : C 0  L,  achieves L0 in P/s for some L0 in C 0 . If A, by inductive
hypothesis,   achieves KC/t, and from the support rule a : KC/t  KL/t in KT,M (P ),
 =   , a , as the merges in a cannot
  , a must achieve KL/t in KT,M (P ), and so must +1
delete a positive literal KL/t. If B, by inductive hypothesis,   achieves KL/t, and for each
cancellation rule a : KC 0 /t  KL/t arising from the rule a : C 0  L in P ,   must
 =   , a ,
achieve KL0 /t for some literal L0  C 0 . This means that   , a, and therefore, +1
must achieve KL/t.
Lemma A.12. Let KT,M (P ) be a covering translation of P . Then if  is applicable in P ,
  is applicable in KT,M (P ).
Proof. If  is empty, this is direct. Else, if +1 = , a is applicable in P , then  must be
applicable in P where it must achieve each literal L in P re(a), and therefore, by inductive
hypothesis   must be applicable in KT,M (P ). Then, let m = {t1 , . . . , tn } be a covering
merge for L  P re(a) in KT,M (P ). From Theorem A.10, for each ti  m there must be a
665

fiPalacios & Geffner

possible initial state s such that rel(s, L)  ti , and then from Lemma A.11,  achieving L in
P/s implies   achieving KL/ti in KT,M (P ). Since this is true for all ti  m and  achieves
L  P re(a) in P/s for all possible initial states s, then it follows that   achieves KL/ti
for all ti  m in KT,M (P ), and therefore that   achieves KL in KT,MV(P ) as   ends with
a sequence of merges that include the action merge am,L with effect ti m KL/ti  KL.
 =   , a is applicable in K
As a result, +1
T,M (P ).
Theorem 15 Covering translations KT,M (P ) are complete; i.e., if  is a conformant plan
for P , then there is a classical plan  0 for KT,M (P ) such that  is  0 with the merge actions
removed.
Proof. The theorem follows trivially from Lemma A.12 by having a problem P 0 that is like
P but with an additional, dummy action aG such that the goals G of P are the preconditions
of aG . The action sequence  is a plan for P iff the action sequence , aG is applicable in P 0 ,
which due to Lemma A.12 implies that the action sequence   , aG is applicable in KT,M (P 0 )
which in turn is true iff the action sequence   is a plan for KT,M (P ). The sequence , in
turn, is the sequence   with all the merge actions removed.
Theorem 17 The translation Kmodels(P ) is sound and complete.
Proof. Direct from the merges m generated by Kmodels for each precondition and goal
literals L. Clearly these merges are all valid, their tags are consistent with I, and they
cover L (the models of CI (L) all satisfy CI (L)). Thus the result follows from Theorems 7
and 15.
Proposition 21 The width w(P ) of P can be determined in time that is exponential in
w(P ).
Proof. If m is the number of clauses in CI (L), then there are at most mi sets of clauses C in
CI (L) such that |C| = i. Each clause in one such set must have at most n literals, where n is
the number of fluents in P , and hence, if one literal from each clause in C is collected, we end
up with at most ni sets of literals of size no greater than i, some of which are inconsistent
with I and some of which are consistent and minimal (no other consistent set in the collection
is properly included); both tests being polynomial given that I is in prime implicate form.
Thus constructing the cover c(C) for a set of clauses C with |C| = i is exponential in i,
while checking whether one such cover satisfies CI (L) is a polynomial operation provided
that I is in prime implicate form. Indeed, if c(C) = {t1 , . . . , tn }, computing the closures
ti for each ti  c(C), when I is in PI, and testing whether each ti intersects each clause
in CI (L) are polynomial operations (the former reducing to checking for each literal L0
whether I |= ti  L0 ). Thus for computing width(L), we generate all sets C of clauses
in CI (L) with |C| = i, starting with i = 0, increasing i one by one until for one such set,
c(C) satisfies CI (L). This computation is exponential in w(L), and the computation over
all preconditions and goal literals in P is exponential in w(P ).
Proposition 22 The width of P is such that 0  w(P )  n, where n is the number of
fluents whose value in the initial situation is not known.
666

fiCompiling Uncertainty Away in Conformant Planning Problems

Proof. The inequality 0  w(P ) is direct as w(L) is defined as the size |C| of the minimal set
of clauses C in CI (L) such that c(C) satisfies CI (L), and w(P ) = w(L) for some precondition
and goal literal L. The inequality w(P )  n follows by noticing that for the set C of clauses
given by the tautologies L0  L0 in CI (L), c(C) must satisfy each clause c in CI (L), as each
t  c(C) must assign a truth value to each literal in c, and if inconsistent with c, it will be
inconsistent with I and thus pruned from c(C). Finally, the max number of such tautologies
in CI (L) is the number of fluents L0 such that neither L0 nor L0 are unit clauses in I.
Theorem 24 For a fixed i, the translation Ki (P ) is sound, polynomial, and if w(P )  i,
covering and complete.
Proof. For soundness, we just need to prove that all merges m in Ki (P ) are valid and that
all tags t in Ki (P ) are consistent. The soundness follows from Theorem 7. The merges
m for a literal L in Ki (P ) are given by the covers c(C) of collections C of i or less clauses
in Ci (L) and clearly since
each model M of I must satisfy CI (L), it must satisfy some
W
t  c(C) so that I |= tm t for m = c(C). At the same time, from the definition of the
cover c(C), each of these tags t must be consistent with I.
For proving that Ki is polynomial for a fixed i, we follow ideas similar to the ones used
in the proof of Proposition 21 above, where we have shown that the width of P can be
determined in time that is exponential in w(P ) and polynomial in the number of clauses
and fluents in P . For a fixed i, the number of sets of clauses C in CI (L) with size |C|  i is
polynomial, and the complexity of computing the covers c(C) for such sets, and hence, the
merges m for L in Ki (P ) is polynomial too. Thus, the whole translation Ki (P ) for a fixed
i is polynomial in the number of clauses, fluents, and rules in P .
Finally, for proving completeness, if w(P )  i, then w(L)  i for each precondition and
goal literal L in P . Therefore, for each such literal L, there is a set C of clauses in CI (L)
such that c(C) satisfies CI (L). The translation Ki (P ) will then generate a unique merge
for L that covers L. Since Ki (P ) is a valid translation, this means that Ki (P ) is a covering
translation, that is then complete, by virtue of Theorem 15.
Lemma A.13. If L0 is relevant to L and rel(s, L)  rel(s0 , L), then rel(s, L0 )  rel(s0 , L0 ).
Proof. If L00 is in rel(s, L0 ), then L00 is relevant to L0 , and since L0 is relevant to L and the
relevance relation is transitive, L00 is relevant to L. Thus, L00 is in rel(s, L) and therefore,
since rel(s, L)  rel(s0 , L), L00 is in rel(s0 , L). But then L00 is in s0 and since it is relevant
to L0 , L00 is in rel(s0 , L0 ).
Proposition 26 Let s and s0 be two states and let  be an action sequence applicable in
the classical problems P/s and P/s0 . Then if  achieves a literal L in P/s0 and rel(s0 , L) 
rel(s, L),  achieves the literal L in P/s.
Proof. By induction on the length of . If  is empty, and  achieves a literal L in P/s0 , L
must be in s0 , and since L is relevant to itself, L  rel(s0 , L). Then as rel(s0 , L)  rel(s, L),
L must be in s, and thus  achieves L in P/s.
667

fiPalacios & Geffner

Likewise, if +1 = , a achieves L in P/s0 then A) there is rule a : C  L such that 
achieves C in P/s0 ; or B)  achieves L in P/s0 and for any rule a : C 0  L,  achieves
L0 in P/s0 for some L0  C 0 .
If A,  must achieve each literal Li  C in P/s0 . Since Li is relevant to L and rel(s0 , L) 
rel(s, L), by Lemma A.13, rel(s0 , Li )  rel(s, Li ). Then, by inductive hypothesis, the plan
 must achieve Li in P/s for each Li  C, and thus +1 = , a must achieve L in P/s
If B, since each such L0 is relevant to L (as L0 is relevant to L), and rel(s0 , L) 
rel(s, L), by Lemma A.13, rel(s0 , L0 )  rel(s, L0 ), and thus by inductive hypothesis, 
must achieve L0 in P/s and also L, so that +1 = , a must achieve L in P/s.
Lemma A.14. If S and S 0 are two collection of states such that for every state s in S and
every precondition and goal literal L in P , there is a state s0 in S 0 such that rel(s0 , L) 
rel(s, L), then if  is applicable in P/S 0 ,  is applicable in P/S.
Proof. By induction on the length of . If  is empty, it is obvious. If +1 = , a is applicable
in P/S 0 , then  is applicable in P/S 0 and, by inductive hypothesis,  is applicable in P/S.
We need to prove that  achieves the preconditions of action a in P/S.
For any L  P rec(a) and any s  S, from the hypothesis, there is a state s0  S 0 such
that rel(s0 , L)  rel(s, L). From Proposition 26, and since  achieves L in P/s0 ,  must
achieve L in P/s. Since the argument applies to any s  S,  achieves L in P/S, and thus
+1 = , a must be applicable in P/S.
Proposition 27 If S and S 0 are two collections of states such that for every state s in S
and every precondition and goal literal L in P , there is a state s0 in S 0 such that rel(s0 , L) 
rel(s, L), then if  is a plan for P that conforms with S 0 ,  is a plan for P that conforms
with S.
Proof. From Lemma A.14, we consider a problem P 0 similar to P but with a new action
aG whose preconditions are the goals G of P . If  is a plan for P that conforms with S 0 ,
then the action sequence , aG is applicable in P 0 /S 0 , and then from the lemma, , aG is
applicable in P 0 /S, and thus  must be a plan for P/S
Proposition 28 S 0 is a basis for P if for every possible initial state s of P and every
precondition and goal literal L in P , S 0 contains a state s0 such that rel(s0 , L)  rel(s, L).
Proof. Direct from Proposition 27, by considering S to be the set of possible initial states
of P .
Proposition 29 If the initial situation I is in prime implicate form and m = {t1 , . . . , tn }
is a merge that covers a literal L in P , then the set S[ti , L] of possible initial states s of P
such that rel(s, L)  ti is non-empty.
Proof. Direct from Theorem A.10.
Theorem 30 Let KT,M (P ) be a covering translation and let S 0 stand for the collection of
states s[ti , L] where L is a precondition or goal literal of P and ti is a tag in a merge m
that covers L. Then S 0 is a basis for P .
668

fiCompiling Uncertainty Away in Conformant Planning Problems

Proof. We show that for every possible initial state s and any precondition and goal literal
L, S 0 in the theorem contains a state s0 such that rel(s0 , L)  rel(s, L). The result then
follows from Proposition 28. Indeed, any such state s must satisfy a tag ti in a covering
merge m = {t1 , . . . , tn } for L, as these merges are valid. But from Theorem A.10, there must
be a possible initial state s0 such that rel(s0 , L)  ti , and therefore, rel(s0 , L)  rel(s, L) as
s must satisfy ti and possibly other literals L0 that are relevant to L.
Theorem 31 If P is a conformant planning problem with bounded width, then P admits
a basis of polynomial size.
Proof. If w(P )  i for a fixed i, Ki (P ) is a covering translation with a polynomial number
of merges and tags, and in such case, the basis S 0 for P defined by Theorem 30 contains a
polynomial number of states, regardless of the number of possible initial states.

Appendix B. Consistency
We have been assuming throughout the paper that the conformant planning problems P
and their translations KT,M (P ) are consistent. In this section we make this notion precise,
explain why it is needed, and prove that KT,M (P ) is consistent if P is. For the proof, we
take into account that the heads KL of the merge actions am,L in KT,M (P ), are extended
with the literals KL0 for the literals L0 that are mutex with L in P (see Definition 4).
We start at the beginning assuming that states are not truth-assignments but sets of
literals over the fluents of the language. A state is complete if for every literal L, L or L is
in s, and consistent if for no literal both L and L are in s. Complete and consistent
states represent truth-assignments over the fluents F and the consistency of P and of
the translation KT,M (P ) ensures that all applicable action sequences  map complete and
consistent states s into complete and consistent states s0 . Once this is guaranteed, complete
and consistent states can be referred to simply as states which is what we have done in the
paper.
Given a complete state s and an action a applicable in s, the next state sa is
sa = (s \ Del(a, s))  Add(a, s)
where
Add(a, s) = {L | a : C  L in P and C  s}
and
Del(a, s) = {L | L  Add(a, s)} .
It follows from this that sa is a complete state if s is a complete state, as the action a
only deletes a literal L in s if L is added by a in s. On the other hand, s may be consistent
and sa inconsistent, as for example, when there are rules a : C  L and a : C 0  L such
that both C and C 0 are in s. In order to exclude this possibility, ensuring that all reachable
states are complete and consistent, and thus represent genuine truth assignments over the
fluents in F , a consistency condition on P is needed:
Definition B.1 (Consistency). A classical or conformant problem P = hF, I, O, Gi is consistent if the initial situation I is logically consistent and every pair of complementary
literals L and L is mutex in P .
669

fiPalacios & Geffner

In a consistent classical problem P , all the reachable states are complete and consistent,
and the standard progression lemma used in the preceding proofs holds:
Theorem B.2 (Progression). An action sequence +1 = , a applicable in the complete and
consistent state s achieves a literal L in a consistent classical problem P iff A)  achieves
the body C of a rule a : C  L in P , or B)  achieves L and for every rule a : C 0  L,
 achieves L0 for a literal L0 in C 0 .
We will see below that if a conformant problem P is consistent in this sense, so will be
any valid translation KT,M (P ). We have tested all the benchmarks considered in this paper
for consistency and found all of them to be consistent except for two domains that we have
introduced elsewhere: 1-Dispose and Look-and-Grab. In these cases, since the consistency
of the classical problem KT,M (P ) cannot be inferred from the consistency of P , it can
be checked explicitly using Definition B.1, or similarly, the plans that are obtained from
KT,M (P ) can be checked for consistency as indicated in Section 8: the soundness of these
plans is ensured provided that they never trigger conflicting effects KL/t and KL/t.10
Proof. The proof of Theorem B.2 does not rest on a particular definition of mutexes, just
that mutex atoms are not both true in a reachable state. In a consistent problem P , an
applicable action sequence  maps s into a complete and consistent state s0 that represents
a truth assignment. Then, the action sequence +1 = , a achieves L iff C) L  Add(a, s0 )
or D) L  s0 and L 6 Del(a, s0 ). Condition A in the theorem, however, is equivalent to C,
and Condition B in the theorem, is equivalent to D. Indeed, L 6 Del(a, s0 ) iff for each rule
a : C 0  L there is a literal L0  C 0 such that L0 6 s0 , which, given that s0 is complete and
consistent, is true iff L0  s0 (this is precisely where consistency is needed; else L0  s0
would not imply L0 6 s0 ).
The notion of mutex used in the definition of consistency expresses a guarantee that
a pair of literals is not true in a reachable state. Sufficient and polynomial conditions for
mutual exclusivity and other type of invariants have been defined in various papers, here
we follow the definition by Bonet and Geffner (1999).
Definition B.3 (Mutex Set). A mutex set is a collection R of unordered literals pairs
(L, L0 ) over a classical or conformant problem P such that:
1. for no pair (L, L0 ) in R, both L and L0 are in a possible initial state s,
2. if a : C  L and a : C 0  L0 are two rules for the same action where (L, L0 ) is a pair
in R, then P re(a)  C  C 0 is mutex in R, and
3. if a : C  L is a rule in P for a literal L in a pair (L, L0 ) in R, then either a) L0 = L,
b) P re(a)  C is mutex with L0 in R, or c) P re(a)  C implies C 0 in R for a rule
a : C 0  L0 in P ;
10. The consistency of the two domains, 1-Dispose and Look-and-Grab, can be established however if a
definition of mutexes slightly stronger than the one below is used. It actually suffices to change the
expression P re(a)  C in clause 3c) of the definition of mutex sets below by P re(a)  C  {L0 }.

670

fiCompiling Uncertainty Away in Conformant Planning Problems

In this definition, a pair is said to be mutex in R if it belongs to R, a set of literals S is
said to be mutex in R if S contains a pair in R, and a set of literals S is said to imply a set
of literals S 0 in R when S is mutex in R with the complement L of each literal L in S 0 \ S.
It easy to verify that if R1 and R2 are mutex sets, their union R1  R2 is a mutex set,
and thus that there is a maximal mutex set for P that we denote as R . The pairs in R
are just called mutexes.
For simplicity and without loss of generality, we will assume that preconditions P re(a)
are empty. Indeed, it is simple to show that the mutexes of a problem P remain the same
if preconditions are pushed in as conditions. We also assume that no condition C in a rule
C  L in P is mutex, as these rules can be simply pruned. In addition, we assume that no
literal L is mutex with a pair of complementary literals L0 and L0 , as then L cannot be
true in a reachable state, and thus, can be pruned as well.
The definition of mutexes is sound, meaning that no pair in a mutex set can be true in
a reachable state:
Theorem B.4. If (L, L0 ) is a pair in a mutex set R of a classical or conformant problem
P , then for no reachable state s in P , {L, L0 }  s.
Proof. We proceed inductively. Clearly, L and L0 cannot be part of a possible initial state, as
this is ruled out by the definition of mutex sets. Thus, let us assume as inductive hypothesis
that L and L0 are not part of any state s reachable in less than i steps, and let us prove
that the same is true for the states s0 = sa that are reachable from s in one step. Clearly if
L and L0 belong to s0 , then either A) both L and L0 belong to Add(a, s), or B) L belongs
to Add(a, s) and L0 belongs to s but not to Del(a, s). We show that this is not possible.
For A, P must comprise rules a : C  L and a : C 0  L0 such that C  C 0  s, yet from
the definition of mutex sets, C  C 0 must be mutex, and from the inductive hypothesis then
C  C 0 6 s. For B, there must be a rule a : C  L with C  s, but then from L0  s
and the inductive hypothesis, it follows that L0 is not mutex with C in R, and thus, from
the mutex set definition, that either L0 = L or C implies C 0 for a rule a : C 0  L0 . In
the first case, however, due to the rule a : C  L and C  s, L0  Del(a, s), while in the
second case, from the completeness of all reachable states, we must have C 0  s, and hence
L0  Del(a, s), contradicting B in both cases.
Provided that the initial situation I of a conformant planning problem P is in prime
implicate form, computing the largest mutex set R and testing the consistency of P are
polynomial time operations. For the former, one starts with the set of literal pairs and
then iteratively drops from this set the pairs that do not comply with the definition until
reaching a fixed point (Bonet & Geffner, 1999).
We move on now to prove that if a conformant problem P is consistent, so is a valid
translation KT,M (P ). The consistency of the classical problems P/s for possible initial
states s is direct, as the set of mutexes in P is a subset of the set of mutexes in P/s where
the initial situation is more constrained.
Proposition B.5 (Mutex Set RT ). For a valid translation KT,M (P ) of a consistent conformant problem P , define RT to be the set of (unordered) literals pairs (KL/t, KL0 /t0 ) and
(KL/t, KL0 /t) where (L, L0 ) is a mutex in P , and t and t0 are two tags jointly satisfiable
with I (I 6|= (t  t0 )). Then RT is a mutex set in KT,M (P ).
671

fiPalacios & Geffner

It follows from this that KT,M (P ) is consistent if P is consistent, as then L0 = L is
mutex with L in P , and so (KL/t, KL/t) must be a mutex in RT .
Theorem B.6 (Consistency KT,M (P )). A valid translation KT,M (P ) is consistent if P is
consistent.
The consistency of the translation K0 (P ) follows as a special case, as K0 (P ) is KT,M (P )
with an empty set of merges M and a set of tags T containing only the empty tag. We are
left to prove Proposition B.5.
Proof of Proposition B.5. We must show that the set RT comprised of the pairs (KL/t, KL0 /t0 )
and (KL/t, KL0 /t) for L0 mutex with L in P , and tags t and t0 jointly satisfiable with
I, is a set that complies with clauses 1, 2, and 3 of Definition B.3. We go one clause at a
time.
1. No pair in RT can be true initially in KT,M (P ) = hF 0 , I 0 , O0 , G0 i for jointly satisfiable
I, t, and t0 . Indeed, if both KL/t and KL0 /t0 are in I 0 there must be a possible initial
state satisfying t and t0 where L and L0 are true in contradiction with L and L0 being
mutex in P . Similarly, if KL/t is in I 0 but KL0 /t not, it must be the case that
I |= t  L and I 6|= t  L0 , so that there must be some possible initial state of P
where t, L, and L0 hold, a contradiction with L and L0 being mutex in P too.
2. If there is an action a with rules for KL/t and KL0 /t0 then the rules must be support
rules of the form a : KC/t  KL/t and a : KC 0 /t0  KL0 /t0 arising from rules
a : C  L and a : C 0  L0 in P .11 Then since L and L0 are mutex in P , C and C 0
must contain literals L1  C and L2  C 0 such that (L1 , L2 ) is a mutex in P , and
hence (KL1 /t, KL2 /t0 ) belongs to RT , so that KC/t and KC 0 /t0 are mutex in RT as
well.
Similarly, if there is an action with rules for KL/t and KL0 /t for a literal L0
mutex with L in P , the rules must be support and cancellation rules of the form
a : KC/t  KL/t a : KC 0 /t  KL0 /t, arising from rules a : C  L and
a : C 0  L0 in P . Since L and L0 are mutex in P , C and C 0 must contain literals
L1  C and L2  C 0 that are mutex in P , and hence RT must contain the pair
(KL1 /t, KL2 /t), so that KC/t and KC 0 /t must be mutex in RT .
3. We are left to show that the set RT given by the pairs (KL/t, KL0 /t0 ) and (KL/t,
KL0 /t) complies with clause 3 in the definition of mutex sets as well. Consider the
first class of pairs (KL/t, KL0 /t0 ) and a rule a : KC/t  KL/t for KL/t arising from
a rule a : C  L in P . Since L is mutex with L0 in P , then one of the conditions 3a,
3b, or 3c must hold for the rule a : C  L and L0 . If 3a, then L0 = L, and KC/t
must imply the body KC/t0 of the cancellation rule a : KC/t0  KL/t0 , as
for each literal L1 in C, RT must contain the pair (KL1 /t, KL1 /t0 ) so that KL1 /t
implies KL1 /t0 , and KC/t implies KC/t0 (case 3c). If 3b, then C and L0 are
11. The action a cannot be a merge for a literal L00 mutex with both L and L0 , as in such case, L00 implies
that L and L0 that are mutex. Similarly, a cannot be a merge for L as in such a case, L will be mutex
with both L0 and L0 . For the same reason, a cannot be a merge for L0 either. Thus, the action a above
cannot be a merge and must be an action from P .

672

fiCompiling Uncertainty Away in Conformant Planning Problems

mutex in P , and thus C contains a literal L1 mutex with L0 in P . This means that
the pair (KL1 /t, KL0 /t0 ) is in RT and hence that KC/t is mutex with KL0 /t0 in RT
(case 3b). Last, if 3c, C implies C 0 in P for a rule a : C 0  L0 , but then KC/t must
imply the body KC 0 /t0 of the cancellation rule a : KC 0 /t0  KL0 /t0 . Indeed,
for each literal L1 in both C and C 0 , we had above that KL1 /t implies KL1 /t0 ,
while if L2 is a literal in C 0 but not in C, then some literal L3  C must be mutex with
L2 in P , and hence the pair (KL3 /t, KL2 /t0 ) must be in RT and KL3 /t implies
then KL2 /t0 (case 3c)
0 0
Consider
V now the same pair (KL/t, KL /t ) along with a merge action am,L with a
rule ti m KL/ti  KL for KL/t = KL (thus t is the empty tag). In this case, since
the merge m is valid and t0 is consistent, there must be some ti  m such that ti and
t0 are jointly consistent with I. It follows then that (KL/ti , KL0 /t0 ) is a pair in RT
and thus that the body of the merge is mutex with KL0 /t0 in RT (case 3b).

There is no need to consider the pair (KL/t, KL0 /t0 ) along with the rules for KL0 /t0 ,
as the literals KL/t and KL0 /t0 have the same structure, and thus the same argument
above applies, replacing t with t0 and L with L0 .
We switch now to the second class of pairs (KL/t, K/L0 /t) and the rules a :
KC/t  KL/t for KL/t. Since L and L0 are mutex in P , then conditions 3a, 3b, or
3c must hold. If a, then L0 = L, and in such a case, condition 3c holds in KT,M (P )
as KC/t implies the body KC/t of the rule a : KC/t  KL0 (L0 = L). If b, C
is mutex with L0 , and thus there is a literal L1 in C such that L1 and L0 are mutex
in P , and therefore KC/t and KL0 /t are mutex in RT (case 3b). Finally, if c, C
implies C 0 for a rule a : C 0  L0 in P , then KC/t must imply KC 0 /t in RT for a
rule a : KC 0 /t  KL0 /t (case 3c).
For the empty tag t, the rule for KL/t may also be a merge, but then due to the extra
effects KL0 in the merge action for L, the merge for KL is also a merge for KL0 ,
and then case 3c holds.
Last, for the same class of pairs, the only rules for KL0 /t are cancellation rules of
the form a : KC 00 /t  KL0 /t for a rule a : C 00  L0 in P . Since L0 is mutex with
L in P , then conditions 3a, 3b, or 3c must hold for the rule a : C 00  L0 and L0 in P . If
a, then L = L0 , and the cancellation rule is then a : KC 00 /t  KL (case 3c). If
b, C 00 is mutex with L, and thus there is a literal L2 in C 00 such that (L2 , L) is a mutex
in P , and therefore KL/t implies KL2 /t in RT , and hence KL2 /t and KC 00 /t
imply KL/t in RT (case 3b). Finally, if c, C 00 implies C 0 for a rule a : C 0  L in P ,
and then KC 00 /t must imply KC 0 /t for a rule a : KC 0 /t  KL/t in RT .
Indeed, if LA implies LB in P , LB implies LA in P , and KLB /t implies KLA /t
in RT , and KLA /t implies KLB /t.

References
Albore, A., Palacios, H., & Geffner, H. (2009). A translation-based approach to contingent
planning. In Proc. 21st Int. Joint Conference on AI (IJCAI-09), pp. 16231628.
673

fiPalacios & Geffner

Baral, C., Kreinovich, V., & Trejo, R. (2000). Computational complexity of planning and
approximate planning in the presence of incompleteness. Artificial Intelligence, 122 (12), 241267.
Baral, C., & Son, T. C. (1997). Approximate reasoning about actions in presence of sensing
and incomplete information. In Proc. ILPS 1997, pp. 387401.
Bayardo Jr., R., & Schrag, R. (1997). Using CSP look-back techniques to solve real-world
sat instances. In Proc. AAAI, pp. 203208.
Bertoli, P., & Cimatti, A. (2002). Improving heuristics for planning as search in belief space.
In Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proc. AIPS-2002, pp. 143152.
AAAI Press.
Bonet, B., & Geffner, H. (1999). Planning as heuristic search: New results. In Proceedings
of ECP-99, pp. 359371. Springer.
Bonet, B., & Geffner, H. (2000). Planning with incomplete information as heuristic search
in belief space. In Proc. of AIPS-2000, pp. 5261. AAAI Press.
Bonet, B., & Geffner, H. (2001). Planning as heuristic search. Artificial Intelligence, 129 (1
2), 533.
Bonet, B., & Givan, B. (2006). Results of the conformant track of the 5th int. planning
competition. At http://www.ldc.usb.ve/bonet/ipc5/docs/results-conformant.pdf.
Bryce, D., & Buffet, O. (2008). International planning competition uncertainty part: Benchmarks and results. At http://ippc-2008.loria.fr/wiki/images/0/03/Results.pdf.
Bryce, D., Kambhampati, S., & Smith, D. E. (2006). Planning graph heuristics for belief
space search. Journal of Artificial Intelligence Research, 26, 3599.
Cimatti, A., Roveri, M., & Bertoli, P. (2004). Conformant planning via symbolic model
checking and heuristic search. Artificial Intelligence, 159, 127206.
Dechter, R. (2003). Constraint Processing. Morgan Kaufmann.
Goldman, R. P., & Boddy, M. S. (1996). Expressive planning and explicit knowledge. In
Proc. AIPS-1996, pp. 110117.
Haslum, P., & Jonsson, P. (1999). Some results on the complexity of planning with incomplete information. In Proc. ECP-99, Lect. Notes in AI Vol 1809, pp. 308318.
Springer.
Hoffmann, J., & Brafman, R. (2005). Contingent planning via heuristic forward search with
implicit belief states. In Proc. 15th Int. Conf. on Automated Planning and Scheduling
(ICAPS 2005), pp. 7180. AAAI.
Hoffmann, J., & Brafman, R. (2006). Conformant planning via heuristic forward search: A
new approach. Artificial Intelligence, 170 (6-7), 507541.
Hoffmann, J., & Nebel, B. (2001). The FF planning system: Fast plan generation through
heuristic search. Journal of Artificial Intelligence Research, 14, 253302.
Marquis, P. (2000). Consequence finding algorithms. In Gabbay, D., & Smets, P. (Eds.),
Handbook on Defeasible Reasoning and Uncertainty Management Systems, Vol. 5, pp.
41145. Kluwer.
674

fiCompiling Uncertainty Away in Conformant Planning Problems

Palacios, H., & Geffner, H. (2006). Compiling uncertainty away: Solving conformant planning problems using a classical planner (sometimes). In Proc. AAAI-06, pp. 900905.
Palacios, H., & Geffner, H. (2007). From conformant into classical planning: Efficient translations that may be complete too. In Proc. ICAPS-07, pp. 264271.
Petrick, R., & Bacchus, F. (2002). A knowledge-based approach to planning with incomplete
information and sensing. In Proc. AIPS-02, pp. 212221.
Rintanen, J. (2004). Complexity of planning with partial observability. In Proc. ICAPS2004, pp. 345354.
Smith, D., & Weld, D. (1998). Conformant graphplan. In Proceedings AAAI-98, pp. 889
896. AAAI Press.
Son, T. C., Tu, P. H., Gelfond, M., & Morales, A. (2005). Conformant planning for domains
with constraints: A new approach. In Proc. AAAI-05, pp. 12111216.
Son, T. C., & Tu, P. H. (2006). On the completeness of approximation based reasoning and
planning in action theories with incomplete information.. In Proc. 10th Int. Conf. on
Principles of KR and Reasoning (KR-06), pp. 481491.
Tison, P. (1967). Generalized consensus theory and applications to the minimization of
boolean circuits. IEEE Transactions on Computers, EC-16 (4), 446456.
Tran, D., Nguyen, H., Pontelli, E., & Son, T. C. (2008). CPA(C)/(H): Two approximationbased conformant planners. At http://ippc-2008.loria.fr/wiki/images/5/57/Team2CPA.pdf.
Tran, D., Nguyen, H., Pontelli, E., & Son, T. C. (2009). Improving performance of conformant planners: Static analysis of declarative planning domain specifications. In Practical Aspects of Declarative Languages, 11th International Symposium, PADL 2009,Proceedings, Vol. 5418 of Lecture Notes in Computer Science, pp. 239253. Springer.
Turner, H. (2002). Polynomial-length planning spans the polynomial hierarchy. In JELIA
02: Proc. of the European Conference on Logics in AI, pp. 111124. Springer-Verlag.

675

fi